<html>
<head>
<title>test.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc8b60;}
.s1 { color: #d8d8d8;}
.s2 { color: #cc7832;}
.s3 { color: #bbb55b;}
.s4 { color: #717ed3; font-style: italic;}
.s5 { color: #96bf7d;}
.s6 { color: #d7539b; font-weight: bold;}
.s7 { color: #5d69bb;}
.s8 { color: #a5c261;}
</style>
</head>
<body bgcolor="#1a1a25">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">dataclasses</span>
<span class="s0">import </span><span class="s1">mimetypes</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">typing </span><span class="s0">as </span><span class="s1">t</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">defaultdict</span>
<span class="s0">from </span><span class="s1">datetime </span><span class="s0">import </span><span class="s1">datetime</span>
<span class="s0">from </span><span class="s1">io </span><span class="s0">import </span><span class="s1">BytesIO</span>
<span class="s0">from </span><span class="s1">itertools </span><span class="s0">import </span><span class="s1">chain</span>
<span class="s0">from </span><span class="s1">random </span><span class="s0">import </span><span class="s1">random</span>
<span class="s0">from </span><span class="s1">tempfile </span><span class="s0">import </span><span class="s1">TemporaryFile</span>
<span class="s0">from </span><span class="s1">time </span><span class="s0">import </span><span class="s1">time</span>
<span class="s0">from </span><span class="s1">urllib.parse </span><span class="s0">import </span><span class="s1">unquote</span>
<span class="s0">from </span><span class="s1">urllib.parse </span><span class="s0">import </span><span class="s1">urlsplit</span>
<span class="s0">from </span><span class="s1">urllib.parse </span><span class="s0">import </span><span class="s1">urlunsplit</span>

<span class="s0">from </span><span class="s1">._internal </span><span class="s0">import </span><span class="s1">_get_environ</span>
<span class="s0">from </span><span class="s1">._internal </span><span class="s0">import </span><span class="s1">_wsgi_decoding_dance</span>
<span class="s0">from </span><span class="s1">._internal </span><span class="s0">import </span><span class="s1">_wsgi_encoding_dance</span>
<span class="s0">from </span><span class="s1">.datastructures </span><span class="s0">import </span><span class="s1">Authorization</span>
<span class="s0">from </span><span class="s1">.datastructures </span><span class="s0">import </span><span class="s1">CallbackDict</span>
<span class="s0">from </span><span class="s1">.datastructures </span><span class="s0">import </span><span class="s1">CombinedMultiDict</span>
<span class="s0">from </span><span class="s1">.datastructures </span><span class="s0">import </span><span class="s1">EnvironHeaders</span>
<span class="s0">from </span><span class="s1">.datastructures </span><span class="s0">import </span><span class="s1">FileMultiDict</span>
<span class="s0">from </span><span class="s1">.datastructures </span><span class="s0">import </span><span class="s1">Headers</span>
<span class="s0">from </span><span class="s1">.datastructures </span><span class="s0">import </span><span class="s1">MultiDict</span>
<span class="s0">from </span><span class="s1">.http </span><span class="s0">import </span><span class="s1">dump_cookie</span>
<span class="s0">from </span><span class="s1">.http </span><span class="s0">import </span><span class="s1">dump_options_header</span>
<span class="s0">from </span><span class="s1">.http </span><span class="s0">import </span><span class="s1">parse_cookie</span>
<span class="s0">from </span><span class="s1">.http </span><span class="s0">import </span><span class="s1">parse_date</span>
<span class="s0">from </span><span class="s1">.http </span><span class="s0">import </span><span class="s1">parse_options_header</span>
<span class="s0">from </span><span class="s1">.sansio.multipart </span><span class="s0">import </span><span class="s1">Data</span>
<span class="s0">from </span><span class="s1">.sansio.multipart </span><span class="s0">import </span><span class="s1">Epilogue</span>
<span class="s0">from </span><span class="s1">.sansio.multipart </span><span class="s0">import </span><span class="s1">Field</span>
<span class="s0">from </span><span class="s1">.sansio.multipart </span><span class="s0">import </span><span class="s1">File</span>
<span class="s0">from </span><span class="s1">.sansio.multipart </span><span class="s0">import </span><span class="s1">MultipartEncoder</span>
<span class="s0">from </span><span class="s1">.sansio.multipart </span><span class="s0">import </span><span class="s1">Preamble</span>
<span class="s0">from </span><span class="s1">.urls </span><span class="s0">import </span><span class="s1">_urlencode</span>
<span class="s0">from </span><span class="s1">.urls </span><span class="s0">import </span><span class="s1">iri_to_uri</span>
<span class="s0">from </span><span class="s1">.utils </span><span class="s0">import </span><span class="s1">cached_property</span>
<span class="s0">from </span><span class="s1">.utils </span><span class="s0">import </span><span class="s1">get_content_type</span>
<span class="s0">from </span><span class="s1">.wrappers.request </span><span class="s0">import </span><span class="s1">Request</span>
<span class="s0">from </span><span class="s1">.wrappers.response </span><span class="s0">import </span><span class="s1">Response</span>
<span class="s0">from </span><span class="s1">.wsgi </span><span class="s0">import </span><span class="s1">ClosingIterator</span>
<span class="s0">from </span><span class="s1">.wsgi </span><span class="s0">import </span><span class="s1">get_current_url</span>

<span class="s0">if </span><span class="s1">t.TYPE_CHECKING:</span>
    <span class="s0">import </span><span class="s1">typing_extensions </span><span class="s0">as </span><span class="s1">te</span>
    <span class="s0">from </span><span class="s1">_typeshed.wsgi </span><span class="s0">import </span><span class="s1">WSGIApplication</span>
    <span class="s0">from </span><span class="s1">_typeshed.wsgi </span><span class="s0">import </span><span class="s1">WSGIEnvironment</span>


<span class="s0">def </span><span class="s1">stream_encode_multipart(</span>
    <span class="s1">data: t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">,</span>
    <span class="s1">use_tempfile: bool = </span><span class="s0">True</span><span class="s2">,</span>
    <span class="s1">threshold: int = </span><span class="s3">1024 </span><span class="s1">* </span><span class="s3">500</span><span class="s2">,</span>
    <span class="s1">boundary: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s2">,</span>
<span class="s1">) -&gt; tuple[t.IO[bytes]</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">str]:</span>
    <span class="s4">&quot;&quot;&quot;Encode a dict of values (either strings or file descriptors or 
    :class:`FileStorage` objects.) into a multipart encoded string stored 
    in a file descriptor. 
 
    .. versionchanged:: 3.0 
        The ``charset`` parameter was removed. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">boundary </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">boundary = </span><span class="s5">f&quot;---------------WerkzeugFormPart_</span><span class="s6">{</span><span class="s1">time()</span><span class="s6">}{</span><span class="s1">random()</span><span class="s6">}</span><span class="s5">&quot;</span>

    <span class="s1">stream: t.IO[bytes] = BytesIO()</span>
    <span class="s1">total_length = </span><span class="s3">0</span>
    <span class="s1">on_disk = </span><span class="s0">False</span>
    <span class="s1">write_binary: t.Callable[[bytes]</span><span class="s2">, </span><span class="s1">int]</span>

    <span class="s0">if </span><span class="s1">use_tempfile:</span>

        <span class="s0">def </span><span class="s1">write_binary(s: bytes) -&gt; int:</span>
            <span class="s0">nonlocal </span><span class="s1">stream</span><span class="s2">, </span><span class="s1">total_length</span><span class="s2">, </span><span class="s1">on_disk</span>

            <span class="s0">if </span><span class="s1">on_disk:</span>
                <span class="s0">return </span><span class="s1">stream.write(s)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">length = len(s)</span>

                <span class="s0">if </span><span class="s1">length + total_length &lt;= threshold:</span>
                    <span class="s1">stream.write(s)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">new_stream = t.cast(t.IO[bytes]</span><span class="s2">, </span><span class="s1">TemporaryFile(</span><span class="s5">&quot;wb+&quot;</span><span class="s1">))</span>
                    <span class="s1">new_stream.write(stream.getvalue())  </span><span class="s7"># type: ignore</span>
                    <span class="s1">new_stream.write(s)</span>
                    <span class="s1">stream = new_stream</span>
                    <span class="s1">on_disk = </span><span class="s0">True</span>

                <span class="s1">total_length += length</span>
                <span class="s0">return </span><span class="s1">length</span>

    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">write_binary = stream.write</span>

    <span class="s1">encoder = MultipartEncoder(boundary.encode())</span>
    <span class="s1">write_binary(encoder.send_event(Preamble(data=</span><span class="s8">b&quot;&quot;</span><span class="s1">)))</span>
    <span class="s0">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">_iter_data(data):</span>
        <span class="s1">reader = getattr(value</span><span class="s2">, </span><span class="s5">&quot;read&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">reader </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">filename = getattr(value</span><span class="s2">, </span><span class="s5">&quot;filename&quot;</span><span class="s2">, </span><span class="s1">getattr(value</span><span class="s2">, </span><span class="s5">&quot;name&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s1">))</span>
            <span class="s1">content_type = getattr(value</span><span class="s2">, </span><span class="s5">&quot;content_type&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">content_type </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">content_type = (</span>
                    <span class="s1">filename</span>
                    <span class="s0">and </span><span class="s1">mimetypes.guess_type(filename)[</span><span class="s3">0</span><span class="s1">]</span>
                    <span class="s0">or </span><span class="s5">&quot;application/octet-stream&quot;</span>
                <span class="s1">)</span>
            <span class="s1">headers = value.headers</span>
            <span class="s1">headers.update([(</span><span class="s5">&quot;Content-Type&quot;</span><span class="s2">, </span><span class="s1">content_type)])</span>
            <span class="s0">if </span><span class="s1">filename </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">write_binary(encoder.send_event(Field(name=key</span><span class="s2">, </span><span class="s1">headers=headers)))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">write_binary(</span>
                    <span class="s1">encoder.send_event(</span>
                        <span class="s1">File(name=key</span><span class="s2">, </span><span class="s1">filename=filename</span><span class="s2">, </span><span class="s1">headers=headers)</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s0">while True</span><span class="s1">:</span>
                <span class="s1">chunk = reader(</span><span class="s3">16384</span><span class="s1">)</span>

                <span class="s0">if not </span><span class="s1">chunk:</span>
                    <span class="s1">write_binary(encoder.send_event(Data(data=chunk</span><span class="s2">, </span><span class="s1">more_data=</span><span class="s0">False</span><span class="s1">)))</span>
                    <span class="s0">break</span>

                <span class="s1">write_binary(encoder.send_event(Data(data=chunk</span><span class="s2">, </span><span class="s1">more_data=</span><span class="s0">True</span><span class="s1">)))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">value = str(value)</span>
            <span class="s1">write_binary(encoder.send_event(Field(name=key</span><span class="s2">, </span><span class="s1">headers=Headers())))</span>
            <span class="s1">write_binary(encoder.send_event(Data(data=value.encode()</span><span class="s2">, </span><span class="s1">more_data=</span><span class="s0">False</span><span class="s1">)))</span>

    <span class="s1">write_binary(encoder.send_event(Epilogue(data=</span><span class="s8">b&quot;&quot;</span><span class="s1">)))</span>

    <span class="s1">length = stream.tell()</span>
    <span class="s1">stream.seek(</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">stream</span><span class="s2">, </span><span class="s1">length</span><span class="s2">, </span><span class="s1">boundary</span>


<span class="s0">def </span><span class="s1">encode_multipart(</span>
    <span class="s1">values: t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]</span><span class="s2">, </span><span class="s1">boundary: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>
<span class="s1">) -&gt; tuple[str</span><span class="s2">, </span><span class="s1">bytes]:</span>
    <span class="s4">&quot;&quot;&quot;Like `stream_encode_multipart` but returns a tuple in the form 
    (``boundary``, ``data``) where data is bytes. 
 
    .. versionchanged:: 3.0 
        The ``charset`` parameter was removed. 
    &quot;&quot;&quot;</span>
    <span class="s1">stream</span><span class="s2">, </span><span class="s1">length</span><span class="s2">, </span><span class="s1">boundary = stream_encode_multipart(</span>
        <span class="s1">values</span><span class="s2">, </span><span class="s1">use_tempfile=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">boundary=boundary</span>
    <span class="s1">)</span>
    <span class="s0">return </span><span class="s1">boundary</span><span class="s2">, </span><span class="s1">stream.read()</span>


<span class="s0">def </span><span class="s1">_iter_data(data: t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]) -&gt; t.Iterator[tuple[str</span><span class="s2">, </span><span class="s1">t.Any]]:</span>
    <span class="s4">&quot;&quot;&quot;Iterate over a mapping that might have a list of values, yielding 
    all key, value pairs. Almost like iter_multi_items but only allows 
    lists, not tuples, of values so tuples can be used for files. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance(data</span><span class="s2">, </span><span class="s1">MultiDict):</span>
        <span class="s0">yield from </span><span class="s1">data.items(multi=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">data.items():</span>
            <span class="s0">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">list):</span>
                <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">value:</span>
                    <span class="s0">yield </span><span class="s1">key</span><span class="s2">, </span><span class="s1">v</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">yield </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span>


<span class="s1">_TAnyMultiDict = t.TypeVar(</span><span class="s5">&quot;_TAnyMultiDict&quot;</span><span class="s2">, </span><span class="s1">bound=</span><span class="s5">&quot;MultiDict[t.Any, t.Any]&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">EnvironBuilder:</span>
    <span class="s4">&quot;&quot;&quot;This class can be used to conveniently create a WSGI environment 
    for testing purposes.  It can be used to quickly create WSGI environments 
    or request objects from arbitrary data. 
 
    The signature of this class is also used in some other places as of 
    Werkzeug 0.5 (:func:`create_environ`, :meth:`Response.from_values`, 
    :meth:`Client.open`).  Because of this most of the functionality is 
    available through the constructor alone. 
 
    Files and regular form data can be manipulated independently of each 
    other with the :attr:`form` and :attr:`files` attributes, but are 
    passed with the same argument to the constructor: `data`. 
 
    `data` can be any of these values: 
 
    -   a `str` or `bytes` object: The object is converted into an 
        :attr:`input_stream`, the :attr:`content_length` is set and you have to 
        provide a :attr:`content_type`. 
    -   a `dict` or :class:`MultiDict`: The keys have to be strings. The values 
        have to be either any of the following objects, or a list of any of the 
        following objects: 
 
        -   a :class:`file`-like object:  These are converted into 
            :class:`FileStorage` objects automatically. 
        -   a `tuple`:  The :meth:`~FileMultiDict.add_file` method is called 
            with the key and the unpacked `tuple` items as positional 
            arguments. 
        -   a `str`:  The string is set as form data for the associated key. 
    -   a file-like object: The object content is loaded in memory and then 
        handled like a regular `str` or a `bytes`. 
 
    :param path: the path of the request.  In the WSGI environment this will 
                 end up as `PATH_INFO`.  If the `query_string` is not defined 
                 and there is a question mark in the `path` everything after 
                 it is used as query string. 
    :param base_url: the base URL is a URL that is used to extract the WSGI 
                     URL scheme, host (server name + server port) and the 
                     script root (`SCRIPT_NAME`). 
    :param query_string: an optional string or dict with URL parameters. 
    :param method: the HTTP method to use, defaults to `GET`. 
    :param input_stream: an optional input stream.  Do not specify this and 
                         `data`.  As soon as an input stream is set you can't 
                         modify :attr:`args` and :attr:`files` unless you 
                         set the :attr:`input_stream` to `None` again. 
    :param content_type: The content type for the request.  As of 0.5 you 
                         don't have to provide this when specifying files 
                         and form data via `data`. 
    :param content_length: The content length for the request.  You don't 
                           have to specify this when providing data via 
                           `data`. 
    :param errors_stream: an optional error stream that is used for 
                          `wsgi.errors`.  Defaults to :data:`stderr`. 
    :param multithread: controls `wsgi.multithread`.  Defaults to `False`. 
    :param multiprocess: controls `wsgi.multiprocess`.  Defaults to `False`. 
    :param run_once: controls `wsgi.run_once`.  Defaults to `False`. 
    :param headers: an optional list or :class:`Headers` object of headers. 
    :param data: a string or dict of form data or a file-object. 
                 See explanation above. 
    :param json: An object to be serialized and assigned to ``data``. 
        Defaults the content type to ``&quot;application/json&quot;``. 
        Serialized with the function assigned to :attr:`json_dumps`. 
    :param environ_base: an optional dict of environment defaults. 
    :param environ_overrides: an optional dict of environment overrides. 
    :param auth: An authorization object to use for the 
        ``Authorization`` header value. A ``(username, password)`` tuple 
        is a shortcut for ``Basic`` authorization. 
 
    .. versionchanged:: 3.0 
        The ``charset`` parameter was removed. 
 
    .. versionchanged:: 2.1 
        ``CONTENT_TYPE`` and ``CONTENT_LENGTH`` are not duplicated as 
        header keys in the environ. 
 
    .. versionchanged:: 2.0 
        ``REQUEST_URI`` and ``RAW_URI`` is the full raw URI including 
        the query string, not only the path. 
 
    .. versionchanged:: 2.0 
        The default :attr:`request_class` is ``Request`` instead of 
        ``BaseRequest``. 
 
    .. versionadded:: 2.0 
       Added the ``auth`` parameter. 
 
    .. versionadded:: 0.15 
        The ``json`` param and :meth:`json_dumps` method. 
 
    .. versionadded:: 0.15 
        The environ has keys ``REQUEST_URI`` and ``RAW_URI`` containing 
        the path before percent-decoding. This is not part of the WSGI 
        PEP, but many WSGI servers include it. 
 
    .. versionchanged:: 0.6 
       ``path`` and ``base_url`` can now be unicode strings that are 
       encoded with :func:`iri_to_uri`. 
    &quot;&quot;&quot;</span>

    <span class="s7">#: the server protocol to use.  defaults to HTTP/1.1</span>
    <span class="s1">server_protocol = </span><span class="s5">&quot;HTTP/1.1&quot;</span>

    <span class="s7">#: the wsgi version to use.  defaults to (1, 0)</span>
    <span class="s1">wsgi_version = (</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>

    <span class="s7">#: The default request class used by :meth:`get_request`.</span>
    <span class="s1">request_class = Request</span>

    <span class="s0">import </span><span class="s1">json</span>

    <span class="s7">#: The serialization function used when ``json`` is passed.</span>
    <span class="s1">json_dumps = staticmethod(json.dumps)</span>
    <span class="s0">del </span><span class="s1">json</span>

    <span class="s1">_args: MultiDict[str</span><span class="s2">, </span><span class="s1">str] | </span><span class="s0">None</span>
    <span class="s1">_query_string: str | </span><span class="s0">None</span>
    <span class="s1">_input_stream: t.IO[bytes] | </span><span class="s0">None</span>
    <span class="s1">_form: MultiDict[str</span><span class="s2">, </span><span class="s1">str] | </span><span class="s0">None</span>
    <span class="s1">_files: FileMultiDict | </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">path: str = </span><span class="s5">&quot;/&quot;</span><span class="s2">,</span>
        <span class="s1">base_url: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">query_string: t.Mapping[str</span><span class="s2">, </span><span class="s1">str] | str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">method: str = </span><span class="s5">&quot;GET&quot;</span><span class="s2">,</span>
        <span class="s1">input_stream: t.IO[bytes] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">content_type: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">content_length: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">errors_stream: t.IO[str] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">multithread: bool = </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">multiprocess: bool = </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">run_once: bool = </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">headers: Headers | t.Iterable[tuple[str</span><span class="s2">, </span><span class="s1">str]] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">data: </span><span class="s0">None </span><span class="s1">| (t.IO[bytes] | str | bytes | t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any]) = </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">environ_base: t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">environ_overrides: t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">mimetype: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">json: t.Mapping[str</span><span class="s2">, </span><span class="s1">t.Any] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">auth: Authorization | tuple[str</span><span class="s2">, </span><span class="s1">str] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">query_string </span><span class="s0">is not None and </span><span class="s5">&quot;?&quot; </span><span class="s0">in </span><span class="s1">path:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Query string is defined in the path and as an argument&quot;</span><span class="s1">)</span>
        <span class="s1">request_uri = urlsplit(path)</span>
        <span class="s0">if </span><span class="s1">query_string </span><span class="s0">is None and </span><span class="s5">&quot;?&quot; </span><span class="s0">in </span><span class="s1">path:</span>
            <span class="s1">query_string = request_uri.query</span>

        <span class="s1">self.path = iri_to_uri(request_uri.path)</span>
        <span class="s1">self.request_uri = path</span>
        <span class="s0">if </span><span class="s1">base_url </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">base_url = iri_to_uri(base_url)</span>
        <span class="s1">self.base_url = base_url  </span><span class="s7"># type: ignore</span>
        <span class="s0">if </span><span class="s1">isinstance(query_string</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">self.query_string = query_string</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">query_string </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">query_string = MultiDict()</span>
            <span class="s0">elif not </span><span class="s1">isinstance(query_string</span><span class="s2">, </span><span class="s1">MultiDict):</span>
                <span class="s1">query_string = MultiDict(query_string)</span>
            <span class="s1">self.args = query_string</span>
        <span class="s1">self.method = method</span>
        <span class="s0">if </span><span class="s1">headers </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">headers = Headers()</span>
        <span class="s0">elif not </span><span class="s1">isinstance(headers</span><span class="s2">, </span><span class="s1">Headers):</span>
            <span class="s1">headers = Headers(headers)</span>
        <span class="s1">self.headers = headers</span>
        <span class="s0">if </span><span class="s1">content_type </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.content_type = content_type</span>
        <span class="s0">if </span><span class="s1">errors_stream </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">errors_stream = sys.stderr</span>
        <span class="s1">self.errors_stream = errors_stream</span>
        <span class="s1">self.multithread = multithread</span>
        <span class="s1">self.multiprocess = multiprocess</span>
        <span class="s1">self.run_once = run_once</span>
        <span class="s1">self.environ_base = environ_base</span>
        <span class="s1">self.environ_overrides = environ_overrides</span>
        <span class="s1">self.input_stream = input_stream</span>
        <span class="s1">self.content_length = content_length</span>
        <span class="s1">self.closed = </span><span class="s0">False</span>

        <span class="s0">if </span><span class="s1">auth </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(auth</span><span class="s2">, </span><span class="s1">tuple):</span>
                <span class="s1">auth = Authorization(</span>
                    <span class="s5">&quot;basic&quot;</span><span class="s2">, </span><span class="s1">{</span><span class="s5">&quot;username&quot;</span><span class="s1">: auth[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">&quot;password&quot;</span><span class="s1">: auth[</span><span class="s3">1</span><span class="s1">]}</span>
                <span class="s1">)</span>

            <span class="s1">self.headers.set(</span><span class="s5">&quot;Authorization&quot;</span><span class="s2">, </span><span class="s1">auth.to_header())</span>

        <span class="s0">if </span><span class="s1">json </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">data </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s5">&quot;can't provide both json and data&quot;</span><span class="s1">)</span>

            <span class="s1">data = self.json_dumps(json)</span>

            <span class="s0">if </span><span class="s1">self.content_type </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">self.content_type = </span><span class="s5">&quot;application/json&quot;</span>

        <span class="s0">if </span><span class="s1">data:</span>
            <span class="s0">if </span><span class="s1">input_stream </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s5">&quot;can't provide input stream and data&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">hasattr(data</span><span class="s2">, </span><span class="s5">&quot;read&quot;</span><span class="s1">):</span>
                <span class="s1">data = data.read()</span>
            <span class="s0">if </span><span class="s1">isinstance(data</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">data = data.encode()</span>
            <span class="s0">if </span><span class="s1">isinstance(data</span><span class="s2">, </span><span class="s1">bytes):</span>
                <span class="s1">self.input_stream = BytesIO(data)</span>
                <span class="s0">if </span><span class="s1">self.content_length </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s1">self.content_length = len(data)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">_iter_data(data):</span>
                    <span class="s0">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">(tuple</span><span class="s2">, </span><span class="s1">dict)) </span><span class="s0">or </span><span class="s1">hasattr(value</span><span class="s2">, </span><span class="s5">&quot;read&quot;</span><span class="s1">):</span>
                        <span class="s1">self._add_file_from_data(key</span><span class="s2">, </span><span class="s1">value)</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">self.form.setlistdefault(key).append(value)</span>

        <span class="s0">if </span><span class="s1">mimetype </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.mimetype = mimetype</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_environ(cls</span><span class="s2">, </span><span class="s1">environ: WSGIEnvironment</span><span class="s2">, </span><span class="s1">**kwargs: t.Any) -&gt; EnvironBuilder:</span>
        <span class="s4">&quot;&quot;&quot;Turn an environ dict back into a builder. Any extra kwargs 
        override the args extracted from the environ. 
 
        .. versionchanged:: 2.0 
            Path and query values are passed through the WSGI decoding 
            dance to avoid double encoding. 
 
        .. versionadded:: 0.15 
        &quot;&quot;&quot;</span>
        <span class="s1">headers = Headers(EnvironHeaders(environ))</span>
        <span class="s1">out = {</span>
            <span class="s5">&quot;path&quot;</span><span class="s1">: _wsgi_decoding_dance(environ[</span><span class="s5">&quot;PATH_INFO&quot;</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s5">&quot;base_url&quot;</span><span class="s1">: cls._make_base_url(</span>
                <span class="s1">environ[</span><span class="s5">&quot;wsgi.url_scheme&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">headers.pop(</span><span class="s5">&quot;Host&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">_wsgi_decoding_dance(environ[</span><span class="s5">&quot;SCRIPT_NAME&quot;</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s5">&quot;query_string&quot;</span><span class="s1">: _wsgi_decoding_dance(environ[</span><span class="s5">&quot;QUERY_STRING&quot;</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s5">&quot;method&quot;</span><span class="s1">: environ[</span><span class="s5">&quot;REQUEST_METHOD&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s5">&quot;input_stream&quot;</span><span class="s1">: environ[</span><span class="s5">&quot;wsgi.input&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s5">&quot;content_type&quot;</span><span class="s1">: headers.pop(</span><span class="s5">&quot;Content-Type&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s5">&quot;content_length&quot;</span><span class="s1">: headers.pop(</span><span class="s5">&quot;Content-Length&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s5">&quot;errors_stream&quot;</span><span class="s1">: environ[</span><span class="s5">&quot;wsgi.errors&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s5">&quot;multithread&quot;</span><span class="s1">: environ[</span><span class="s5">&quot;wsgi.multithread&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s5">&quot;multiprocess&quot;</span><span class="s1">: environ[</span><span class="s5">&quot;wsgi.multiprocess&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s5">&quot;run_once&quot;</span><span class="s1">: environ[</span><span class="s5">&quot;wsgi.run_once&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s5">&quot;headers&quot;</span><span class="s1">: headers</span><span class="s2">,</span>
        <span class="s1">}</span>
        <span class="s1">out.update(kwargs)</span>
        <span class="s0">return </span><span class="s1">cls(**out)</span>

    <span class="s0">def </span><span class="s1">_add_file_from_data(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">key: str</span><span class="s2">,</span>
        <span class="s1">value: (t.IO[bytes] | tuple[t.IO[bytes]</span><span class="s2">, </span><span class="s1">str] | tuple[t.IO[bytes]</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">str])</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Called in the EnvironBuilder to add files from the data dict.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">tuple):</span>
            <span class="s1">self.files.add_file(key</span><span class="s2">, </span><span class="s1">*value)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.files.add_file(key</span><span class="s2">, </span><span class="s1">value)</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_make_base_url(scheme: str</span><span class="s2">, </span><span class="s1">host: str</span><span class="s2">, </span><span class="s1">script_root: str) -&gt; str:</span>
        <span class="s0">return </span><span class="s1">urlunsplit((scheme</span><span class="s2">, </span><span class="s1">host</span><span class="s2">, </span><span class="s1">script_root</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s1">)).rstrip(</span><span class="s5">&quot;/&quot;</span><span class="s1">) + </span><span class="s5">&quot;/&quot;</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">base_url(self) -&gt; str:</span>
        <span class="s4">&quot;&quot;&quot;The base URL is used to extract the URL scheme, host name, 
        port, and root path. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._make_base_url(self.url_scheme</span><span class="s2">, </span><span class="s1">self.host</span><span class="s2">, </span><span class="s1">self.script_root)</span>

    <span class="s1">@base_url.setter</span>
    <span class="s0">def </span><span class="s1">base_url(self</span><span class="s2">, </span><span class="s1">value: str | </span><span class="s0">None</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">value </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">scheme = </span><span class="s5">&quot;http&quot;</span>
            <span class="s1">netloc = </span><span class="s5">&quot;localhost&quot;</span>
            <span class="s1">script_root = </span><span class="s5">&quot;&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">scheme</span><span class="s2">, </span><span class="s1">netloc</span><span class="s2">, </span><span class="s1">script_root</span><span class="s2">, </span><span class="s1">qs</span><span class="s2">, </span><span class="s1">anchor = urlsplit(value)</span>
            <span class="s0">if </span><span class="s1">qs </span><span class="s0">or </span><span class="s1">anchor:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;base url must not contain a query string or fragment&quot;</span><span class="s1">)</span>
        <span class="s1">self.script_root = script_root.rstrip(</span><span class="s5">&quot;/&quot;</span><span class="s1">)</span>
        <span class="s1">self.host = netloc</span>
        <span class="s1">self.url_scheme = scheme</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">content_type(self) -&gt; str | </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;The content type for the request.  Reflected from and to 
        the :attr:`headers`.  Do not set if you set :attr:`files` or 
        :attr:`form` for auto detection. 
        &quot;&quot;&quot;</span>
        <span class="s1">ct = self.headers.get(</span><span class="s5">&quot;Content-Type&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">ct </span><span class="s0">is None and not </span><span class="s1">self._input_stream:</span>
            <span class="s0">if </span><span class="s1">self._files:</span>
                <span class="s0">return </span><span class="s5">&quot;multipart/form-data&quot;</span>
            <span class="s0">if </span><span class="s1">self._form:</span>
                <span class="s0">return </span><span class="s5">&quot;application/x-www-form-urlencoded&quot;</span>
            <span class="s0">return None</span>
        <span class="s0">return </span><span class="s1">ct</span>

    <span class="s1">@content_type.setter</span>
    <span class="s0">def </span><span class="s1">content_type(self</span><span class="s2">, </span><span class="s1">value: str | </span><span class="s0">None</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">value </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self.headers.pop(</span><span class="s5">&quot;Content-Type&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.headers[</span><span class="s5">&quot;Content-Type&quot;</span><span class="s1">] = value</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">mimetype(self) -&gt; str | </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;The mimetype (content type without charset etc.) 
 
        .. versionadded:: 0.14 
        &quot;&quot;&quot;</span>
        <span class="s1">ct = self.content_type</span>
        <span class="s0">return </span><span class="s1">ct.split(</span><span class="s5">&quot;;&quot;</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">].strip() </span><span class="s0">if </span><span class="s1">ct </span><span class="s0">else None</span>

    <span class="s1">@mimetype.setter</span>
    <span class="s0">def </span><span class="s1">mimetype(self</span><span class="s2">, </span><span class="s1">value: str) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.content_type = get_content_type(value</span><span class="s2">, </span><span class="s5">&quot;utf-8&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">mimetype_params(self) -&gt; t.Mapping[str</span><span class="s2">, </span><span class="s1">str]:</span>
        <span class="s4">&quot;&quot;&quot;The mimetype parameters as dict.  For example if the 
        content type is ``text/html; charset=utf-8`` the params would be 
        ``{'charset': 'utf-8'}``. 
 
        .. versionadded:: 0.14 
        &quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">on_update(d: CallbackDict[str</span><span class="s2">, </span><span class="s1">str]) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
            <span class="s1">self.headers[</span><span class="s5">&quot;Content-Type&quot;</span><span class="s1">] = dump_options_header(self.mimetype</span><span class="s2">, </span><span class="s1">d)</span>

        <span class="s1">d = parse_options_header(self.headers.get(</span><span class="s5">&quot;content-type&quot;</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s1">))[</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s0">return </span><span class="s1">CallbackDict(d</span><span class="s2">, </span><span class="s1">on_update)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">content_length(self) -&gt; int | </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;The content length as integer.  Reflected from and to the 
        :attr:`headers`.  Do not set if you set :attr:`files` or 
        :attr:`form` for auto detection. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.headers.get(</span><span class="s5">&quot;Content-Length&quot;</span><span class="s2">, </span><span class="s1">type=int)</span>

    <span class="s1">@content_length.setter</span>
    <span class="s0">def </span><span class="s1">content_length(self</span><span class="s2">, </span><span class="s1">value: int | </span><span class="s0">None</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">value </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self.headers.pop(</span><span class="s5">&quot;Content-Length&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.headers[</span><span class="s5">&quot;Content-Length&quot;</span><span class="s1">] = str(value)</span>

    <span class="s0">def </span><span class="s1">_get_form(self</span><span class="s2">, </span><span class="s1">name: str</span><span class="s2">, </span><span class="s1">storage: type[_TAnyMultiDict]) -&gt; _TAnyMultiDict:</span>
        <span class="s4">&quot;&quot;&quot;Common behavior for getting the :attr:`form` and 
        :attr:`files` properties. 
 
        :param name: Name of the internal cached attribute. 
        :param storage: Storage class used for the data. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.input_stream </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">AttributeError(</span><span class="s5">&quot;an input stream is defined&quot;</span><span class="s1">)</span>

        <span class="s1">rv = getattr(self</span><span class="s2">, </span><span class="s1">name)</span>

        <span class="s0">if </span><span class="s1">rv </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">rv = storage()</span>
            <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">rv)</span>

        <span class="s0">return </span><span class="s1">rv  </span><span class="s7"># type: ignore</span>

    <span class="s0">def </span><span class="s1">_set_form(self</span><span class="s2">, </span><span class="s1">name: str</span><span class="s2">, </span><span class="s1">value: MultiDict[str</span><span class="s2">, </span><span class="s1">t.Any]) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Common behavior for setting the :attr:`form` and 
        :attr:`files` properties. 
 
        :param name: Name of the internal cached attribute. 
        :param value: Value to assign to the attribute. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._input_stream = </span><span class="s0">None</span>
        <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">form(self) -&gt; MultiDict[str</span><span class="s2">, </span><span class="s1">str]:</span>
        <span class="s4">&quot;&quot;&quot;A :class:`MultiDict` of form values.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._get_form(</span><span class="s5">&quot;_form&quot;</span><span class="s2">, </span><span class="s1">MultiDict)</span>

    <span class="s1">@form.setter</span>
    <span class="s0">def </span><span class="s1">form(self</span><span class="s2">, </span><span class="s1">value: MultiDict[str</span><span class="s2">, </span><span class="s1">str]) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self._set_form(</span><span class="s5">&quot;_form&quot;</span><span class="s2">, </span><span class="s1">value)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">files(self) -&gt; FileMultiDict:</span>
        <span class="s4">&quot;&quot;&quot;A :class:`FileMultiDict` of uploaded files. Use 
        :meth:`~FileMultiDict.add_file` to add new files. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._get_form(</span><span class="s5">&quot;_files&quot;</span><span class="s2">, </span><span class="s1">FileMultiDict)</span>

    <span class="s1">@files.setter</span>
    <span class="s0">def </span><span class="s1">files(self</span><span class="s2">, </span><span class="s1">value: FileMultiDict) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self._set_form(</span><span class="s5">&quot;_files&quot;</span><span class="s2">, </span><span class="s1">value)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">input_stream(self) -&gt; t.IO[bytes] | </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;An optional input stream. This is mutually exclusive with 
        setting :attr:`form` and :attr:`files`, setting it will clear 
        those. Do not provide this if the method is not ``POST`` or 
        another method that has a body. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._input_stream</span>

    <span class="s1">@input_stream.setter</span>
    <span class="s0">def </span><span class="s1">input_stream(self</span><span class="s2">, </span><span class="s1">value: t.IO[bytes] | </span><span class="s0">None</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self._input_stream = value</span>
        <span class="s1">self._form = </span><span class="s0">None</span>
        <span class="s1">self._files = </span><span class="s0">None</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">query_string(self) -&gt; str:</span>
        <span class="s4">&quot;&quot;&quot;The query string.  If you set this to a string 
        :attr:`args` will no longer be available. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._query_string </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self._args </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">_urlencode(self._args)</span>
            <span class="s0">return </span><span class="s5">&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._query_string</span>

    <span class="s1">@query_string.setter</span>
    <span class="s0">def </span><span class="s1">query_string(self</span><span class="s2">, </span><span class="s1">value: str | </span><span class="s0">None</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self._query_string = value</span>
        <span class="s1">self._args = </span><span class="s0">None</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">args(self) -&gt; MultiDict[str</span><span class="s2">, </span><span class="s1">str]:</span>
        <span class="s4">&quot;&quot;&quot;The URL arguments as :class:`MultiDict`.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._query_string </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">AttributeError(</span><span class="s5">&quot;a query string is defined&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">self._args </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self._args = MultiDict()</span>
        <span class="s0">return </span><span class="s1">self._args</span>

    <span class="s1">@args.setter</span>
    <span class="s0">def </span><span class="s1">args(self</span><span class="s2">, </span><span class="s1">value: MultiDict[str</span><span class="s2">, </span><span class="s1">str] | </span><span class="s0">None</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self._query_string = </span><span class="s0">None</span>
        <span class="s1">self._args = value</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">server_name(self) -&gt; str:</span>
        <span class="s4">&quot;&quot;&quot;The server name (read-only, use :attr:`host` to set)&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.host.split(</span><span class="s5">&quot;:&quot;</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">server_port(self) -&gt; int:</span>
        <span class="s4">&quot;&quot;&quot;The server port as integer (read-only, use :attr:`host` to set)&quot;&quot;&quot;</span>
        <span class="s1">pieces = self.host.split(</span><span class="s5">&quot;:&quot;</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">len(pieces) == </span><span class="s3">2</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">int(pieces[</span><span class="s3">1</span><span class="s1">])</span>
            <span class="s0">except </span><span class="s1">ValueError:</span>
                <span class="s0">pass</span>

        <span class="s0">if </span><span class="s1">self.url_scheme == </span><span class="s5">&quot;https&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s3">443</span>
        <span class="s0">return </span><span class="s3">80</span>

    <span class="s0">def </span><span class="s1">__del__(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self.close()</span>
        <span class="s0">except </span><span class="s1">Exception:</span>
            <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">close(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Closes all files.  If you put real :class:`file` objects into the 
        :attr:`files` dict you can call this method to automatically close 
        them all in one go. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.closed:</span>
            <span class="s0">return</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">files = self.files.values()</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s1">files = ()</span>
        <span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">files:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">f.close()</span>
            <span class="s0">except </span><span class="s1">Exception:</span>
                <span class="s0">pass</span>
        <span class="s1">self.closed = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">get_environ(self) -&gt; WSGIEnvironment:</span>
        <span class="s4">&quot;&quot;&quot;Return the built environ. 
 
        .. versionchanged:: 0.15 
            The content type and length headers are set based on 
            input stream detection. Previously this only set the WSGI 
            keys. 
        &quot;&quot;&quot;</span>
        <span class="s1">input_stream = self.input_stream</span>
        <span class="s1">content_length = self.content_length</span>

        <span class="s1">mimetype = self.mimetype</span>
        <span class="s1">content_type = self.content_type</span>

        <span class="s0">if </span><span class="s1">input_stream </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">start_pos = input_stream.tell()</span>
            <span class="s1">input_stream.seek(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
            <span class="s1">end_pos = input_stream.tell()</span>
            <span class="s1">input_stream.seek(start_pos)</span>
            <span class="s1">content_length = end_pos - start_pos</span>
        <span class="s0">elif </span><span class="s1">mimetype == </span><span class="s5">&quot;multipart/form-data&quot;</span><span class="s1">:</span>
            <span class="s1">input_stream</span><span class="s2">, </span><span class="s1">content_length</span><span class="s2">, </span><span class="s1">boundary = stream_encode_multipart(</span>
                <span class="s1">CombinedMultiDict([self.form</span><span class="s2">, </span><span class="s1">self.files])</span>
            <span class="s1">)</span>
            <span class="s1">content_type = </span><span class="s5">f'</span><span class="s6">{</span><span class="s1">mimetype</span><span class="s6">}</span><span class="s5">; boundary=&quot;</span><span class="s6">{</span><span class="s1">boundary</span><span class="s6">}</span><span class="s5">&quot;'</span>
        <span class="s0">elif </span><span class="s1">mimetype == </span><span class="s5">&quot;application/x-www-form-urlencoded&quot;</span><span class="s1">:</span>
            <span class="s1">form_encoded = _urlencode(self.form).encode(</span><span class="s5">&quot;ascii&quot;</span><span class="s1">)</span>
            <span class="s1">content_length = len(form_encoded)</span>
            <span class="s1">input_stream = BytesIO(form_encoded)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">input_stream = BytesIO()</span>

        <span class="s1">result: WSGIEnvironment = {}</span>
        <span class="s0">if </span><span class="s1">self.environ_base:</span>
            <span class="s1">result.update(self.environ_base)</span>

        <span class="s0">def </span><span class="s1">_path_encode(x: str) -&gt; str:</span>
            <span class="s0">return </span><span class="s1">_wsgi_encoding_dance(unquote(x))</span>

        <span class="s1">raw_uri = _wsgi_encoding_dance(self.request_uri)</span>
        <span class="s1">result.update(</span>
            <span class="s1">{</span>
                <span class="s5">&quot;REQUEST_METHOD&quot;</span><span class="s1">: self.method</span><span class="s2">,</span>
                <span class="s5">&quot;SCRIPT_NAME&quot;</span><span class="s1">: _path_encode(self.script_root)</span><span class="s2">,</span>
                <span class="s5">&quot;PATH_INFO&quot;</span><span class="s1">: _path_encode(self.path)</span><span class="s2">,</span>
                <span class="s5">&quot;QUERY_STRING&quot;</span><span class="s1">: _wsgi_encoding_dance(self.query_string)</span><span class="s2">,</span>
                <span class="s7"># Non-standard, added by mod_wsgi, uWSGI</span>
                <span class="s5">&quot;REQUEST_URI&quot;</span><span class="s1">: raw_uri</span><span class="s2">,</span>
                <span class="s7"># Non-standard, added by gunicorn</span>
                <span class="s5">&quot;RAW_URI&quot;</span><span class="s1">: raw_uri</span><span class="s2">,</span>
                <span class="s5">&quot;SERVER_NAME&quot;</span><span class="s1">: self.server_name</span><span class="s2">,</span>
                <span class="s5">&quot;SERVER_PORT&quot;</span><span class="s1">: str(self.server_port)</span><span class="s2">,</span>
                <span class="s5">&quot;HTTP_HOST&quot;</span><span class="s1">: self.host</span><span class="s2">,</span>
                <span class="s5">&quot;SERVER_PROTOCOL&quot;</span><span class="s1">: self.server_protocol</span><span class="s2">,</span>
                <span class="s5">&quot;wsgi.version&quot;</span><span class="s1">: self.wsgi_version</span><span class="s2">,</span>
                <span class="s5">&quot;wsgi.url_scheme&quot;</span><span class="s1">: self.url_scheme</span><span class="s2">,</span>
                <span class="s5">&quot;wsgi.input&quot;</span><span class="s1">: input_stream</span><span class="s2">,</span>
                <span class="s5">&quot;wsgi.errors&quot;</span><span class="s1">: self.errors_stream</span><span class="s2">,</span>
                <span class="s5">&quot;wsgi.multithread&quot;</span><span class="s1">: self.multithread</span><span class="s2">,</span>
                <span class="s5">&quot;wsgi.multiprocess&quot;</span><span class="s1">: self.multiprocess</span><span class="s2">,</span>
                <span class="s5">&quot;wsgi.run_once&quot;</span><span class="s1">: self.run_once</span><span class="s2">,</span>
            <span class="s1">}</span>
        <span class="s1">)</span>

        <span class="s1">headers = self.headers.copy()</span>
        <span class="s7"># Don't send these as headers, they're part of the environ.</span>
        <span class="s1">headers.remove(</span><span class="s5">&quot;Content-Type&quot;</span><span class="s1">)</span>
        <span class="s1">headers.remove(</span><span class="s5">&quot;Content-Length&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">content_type </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">result[</span><span class="s5">&quot;CONTENT_TYPE&quot;</span><span class="s1">] = content_type</span>

        <span class="s0">if </span><span class="s1">content_length </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">result[</span><span class="s5">&quot;CONTENT_LENGTH&quot;</span><span class="s1">] = str(content_length)</span>

        <span class="s1">combined_headers = defaultdict(list)</span>

        <span class="s0">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">headers.to_wsgi_list():</span>
            <span class="s1">combined_headers[</span><span class="s5">f&quot;HTTP_</span><span class="s6">{</span><span class="s1">key.upper().replace(</span><span class="s5">'-'</span><span class="s2">, </span><span class="s5">'_'</span><span class="s1">)</span><span class="s6">}</span><span class="s5">&quot;</span><span class="s1">].append(value)</span>

        <span class="s0">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">values </span><span class="s0">in </span><span class="s1">combined_headers.items():</span>
            <span class="s1">result[key] = </span><span class="s5">&quot;, &quot;</span><span class="s1">.join(values)</span>

        <span class="s0">if </span><span class="s1">self.environ_overrides:</span>
            <span class="s1">result.update(self.environ_overrides)</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">get_request(self</span><span class="s2">, </span><span class="s1">cls: type[Request] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s1">) -&gt; Request:</span>
        <span class="s4">&quot;&quot;&quot;Returns a request with the data.  If the request class is not 
        specified :attr:`request_class` is used. 
 
        :param cls: The request wrapper to use. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">cls </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">cls = self.request_class</span>

        <span class="s0">return </span><span class="s1">cls(self.get_environ())</span>


<span class="s0">class </span><span class="s1">ClientRedirectError(Exception):</span>
    <span class="s4">&quot;&quot;&quot;If a redirect loop is detected when using follow_redirects=True with 
    the :cls:`Client`, then this exception is raised. 
    &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">Client:</span>
    <span class="s4">&quot;&quot;&quot;Simulate sending requests to a WSGI application without running a WSGI or HTTP 
    server. 
 
    :param application: The WSGI application to make requests to. 
    :param response_wrapper: A :class:`.Response` class to wrap response data with. 
        Defaults to :class:`.TestResponse`. If it's not a subclass of ``TestResponse``, 
        one will be created. 
    :param use_cookies: Persist cookies from ``Set-Cookie`` response headers to the 
        ``Cookie`` header in subsequent requests. Domain and path matching is supported, 
        but other cookie parameters are ignored. 
    :param allow_subdomain_redirects: Allow requests to follow redirects to subdomains. 
        Enable this if the application handles subdomains and redirects between them. 
 
    .. versionchanged:: 2.3 
        Simplify cookie implementation, support domain and path matching. 
 
    .. versionchanged:: 2.1 
        All data is available as properties on the returned response object. The 
        response cannot be returned as a tuple. 
 
    .. versionchanged:: 2.0 
        ``response_wrapper`` is always a subclass of :class:``TestResponse``. 
 
    .. versionchanged:: 0.5 
        Added the ``use_cookies`` parameter. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">application: WSGIApplication</span><span class="s2">,</span>
        <span class="s1">response_wrapper: type[Response] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">use_cookies: bool = </span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">allow_subdomain_redirects: bool = </span><span class="s0">False</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.application = application</span>

        <span class="s0">if </span><span class="s1">response_wrapper </span><span class="s0">in </span><span class="s1">{</span><span class="s0">None</span><span class="s2">, </span><span class="s1">Response}:</span>
            <span class="s1">response_wrapper = TestResponse</span>
        <span class="s0">elif </span><span class="s1">response_wrapper </span><span class="s0">is not None and not </span><span class="s1">issubclass(</span>
            <span class="s1">response_wrapper</span><span class="s2">, </span><span class="s1">TestResponse</span>
        <span class="s1">):</span>
            <span class="s1">response_wrapper = type(</span>
                <span class="s5">&quot;WrapperTestResponse&quot;</span><span class="s2">,</span>
                <span class="s1">(TestResponse</span><span class="s2">, </span><span class="s1">response_wrapper)</span><span class="s2">,</span>
                <span class="s1">{}</span><span class="s2">,</span>
            <span class="s1">)</span>

        <span class="s1">self.response_wrapper = t.cast(type[</span><span class="s5">&quot;TestResponse&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">response_wrapper)</span>

        <span class="s0">if </span><span class="s1">use_cookies:</span>
            <span class="s1">self._cookies: dict[tuple[str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">, </span><span class="s1">Cookie] | </span><span class="s0">None </span><span class="s1">= {}</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self._cookies = </span><span class="s0">None</span>

        <span class="s1">self.allow_subdomain_redirects = allow_subdomain_redirects</span>

    <span class="s0">def </span><span class="s1">get_cookie(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">key: str</span><span class="s2">, </span><span class="s1">domain: str = </span><span class="s5">&quot;localhost&quot;</span><span class="s2">, </span><span class="s1">path: str = </span><span class="s5">&quot;/&quot;</span>
    <span class="s1">) -&gt; Cookie | </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Return a :class:`.Cookie` if it exists. Cookies are uniquely identified by 
        ``(domain, path, key)``. 
 
        :param key: The decoded form of the key for the cookie. 
        :param domain: The domain the cookie was set for. 
        :param path: The path the cookie was set for. 
 
        .. versionadded:: 2.3 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._cookies </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s5">&quot;Cookies are disabled. Create a client with 'use_cookies=True'.&quot;</span>
            <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">self._cookies.get((domain</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">key))</span>

    <span class="s0">def </span><span class="s1">set_cookie(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">key: str</span><span class="s2">,</span>
        <span class="s1">value: str = </span><span class="s5">&quot;&quot;</span><span class="s2">,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">domain: str = </span><span class="s5">&quot;localhost&quot;</span><span class="s2">,</span>
        <span class="s1">origin_only: bool = </span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">path: str = </span><span class="s5">&quot;/&quot;</span><span class="s2">,</span>
        <span class="s1">**kwargs: t.Any</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Set a cookie to be sent in subsequent requests. 
 
        This is a convenience to skip making a test request to a route that would set 
        the cookie. To test the cookie, make a test request to a route that uses the 
        cookie value. 
 
        The client uses ``domain``, ``origin_only``, and ``path`` to determine which 
        cookies to send with a request. It does not use other cookie parameters that 
        browsers use, since they're not applicable in tests. 
 
        :param key: The key part of the cookie. 
        :param value: The value part of the cookie. 
        :param domain: Send this cookie with requests that match this domain. If 
            ``origin_only`` is true, it must be an exact match, otherwise it may be a 
            suffix match. 
        :param origin_only: Whether the domain must be an exact match to the request. 
        :param path: Send this cookie with requests that match this path either exactly 
            or as a prefix. 
        :param kwargs: Passed to :func:`.dump_cookie`. 
 
        .. versionchanged:: 3.0 
            The parameter ``server_name`` is removed. The first parameter is 
            ``key``. Use the ``domain`` and ``origin_only`` parameters instead. 
 
        .. versionchanged:: 2.3 
            The ``origin_only`` parameter was added. 
 
        .. versionchanged:: 2.3 
            The ``domain`` parameter defaults to ``localhost``. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._cookies </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s5">&quot;Cookies are disabled. Create a client with 'use_cookies=True'.&quot;</span>
            <span class="s1">)</span>

        <span class="s1">cookie = Cookie._from_response_header(</span>
            <span class="s1">domain</span><span class="s2">, </span><span class="s5">&quot;/&quot;</span><span class="s2">, </span><span class="s1">dump_cookie(key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">domain=domain</span><span class="s2">, </span><span class="s1">path=path</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">)</span>
        <span class="s1">cookie.origin_only = origin_only</span>

        <span class="s0">if </span><span class="s1">cookie._should_delete:</span>
            <span class="s1">self._cookies.pop(cookie._storage_key</span><span class="s2">, </span><span class="s0">None</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self._cookies[cookie._storage_key] = cookie</span>

    <span class="s0">def </span><span class="s1">delete_cookie(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">key: str</span><span class="s2">,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">domain: str = </span><span class="s5">&quot;localhost&quot;</span><span class="s2">,</span>
        <span class="s1">path: str = </span><span class="s5">&quot;/&quot;</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Delete a cookie if it exists. Cookies are uniquely identified by 
        ``(domain, path, key)``. 
 
        :param key: The decoded form of the key for the cookie. 
        :param domain: The domain the cookie was set for. 
        :param path: The path the cookie was set for. 
 
        .. versionchanged:: 3.0 
            The ``server_name`` parameter is removed. The first parameter is 
            ``key``. Use the ``domain`` parameter instead. 
 
        .. versionchanged:: 3.0 
            The ``secure``, ``httponly`` and ``samesite`` parameters are removed. 
 
        .. versionchanged:: 2.3 
            The ``domain`` parameter defaults to ``localhost``. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._cookies </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s5">&quot;Cookies are disabled. Create a client with 'use_cookies=True'.&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self._cookies.pop((domain</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">, </span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_add_cookies_to_wsgi(self</span><span class="s2">, </span><span class="s1">environ: WSGIEnvironment) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;If cookies are enabled, set the ``Cookie`` header in the environ to the 
        cookies that are applicable to the request host and path. 
 
        :meta private: 
 
        .. versionadded:: 2.3 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._cookies </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return</span>

        <span class="s1">url = urlsplit(get_current_url(environ))</span>
        <span class="s1">server_name = url.hostname </span><span class="s0">or </span><span class="s5">&quot;localhost&quot;</span>
        <span class="s1">value = </span><span class="s5">&quot;; &quot;</span><span class="s1">.join(</span>
            <span class="s1">c._to_request_header()</span>
            <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">self._cookies.values()</span>
            <span class="s0">if </span><span class="s1">c._matches_request(server_name</span><span class="s2">, </span><span class="s1">url.path)</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">value:</span>
            <span class="s1">environ[</span><span class="s5">&quot;HTTP_COOKIE&quot;</span><span class="s1">] = value</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">environ.pop(</span><span class="s5">&quot;HTTP_COOKIE&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_update_cookies_from_response(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">server_name: str</span><span class="s2">, </span><span class="s1">path: str</span><span class="s2">, </span><span class="s1">headers: list[str]</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;If cookies are enabled, update the stored cookies from any ``Set-Cookie`` 
        headers in the response. 
 
        :meta private: 
 
        .. versionadded:: 2.3 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._cookies </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return</span>

        <span class="s0">for </span><span class="s1">header </span><span class="s0">in </span><span class="s1">headers:</span>
            <span class="s1">cookie = Cookie._from_response_header(server_name</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">header)</span>

            <span class="s0">if </span><span class="s1">cookie._should_delete:</span>
                <span class="s1">self._cookies.pop(cookie._storage_key</span><span class="s2">, </span><span class="s0">None</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self._cookies[cookie._storage_key] = cookie</span>

    <span class="s0">def </span><span class="s1">run_wsgi_app(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">environ: WSGIEnvironment</span><span class="s2">, </span><span class="s1">buffered: bool = </span><span class="s0">False</span>
    <span class="s1">) -&gt; tuple[t.Iterable[bytes]</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">Headers]:</span>
        <span class="s4">&quot;&quot;&quot;Runs the wrapped WSGI app with the given environment. 
 
        :meta private: 
        &quot;&quot;&quot;</span>
        <span class="s1">self._add_cookies_to_wsgi(environ)</span>
        <span class="s1">rv = run_wsgi_app(self.application</span><span class="s2">, </span><span class="s1">environ</span><span class="s2">, </span><span class="s1">buffered=buffered)</span>
        <span class="s1">url = urlsplit(get_current_url(environ))</span>
        <span class="s1">self._update_cookies_from_response(</span>
            <span class="s1">url.hostname </span><span class="s0">or </span><span class="s5">&quot;localhost&quot;</span><span class="s2">, </span><span class="s1">url.path</span><span class="s2">, </span><span class="s1">rv[</span><span class="s3">2</span><span class="s1">].getlist(</span><span class="s5">&quot;Set-Cookie&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">rv</span>

    <span class="s0">def </span><span class="s1">resolve_redirect(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">response: TestResponse</span><span class="s2">, </span><span class="s1">buffered: bool = </span><span class="s0">False</span>
    <span class="s1">) -&gt; TestResponse:</span>
        <span class="s4">&quot;&quot;&quot;Perform a new request to the location given by the redirect 
        response to the previous request. 
 
        :meta private: 
        &quot;&quot;&quot;</span>
        <span class="s1">scheme</span><span class="s2">, </span><span class="s1">netloc</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">qs</span><span class="s2">, </span><span class="s1">anchor = urlsplit(response.location)</span>
        <span class="s1">builder = EnvironBuilder.from_environ(</span>
            <span class="s1">response.request.environ</span><span class="s2">, </span><span class="s1">path=path</span><span class="s2">, </span><span class="s1">query_string=qs</span>
        <span class="s1">)</span>

        <span class="s1">to_name_parts = netloc.split(</span><span class="s5">&quot;:&quot;</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">].split(</span><span class="s5">&quot;.&quot;</span><span class="s1">)</span>
        <span class="s1">from_name_parts = builder.server_name.split(</span><span class="s5">&quot;.&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">to_name_parts != [</span><span class="s5">&quot;&quot;</span><span class="s1">]:</span>
            <span class="s7"># The new location has a host, use it for the base URL.</span>
            <span class="s1">builder.url_scheme = scheme</span>
            <span class="s1">builder.host = netloc</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s7"># A local redirect with autocorrect_location_header=False</span>
            <span class="s7"># doesn't have a host, so use the request's host.</span>
            <span class="s1">to_name_parts = from_name_parts</span>

        <span class="s7"># Explain why a redirect to a different server name won't be followed.</span>
        <span class="s0">if </span><span class="s1">to_name_parts != from_name_parts:</span>
            <span class="s0">if </span><span class="s1">to_name_parts[-len(from_name_parts) :] == from_name_parts:</span>
                <span class="s0">if not </span><span class="s1">self.allow_subdomain_redirects:</span>
                    <span class="s0">raise </span><span class="s1">RuntimeError(</span><span class="s5">&quot;Following subdomain redirects is not enabled.&quot;</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">RuntimeError(</span><span class="s5">&quot;Following external redirects is not supported.&quot;</span><span class="s1">)</span>

        <span class="s1">path_parts = path.split(</span><span class="s5">&quot;/&quot;</span><span class="s1">)</span>
        <span class="s1">root_parts = builder.script_root.split(</span><span class="s5">&quot;/&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">path_parts[: len(root_parts)] == root_parts:</span>
            <span class="s7"># Strip the script root from the path.</span>
            <span class="s1">builder.path = path[len(builder.script_root) :]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s7"># The new location is not under the script root, so use the</span>
            <span class="s7"># whole path and clear the previous root.</span>
            <span class="s1">builder.path = path</span>
            <span class="s1">builder.script_root = </span><span class="s5">&quot;&quot;</span>

        <span class="s7"># Only 307 and 308 preserve all of the original request.</span>
        <span class="s0">if </span><span class="s1">response.status_code </span><span class="s0">not in </span><span class="s1">{</span><span class="s3">307</span><span class="s2">, </span><span class="s3">308</span><span class="s1">}:</span>
            <span class="s7"># HEAD is preserved, everything else becomes GET.</span>
            <span class="s0">if </span><span class="s1">builder.method != </span><span class="s5">&quot;HEAD&quot;</span><span class="s1">:</span>
                <span class="s1">builder.method = </span><span class="s5">&quot;GET&quot;</span>

            <span class="s7"># Clear the body and the headers that describe it.</span>

            <span class="s0">if </span><span class="s1">builder.input_stream </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">builder.input_stream.close()</span>
                <span class="s1">builder.input_stream = </span><span class="s0">None</span>

            <span class="s1">builder.content_type = </span><span class="s0">None</span>
            <span class="s1">builder.content_length = </span><span class="s0">None</span>
            <span class="s1">builder.headers.pop(</span><span class="s5">&quot;Transfer-Encoding&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">self.open(builder</span><span class="s2">, </span><span class="s1">buffered=buffered)</span>

    <span class="s0">def </span><span class="s1">open(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">*args: t.Any</span><span class="s2">,</span>
        <span class="s1">buffered: bool = </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">follow_redirects: bool = </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">**kwargs: t.Any</span><span class="s2">,</span>
    <span class="s1">) -&gt; TestResponse:</span>
        <span class="s4">&quot;&quot;&quot;Generate an environ dict from the given arguments, make a 
        request to the application using it, and return the response. 
 
        :param args: Passed to :class:`EnvironBuilder` to create the 
            environ for the request. If a single arg is passed, it can 
            be an existing :class:`EnvironBuilder` or an environ dict. 
        :param buffered: Convert the iterator returned by the app into 
            a list. If the iterator has a ``close()`` method, it is 
            called automatically. 
        :param follow_redirects: Make additional requests to follow HTTP 
            redirects until a non-redirect status is returned. 
            :attr:`TestResponse.history` lists the intermediate 
            responses. 
 
        .. versionchanged:: 2.1 
            Removed the ``as_tuple`` parameter. 
 
        .. versionchanged:: 2.0 
            The request input stream is closed when calling 
            ``response.close()``. Input streams for redirects are 
            automatically closed. 
 
        .. versionchanged:: 0.5 
            If a dict is provided as file in the dict for the ``data`` 
            parameter the content type has to be called ``content_type`` 
            instead of ``mimetype``. This change was made for 
            consistency with :class:`werkzeug.FileWrapper`. 
 
        .. versionchanged:: 0.5 
            Added the ``follow_redirects`` parameter. 
        &quot;&quot;&quot;</span>
        <span class="s1">request: Request | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>

        <span class="s0">if not </span><span class="s1">kwargs </span><span class="s0">and </span><span class="s1">len(args) == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">arg = args[</span><span class="s3">0</span><span class="s1">]</span>

            <span class="s0">if </span><span class="s1">isinstance(arg</span><span class="s2">, </span><span class="s1">EnvironBuilder):</span>
                <span class="s1">request = arg.get_request()</span>
            <span class="s0">elif </span><span class="s1">isinstance(arg</span><span class="s2">, </span><span class="s1">dict):</span>
                <span class="s1">request = EnvironBuilder.from_environ(arg).get_request()</span>
            <span class="s0">elif </span><span class="s1">isinstance(arg</span><span class="s2">, </span><span class="s1">Request):</span>
                <span class="s1">request = arg</span>

        <span class="s0">if </span><span class="s1">request </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">builder = EnvironBuilder(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">request = builder.get_request()</span>
            <span class="s0">finally</span><span class="s1">:</span>
                <span class="s1">builder.close()</span>

        <span class="s1">response_parts = self.run_wsgi_app(request.environ</span><span class="s2">, </span><span class="s1">buffered=buffered)</span>
        <span class="s1">response = self.response_wrapper(*response_parts</span><span class="s2">, </span><span class="s1">request=request)</span>

        <span class="s1">redirects = set()</span>
        <span class="s1">history: list[TestResponse] = []</span>

        <span class="s0">if not </span><span class="s1">follow_redirects:</span>
            <span class="s0">return </span><span class="s1">response</span>

        <span class="s0">while </span><span class="s1">response.status_code </span><span class="s0">in </span><span class="s1">{</span>
            <span class="s3">301</span><span class="s2">,</span>
            <span class="s3">302</span><span class="s2">,</span>
            <span class="s3">303</span><span class="s2">,</span>
            <span class="s3">305</span><span class="s2">,</span>
            <span class="s3">307</span><span class="s2">,</span>
            <span class="s3">308</span><span class="s2">,</span>
        <span class="s1">}:</span>
            <span class="s7"># Exhaust intermediate response bodies to ensure middleware</span>
            <span class="s7"># that returns an iterator runs any cleanup code.</span>
            <span class="s0">if not </span><span class="s1">buffered:</span>
                <span class="s1">response.make_sequence()</span>
                <span class="s1">response.close()</span>

            <span class="s1">new_redirect_entry = (response.location</span><span class="s2">, </span><span class="s1">response.status_code)</span>

            <span class="s0">if </span><span class="s1">new_redirect_entry </span><span class="s0">in </span><span class="s1">redirects:</span>
                <span class="s0">raise </span><span class="s1">ClientRedirectError(</span>
                    <span class="s5">f&quot;Loop detected: A </span><span class="s6">{</span><span class="s1">response.status_code</span><span class="s6">} </span><span class="s5">redirect&quot;</span>
                    <span class="s5">f&quot; to </span><span class="s6">{</span><span class="s1">response.location</span><span class="s6">} </span><span class="s5">was already made.&quot;</span>
                <span class="s1">)</span>

            <span class="s1">redirects.add(new_redirect_entry)</span>
            <span class="s1">response.history = tuple(history)</span>
            <span class="s1">history.append(response)</span>
            <span class="s1">response = self.resolve_redirect(response</span><span class="s2">, </span><span class="s1">buffered=buffered)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s7"># This is the final request after redirects.</span>
            <span class="s1">response.history = tuple(history)</span>
            <span class="s7"># Close the input stream when closing the response, in case</span>
            <span class="s7"># the input is an open temporary file.</span>
            <span class="s1">response.call_on_close(request.input_stream.close)</span>
            <span class="s0">return </span><span class="s1">response</span>

    <span class="s0">def </span><span class="s1">get(self</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kw: t.Any) -&gt; TestResponse:</span>
        <span class="s4">&quot;&quot;&quot;Call :meth:`open` with ``method`` set to ``GET``.&quot;&quot;&quot;</span>
        <span class="s1">kw[</span><span class="s5">&quot;method&quot;</span><span class="s1">] = </span><span class="s5">&quot;GET&quot;</span>
        <span class="s0">return </span><span class="s1">self.open(*args</span><span class="s2">, </span><span class="s1">**kw)</span>

    <span class="s0">def </span><span class="s1">post(self</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kw: t.Any) -&gt; TestResponse:</span>
        <span class="s4">&quot;&quot;&quot;Call :meth:`open` with ``method`` set to ``POST``.&quot;&quot;&quot;</span>
        <span class="s1">kw[</span><span class="s5">&quot;method&quot;</span><span class="s1">] = </span><span class="s5">&quot;POST&quot;</span>
        <span class="s0">return </span><span class="s1">self.open(*args</span><span class="s2">, </span><span class="s1">**kw)</span>

    <span class="s0">def </span><span class="s1">put(self</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kw: t.Any) -&gt; TestResponse:</span>
        <span class="s4">&quot;&quot;&quot;Call :meth:`open` with ``method`` set to ``PUT``.&quot;&quot;&quot;</span>
        <span class="s1">kw[</span><span class="s5">&quot;method&quot;</span><span class="s1">] = </span><span class="s5">&quot;PUT&quot;</span>
        <span class="s0">return </span><span class="s1">self.open(*args</span><span class="s2">, </span><span class="s1">**kw)</span>

    <span class="s0">def </span><span class="s1">delete(self</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kw: t.Any) -&gt; TestResponse:</span>
        <span class="s4">&quot;&quot;&quot;Call :meth:`open` with ``method`` set to ``DELETE``.&quot;&quot;&quot;</span>
        <span class="s1">kw[</span><span class="s5">&quot;method&quot;</span><span class="s1">] = </span><span class="s5">&quot;DELETE&quot;</span>
        <span class="s0">return </span><span class="s1">self.open(*args</span><span class="s2">, </span><span class="s1">**kw)</span>

    <span class="s0">def </span><span class="s1">patch(self</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kw: t.Any) -&gt; TestResponse:</span>
        <span class="s4">&quot;&quot;&quot;Call :meth:`open` with ``method`` set to ``PATCH``.&quot;&quot;&quot;</span>
        <span class="s1">kw[</span><span class="s5">&quot;method&quot;</span><span class="s1">] = </span><span class="s5">&quot;PATCH&quot;</span>
        <span class="s0">return </span><span class="s1">self.open(*args</span><span class="s2">, </span><span class="s1">**kw)</span>

    <span class="s0">def </span><span class="s1">options(self</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kw: t.Any) -&gt; TestResponse:</span>
        <span class="s4">&quot;&quot;&quot;Call :meth:`open` with ``method`` set to ``OPTIONS``.&quot;&quot;&quot;</span>
        <span class="s1">kw[</span><span class="s5">&quot;method&quot;</span><span class="s1">] = </span><span class="s5">&quot;OPTIONS&quot;</span>
        <span class="s0">return </span><span class="s1">self.open(*args</span><span class="s2">, </span><span class="s1">**kw)</span>

    <span class="s0">def </span><span class="s1">head(self</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kw: t.Any) -&gt; TestResponse:</span>
        <span class="s4">&quot;&quot;&quot;Call :meth:`open` with ``method`` set to ``HEAD``.&quot;&quot;&quot;</span>
        <span class="s1">kw[</span><span class="s5">&quot;method&quot;</span><span class="s1">] = </span><span class="s5">&quot;HEAD&quot;</span>
        <span class="s0">return </span><span class="s1">self.open(*args</span><span class="s2">, </span><span class="s1">**kw)</span>

    <span class="s0">def </span><span class="s1">trace(self</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kw: t.Any) -&gt; TestResponse:</span>
        <span class="s4">&quot;&quot;&quot;Call :meth:`open` with ``method`` set to ``TRACE``.&quot;&quot;&quot;</span>
        <span class="s1">kw[</span><span class="s5">&quot;method&quot;</span><span class="s1">] = </span><span class="s5">&quot;TRACE&quot;</span>
        <span class="s0">return </span><span class="s1">self.open(*args</span><span class="s2">, </span><span class="s1">**kw)</span>

    <span class="s0">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s5">f&quot;&lt;</span><span class="s6">{</span><span class="s1">type(self).__name__</span><span class="s6">} {</span><span class="s1">self.application</span><span class="s6">!r}</span><span class="s5">&gt;&quot;</span>


<span class="s0">def </span><span class="s1">create_environ(*args: t.Any</span><span class="s2">, </span><span class="s1">**kwargs: t.Any) -&gt; WSGIEnvironment:</span>
    <span class="s4">&quot;&quot;&quot;Create a new WSGI environ dict based on the values passed.  The first 
    parameter should be the path of the request which defaults to '/'.  The 
    second one can either be an absolute path (in that case the host is 
    localhost:80) or a full path to the request with scheme, netloc port and 
    the path to the script. 
 
    This accepts the same arguments as the :class:`EnvironBuilder` 
    constructor. 
 
    .. versionchanged:: 0.5 
       This function is now a thin wrapper over :class:`EnvironBuilder` which 
       was added in 0.5.  The `headers`, `environ_base`, `environ_overrides` 
       and `charset` parameters were added. 
    &quot;&quot;&quot;</span>
    <span class="s1">builder = EnvironBuilder(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">builder.get_environ()</span>
    <span class="s0">finally</span><span class="s1">:</span>
        <span class="s1">builder.close()</span>


<span class="s0">def </span><span class="s1">run_wsgi_app(</span>
    <span class="s1">app: WSGIApplication</span><span class="s2">, </span><span class="s1">environ: WSGIEnvironment</span><span class="s2">, </span><span class="s1">buffered: bool = </span><span class="s0">False</span>
<span class="s1">) -&gt; tuple[t.Iterable[bytes]</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">Headers]:</span>
    <span class="s4">&quot;&quot;&quot;Return a tuple in the form (app_iter, status, headers) of the 
    application output.  This works best if you pass it an application that 
    returns an iterator all the time. 
 
    Sometimes applications may use the `write()` callable returned 
    by the `start_response` function.  This tries to resolve such edge 
    cases automatically.  But if you don't get the expected output you 
    should set `buffered` to `True` which enforces buffering. 
 
    If passed an invalid WSGI application the behavior of this function is 
    undefined.  Never pass non-conforming WSGI applications to this function. 
 
    :param app: the application to execute. 
    :param buffered: set to `True` to enforce buffering. 
    :return: tuple in the form ``(app_iter, status, headers)`` 
    &quot;&quot;&quot;</span>
    <span class="s7"># Copy environ to ensure any mutations by the app (ProxyFix, for</span>
    <span class="s7"># example) don't affect subsequent requests (such as redirects).</span>
    <span class="s1">environ = _get_environ(environ).copy()</span>
    <span class="s1">status: str</span>
    <span class="s1">response: tuple[str</span><span class="s2">, </span><span class="s1">list[tuple[str</span><span class="s2">, </span><span class="s1">str]]] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>
    <span class="s1">buffer: list[bytes] = []</span>

    <span class="s0">def </span><span class="s1">start_response(status</span><span class="s2">, </span><span class="s1">headers</span><span class="s2">, </span><span class="s1">exc_info=</span><span class="s0">None</span><span class="s1">):  </span><span class="s7"># type: ignore</span>
        <span class="s0">nonlocal </span><span class="s1">response</span>

        <span class="s0">if </span><span class="s1">exc_info:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">exc_info[</span><span class="s3">1</span><span class="s1">].with_traceback(exc_info[</span><span class="s3">2</span><span class="s1">])</span>
            <span class="s0">finally</span><span class="s1">:</span>
                <span class="s1">exc_info = </span><span class="s0">None</span>

        <span class="s1">response = (status</span><span class="s2">, </span><span class="s1">headers)</span>
        <span class="s0">return </span><span class="s1">buffer.append</span>

    <span class="s1">app_rv = app(environ</span><span class="s2">, </span><span class="s1">start_response)</span>
    <span class="s1">close_func = getattr(app_rv</span><span class="s2">, </span><span class="s5">&quot;close&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s1">)</span>
    <span class="s1">app_iter: t.Iterable[bytes] = iter(app_rv)</span>

    <span class="s7"># when buffering we emit the close call early and convert the</span>
    <span class="s7"># application iterator into a regular list</span>
    <span class="s0">if </span><span class="s1">buffered:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">app_iter = list(app_iter)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">close_func </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">close_func()</span>

    <span class="s7"># otherwise we iterate the application iter until we have a response, chain</span>
    <span class="s7"># the already received data with the already collected data and wrap it in</span>
    <span class="s7"># a new `ClosingIterator` if we need to restore a `close` callable from the</span>
    <span class="s7"># original return value.</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">app_iter:</span>
            <span class="s1">buffer.append(item)</span>

            <span class="s0">if </span><span class="s1">response </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">break</span>

        <span class="s0">if </span><span class="s1">buffer:</span>
            <span class="s1">app_iter = chain(buffer</span><span class="s2">, </span><span class="s1">app_iter)</span>

        <span class="s0">if </span><span class="s1">close_func </span><span class="s0">is not None and </span><span class="s1">app_iter </span><span class="s0">is not </span><span class="s1">app_rv:</span>
            <span class="s1">app_iter = ClosingIterator(app_iter</span><span class="s2">, </span><span class="s1">close_func)</span>

    <span class="s1">status</span><span class="s2">, </span><span class="s1">headers = response  </span><span class="s7"># type: ignore</span>
    <span class="s0">return </span><span class="s1">app_iter</span><span class="s2">, </span><span class="s1">status</span><span class="s2">, </span><span class="s1">Headers(headers)</span>


<span class="s0">class </span><span class="s1">TestResponse(Response):</span>
    <span class="s4">&quot;&quot;&quot;:class:`~werkzeug.wrappers.Response` subclass that provides extra 
    information about requests made with the test :class:`Client`. 
 
    Test client requests will always return an instance of this class. 
    If a custom response class is passed to the client, it is 
    subclassed along with this to support test information. 
 
    If the test request included large files, or if the application is 
    serving a file, call :meth:`close` to close any open files and 
    prevent Python showing a ``ResourceWarning``. 
 
    .. versionchanged:: 2.2 
        Set the ``default_mimetype`` to None to prevent a mimetype being 
        assumed if missing. 
 
    .. versionchanged:: 2.1 
        Response instances cannot be treated as tuples. 
 
    .. versionadded:: 2.0 
        Test client methods always return instances of this class. 
    &quot;&quot;&quot;</span>

    <span class="s1">default_mimetype = </span><span class="s0">None</span>
    <span class="s7"># Don't assume a mimetype, instead use whatever the response provides</span>

    <span class="s1">request: Request</span>
    <span class="s5">&quot;&quot;&quot;A request object with the environ used to make the request that 
    resulted in this response. 
    &quot;&quot;&quot;</span>

    <span class="s1">history: tuple[TestResponse</span><span class="s2">, </span><span class="s1">...]</span>
    <span class="s5">&quot;&quot;&quot;A list of intermediate responses. Populated when the test request 
    is made with ``follow_redirects`` enabled. 
    &quot;&quot;&quot;</span>

    <span class="s7"># Tell Pytest to ignore this, it's not a test class.</span>
    <span class="s1">__test__ = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">response: t.Iterable[bytes]</span><span class="s2">,</span>
        <span class="s1">status: str</span><span class="s2">,</span>
        <span class="s1">headers: Headers</span><span class="s2">,</span>
        <span class="s1">request: Request</span><span class="s2">,</span>
        <span class="s1">history: tuple[TestResponse] = ()</span><span class="s2">,  </span><span class="s7"># type: ignore</span>
        <span class="s1">**kwargs: t.Any</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">super().__init__(response</span><span class="s2">, </span><span class="s1">status</span><span class="s2">, </span><span class="s1">headers</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.request = request</span>
        <span class="s1">self.history = history</span>
        <span class="s1">self._compat_tuple = response</span><span class="s2">, </span><span class="s1">status</span><span class="s2">, </span><span class="s1">headers</span>

    <span class="s1">@cached_property</span>
    <span class="s0">def </span><span class="s1">text(self) -&gt; str:</span>
        <span class="s4">&quot;&quot;&quot;The response data as text. A shortcut for 
        ``response.get_data(as_text=True)``. 
 
        .. versionadded:: 2.1 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.get_data(as_text=</span><span class="s0">True</span><span class="s1">)</span>


<span class="s1">@dataclasses.dataclass</span>
<span class="s0">class </span><span class="s1">Cookie:</span>
    <span class="s4">&quot;&quot;&quot;A cookie key, value, and parameters. 
 
    The class itself is not a public API. Its attributes are documented for inspection 
    with :meth:`.Client.get_cookie` only. 
 
    .. versionadded:: 2.3 
    &quot;&quot;&quot;</span>

    <span class="s1">key: str</span>
    <span class="s5">&quot;&quot;&quot;The cookie key, encoded as a client would see it.&quot;&quot;&quot;</span>

    <span class="s1">value: str</span>
    <span class="s5">&quot;&quot;&quot;The cookie key, encoded as a client would see it.&quot;&quot;&quot;</span>

    <span class="s1">decoded_key: str</span>
    <span class="s5">&quot;&quot;&quot;The cookie key, decoded as the application would set and see it.&quot;&quot;&quot;</span>

    <span class="s1">decoded_value: str</span>
    <span class="s5">&quot;&quot;&quot;The cookie value, decoded as the application would set and see it.&quot;&quot;&quot;</span>

    <span class="s1">expires: datetime | </span><span class="s0">None</span>
    <span class="s5">&quot;&quot;&quot;The time at which the cookie is no longer valid.&quot;&quot;&quot;</span>

    <span class="s1">max_age: int | </span><span class="s0">None</span>
    <span class="s5">&quot;&quot;&quot;The number of seconds from when the cookie was set at which it is 
    no longer valid. 
    &quot;&quot;&quot;</span>

    <span class="s1">domain: str</span>
    <span class="s5">&quot;&quot;&quot;The domain that the cookie was set for, or the request domain if not set.&quot;&quot;&quot;</span>

    <span class="s1">origin_only: bool</span>
    <span class="s5">&quot;&quot;&quot;Whether the cookie will be sent for exact domain matches only. This is ``True`` 
    if the ``Domain`` parameter was not present. 
    &quot;&quot;&quot;</span>

    <span class="s1">path: str</span>
    <span class="s5">&quot;&quot;&quot;The path that the cookie was set for.&quot;&quot;&quot;</span>

    <span class="s1">secure: bool | </span><span class="s0">None</span>
    <span class="s5">&quot;&quot;&quot;The ``Secure`` parameter.&quot;&quot;&quot;</span>

    <span class="s1">http_only: bool | </span><span class="s0">None</span>
    <span class="s5">&quot;&quot;&quot;The ``HttpOnly`` parameter.&quot;&quot;&quot;</span>

    <span class="s1">same_site: str | </span><span class="s0">None</span>
    <span class="s5">&quot;&quot;&quot;The ``SameSite`` parameter.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">_matches_request(self</span><span class="s2">, </span><span class="s1">server_name: str</span><span class="s2">, </span><span class="s1">path: str) -&gt; bool:</span>
        <span class="s0">return </span><span class="s1">(</span>
            <span class="s1">server_name == self.domain</span>
            <span class="s0">or </span><span class="s1">(</span>
                <span class="s0">not </span><span class="s1">self.origin_only</span>
                <span class="s0">and </span><span class="s1">server_name.endswith(self.domain)</span>
                <span class="s0">and </span><span class="s1">server_name[: -len(self.domain)].endswith(</span><span class="s5">&quot;.&quot;</span><span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s1">) </span><span class="s0">and </span><span class="s1">(</span>
            <span class="s1">path == self.path</span>
            <span class="s0">or </span><span class="s1">(</span>
                <span class="s1">path.startswith(self.path)</span>
                <span class="s0">and </span><span class="s1">path[len(self.path) - self.path.endswith(</span><span class="s5">&quot;/&quot;</span><span class="s1">) :].startswith(</span><span class="s5">&quot;/&quot;</span><span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_to_request_header(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s5">f&quot;</span><span class="s6">{</span><span class="s1">self.key</span><span class="s6">}</span><span class="s5">=</span><span class="s6">{</span><span class="s1">self.value</span><span class="s6">}</span><span class="s5">&quot;</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_from_response_header(cls</span><span class="s2">, </span><span class="s1">server_name: str</span><span class="s2">, </span><span class="s1">path: str</span><span class="s2">, </span><span class="s1">header: str) -&gt; te.Self:</span>
        <span class="s1">header</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">parameters_str = header.partition(</span><span class="s5">&quot;;&quot;</span><span class="s1">)</span>
        <span class="s1">key</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">value = header.partition(</span><span class="s5">&quot;=&quot;</span><span class="s1">)</span>
        <span class="s1">decoded_key</span><span class="s2">, </span><span class="s1">decoded_value = next(parse_cookie(header).items())  </span><span class="s7"># type: ignore[call-overload]</span>
        <span class="s1">params = {}</span>

        <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">parameters_str.split(</span><span class="s5">&quot;;&quot;</span><span class="s1">):</span>
            <span class="s1">k</span><span class="s2">, </span><span class="s1">sep</span><span class="s2">, </span><span class="s1">v = item.partition(</span><span class="s5">&quot;=&quot;</span><span class="s1">)</span>
            <span class="s1">params[k.strip().lower()] = v.strip() </span><span class="s0">if </span><span class="s1">sep </span><span class="s0">else None</span>

        <span class="s0">return </span><span class="s1">cls(</span>
            <span class="s1">key=key.strip()</span><span class="s2">,</span>
            <span class="s1">value=value.strip()</span><span class="s2">,</span>
            <span class="s1">decoded_key=decoded_key</span><span class="s2">,</span>
            <span class="s1">decoded_value=decoded_value</span><span class="s2">,</span>
            <span class="s1">expires=parse_date(params.get(</span><span class="s5">&quot;expires&quot;</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">max_age=int(params[</span><span class="s5">&quot;max-age&quot;</span><span class="s1">] </span><span class="s0">or </span><span class="s3">0</span><span class="s1">) </span><span class="s0">if </span><span class="s5">&quot;max-age&quot; </span><span class="s0">in </span><span class="s1">params </span><span class="s0">else None</span><span class="s2">,</span>
            <span class="s1">domain=params.get(</span><span class="s5">&quot;domain&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s1">server_name</span><span class="s2">,</span>
            <span class="s1">origin_only=</span><span class="s5">&quot;domain&quot; </span><span class="s0">not in </span><span class="s1">params</span><span class="s2">,</span>
            <span class="s1">path=params.get(</span><span class="s5">&quot;path&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s1">path.rpartition(</span><span class="s5">&quot;/&quot;</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">] </span><span class="s0">or </span><span class="s5">&quot;/&quot;</span><span class="s2">,</span>
            <span class="s1">secure=</span><span class="s5">&quot;secure&quot; </span><span class="s0">in </span><span class="s1">params</span><span class="s2">,</span>
            <span class="s1">http_only=</span><span class="s5">&quot;httponly&quot; </span><span class="s0">in </span><span class="s1">params</span><span class="s2">,</span>
            <span class="s1">same_site=params.get(</span><span class="s5">&quot;samesite&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_storage_key(self) -&gt; tuple[str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">str]:</span>
        <span class="s0">return </span><span class="s1">self.domain</span><span class="s2">, </span><span class="s1">self.path</span><span class="s2">, </span><span class="s1">self.decoded_key</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_should_delete(self) -&gt; bool:</span>
        <span class="s0">return </span><span class="s1">self.max_age == </span><span class="s3">0 </span><span class="s0">or </span><span class="s1">(</span>
            <span class="s1">self.expires </span><span class="s0">is not None and </span><span class="s1">self.expires.timestamp() == </span><span class="s3">0</span>
        <span class="s1">)</span>
</pre>
</body>
</html>