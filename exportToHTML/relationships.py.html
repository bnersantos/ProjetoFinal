<html>
<head>
<title>relationships.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5d69bb;}
.s1 { color: #d8d8d8;}
.s2 { color: #717ed3; font-style: italic;}
.s3 { color: #cc8b60;}
.s4 { color: #96bf7d;}
.s5 { color: #cc7832;}
.s6 { color: #bbb55b;}
.s7 { color: #d7539b; font-weight: bold;}
</style>
</head>
<body bgcolor="#1a1a25">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
relationships.py</font>
</center></td></tr></table>
<pre><span class="s0"># orm/relationships.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>

<span class="s2">&quot;&quot;&quot;Heuristics related to join conditions as used in 
:func:`_orm.relationship`. 
 
Provides the :class:`.JoinCondition` object, which encapsulates 
SQL annotation and aliasing behavior focused on the `primaryjoin` 
and `secondaryjoin` aspects of :func:`_orm.relationship`. 
 
&quot;&quot;&quot;</span>
<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">annotations</span>

<span class="s3">import </span><span class="s1">collections</span>
<span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">abc</span>
<span class="s3">import </span><span class="s1">dataclasses</span>
<span class="s3">import </span><span class="s1">inspect </span><span class="s3">as </span><span class="s1">_py_inspect</span>
<span class="s3">import </span><span class="s1">itertools</span>
<span class="s3">import </span><span class="s1">re</span>
<span class="s3">import </span><span class="s1">typing</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Callable</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">cast</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Collection</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Dict</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">FrozenSet</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Generic</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Iterable</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Iterator</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">List</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">NamedTuple</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">NoReturn</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Optional</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Sequence</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Set</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Tuple</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Type</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TypeVar</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Union</span>
<span class="s3">import </span><span class="s1">weakref</span>

<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">attributes</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">strategy_options</span>
<span class="s3">from </span><span class="s1">._typing </span><span class="s3">import </span><span class="s1">insp_is_aliased_class</span>
<span class="s3">from </span><span class="s1">._typing </span><span class="s3">import </span><span class="s1">is_has_collection_adapter</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">_DeclarativeMapped</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">_is_mapped_class</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">class_mapper</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">DynamicMapped</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">LoaderCallableStatus</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">PassiveFlag</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">state_str</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">WriteOnlyMapped</span>
<span class="s3">from </span><span class="s1">.interfaces </span><span class="s3">import </span><span class="s1">_AttributeOptions</span>
<span class="s3">from </span><span class="s1">.interfaces </span><span class="s3">import </span><span class="s1">_IntrospectsAnnotations</span>
<span class="s3">from </span><span class="s1">.interfaces </span><span class="s3">import </span><span class="s1">MANYTOMANY</span>
<span class="s3">from </span><span class="s1">.interfaces </span><span class="s3">import </span><span class="s1">MANYTOONE</span>
<span class="s3">from </span><span class="s1">.interfaces </span><span class="s3">import </span><span class="s1">ONETOMANY</span>
<span class="s3">from </span><span class="s1">.interfaces </span><span class="s3">import </span><span class="s1">PropComparator</span>
<span class="s3">from </span><span class="s1">.interfaces </span><span class="s3">import </span><span class="s1">RelationshipDirection</span>
<span class="s3">from </span><span class="s1">.interfaces </span><span class="s3">import </span><span class="s1">StrategizedProperty</span>
<span class="s3">from </span><span class="s1">.util </span><span class="s3">import </span><span class="s1">_orm_annotate</span>
<span class="s3">from </span><span class="s1">.util </span><span class="s3">import </span><span class="s1">_orm_deannotate</span>
<span class="s3">from </span><span class="s1">.util </span><span class="s3">import </span><span class="s1">CascadeOptions</span>
<span class="s3">from </span><span class="s1">.. </span><span class="s3">import </span><span class="s1">exc </span><span class="s3">as </span><span class="s1">sa_exc</span>
<span class="s3">from </span><span class="s1">.. </span><span class="s3">import </span><span class="s1">Exists</span>
<span class="s3">from </span><span class="s1">.. </span><span class="s3">import </span><span class="s1">log</span>
<span class="s3">from </span><span class="s1">.. </span><span class="s3">import </span><span class="s1">schema</span>
<span class="s3">from </span><span class="s1">.. </span><span class="s3">import </span><span class="s1">sql</span>
<span class="s3">from </span><span class="s1">.. </span><span class="s3">import </span><span class="s1">util</span>
<span class="s3">from </span><span class="s1">..inspection </span><span class="s3">import </span><span class="s1">inspect</span>
<span class="s3">from </span><span class="s1">..sql </span><span class="s3">import </span><span class="s1">coercions</span>
<span class="s3">from </span><span class="s1">..sql </span><span class="s3">import </span><span class="s1">expression</span>
<span class="s3">from </span><span class="s1">..sql </span><span class="s3">import </span><span class="s1">operators</span>
<span class="s3">from </span><span class="s1">..sql </span><span class="s3">import </span><span class="s1">roles</span>
<span class="s3">from </span><span class="s1">..sql </span><span class="s3">import </span><span class="s1">visitors</span>
<span class="s3">from </span><span class="s1">..sql._typing </span><span class="s3">import </span><span class="s1">_ColumnExpressionArgument</span>
<span class="s3">from </span><span class="s1">..sql._typing </span><span class="s3">import </span><span class="s1">_HasClauseElement</span>
<span class="s3">from </span><span class="s1">..sql.annotation </span><span class="s3">import </span><span class="s1">_safe_annotate</span>
<span class="s3">from </span><span class="s1">..sql.elements </span><span class="s3">import </span><span class="s1">ColumnClause</span>
<span class="s3">from </span><span class="s1">..sql.elements </span><span class="s3">import </span><span class="s1">ColumnElement</span>
<span class="s3">from </span><span class="s1">..sql.util </span><span class="s3">import </span><span class="s1">_deep_annotate</span>
<span class="s3">from </span><span class="s1">..sql.util </span><span class="s3">import </span><span class="s1">_deep_deannotate</span>
<span class="s3">from </span><span class="s1">..sql.util </span><span class="s3">import </span><span class="s1">_shallow_annotate</span>
<span class="s3">from </span><span class="s1">..sql.util </span><span class="s3">import </span><span class="s1">adapt_criterion_to_null</span>
<span class="s3">from </span><span class="s1">..sql.util </span><span class="s3">import </span><span class="s1">ClauseAdapter</span>
<span class="s3">from </span><span class="s1">..sql.util </span><span class="s3">import </span><span class="s1">join_condition</span>
<span class="s3">from </span><span class="s1">..sql.util </span><span class="s3">import </span><span class="s1">selectables_overlap</span>
<span class="s3">from </span><span class="s1">..sql.util </span><span class="s3">import </span><span class="s1">visit_binary_product</span>
<span class="s3">from </span><span class="s1">..util.typing </span><span class="s3">import </span><span class="s1">de_optionalize_union_types</span>
<span class="s3">from </span><span class="s1">..util.typing </span><span class="s3">import </span><span class="s1">Literal</span>
<span class="s3">from </span><span class="s1">..util.typing </span><span class="s3">import </span><span class="s1">resolve_name_to_real_class_name</span>

<span class="s3">if </span><span class="s1">typing.TYPE_CHECKING:</span>
    <span class="s3">from </span><span class="s1">._typing </span><span class="s3">import </span><span class="s1">_EntityType</span>
    <span class="s3">from </span><span class="s1">._typing </span><span class="s3">import </span><span class="s1">_ExternalEntityType</span>
    <span class="s3">from </span><span class="s1">._typing </span><span class="s3">import </span><span class="s1">_IdentityKeyType</span>
    <span class="s3">from </span><span class="s1">._typing </span><span class="s3">import </span><span class="s1">_InstanceDict</span>
    <span class="s3">from </span><span class="s1">._typing </span><span class="s3">import </span><span class="s1">_InternalEntityType</span>
    <span class="s3">from </span><span class="s1">._typing </span><span class="s3">import </span><span class="s1">_O</span>
    <span class="s3">from </span><span class="s1">._typing </span><span class="s3">import </span><span class="s1">_RegistryType</span>
    <span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">Mapped</span>
    <span class="s3">from </span><span class="s1">.clsregistry </span><span class="s3">import </span><span class="s1">_class_resolver</span>
    <span class="s3">from </span><span class="s1">.clsregistry </span><span class="s3">import </span><span class="s1">_ModNS</span>
    <span class="s3">from </span><span class="s1">.decl_base </span><span class="s3">import </span><span class="s1">_ClassScanMapperConfig</span>
    <span class="s3">from </span><span class="s1">.dependency </span><span class="s3">import </span><span class="s1">DependencyProcessor</span>
    <span class="s3">from </span><span class="s1">.mapper </span><span class="s3">import </span><span class="s1">Mapper</span>
    <span class="s3">from </span><span class="s1">.query </span><span class="s3">import </span><span class="s1">Query</span>
    <span class="s3">from </span><span class="s1">.session </span><span class="s3">import </span><span class="s1">Session</span>
    <span class="s3">from </span><span class="s1">.state </span><span class="s3">import </span><span class="s1">InstanceState</span>
    <span class="s3">from </span><span class="s1">.strategies </span><span class="s3">import </span><span class="s1">LazyLoader</span>
    <span class="s3">from </span><span class="s1">.util </span><span class="s3">import </span><span class="s1">AliasedClass</span>
    <span class="s3">from </span><span class="s1">.util </span><span class="s3">import </span><span class="s1">AliasedInsp</span>
    <span class="s3">from </span><span class="s1">..sql._typing </span><span class="s3">import </span><span class="s1">_CoreAdapterProto</span>
    <span class="s3">from </span><span class="s1">..sql._typing </span><span class="s3">import </span><span class="s1">_EquivalentColumnMap</span>
    <span class="s3">from </span><span class="s1">..sql._typing </span><span class="s3">import </span><span class="s1">_InfoType</span>
    <span class="s3">from </span><span class="s1">..sql.annotation </span><span class="s3">import </span><span class="s1">_AnnotationDict</span>
    <span class="s3">from </span><span class="s1">..sql.annotation </span><span class="s3">import </span><span class="s1">SupportsAnnotations</span>
    <span class="s3">from </span><span class="s1">..sql.elements </span><span class="s3">import </span><span class="s1">BinaryExpression</span>
    <span class="s3">from </span><span class="s1">..sql.elements </span><span class="s3">import </span><span class="s1">BindParameter</span>
    <span class="s3">from </span><span class="s1">..sql.elements </span><span class="s3">import </span><span class="s1">ClauseElement</span>
    <span class="s3">from </span><span class="s1">..sql.schema </span><span class="s3">import </span><span class="s1">Table</span>
    <span class="s3">from </span><span class="s1">..sql.selectable </span><span class="s3">import </span><span class="s1">FromClause</span>
    <span class="s3">from </span><span class="s1">..util.typing </span><span class="s3">import </span><span class="s1">_AnnotationScanType</span>
    <span class="s3">from </span><span class="s1">..util.typing </span><span class="s3">import </span><span class="s1">RODescriptorReference</span>

<span class="s1">_T = TypeVar(</span><span class="s4">&quot;_T&quot;</span><span class="s5">, </span><span class="s1">bound=Any)</span>
<span class="s1">_T1 = TypeVar(</span><span class="s4">&quot;_T1&quot;</span><span class="s5">, </span><span class="s1">bound=Any)</span>
<span class="s1">_T2 = TypeVar(</span><span class="s4">&quot;_T2&quot;</span><span class="s5">, </span><span class="s1">bound=Any)</span>

<span class="s1">_PT = TypeVar(</span><span class="s4">&quot;_PT&quot;</span><span class="s5">, </span><span class="s1">bound=Any)</span>

<span class="s1">_PT2 = TypeVar(</span><span class="s4">&quot;_PT2&quot;</span><span class="s5">, </span><span class="s1">bound=Any)</span>


<span class="s1">_RelationshipArgumentType = Union[</span>
    <span class="s1">str</span><span class="s5">,</span>
    <span class="s1">Type[_T]</span><span class="s5">,</span>
    <span class="s1">Callable[[]</span><span class="s5">, </span><span class="s1">Type[_T]]</span><span class="s5">,</span>
    <span class="s4">&quot;Mapper[_T]&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;AliasedClass[_T]&quot;</span><span class="s5">,</span>
    <span class="s1">Callable[[]</span><span class="s5">, </span><span class="s4">&quot;Mapper[_T]&quot;</span><span class="s1">]</span><span class="s5">,</span>
    <span class="s1">Callable[[]</span><span class="s5">, </span><span class="s4">&quot;AliasedClass[_T]&quot;</span><span class="s1">]</span><span class="s5">,</span>
<span class="s1">]</span>

<span class="s1">_LazyLoadArgumentType = Literal[</span>
    <span class="s4">&quot;select&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;joined&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;selectin&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;subquery&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;raise&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;raise_on_sql&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;noload&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;immediate&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;write_only&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;dynamic&quot;</span><span class="s5">,</span>
    <span class="s3">True</span><span class="s5">,</span>
    <span class="s3">False</span><span class="s5">,</span>
    <span class="s3">None</span><span class="s5">,</span>
<span class="s1">]</span>


<span class="s1">_RelationshipJoinConditionArgument = Union[</span>
    <span class="s1">str</span><span class="s5">, </span><span class="s1">_ColumnExpressionArgument[bool]</span>
<span class="s1">]</span>
<span class="s1">_RelationshipSecondaryArgument = Union[</span>
    <span class="s4">&quot;FromClause&quot;</span><span class="s5">, </span><span class="s1">str</span><span class="s5">, </span><span class="s1">Callable[[]</span><span class="s5">, </span><span class="s4">&quot;FromClause&quot;</span><span class="s1">]</span>
<span class="s1">]</span>
<span class="s1">_ORMOrderByArgument = Union[</span>
    <span class="s1">Literal[</span><span class="s3">False</span><span class="s1">]</span><span class="s5">,</span>
    <span class="s1">str</span><span class="s5">,</span>
    <span class="s1">_ColumnExpressionArgument[Any]</span><span class="s5">,</span>
    <span class="s1">Callable[[]</span><span class="s5">, </span><span class="s1">_ColumnExpressionArgument[Any]]</span><span class="s5">,</span>
    <span class="s1">Callable[[]</span><span class="s5">, </span><span class="s1">Iterable[_ColumnExpressionArgument[Any]]]</span><span class="s5">,</span>
    <span class="s1">Iterable[Union[str</span><span class="s5">, </span><span class="s1">_ColumnExpressionArgument[Any]]]</span><span class="s5">,</span>
<span class="s1">]</span>
<span class="s1">ORMBackrefArgument = Union[str</span><span class="s5">, </span><span class="s1">Tuple[str</span><span class="s5">, </span><span class="s1">Dict[str</span><span class="s5">, </span><span class="s1">Any]]]</span>

<span class="s1">_ORMColCollectionElement = Union[</span>
    <span class="s1">ColumnClause[Any]</span><span class="s5">,</span>
    <span class="s1">_HasClauseElement[Any]</span><span class="s5">,</span>
    <span class="s1">roles.DMLColumnRole</span><span class="s5">,</span>
    <span class="s4">&quot;Mapped[Any]&quot;</span><span class="s5">,</span>
<span class="s1">]</span>
<span class="s1">_ORMColCollectionArgument = Union[</span>
    <span class="s1">str</span><span class="s5">,</span>
    <span class="s1">Sequence[_ORMColCollectionElement]</span><span class="s5">,</span>
    <span class="s1">Callable[[]</span><span class="s5">, </span><span class="s1">Sequence[_ORMColCollectionElement]]</span><span class="s5">,</span>
    <span class="s1">Callable[[]</span><span class="s5">, </span><span class="s1">_ORMColCollectionElement]</span><span class="s5">,</span>
    <span class="s1">_ORMColCollectionElement</span><span class="s5">,</span>
<span class="s1">]</span>


<span class="s1">_CEA = TypeVar(</span><span class="s4">&quot;_CEA&quot;</span><span class="s5">, </span><span class="s1">bound=_ColumnExpressionArgument[Any])</span>

<span class="s1">_CE = TypeVar(</span><span class="s4">&quot;_CE&quot;</span><span class="s5">, </span><span class="s1">bound=</span><span class="s4">&quot;ColumnElement[Any]&quot;</span><span class="s1">)</span>


<span class="s1">_ColumnPairIterable = Iterable[Tuple[ColumnElement[Any]</span><span class="s5">, </span><span class="s1">ColumnElement[Any]]]</span>

<span class="s1">_ColumnPairs = Sequence[Tuple[ColumnElement[Any]</span><span class="s5">, </span><span class="s1">ColumnElement[Any]]]</span>

<span class="s1">_MutableColumnPairs = List[Tuple[ColumnElement[Any]</span><span class="s5">, </span><span class="s1">ColumnElement[Any]]]</span>


<span class="s3">def </span><span class="s1">remote(expr: _CEA) -&gt; _CEA:</span>
    <span class="s2">&quot;&quot;&quot;Annotate a portion of a primaryjoin expression 
    with a 'remote' annotation. 
 
    See the section :ref:`relationship_custom_foreign` for a 
    description of use. 
 
    .. seealso:: 
 
        :ref:`relationship_custom_foreign` 
 
        :func:`.foreign` 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_annotate_columns(  </span><span class="s0"># type: ignore</span>
        <span class="s1">coercions.expect(roles.ColumnArgumentRole</span><span class="s5">, </span><span class="s1">expr)</span><span class="s5">, </span><span class="s1">{</span><span class="s4">&quot;remote&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">}</span>
    <span class="s1">)</span>


<span class="s3">def </span><span class="s1">foreign(expr: _CEA) -&gt; _CEA:</span>
    <span class="s2">&quot;&quot;&quot;Annotate a portion of a primaryjoin expression 
    with a 'foreign' annotation. 
 
    See the section :ref:`relationship_custom_foreign` for a 
    description of use. 
 
    .. seealso:: 
 
        :ref:`relationship_custom_foreign` 
 
        :func:`.remote` 
 
    &quot;&quot;&quot;</span>

    <span class="s3">return </span><span class="s1">_annotate_columns(  </span><span class="s0"># type: ignore</span>
        <span class="s1">coercions.expect(roles.ColumnArgumentRole</span><span class="s5">, </span><span class="s1">expr)</span><span class="s5">, </span><span class="s1">{</span><span class="s4">&quot;foreign&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">}</span>
    <span class="s1">)</span>


<span class="s1">@dataclasses.dataclass</span>
<span class="s3">class </span><span class="s1">_RelationshipArg(Generic[_T1</span><span class="s5">, </span><span class="s1">_T2]):</span>
    <span class="s2">&quot;&quot;&quot;stores a user-defined parameter value that must be resolved and 
    parsed later at mapper configuration time. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = </span><span class="s4">&quot;name&quot;</span><span class="s5">, </span><span class="s4">&quot;argument&quot;</span><span class="s5">, </span><span class="s4">&quot;resolved&quot;</span>
    <span class="s1">name: str</span>
    <span class="s1">argument: _T1</span>
    <span class="s1">resolved: Optional[_T2]</span>

    <span class="s3">def </span><span class="s1">_is_populated(self) -&gt; bool:</span>
        <span class="s3">return </span><span class="s1">self.argument </span><span class="s3">is not None</span>

    <span class="s3">def </span><span class="s1">_resolve_against_registry(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">clsregistry_resolver: Callable[[str</span><span class="s5">, </span><span class="s1">bool]</span><span class="s5">, </span><span class="s1">_class_resolver]</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">attr_value = self.argument</span>

        <span class="s3">if </span><span class="s1">isinstance(attr_value</span><span class="s5">, </span><span class="s1">str):</span>
            <span class="s1">self.resolved = clsregistry_resolver(</span>
                <span class="s1">attr_value</span><span class="s5">, </span><span class="s1">self.name == </span><span class="s4">&quot;secondary&quot;</span>
            <span class="s1">)()</span>
        <span class="s3">elif </span><span class="s1">callable(attr_value) </span><span class="s3">and not </span><span class="s1">_is_mapped_class(attr_value):</span>
            <span class="s1">self.resolved = attr_value()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.resolved = attr_value</span>


<span class="s1">_RelationshipOrderByArg = Union[Literal[</span><span class="s3">False</span><span class="s1">]</span><span class="s5">, </span><span class="s1">Tuple[ColumnElement[Any]</span><span class="s5">, </span><span class="s1">...]]</span>


<span class="s3">class </span><span class="s1">_RelationshipArgs(NamedTuple):</span>
    <span class="s2">&quot;&quot;&quot;stores user-passed parameters that are resolved at mapper configuration 
    time. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">secondary: _RelationshipArg[</span>
        <span class="s1">Optional[_RelationshipSecondaryArgument]</span><span class="s5">,</span>
        <span class="s1">Optional[FromClause]</span><span class="s5">,</span>
    <span class="s1">]</span>
    <span class="s1">primaryjoin: _RelationshipArg[</span>
        <span class="s1">Optional[_RelationshipJoinConditionArgument]</span><span class="s5">,</span>
        <span class="s1">Optional[ColumnElement[Any]]</span><span class="s5">,</span>
    <span class="s1">]</span>
    <span class="s1">secondaryjoin: _RelationshipArg[</span>
        <span class="s1">Optional[_RelationshipJoinConditionArgument]</span><span class="s5">,</span>
        <span class="s1">Optional[ColumnElement[Any]]</span><span class="s5">,</span>
    <span class="s1">]</span>
    <span class="s1">order_by: _RelationshipArg[_ORMOrderByArgument</span><span class="s5">, </span><span class="s1">_RelationshipOrderByArg]</span>
    <span class="s1">foreign_keys: _RelationshipArg[</span>
        <span class="s1">Optional[_ORMColCollectionArgument]</span><span class="s5">, </span><span class="s1">Set[ColumnElement[Any]]</span>
    <span class="s1">]</span>
    <span class="s1">remote_side: _RelationshipArg[</span>
        <span class="s1">Optional[_ORMColCollectionArgument]</span><span class="s5">, </span><span class="s1">Set[ColumnElement[Any]]</span>
    <span class="s1">]</span>


<span class="s1">@log.class_logger</span>
<span class="s3">class </span><span class="s1">RelationshipProperty(</span>
    <span class="s1">_IntrospectsAnnotations</span><span class="s5">, </span><span class="s1">StrategizedProperty[_T]</span><span class="s5">, </span><span class="s1">log.Identified</span>
<span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Describes an object property that holds a single item or list 
    of items that correspond to a related database table. 
 
    Public constructor is the :func:`_orm.relationship` function. 
 
    .. seealso:: 
 
        :ref:`relationship_config_toplevel` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">strategy_wildcard_key = strategy_options._RELATIONSHIP_TOKEN</span>
    <span class="s1">inherit_cache = </span><span class="s3">True</span>
    <span class="s4">&quot;&quot;&quot;:meta private:&quot;&quot;&quot;</span>

    <span class="s1">_links_to_entity = </span><span class="s3">True</span>
    <span class="s1">_is_relationship = </span><span class="s3">True</span>

    <span class="s1">_overlaps: Sequence[str]</span>

    <span class="s1">_lazy_strategy: LazyLoader</span>

    <span class="s1">_persistence_only = dict(</span>
        <span class="s1">passive_deletes=</span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">passive_updates=</span><span class="s3">True</span><span class="s5">,</span>
        <span class="s1">enable_typechecks=</span><span class="s3">True</span><span class="s5">,</span>
        <span class="s1">active_history=</span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">cascade_backrefs=</span><span class="s3">False</span><span class="s5">,</span>
    <span class="s1">)</span>

    <span class="s1">_dependency_processor: Optional[DependencyProcessor] = </span><span class="s3">None</span>

    <span class="s1">primaryjoin: ColumnElement[bool]</span>
    <span class="s1">secondaryjoin: Optional[ColumnElement[bool]]</span>
    <span class="s1">secondary: Optional[FromClause]</span>
    <span class="s1">_join_condition: JoinCondition</span>
    <span class="s1">order_by: _RelationshipOrderByArg</span>

    <span class="s1">_user_defined_foreign_keys: Set[ColumnElement[Any]]</span>
    <span class="s1">_calculated_foreign_keys: Set[ColumnElement[Any]]</span>

    <span class="s1">remote_side: Set[ColumnElement[Any]]</span>
    <span class="s1">local_columns: Set[ColumnElement[Any]]</span>

    <span class="s1">synchronize_pairs: _ColumnPairs</span>
    <span class="s1">secondary_synchronize_pairs: Optional[_ColumnPairs]</span>

    <span class="s1">local_remote_pairs: Optional[_ColumnPairs]</span>

    <span class="s1">direction: RelationshipDirection</span>

    <span class="s1">_init_args: _RelationshipArgs</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">argument: Optional[_RelationshipArgumentType[_T]] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">secondary: Optional[_RelationshipSecondaryArgument] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">*</span><span class="s5">,</span>
        <span class="s1">uselist: Optional[bool] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">collection_class: Optional[</span>
            <span class="s1">Union[Type[Collection[Any]]</span><span class="s5">, </span><span class="s1">Callable[[]</span><span class="s5">, </span><span class="s1">Collection[Any]]]</span>
        <span class="s1">] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">primaryjoin: Optional[_RelationshipJoinConditionArgument] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">secondaryjoin: Optional[_RelationshipJoinConditionArgument] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">back_populates: Optional[str] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">order_by: _ORMOrderByArgument = </span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">backref: Optional[ORMBackrefArgument] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">overlaps: Optional[str] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">post_update: bool = </span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">cascade: str = </span><span class="s4">&quot;save-update, merge&quot;</span><span class="s5">,</span>
        <span class="s1">viewonly: bool = </span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">attribute_options: Optional[_AttributeOptions] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">lazy: _LazyLoadArgumentType = </span><span class="s4">&quot;select&quot;</span><span class="s5">,</span>
        <span class="s1">passive_deletes: Union[Literal[</span><span class="s4">&quot;all&quot;</span><span class="s1">]</span><span class="s5">, </span><span class="s1">bool] = </span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">passive_updates: bool = </span><span class="s3">True</span><span class="s5">,</span>
        <span class="s1">active_history: bool = </span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">enable_typechecks: bool = </span><span class="s3">True</span><span class="s5">,</span>
        <span class="s1">foreign_keys: Optional[_ORMColCollectionArgument] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">remote_side: Optional[_ORMColCollectionArgument] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">join_depth: Optional[int] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">comparator_factory: Optional[</span>
            <span class="s1">Type[RelationshipProperty.Comparator[Any]]</span>
        <span class="s1">] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">single_parent: bool = </span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">innerjoin: bool = </span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">distinct_target_key: Optional[bool] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">load_on_pending: bool = </span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">query_class: Optional[Type[Query[Any]]] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">info: Optional[_InfoType] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">omit_join: Literal[</span><span class="s3">None</span><span class="s5">, </span><span class="s3">False</span><span class="s1">] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">sync_backref: Optional[bool] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">doc: Optional[str] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">bake_queries: Literal[</span><span class="s3">True</span><span class="s1">] = </span><span class="s3">True</span><span class="s5">,</span>
        <span class="s1">cascade_backrefs: Literal[</span><span class="s3">False</span><span class="s1">] = </span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">_local_remote_pairs: Optional[_ColumnPairs] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">_legacy_inactive_history_style: bool = </span><span class="s3">False</span><span class="s5">,</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(attribute_options=attribute_options)</span>

        <span class="s1">self.uselist = uselist</span>
        <span class="s1">self.argument = argument</span>

        <span class="s1">self._init_args = _RelationshipArgs(</span>
            <span class="s1">_RelationshipArg(</span><span class="s4">&quot;secondary&quot;</span><span class="s5">, </span><span class="s1">secondary</span><span class="s5">, </span><span class="s3">None</span><span class="s1">)</span><span class="s5">,</span>
            <span class="s1">_RelationshipArg(</span><span class="s4">&quot;primaryjoin&quot;</span><span class="s5">, </span><span class="s1">primaryjoin</span><span class="s5">, </span><span class="s3">None</span><span class="s1">)</span><span class="s5">,</span>
            <span class="s1">_RelationshipArg(</span><span class="s4">&quot;secondaryjoin&quot;</span><span class="s5">, </span><span class="s1">secondaryjoin</span><span class="s5">, </span><span class="s3">None</span><span class="s1">)</span><span class="s5">,</span>
            <span class="s1">_RelationshipArg(</span><span class="s4">&quot;order_by&quot;</span><span class="s5">, </span><span class="s1">order_by</span><span class="s5">, </span><span class="s3">None</span><span class="s1">)</span><span class="s5">,</span>
            <span class="s1">_RelationshipArg(</span><span class="s4">&quot;foreign_keys&quot;</span><span class="s5">, </span><span class="s1">foreign_keys</span><span class="s5">, </span><span class="s3">None</span><span class="s1">)</span><span class="s5">,</span>
            <span class="s1">_RelationshipArg(</span><span class="s4">&quot;remote_side&quot;</span><span class="s5">, </span><span class="s1">remote_side</span><span class="s5">, </span><span class="s3">None</span><span class="s1">)</span><span class="s5">,</span>
        <span class="s1">)</span>

        <span class="s1">self.post_update = post_update</span>
        <span class="s1">self.viewonly = viewonly</span>
        <span class="s3">if </span><span class="s1">viewonly:</span>
            <span class="s1">self._warn_for_persistence_only_flags(</span>
                <span class="s1">passive_deletes=passive_deletes</span><span class="s5">,</span>
                <span class="s1">passive_updates=passive_updates</span><span class="s5">,</span>
                <span class="s1">enable_typechecks=enable_typechecks</span><span class="s5">,</span>
                <span class="s1">active_history=active_history</span><span class="s5">,</span>
                <span class="s1">cascade_backrefs=cascade_backrefs</span><span class="s5">,</span>
            <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">viewonly </span><span class="s3">and </span><span class="s1">sync_backref:</span>
            <span class="s3">raise </span><span class="s1">sa_exc.ArgumentError(</span>
                <span class="s4">&quot;sync_backref and viewonly cannot both be True&quot;</span>
            <span class="s1">)</span>
        <span class="s1">self.sync_backref = sync_backref</span>
        <span class="s1">self.lazy = lazy</span>
        <span class="s1">self.single_parent = single_parent</span>
        <span class="s1">self.collection_class = collection_class</span>
        <span class="s1">self.passive_deletes = passive_deletes</span>

        <span class="s3">if </span><span class="s1">cascade_backrefs:</span>
            <span class="s3">raise </span><span class="s1">sa_exc.ArgumentError(</span>
                <span class="s4">&quot;The 'cascade_backrefs' parameter passed to &quot;</span>
                <span class="s4">&quot;relationship() may only be set to False.&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self.passive_updates = passive_updates</span>
        <span class="s1">self.enable_typechecks = enable_typechecks</span>
        <span class="s1">self.query_class = query_class</span>
        <span class="s1">self.innerjoin = innerjoin</span>
        <span class="s1">self.distinct_target_key = distinct_target_key</span>
        <span class="s1">self.doc = doc</span>
        <span class="s1">self.active_history = active_history</span>
        <span class="s1">self._legacy_inactive_history_style = _legacy_inactive_history_style</span>

        <span class="s1">self.join_depth = join_depth</span>
        <span class="s3">if </span><span class="s1">omit_join:</span>
            <span class="s1">util.warn(</span>
                <span class="s4">&quot;setting omit_join to True is not supported; selectin &quot;</span>
                <span class="s4">&quot;loading of this relationship may not work correctly if this &quot;</span>
                <span class="s4">&quot;flag is set explicitly.  omit_join optimization is &quot;</span>
                <span class="s4">&quot;automatically detected for conditions under which it is &quot;</span>
                <span class="s4">&quot;supported.&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self.omit_join = omit_join</span>
        <span class="s1">self.local_remote_pairs = _local_remote_pairs</span>
        <span class="s1">self.load_on_pending = load_on_pending</span>
        <span class="s1">self.comparator_factory = (</span>
            <span class="s1">comparator_factory </span><span class="s3">or </span><span class="s1">RelationshipProperty.Comparator</span>
        <span class="s1">)</span>
        <span class="s1">util.set_creation_order(self)</span>

        <span class="s3">if </span><span class="s1">info </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.info.update(info)</span>

        <span class="s1">self.strategy_key = ((</span><span class="s4">&quot;lazy&quot;</span><span class="s5">, </span><span class="s1">self.lazy)</span><span class="s5">,</span><span class="s1">)</span>

        <span class="s1">self._reverse_property: Set[RelationshipProperty[Any]] = set()</span>

        <span class="s3">if </span><span class="s1">overlaps:</span>
            <span class="s1">self._overlaps = set(re.split(</span><span class="s4">r&quot;\s*,\s*&quot;</span><span class="s5">, </span><span class="s1">overlaps))  </span><span class="s0"># type: ignore  # noqa: E501</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self._overlaps = ()</span>

        <span class="s0"># mypy ignoring the @property setter</span>
        <span class="s1">self.cascade = cascade  </span><span class="s0"># type: ignore</span>

        <span class="s1">self.back_populates = back_populates</span>

        <span class="s3">if </span><span class="s1">self.back_populates:</span>
            <span class="s3">if </span><span class="s1">backref:</span>
                <span class="s3">raise </span><span class="s1">sa_exc.ArgumentError(</span>
                    <span class="s4">&quot;backref and back_populates keyword arguments &quot;</span>
                    <span class="s4">&quot;are mutually exclusive&quot;</span>
                <span class="s1">)</span>
            <span class="s1">self.backref = </span><span class="s3">None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.backref = backref</span>

    <span class="s3">def </span><span class="s1">_warn_for_persistence_only_flags(self</span><span class="s5">, </span><span class="s1">**kw: Any) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">for </span><span class="s1">k</span><span class="s5">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">kw.items():</span>
            <span class="s3">if </span><span class="s1">v != self._persistence_only[k]:</span>
                <span class="s0"># we are warning here rather than warn deprecated as this is a</span>
                <span class="s0"># configuration mistake, and Python shows regular warnings more</span>
                <span class="s0"># aggressively than deprecation warnings by default. Unlike the</span>
                <span class="s0"># case of setting viewonly with cascade, the settings being</span>
                <span class="s0"># warned about here are not actively doing the wrong thing</span>
                <span class="s0"># against viewonly=True, so it is not as urgent to have these</span>
                <span class="s0"># raise an error.</span>
                <span class="s1">util.warn(</span>
                    <span class="s4">&quot;Setting %s on relationship() while also &quot;</span>
                    <span class="s4">&quot;setting viewonly=True does not make sense, as a &quot;</span>
                    <span class="s4">&quot;viewonly=True relationship does not perform persistence &quot;</span>
                    <span class="s4">&quot;operations. This configuration may raise an error &quot;</span>
                    <span class="s4">&quot;in a future release.&quot; </span><span class="s1">% (k</span><span class="s5">,</span><span class="s1">)</span>
                <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">instrument_class(self</span><span class="s5">, </span><span class="s1">mapper: Mapper[Any]) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">attributes.register_descriptor(</span>
            <span class="s1">mapper.class_</span><span class="s5">,</span>
            <span class="s1">self.key</span><span class="s5">,</span>
            <span class="s1">comparator=self.comparator_factory(self</span><span class="s5">, </span><span class="s1">mapper)</span><span class="s5">,</span>
            <span class="s1">parententity=mapper</span><span class="s5">,</span>
            <span class="s1">doc=self.doc</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">class </span><span class="s1">Comparator(util.MemoizedSlots</span><span class="s5">, </span><span class="s1">PropComparator[_PT]):</span>
        <span class="s2">&quot;&quot;&quot;Produce boolean, comparison, and other operators for 
        :class:`.RelationshipProperty` attributes. 
 
        See the documentation for :class:`.PropComparator` for a brief 
        overview of ORM level operator definition. 
 
        .. seealso:: 
 
            :class:`.PropComparator` 
 
            :class:`.ColumnProperty.Comparator` 
 
            :class:`.ColumnOperators` 
 
            :ref:`types_operators` 
 
            :attr:`.TypeEngine.comparator_factory` 
 
        &quot;&quot;&quot;</span>

        <span class="s1">__slots__ = (</span>
            <span class="s4">&quot;entity&quot;</span><span class="s5">,</span>
            <span class="s4">&quot;mapper&quot;</span><span class="s5">,</span>
            <span class="s4">&quot;property&quot;</span><span class="s5">,</span>
            <span class="s4">&quot;_of_type&quot;</span><span class="s5">,</span>
            <span class="s4">&quot;_extra_criteria&quot;</span><span class="s5">,</span>
        <span class="s1">)</span>

        <span class="s1">prop: RODescriptorReference[RelationshipProperty[_PT]]</span>
        <span class="s1">_of_type: Optional[_EntityType[_PT]]</span>

        <span class="s3">def </span><span class="s1">__init__(</span>
            <span class="s1">self</span><span class="s5">,</span>
            <span class="s1">prop: RelationshipProperty[_PT]</span><span class="s5">,</span>
            <span class="s1">parentmapper: _InternalEntityType[Any]</span><span class="s5">,</span>
            <span class="s1">adapt_to_entity: Optional[AliasedInsp[Any]] = </span><span class="s3">None</span><span class="s5">,</span>
            <span class="s1">of_type: Optional[_EntityType[_PT]] = </span><span class="s3">None</span><span class="s5">,</span>
            <span class="s1">extra_criteria: Tuple[ColumnElement[bool]</span><span class="s5">, </span><span class="s1">...] = ()</span><span class="s5">,</span>
        <span class="s1">):</span>
            <span class="s2">&quot;&quot;&quot;Construction of :class:`.RelationshipProperty.Comparator` 
            is internal to the ORM's attribute mechanics. 
 
            &quot;&quot;&quot;</span>
            <span class="s1">self.prop = prop</span>
            <span class="s1">self._parententity = parentmapper</span>
            <span class="s1">self._adapt_to_entity = adapt_to_entity</span>
            <span class="s3">if </span><span class="s1">of_type:</span>
                <span class="s1">self._of_type = of_type</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self._of_type = </span><span class="s3">None</span>
            <span class="s1">self._extra_criteria = extra_criteria</span>

        <span class="s3">def </span><span class="s1">adapt_to_entity(</span>
            <span class="s1">self</span><span class="s5">, </span><span class="s1">adapt_to_entity: AliasedInsp[Any]</span>
        <span class="s1">) -&gt; RelationshipProperty.Comparator[Any]:</span>
            <span class="s3">return </span><span class="s1">self.__class__(</span>
                <span class="s1">self.prop</span><span class="s5">,</span>
                <span class="s1">self._parententity</span><span class="s5">,</span>
                <span class="s1">adapt_to_entity=adapt_to_entity</span><span class="s5">,</span>
                <span class="s1">of_type=self._of_type</span><span class="s5">,</span>
            <span class="s1">)</span>

        <span class="s1">entity: _InternalEntityType[_PT]</span>
        <span class="s4">&quot;&quot;&quot;The target entity referred to by this 
        :class:`.RelationshipProperty.Comparator`. 
 
        This is either a :class:`_orm.Mapper` or :class:`.AliasedInsp` 
        object. 
 
        This is the &quot;target&quot; or &quot;remote&quot; side of the 
        :func:`_orm.relationship`. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">mapper: Mapper[_PT]</span>
        <span class="s4">&quot;&quot;&quot;The target :class:`_orm.Mapper` referred to by this 
        :class:`.RelationshipProperty.Comparator`. 
 
        This is the &quot;target&quot; or &quot;remote&quot; side of the 
        :func:`_orm.relationship`. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">def </span><span class="s1">_memoized_attr_entity(self) -&gt; _InternalEntityType[_PT]:</span>
            <span class="s3">if </span><span class="s1">self._of_type:</span>
                <span class="s3">return </span><span class="s1">inspect(self._of_type)  </span><span class="s0"># type: ignore</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">self.prop.entity</span>

        <span class="s3">def </span><span class="s1">_memoized_attr_mapper(self) -&gt; Mapper[_PT]:</span>
            <span class="s3">return </span><span class="s1">self.entity.mapper</span>

        <span class="s3">def </span><span class="s1">_source_selectable(self) -&gt; FromClause:</span>
            <span class="s3">if </span><span class="s1">self._adapt_to_entity:</span>
                <span class="s3">return </span><span class="s1">self._adapt_to_entity.selectable</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">self.property.parent._with_polymorphic_selectable</span>

        <span class="s3">def </span><span class="s1">__clause_element__(self) -&gt; ColumnElement[bool]:</span>
            <span class="s1">adapt_from = self._source_selectable()</span>
            <span class="s3">if </span><span class="s1">self._of_type:</span>
                <span class="s1">of_type_entity = inspect(self._of_type)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">of_type_entity = </span><span class="s3">None</span>

            <span class="s1">(</span>
                <span class="s1">pj</span><span class="s5">,</span>
                <span class="s1">sj</span><span class="s5">,</span>
                <span class="s1">source</span><span class="s5">,</span>
                <span class="s1">dest</span><span class="s5">,</span>
                <span class="s1">secondary</span><span class="s5">,</span>
                <span class="s1">target_adapter</span><span class="s5">,</span>
            <span class="s1">) = self.prop._create_joins(</span>
                <span class="s1">source_selectable=adapt_from</span><span class="s5">,</span>
                <span class="s1">source_polymorphic=</span><span class="s3">True</span><span class="s5">,</span>
                <span class="s1">of_type_entity=of_type_entity</span><span class="s5">,</span>
                <span class="s1">alias_secondary=</span><span class="s3">True</span><span class="s5">,</span>
                <span class="s1">extra_criteria=self._extra_criteria</span><span class="s5">,</span>
            <span class="s1">)</span>
            <span class="s3">if </span><span class="s1">sj </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">pj &amp; sj</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">pj</span>

        <span class="s3">def </span><span class="s1">of_type(self</span><span class="s5">, </span><span class="s1">class_: _EntityType[Any]) -&gt; PropComparator[_PT]:</span>
            <span class="s2">r&quot;&quot;&quot;Redefine this object in terms of a polymorphic subclass. 
 
            See :meth:`.PropComparator.of_type` for an example. 
 
 
            &quot;&quot;&quot;</span>
            <span class="s3">return </span><span class="s1">RelationshipProperty.Comparator(</span>
                <span class="s1">self.prop</span><span class="s5">,</span>
                <span class="s1">self._parententity</span><span class="s5">,</span>
                <span class="s1">adapt_to_entity=self._adapt_to_entity</span><span class="s5">,</span>
                <span class="s1">of_type=class_</span><span class="s5">,</span>
                <span class="s1">extra_criteria=self._extra_criteria</span><span class="s5">,</span>
            <span class="s1">)</span>

        <span class="s3">def </span><span class="s1">and_(</span>
            <span class="s1">self</span><span class="s5">, </span><span class="s1">*criteria: _ColumnExpressionArgument[bool]</span>
        <span class="s1">) -&gt; PropComparator[Any]:</span>
            <span class="s2">&quot;&quot;&quot;Add AND criteria. 
 
            See :meth:`.PropComparator.and_` for an example. 
 
            .. versionadded:: 1.4 
 
            &quot;&quot;&quot;</span>
            <span class="s1">exprs = tuple(</span>
                <span class="s1">coercions.expect(roles.WhereHavingRole</span><span class="s5">, </span><span class="s1">clause)</span>
                <span class="s3">for </span><span class="s1">clause </span><span class="s3">in </span><span class="s1">util.coerce_generator_arg(criteria)</span>
            <span class="s1">)</span>

            <span class="s3">return </span><span class="s1">RelationshipProperty.Comparator(</span>
                <span class="s1">self.prop</span><span class="s5">,</span>
                <span class="s1">self._parententity</span><span class="s5">,</span>
                <span class="s1">adapt_to_entity=self._adapt_to_entity</span><span class="s5">,</span>
                <span class="s1">of_type=self._of_type</span><span class="s5">,</span>
                <span class="s1">extra_criteria=self._extra_criteria + exprs</span><span class="s5">,</span>
            <span class="s1">)</span>

        <span class="s3">def </span><span class="s1">in_(self</span><span class="s5">, </span><span class="s1">other: Any) -&gt; NoReturn:</span>
            <span class="s2">&quot;&quot;&quot;Produce an IN clause - this is not implemented 
            for :func:`_orm.relationship`-based attributes at this time. 
 
            &quot;&quot;&quot;</span>
            <span class="s3">raise </span><span class="s1">NotImplementedError(</span>
                <span class="s4">&quot;in_() not yet supported for &quot;</span>
                <span class="s4">&quot;relationships.  For a simple &quot;</span>
                <span class="s4">&quot;many-to-one, use in_() against &quot;</span>
                <span class="s4">&quot;the set of foreign key values.&quot;</span>
            <span class="s1">)</span>

        <span class="s0"># https://github.com/python/mypy/issues/4266</span>
        <span class="s1">__hash__ = </span><span class="s3">None  </span><span class="s0"># type: ignore</span>

        <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s5">, </span><span class="s1">other: Any) -&gt; ColumnElement[bool]:  </span><span class="s0"># type: ignore[override]  # noqa: E501</span>
            <span class="s2">&quot;&quot;&quot;Implement the ``==`` operator. 
 
            In a many-to-one context, such as:: 
 
              MyClass.some_prop == &lt;some object&gt; 
 
            this will typically produce a 
            clause such as:: 
 
              mytable.related_id == &lt;some id&gt; 
 
            Where ``&lt;some id&gt;`` is the primary key of the given 
            object. 
 
            The ``==`` operator provides partial functionality for non- 
            many-to-one comparisons: 
 
            * Comparisons against collections are not supported. 
              Use :meth:`~.Relationship.Comparator.contains`. 
            * Compared to a scalar one-to-many, will produce a 
              clause that compares the target columns in the parent to 
              the given target. 
            * Compared to a scalar many-to-many, an alias 
              of the association table will be rendered as 
              well, forming a natural join that is part of the 
              main body of the query. This will not work for 
              queries that go beyond simple AND conjunctions of 
              comparisons, such as those which use OR. Use 
              explicit joins, outerjoins, or 
              :meth:`~.Relationship.Comparator.has` for 
              more comprehensive non-many-to-one scalar 
              membership tests. 
            * Comparisons against ``None`` given in a one-to-many 
              or many-to-many context produce a NOT EXISTS clause. 
 
            &quot;&quot;&quot;</span>
            <span class="s3">if </span><span class="s1">other </span><span class="s3">is None or </span><span class="s1">isinstance(other</span><span class="s5">, </span><span class="s1">expression.Null):</span>
                <span class="s3">if </span><span class="s1">self.property.direction </span><span class="s3">in </span><span class="s1">[ONETOMANY</span><span class="s5">, </span><span class="s1">MANYTOMANY]:</span>
                    <span class="s3">return </span><span class="s1">~self._criterion_exists()</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s1">_orm_annotate(</span>
                        <span class="s1">self.property._optimized_compare(</span>
                            <span class="s3">None</span><span class="s5">, </span><span class="s1">adapt_source=self.adapter</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>
            <span class="s3">elif </span><span class="s1">self.property.uselist:</span>
                <span class="s3">raise </span><span class="s1">sa_exc.InvalidRequestError(</span>
                    <span class="s4">&quot;Can't compare a collection to an object or collection; &quot;</span>
                    <span class="s4">&quot;use contains() to test for membership.&quot;</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">_orm_annotate(</span>
                    <span class="s1">self.property._optimized_compare(</span>
                        <span class="s1">other</span><span class="s5">, </span><span class="s1">adapt_source=self.adapter</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>

        <span class="s3">def </span><span class="s1">_criterion_exists(</span>
            <span class="s1">self</span><span class="s5">,</span>
            <span class="s1">criterion: Optional[_ColumnExpressionArgument[bool]] = </span><span class="s3">None</span><span class="s5">,</span>
            <span class="s1">**kwargs: Any</span><span class="s5">,</span>
        <span class="s1">) -&gt; Exists:</span>
            <span class="s1">where_criteria = (</span>
                <span class="s1">coercions.expect(roles.WhereHavingRole</span><span class="s5">, </span><span class="s1">criterion)</span>
                <span class="s3">if </span><span class="s1">criterion </span><span class="s3">is not None</span>
                <span class="s3">else None</span>
            <span class="s1">)</span>

            <span class="s3">if </span><span class="s1">getattr(self</span><span class="s5">, </span><span class="s4">&quot;_of_type&quot;</span><span class="s5">, </span><span class="s3">None</span><span class="s1">):</span>
                <span class="s1">info: Optional[_InternalEntityType[Any]] = inspect(</span>
                    <span class="s1">self._of_type</span>
                <span class="s1">)</span>
                <span class="s3">assert </span><span class="s1">info </span><span class="s3">is not None</span>
                <span class="s1">target_mapper</span><span class="s5">, </span><span class="s1">to_selectable</span><span class="s5">, </span><span class="s1">is_aliased_class = (</span>
                    <span class="s1">info.mapper</span><span class="s5">,</span>
                    <span class="s1">info.selectable</span><span class="s5">,</span>
                    <span class="s1">info.is_aliased_class</span><span class="s5">,</span>
                <span class="s1">)</span>
                <span class="s3">if </span><span class="s1">self.property._is_self_referential </span><span class="s3">and not </span><span class="s1">is_aliased_class:</span>
                    <span class="s1">to_selectable = to_selectable._anonymous_fromclause()</span>

                <span class="s1">single_crit = target_mapper._single_table_criterion</span>
                <span class="s3">if </span><span class="s1">single_crit </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s3">if </span><span class="s1">where_criteria </span><span class="s3">is not None</span><span class="s1">:</span>
                        <span class="s1">where_criteria = single_crit &amp; where_criteria</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">where_criteria = single_crit</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">is_aliased_class = </span><span class="s3">False</span>
                <span class="s1">to_selectable = </span><span class="s3">None</span>

            <span class="s3">if </span><span class="s1">self.adapter:</span>
                <span class="s1">source_selectable = self._source_selectable()</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">source_selectable = </span><span class="s3">None</span>

            <span class="s1">(</span>
                <span class="s1">pj</span><span class="s5">,</span>
                <span class="s1">sj</span><span class="s5">,</span>
                <span class="s1">source</span><span class="s5">,</span>
                <span class="s1">dest</span><span class="s5">,</span>
                <span class="s1">secondary</span><span class="s5">,</span>
                <span class="s1">target_adapter</span><span class="s5">,</span>
            <span class="s1">) = self.property._create_joins(</span>
                <span class="s1">dest_selectable=to_selectable</span><span class="s5">,</span>
                <span class="s1">source_selectable=source_selectable</span><span class="s5">,</span>
            <span class="s1">)</span>

            <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">kwargs:</span>
                <span class="s1">crit = getattr(self.property.mapper.class_</span><span class="s5">, </span><span class="s1">k) == kwargs[k]</span>
                <span class="s3">if </span><span class="s1">where_criteria </span><span class="s3">is None</span><span class="s1">:</span>
                    <span class="s1">where_criteria = crit</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">where_criteria = where_criteria &amp; crit</span>

            <span class="s0"># annotate the *local* side of the join condition, in the case</span>
            <span class="s0"># of pj + sj this is the full primaryjoin, in the case of just</span>
            <span class="s0"># pj its the local side of the primaryjoin.</span>
            <span class="s3">if </span><span class="s1">sj </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">j = _orm_annotate(pj) &amp; sj</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">j = _orm_annotate(pj</span><span class="s5">, </span><span class="s1">exclude=self.property.remote_side)</span>

            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">where_criteria </span><span class="s3">is not None</span>
                <span class="s3">and </span><span class="s1">target_adapter</span>
                <span class="s3">and not </span><span class="s1">is_aliased_class</span>
            <span class="s1">):</span>
                <span class="s0"># limit this adapter to annotated only?</span>
                <span class="s1">where_criteria = target_adapter.traverse(where_criteria)</span>

            <span class="s0"># only have the &quot;joined left side&quot; of what we</span>
            <span class="s0"># return be subject to Query adaption.  The right</span>
            <span class="s0"># side of it is used for an exists() subquery and</span>
            <span class="s0"># should not correlate or otherwise reach out</span>
            <span class="s0"># to anything in the enclosing query.</span>
            <span class="s3">if </span><span class="s1">where_criteria </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">where_criteria = where_criteria._annotate(</span>
                    <span class="s1">{</span><span class="s4">&quot;no_replacement_traverse&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">}</span>
                <span class="s1">)</span>

            <span class="s1">crit = j &amp; sql.True_._ifnone(where_criteria)</span>

            <span class="s3">if </span><span class="s1">secondary </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">ex = (</span>
                    <span class="s1">sql.exists(</span><span class="s6">1</span><span class="s1">)</span>
                    <span class="s1">.where(crit)</span>
                    <span class="s1">.select_from(dest</span><span class="s5">, </span><span class="s1">secondary)</span>
                    <span class="s1">.correlate_except(dest</span><span class="s5">, </span><span class="s1">secondary)</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">ex = (</span>
                    <span class="s1">sql.exists(</span><span class="s6">1</span><span class="s1">)</span>
                    <span class="s1">.where(crit)</span>
                    <span class="s1">.select_from(dest)</span>
                    <span class="s1">.correlate_except(dest)</span>
                <span class="s1">)</span>
            <span class="s3">return </span><span class="s1">ex</span>

        <span class="s3">def </span><span class="s1">any(</span>
            <span class="s1">self</span><span class="s5">,</span>
            <span class="s1">criterion: Optional[_ColumnExpressionArgument[bool]] = </span><span class="s3">None</span><span class="s5">,</span>
            <span class="s1">**kwargs: Any</span><span class="s5">,</span>
        <span class="s1">) -&gt; ColumnElement[bool]:</span>
            <span class="s2">&quot;&quot;&quot;Produce an expression that tests a collection against 
            particular criterion, using EXISTS. 
 
            An expression like:: 
 
                session.query(MyClass).filter( 
                    MyClass.somereference.any(SomeRelated.x==2) 
                ) 
 
 
            Will produce a query like:: 
 
                SELECT * FROM my_table WHERE 
                EXISTS (SELECT 1 FROM related WHERE related.my_id=my_table.id 
                AND related.x=2) 
 
            Because :meth:`~.Relationship.Comparator.any` uses 
            a correlated subquery, its performance is not nearly as 
            good when compared against large target tables as that of 
            using a join. 
 
            :meth:`~.Relationship.Comparator.any` is particularly 
            useful for testing for empty collections:: 
 
                session.query(MyClass).filter( 
                    ~MyClass.somereference.any() 
                ) 
 
            will produce:: 
 
                SELECT * FROM my_table WHERE 
                NOT (EXISTS (SELECT 1 FROM related WHERE 
                related.my_id=my_table.id)) 
 
            :meth:`~.Relationship.Comparator.any` is only 
            valid for collections, i.e. a :func:`_orm.relationship` 
            that has ``uselist=True``.  For scalar references, 
            use :meth:`~.Relationship.Comparator.has`. 
 
            &quot;&quot;&quot;</span>
            <span class="s3">if not </span><span class="s1">self.property.uselist:</span>
                <span class="s3">raise </span><span class="s1">sa_exc.InvalidRequestError(</span>
                    <span class="s4">&quot;'any()' not implemented for scalar &quot;</span>
                    <span class="s4">&quot;attributes. Use has().&quot;</span>
                <span class="s1">)</span>

            <span class="s3">return </span><span class="s1">self._criterion_exists(criterion</span><span class="s5">, </span><span class="s1">**kwargs)</span>

        <span class="s3">def </span><span class="s1">has(</span>
            <span class="s1">self</span><span class="s5">,</span>
            <span class="s1">criterion: Optional[_ColumnExpressionArgument[bool]] = </span><span class="s3">None</span><span class="s5">,</span>
            <span class="s1">**kwargs: Any</span><span class="s5">,</span>
        <span class="s1">) -&gt; ColumnElement[bool]:</span>
            <span class="s2">&quot;&quot;&quot;Produce an expression that tests a scalar reference against 
            particular criterion, using EXISTS. 
 
            An expression like:: 
 
                session.query(MyClass).filter( 
                    MyClass.somereference.has(SomeRelated.x==2) 
                ) 
 
 
            Will produce a query like:: 
 
                SELECT * FROM my_table WHERE 
                EXISTS (SELECT 1 FROM related WHERE 
                related.id==my_table.related_id AND related.x=2) 
 
            Because :meth:`~.Relationship.Comparator.has` uses 
            a correlated subquery, its performance is not nearly as 
            good when compared against large target tables as that of 
            using a join. 
 
            :meth:`~.Relationship.Comparator.has` is only 
            valid for scalar references, i.e. a :func:`_orm.relationship` 
            that has ``uselist=False``.  For collection references, 
            use :meth:`~.Relationship.Comparator.any`. 
 
            &quot;&quot;&quot;</span>
            <span class="s3">if </span><span class="s1">self.property.uselist:</span>
                <span class="s3">raise </span><span class="s1">sa_exc.InvalidRequestError(</span>
                    <span class="s4">&quot;'has()' not implemented for collections. Use any().&quot;</span>
                <span class="s1">)</span>
            <span class="s3">return </span><span class="s1">self._criterion_exists(criterion</span><span class="s5">, </span><span class="s1">**kwargs)</span>

        <span class="s3">def </span><span class="s1">contains(</span>
            <span class="s1">self</span><span class="s5">, </span><span class="s1">other: _ColumnExpressionArgument[Any]</span><span class="s5">, </span><span class="s1">**kwargs: Any</span>
        <span class="s1">) -&gt; ColumnElement[bool]:</span>
            <span class="s2">&quot;&quot;&quot;Return a simple expression that tests a collection for 
            containment of a particular item. 
 
            :meth:`~.Relationship.Comparator.contains` is 
            only valid for a collection, i.e. a 
            :func:`_orm.relationship` that implements 
            one-to-many or many-to-many with ``uselist=True``. 
 
            When used in a simple one-to-many context, an 
            expression like:: 
 
                MyClass.contains(other) 
 
            Produces a clause like:: 
 
                mytable.id == &lt;some id&gt; 
 
            Where ``&lt;some id&gt;`` is the value of the foreign key 
            attribute on ``other`` which refers to the primary 
            key of its parent object. From this it follows that 
            :meth:`~.Relationship.Comparator.contains` is 
            very useful when used with simple one-to-many 
            operations. 
 
            For many-to-many operations, the behavior of 
            :meth:`~.Relationship.Comparator.contains` 
            has more caveats. The association table will be 
            rendered in the statement, producing an &quot;implicit&quot; 
            join, that is, includes multiple tables in the FROM 
            clause which are equated in the WHERE clause:: 
 
                query(MyClass).filter(MyClass.contains(other)) 
 
            Produces a query like:: 
 
                SELECT * FROM my_table, my_association_table AS 
                my_association_table_1 WHERE 
                my_table.id = my_association_table_1.parent_id 
                AND my_association_table_1.child_id = &lt;some id&gt; 
 
            Where ``&lt;some id&gt;`` would be the primary key of 
            ``other``. From the above, it is clear that 
            :meth:`~.Relationship.Comparator.contains` 
            will **not** work with many-to-many collections when 
            used in queries that move beyond simple AND 
            conjunctions, such as multiple 
            :meth:`~.Relationship.Comparator.contains` 
            expressions joined by OR. In such cases subqueries or 
            explicit &quot;outer joins&quot; will need to be used instead. 
            See :meth:`~.Relationship.Comparator.any` for 
            a less-performant alternative using EXISTS, or refer 
            to :meth:`_query.Query.outerjoin` 
            as well as :ref:`orm_queryguide_joins` 
            for more details on constructing outer joins. 
 
            kwargs may be ignored by this operator but are required for API 
            conformance. 
            &quot;&quot;&quot;</span>
            <span class="s3">if not </span><span class="s1">self.prop.uselist:</span>
                <span class="s3">raise </span><span class="s1">sa_exc.InvalidRequestError(</span>
                    <span class="s4">&quot;'contains' not implemented for scalar &quot;</span>
                    <span class="s4">&quot;attributes.  Use ==&quot;</span>
                <span class="s1">)</span>

            <span class="s1">clause = self.prop._optimized_compare(</span>
                <span class="s1">other</span><span class="s5">, </span><span class="s1">adapt_source=self.adapter</span>
            <span class="s1">)</span>

            <span class="s3">if </span><span class="s1">self.prop.secondaryjoin </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">clause.negation_clause = self.__negated_contains_or_equals(</span>
                    <span class="s1">other</span>
                <span class="s1">)</span>

            <span class="s3">return </span><span class="s1">clause</span>

        <span class="s3">def </span><span class="s1">__negated_contains_or_equals(</span>
            <span class="s1">self</span><span class="s5">, </span><span class="s1">other: Any</span>
        <span class="s1">) -&gt; ColumnElement[bool]:</span>
            <span class="s3">if </span><span class="s1">self.prop.direction == MANYTOONE:</span>
                <span class="s1">state = attributes.instance_state(other)</span>

                <span class="s3">def </span><span class="s1">state_bindparam(</span>
                    <span class="s1">local_col: ColumnElement[Any]</span><span class="s5">,</span>
                    <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
                    <span class="s1">remote_col: ColumnElement[Any]</span><span class="s5">,</span>
                <span class="s1">) -&gt; BindParameter[Any]:</span>
                    <span class="s1">dict_ = state.dict</span>
                    <span class="s3">return </span><span class="s1">sql.bindparam(</span>
                        <span class="s1">local_col.key</span><span class="s5">,</span>
                        <span class="s1">type_=local_col.type</span><span class="s5">,</span>
                        <span class="s1">unique=</span><span class="s3">True</span><span class="s5">,</span>
                        <span class="s1">callable_=self.prop._get_attr_w_warn_on_none(</span>
                            <span class="s1">self.prop.mapper</span><span class="s5">, </span><span class="s1">state</span><span class="s5">, </span><span class="s1">dict_</span><span class="s5">, </span><span class="s1">remote_col</span>
                        <span class="s1">)</span><span class="s5">,</span>
                    <span class="s1">)</span>

                <span class="s3">def </span><span class="s1">adapt(col: _CE) -&gt; _CE:</span>
                    <span class="s3">if </span><span class="s1">self.adapter:</span>
                        <span class="s3">return </span><span class="s1">self.adapter(col)</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s3">return </span><span class="s1">col</span>

                <span class="s3">if </span><span class="s1">self.property._use_get:</span>
                    <span class="s3">return </span><span class="s1">sql.and_(</span>
                        <span class="s1">*[</span>
                            <span class="s1">sql.or_(</span>
                                <span class="s1">adapt(x)</span>
                                <span class="s1">!= state_bindparam(adapt(x)</span><span class="s5">, </span><span class="s1">state</span><span class="s5">, </span><span class="s1">y)</span><span class="s5">,</span>
                                <span class="s1">adapt(x) == </span><span class="s3">None</span><span class="s5">,</span>
                            <span class="s1">)</span>
                            <span class="s3">for </span><span class="s1">(x</span><span class="s5">, </span><span class="s1">y) </span><span class="s3">in </span><span class="s1">self.property.local_remote_pairs</span>
                        <span class="s1">]</span>
                    <span class="s1">)</span>

            <span class="s1">criterion = sql.and_(</span>
                <span class="s1">*[</span>
                    <span class="s1">x == y</span>
                    <span class="s3">for </span><span class="s1">(x</span><span class="s5">, </span><span class="s1">y) </span><span class="s3">in </span><span class="s1">zip(</span>
                        <span class="s1">self.property.mapper.primary_key</span><span class="s5">,</span>
                        <span class="s1">self.property.mapper.primary_key_from_instance(other)</span><span class="s5">,</span>
                    <span class="s1">)</span>
                <span class="s1">]</span>
            <span class="s1">)</span>

            <span class="s3">return </span><span class="s1">~self._criterion_exists(criterion)</span>

        <span class="s3">def </span><span class="s1">__ne__(self</span><span class="s5">, </span><span class="s1">other: Any) -&gt; ColumnElement[bool]:  </span><span class="s0"># type: ignore[override]  # noqa: E501</span>
            <span class="s2">&quot;&quot;&quot;Implement the ``!=`` operator. 
 
            In a many-to-one context, such as:: 
 
              MyClass.some_prop != &lt;some object&gt; 
 
            This will typically produce a clause such as:: 
 
              mytable.related_id != &lt;some id&gt; 
 
            Where ``&lt;some id&gt;`` is the primary key of the 
            given object. 
 
            The ``!=`` operator provides partial functionality for non- 
            many-to-one comparisons: 
 
            * Comparisons against collections are not supported. 
              Use 
              :meth:`~.Relationship.Comparator.contains` 
              in conjunction with :func:`_expression.not_`. 
            * Compared to a scalar one-to-many, will produce a 
              clause that compares the target columns in the parent to 
              the given target. 
            * Compared to a scalar many-to-many, an alias 
              of the association table will be rendered as 
              well, forming a natural join that is part of the 
              main body of the query. This will not work for 
              queries that go beyond simple AND conjunctions of 
              comparisons, such as those which use OR. Use 
              explicit joins, outerjoins, or 
              :meth:`~.Relationship.Comparator.has` in 
              conjunction with :func:`_expression.not_` for 
              more comprehensive non-many-to-one scalar 
              membership tests. 
            * Comparisons against ``None`` given in a one-to-many 
              or many-to-many context produce an EXISTS clause. 
 
            &quot;&quot;&quot;</span>
            <span class="s3">if </span><span class="s1">other </span><span class="s3">is None or </span><span class="s1">isinstance(other</span><span class="s5">, </span><span class="s1">expression.Null):</span>
                <span class="s3">if </span><span class="s1">self.property.direction == MANYTOONE:</span>
                    <span class="s3">return </span><span class="s1">_orm_annotate(</span>
                        <span class="s1">~self.property._optimized_compare(</span>
                            <span class="s3">None</span><span class="s5">, </span><span class="s1">adapt_source=self.adapter</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>

                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s1">self._criterion_exists()</span>
            <span class="s3">elif </span><span class="s1">self.property.uselist:</span>
                <span class="s3">raise </span><span class="s1">sa_exc.InvalidRequestError(</span>
                    <span class="s4">&quot;Can't compare a collection&quot;</span>
                    <span class="s4">&quot; to an object or collection; use &quot;</span>
                    <span class="s4">&quot;contains() to test for membership.&quot;</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">_orm_annotate(self.__negated_contains_or_equals(other))</span>

        <span class="s3">def </span><span class="s1">_memoized_attr_property(self) -&gt; RelationshipProperty[_PT]:</span>
            <span class="s1">self.prop.parent._check_configure()</span>
            <span class="s3">return </span><span class="s1">self.prop</span>

    <span class="s3">def </span><span class="s1">_with_parent(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">instance: object</span><span class="s5">,</span>
        <span class="s1">alias_secondary: bool = </span><span class="s3">True</span><span class="s5">,</span>
        <span class="s1">from_entity: Optional[_EntityType[Any]] = </span><span class="s3">None</span><span class="s5">,</span>
    <span class="s1">) -&gt; ColumnElement[bool]:</span>
        <span class="s3">assert </span><span class="s1">instance </span><span class="s3">is not None</span>
        <span class="s1">adapt_source: Optional[_CoreAdapterProto] = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">from_entity </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">insp: Optional[_InternalEntityType[Any]] = inspect(from_entity)</span>
            <span class="s3">assert </span><span class="s1">insp </span><span class="s3">is not None</span>
            <span class="s3">if </span><span class="s1">insp_is_aliased_class(insp):</span>
                <span class="s1">adapt_source = insp._adapter.adapt_clause</span>
        <span class="s3">return </span><span class="s1">self._optimized_compare(</span>
            <span class="s1">instance</span><span class="s5">,</span>
            <span class="s1">value_is_parent=</span><span class="s3">True</span><span class="s5">,</span>
            <span class="s1">adapt_source=adapt_source</span><span class="s5">,</span>
            <span class="s1">alias_secondary=alias_secondary</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_optimized_compare(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: Any</span><span class="s5">,</span>
        <span class="s1">value_is_parent: bool = </span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">adapt_source: Optional[_CoreAdapterProto] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">alias_secondary: bool = </span><span class="s3">True</span><span class="s5">,</span>
    <span class="s1">) -&gt; ColumnElement[bool]:</span>
        <span class="s3">if </span><span class="s1">state </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">state = inspect(state)</span>
            <span class="s3">except </span><span class="s1">sa_exc.NoInspectionAvailable:</span>
                <span class="s1">state = </span><span class="s3">None</span>

            <span class="s3">if </span><span class="s1">state </span><span class="s3">is None or not </span><span class="s1">getattr(state</span><span class="s5">, </span><span class="s4">&quot;is_instance&quot;</span><span class="s5">, </span><span class="s3">False</span><span class="s1">):</span>
                <span class="s3">raise </span><span class="s1">sa_exc.ArgumentError(</span>
                    <span class="s4">&quot;Mapped instance expected for relationship &quot;</span>
                    <span class="s4">&quot;comparison to object.   Classes, queries and other &quot;</span>
                    <span class="s4">&quot;SQL elements are not accepted in this context; for &quot;</span>
                    <span class="s4">&quot;comparison with a subquery, &quot;</span>
                    <span class="s4">&quot;use %s.has(**criteria).&quot; </span><span class="s1">% self</span>
                <span class="s1">)</span>
        <span class="s1">reverse_direction = </span><span class="s3">not </span><span class="s1">value_is_parent</span>

        <span class="s3">if </span><span class="s1">state </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self._lazy_none_clause(</span>
                <span class="s1">reverse_direction</span><span class="s5">, </span><span class="s1">adapt_source=adapt_source</span>
            <span class="s1">)</span>

        <span class="s3">if not </span><span class="s1">reverse_direction:</span>
            <span class="s1">criterion</span><span class="s5">, </span><span class="s1">bind_to_col = (</span>
                <span class="s1">self._lazy_strategy._lazywhere</span><span class="s5">,</span>
                <span class="s1">self._lazy_strategy._bind_to_col</span><span class="s5">,</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">criterion</span><span class="s5">, </span><span class="s1">bind_to_col = (</span>
                <span class="s1">self._lazy_strategy._rev_lazywhere</span><span class="s5">,</span>
                <span class="s1">self._lazy_strategy._rev_bind_to_col</span><span class="s5">,</span>
            <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">reverse_direction:</span>
            <span class="s1">mapper = self.mapper</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">mapper = self.parent</span>

        <span class="s1">dict_ = attributes.instance_dict(state.obj())</span>

        <span class="s3">def </span><span class="s1">visit_bindparam(bindparam: BindParameter[Any]) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">bindparam._identifying_key </span><span class="s3">in </span><span class="s1">bind_to_col:</span>
                <span class="s1">bindparam.callable = self._get_attr_w_warn_on_none(</span>
                    <span class="s1">mapper</span><span class="s5">,</span>
                    <span class="s1">state</span><span class="s5">,</span>
                    <span class="s1">dict_</span><span class="s5">,</span>
                    <span class="s1">bind_to_col[bindparam._identifying_key]</span><span class="s5">,</span>
                <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">self.secondary </span><span class="s3">is not None and </span><span class="s1">alias_secondary:</span>
            <span class="s1">criterion = ClauseAdapter(</span>
                <span class="s1">self.secondary._anonymous_fromclause()</span>
            <span class="s1">).traverse(criterion)</span>

        <span class="s1">criterion = visitors.cloned_traverse(</span>
            <span class="s1">criterion</span><span class="s5">, </span><span class="s1">{}</span><span class="s5">, </span><span class="s1">{</span><span class="s4">&quot;bindparam&quot;</span><span class="s1">: visit_bindparam}</span>
        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">adapt_source:</span>
            <span class="s1">criterion = adapt_source(criterion)</span>
        <span class="s3">return </span><span class="s1">criterion</span>

    <span class="s3">def </span><span class="s1">_get_attr_w_warn_on_none(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">mapper: Mapper[Any]</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">column: ColumnElement[Any]</span><span class="s5">,</span>
    <span class="s1">) -&gt; Callable[[]</span><span class="s5">, </span><span class="s1">Any]:</span>
        <span class="s2">&quot;&quot;&quot;Create the callable that is used in a many-to-one expression. 
 
        E.g.:: 
 
            u1 = s.query(User).get(5) 
 
            expr = Address.user == u1 
 
        Above, the SQL should be &quot;address.user_id = 5&quot;. The callable 
        returned by this method produces the value &quot;5&quot; based on the identity 
        of ``u1``. 
 
        &quot;&quot;&quot;</span>

        <span class="s0"># in this callable, we're trying to thread the needle through</span>
        <span class="s0"># a wide variety of scenarios, including:</span>
        <span class="s0">#</span>
        <span class="s0"># * the object hasn't been flushed yet and there's no value for</span>
        <span class="s0">#   the attribute as of yet</span>
        <span class="s0">#</span>
        <span class="s0"># * the object hasn't been flushed yet but it has a user-defined</span>
        <span class="s0">#   value</span>
        <span class="s0">#</span>
        <span class="s0"># * the object has a value but it's expired and not locally present</span>
        <span class="s0">#</span>
        <span class="s0"># * the object has a value but it's expired and not locally present,</span>
        <span class="s0">#   and the object is also detached</span>
        <span class="s0">#</span>
        <span class="s0"># * The object hadn't been flushed yet, there was no value, but</span>
        <span class="s0">#   later, the object has been expired and detached, and *now*</span>
        <span class="s0">#   they're trying to evaluate it</span>
        <span class="s0">#</span>
        <span class="s0"># * the object had a value, but it was changed to a new value, and</span>
        <span class="s0">#   then expired</span>
        <span class="s0">#</span>
        <span class="s0"># * the object had a value, but it was changed to a new value, and</span>
        <span class="s0">#   then expired, then the object was detached</span>
        <span class="s0">#</span>
        <span class="s0"># * the object has a user-set value, but it's None and we don't do</span>
        <span class="s0">#   the comparison correctly for that so warn</span>
        <span class="s0">#</span>

        <span class="s1">prop = mapper.get_property_by_column(column)</span>

        <span class="s0"># by invoking this method, InstanceState will track the last known</span>
        <span class="s0"># value for this key each time the attribute is to be expired.</span>
        <span class="s0"># this feature was added explicitly for use in this method.</span>
        <span class="s1">state._track_last_known_value(prop.key)</span>

        <span class="s1">lkv_fixed = state._last_known_values</span>

        <span class="s3">def </span><span class="s1">_go() -&gt; Any:</span>
            <span class="s3">assert </span><span class="s1">lkv_fixed </span><span class="s3">is not None</span>
            <span class="s1">last_known = to_return = lkv_fixed[prop.key]</span>
            <span class="s1">existing_is_available = (</span>
                <span class="s1">last_known </span><span class="s3">is not </span><span class="s1">LoaderCallableStatus.NO_VALUE</span>
            <span class="s1">)</span>

            <span class="s0"># we support that the value may have changed.  so here we</span>
            <span class="s0"># try to get the most recent value including re-fetching.</span>
            <span class="s0"># only if we can't get a value now due to detachment do we return</span>
            <span class="s0"># the last known value</span>
            <span class="s1">current_value = mapper._get_state_attr_by_column(</span>
                <span class="s1">state</span><span class="s5">,</span>
                <span class="s1">dict_</span><span class="s5">,</span>
                <span class="s1">column</span><span class="s5">,</span>
                <span class="s1">passive=(</span>
                    <span class="s1">PassiveFlag.PASSIVE_OFF</span>
                    <span class="s3">if </span><span class="s1">state.persistent</span>
                    <span class="s3">else </span><span class="s1">PassiveFlag.PASSIVE_NO_FETCH ^ PassiveFlag.INIT_OK</span>
                <span class="s1">)</span><span class="s5">,</span>
            <span class="s1">)</span>

            <span class="s3">if </span><span class="s1">current_value </span><span class="s3">is </span><span class="s1">LoaderCallableStatus.NEVER_SET:</span>
                <span class="s3">if not </span><span class="s1">existing_is_available:</span>
                    <span class="s3">raise </span><span class="s1">sa_exc.InvalidRequestError(</span>
                        <span class="s4">&quot;Can't resolve value for column %s on object &quot;</span>
                        <span class="s4">&quot;%s; no value has been set for this column&quot;</span>
                        <span class="s1">% (column</span><span class="s5">, </span><span class="s1">state_str(state))</span>
                    <span class="s1">)</span>
            <span class="s3">elif </span><span class="s1">current_value </span><span class="s3">is </span><span class="s1">LoaderCallableStatus.PASSIVE_NO_RESULT:</span>
                <span class="s3">if not </span><span class="s1">existing_is_available:</span>
                    <span class="s3">raise </span><span class="s1">sa_exc.InvalidRequestError(</span>
                        <span class="s4">&quot;Can't resolve value for column %s on object &quot;</span>
                        <span class="s4">&quot;%s; the object is detached and the value was &quot;</span>
                        <span class="s4">&quot;expired&quot; </span><span class="s1">% (column</span><span class="s5">, </span><span class="s1">state_str(state))</span>
                    <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">to_return = current_value</span>
            <span class="s3">if </span><span class="s1">to_return </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">util.warn(</span>
                    <span class="s4">&quot;Got None for value of column %s; this is unsupported &quot;</span>
                    <span class="s4">&quot;for a relationship comparison and will not &quot;</span>
                    <span class="s4">&quot;currently produce an IS comparison &quot;</span>
                    <span class="s4">&quot;(but may in a future release)&quot; </span><span class="s1">% column</span>
                <span class="s1">)</span>
            <span class="s3">return </span><span class="s1">to_return</span>

        <span class="s3">return </span><span class="s1">_go</span>

    <span class="s3">def </span><span class="s1">_lazy_none_clause(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">reverse_direction: bool = </span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">adapt_source: Optional[_CoreAdapterProto] = </span><span class="s3">None</span><span class="s5">,</span>
    <span class="s1">) -&gt; ColumnElement[bool]:</span>
        <span class="s3">if not </span><span class="s1">reverse_direction:</span>
            <span class="s1">criterion</span><span class="s5">, </span><span class="s1">bind_to_col = (</span>
                <span class="s1">self._lazy_strategy._lazywhere</span><span class="s5">,</span>
                <span class="s1">self._lazy_strategy._bind_to_col</span><span class="s5">,</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">criterion</span><span class="s5">, </span><span class="s1">bind_to_col = (</span>
                <span class="s1">self._lazy_strategy._rev_lazywhere</span><span class="s5">,</span>
                <span class="s1">self._lazy_strategy._rev_bind_to_col</span><span class="s5">,</span>
            <span class="s1">)</span>

        <span class="s1">criterion = adapt_criterion_to_null(criterion</span><span class="s5">, </span><span class="s1">bind_to_col)</span>

        <span class="s3">if </span><span class="s1">adapt_source:</span>
            <span class="s1">criterion = adapt_source(criterion)</span>
        <span class="s3">return </span><span class="s1">criterion</span>

    <span class="s3">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s3">return </span><span class="s1">str(self.parent.class_.__name__) + </span><span class="s4">&quot;.&quot; </span><span class="s1">+ self.key</span>

    <span class="s3">def </span><span class="s1">merge(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">session: Session</span><span class="s5">,</span>
        <span class="s1">source_state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">source_dict: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">dest_state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dest_dict: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">load: bool</span><span class="s5">,</span>
        <span class="s1">_recursive: Dict[Any</span><span class="s5">, </span><span class="s1">object]</span><span class="s5">,</span>
        <span class="s1">_resolve_conflict_map: Dict[_IdentityKeyType[Any]</span><span class="s5">, </span><span class="s1">object]</span><span class="s5">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">load:</span>
            <span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">self._reverse_property:</span>
                <span class="s3">if </span><span class="s1">(source_state</span><span class="s5">, </span><span class="s1">r) </span><span class="s3">in </span><span class="s1">_recursive:</span>
                    <span class="s3">return</span>

        <span class="s3">if </span><span class="s4">&quot;merge&quot; </span><span class="s3">not in </span><span class="s1">self._cascade:</span>
            <span class="s3">return</span>

        <span class="s3">if </span><span class="s1">self.key </span><span class="s3">not in </span><span class="s1">source_dict:</span>
            <span class="s3">return</span>

        <span class="s3">if </span><span class="s1">self.uselist:</span>
            <span class="s1">impl = source_state.get_impl(self.key)</span>

            <span class="s3">assert </span><span class="s1">is_has_collection_adapter(impl)</span>
            <span class="s1">instances_iterable = impl.get_collection(source_state</span><span class="s5">, </span><span class="s1">source_dict)</span>

            <span class="s0"># if this is a CollectionAttributeImpl, then empty should</span>
            <span class="s0"># be False, otherwise &quot;self.key in source_dict&quot; should not be</span>
            <span class="s0"># True</span>
            <span class="s3">assert not </span><span class="s1">instances_iterable.empty </span><span class="s3">if </span><span class="s1">impl.collection </span><span class="s3">else True</span>

            <span class="s3">if </span><span class="s1">load:</span>
                <span class="s0"># for a full merge, pre-load the destination collection,</span>
                <span class="s0"># so that individual _merge of each item pulls from identity</span>
                <span class="s0"># map for those already present.</span>
                <span class="s0"># also assumes CollectionAttributeImpl behavior of loading</span>
                <span class="s0"># &quot;old&quot; list in any case</span>
                <span class="s1">dest_state.get_impl(self.key).get(</span>
                    <span class="s1">dest_state</span><span class="s5">, </span><span class="s1">dest_dict</span><span class="s5">, </span><span class="s1">passive=PassiveFlag.PASSIVE_MERGE</span>
                <span class="s1">)</span>

            <span class="s1">dest_list = []</span>
            <span class="s3">for </span><span class="s1">current </span><span class="s3">in </span><span class="s1">instances_iterable:</span>
                <span class="s1">current_state = attributes.instance_state(current)</span>
                <span class="s1">current_dict = attributes.instance_dict(current)</span>
                <span class="s1">_recursive[(current_state</span><span class="s5">, </span><span class="s1">self)] = </span><span class="s3">True</span>
                <span class="s1">obj = session._merge(</span>
                    <span class="s1">current_state</span><span class="s5">,</span>
                    <span class="s1">current_dict</span><span class="s5">,</span>
                    <span class="s1">load=load</span><span class="s5">,</span>
                    <span class="s1">_recursive=_recursive</span><span class="s5">,</span>
                    <span class="s1">_resolve_conflict_map=_resolve_conflict_map</span><span class="s5">,</span>
                <span class="s1">)</span>
                <span class="s3">if </span><span class="s1">obj </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">dest_list.append(obj)</span>

            <span class="s3">if not </span><span class="s1">load:</span>
                <span class="s1">coll = attributes.init_state_collection(</span>
                    <span class="s1">dest_state</span><span class="s5">, </span><span class="s1">dest_dict</span><span class="s5">, </span><span class="s1">self.key</span>
                <span class="s1">)</span>
                <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">dest_list:</span>
                    <span class="s1">coll.append_without_event(c)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">dest_impl = dest_state.get_impl(self.key)</span>
                <span class="s3">assert </span><span class="s1">is_has_collection_adapter(dest_impl)</span>
                <span class="s1">dest_impl.set(</span>
                    <span class="s1">dest_state</span><span class="s5">,</span>
                    <span class="s1">dest_dict</span><span class="s5">,</span>
                    <span class="s1">dest_list</span><span class="s5">,</span>
                    <span class="s1">_adapt=</span><span class="s3">False</span><span class="s5">,</span>
                    <span class="s1">passive=PassiveFlag.PASSIVE_MERGE</span><span class="s5">,</span>
                <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">current = source_dict[self.key]</span>
            <span class="s3">if </span><span class="s1">current </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">current_state = attributes.instance_state(current)</span>
                <span class="s1">current_dict = attributes.instance_dict(current)</span>
                <span class="s1">_recursive[(current_state</span><span class="s5">, </span><span class="s1">self)] = </span><span class="s3">True</span>
                <span class="s1">obj = session._merge(</span>
                    <span class="s1">current_state</span><span class="s5">,</span>
                    <span class="s1">current_dict</span><span class="s5">,</span>
                    <span class="s1">load=load</span><span class="s5">,</span>
                    <span class="s1">_recursive=_recursive</span><span class="s5">,</span>
                    <span class="s1">_resolve_conflict_map=_resolve_conflict_map</span><span class="s5">,</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">obj = </span><span class="s3">None</span>

            <span class="s3">if not </span><span class="s1">load:</span>
                <span class="s1">dest_dict[self.key] = obj</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">dest_state.get_impl(self.key).set(</span>
                    <span class="s1">dest_state</span><span class="s5">, </span><span class="s1">dest_dict</span><span class="s5">, </span><span class="s1">obj</span><span class="s5">, </span><span class="s3">None</span>
                <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_value_as_iterable(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[_O]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">key: str</span><span class="s5">,</span>
        <span class="s1">passive: PassiveFlag = PassiveFlag.PASSIVE_OFF</span><span class="s5">,</span>
    <span class="s1">) -&gt; Sequence[Tuple[InstanceState[_O]</span><span class="s5">, </span><span class="s1">_O]]:</span>
        <span class="s2">&quot;&quot;&quot;Return a list of tuples (state, obj) for the given 
        key. 
 
        returns an empty list if the value is None/empty/PASSIVE_NO_RESULT 
        &quot;&quot;&quot;</span>

        <span class="s1">impl = state.manager[key].impl</span>
        <span class="s1">x = impl.get(state</span><span class="s5">, </span><span class="s1">dict_</span><span class="s5">, </span><span class="s1">passive=passive)</span>
        <span class="s3">if </span><span class="s1">x </span><span class="s3">is </span><span class="s1">LoaderCallableStatus.PASSIVE_NO_RESULT </span><span class="s3">or </span><span class="s1">x </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">[]</span>
        <span class="s3">elif </span><span class="s1">is_has_collection_adapter(impl):</span>
            <span class="s3">return </span><span class="s1">[</span>
                <span class="s1">(attributes.instance_state(o)</span><span class="s5">, </span><span class="s1">o)</span>
                <span class="s3">for </span><span class="s1">o </span><span class="s3">in </span><span class="s1">impl.get_collection(state</span><span class="s5">, </span><span class="s1">dict_</span><span class="s5">, </span><span class="s1">x</span><span class="s5">, </span><span class="s1">passive=passive)</span>
            <span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">[(attributes.instance_state(x)</span><span class="s5">, </span><span class="s1">x)]</span>

    <span class="s3">def </span><span class="s1">cascade_iterator(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">type_: str</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">visited_states: Set[InstanceState[Any]]</span><span class="s5">,</span>
        <span class="s1">halt_on: Optional[Callable[[InstanceState[Any]]</span><span class="s5">, </span><span class="s1">bool]] = </span><span class="s3">None</span><span class="s5">,</span>
    <span class="s1">) -&gt; Iterator[Tuple[Any</span><span class="s5">, </span><span class="s1">Mapper[Any]</span><span class="s5">, </span><span class="s1">InstanceState[Any]</span><span class="s5">, </span><span class="s1">_InstanceDict]]:</span>
        <span class="s0"># assert type_ in self._cascade</span>

        <span class="s0"># only actively lazy load on the 'delete' cascade</span>
        <span class="s3">if </span><span class="s1">type_ != </span><span class="s4">&quot;delete&quot; </span><span class="s3">or </span><span class="s1">self.passive_deletes:</span>
            <span class="s1">passive = PassiveFlag.PASSIVE_NO_INITIALIZE</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">passive = PassiveFlag.PASSIVE_OFF | PassiveFlag.NO_RAISE</span>

        <span class="s3">if </span><span class="s1">type_ == </span><span class="s4">&quot;save-update&quot;</span><span class="s1">:</span>
            <span class="s1">tuples = state.manager[self.key].impl.get_all_pending(state</span><span class="s5">, </span><span class="s1">dict_)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">tuples = self._value_as_iterable(</span>
                <span class="s1">state</span><span class="s5">, </span><span class="s1">dict_</span><span class="s5">, </span><span class="s1">self.key</span><span class="s5">, </span><span class="s1">passive=passive</span>
            <span class="s1">)</span>

        <span class="s1">skip_pending = (</span>
            <span class="s1">type_ == </span><span class="s4">&quot;refresh-expire&quot; </span><span class="s3">and </span><span class="s4">&quot;delete-orphan&quot; </span><span class="s3">not in </span><span class="s1">self._cascade</span>
        <span class="s1">)</span>

        <span class="s3">for </span><span class="s1">instance_state</span><span class="s5">, </span><span class="s1">c </span><span class="s3">in </span><span class="s1">tuples:</span>
            <span class="s3">if </span><span class="s1">instance_state </span><span class="s3">in </span><span class="s1">visited_states:</span>
                <span class="s3">continue</span>

            <span class="s3">if </span><span class="s1">c </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s0"># would like to emit a warning here, but</span>
                <span class="s0"># would not be consistent with collection.append(None)</span>
                <span class="s0"># current behavior of silently skipping.</span>
                <span class="s0"># see [ticket:2229]</span>
                <span class="s3">continue</span>

            <span class="s3">assert </span><span class="s1">instance_state </span><span class="s3">is not None</span>
            <span class="s1">instance_dict = attributes.instance_dict(c)</span>

            <span class="s3">if </span><span class="s1">halt_on </span><span class="s3">and </span><span class="s1">halt_on(instance_state):</span>
                <span class="s3">continue</span>

            <span class="s3">if </span><span class="s1">skip_pending </span><span class="s3">and not </span><span class="s1">instance_state.key:</span>
                <span class="s3">continue</span>

            <span class="s1">instance_mapper = instance_state.manager.mapper</span>

            <span class="s3">if not </span><span class="s1">instance_mapper.isa(self.mapper.class_manager.mapper):</span>
                <span class="s3">raise </span><span class="s1">AssertionError(</span>
                    <span class="s4">&quot;Attribute '%s' on class '%s' &quot;</span>
                    <span class="s4">&quot;doesn't handle objects &quot;</span>
                    <span class="s4">&quot;of type '%s'&quot;</span>
                    <span class="s1">% (self.key</span><span class="s5">, </span><span class="s1">self.parent.class_</span><span class="s5">, </span><span class="s1">c.__class__)</span>
                <span class="s1">)</span>

            <span class="s1">visited_states.add(instance_state)</span>

            <span class="s3">yield </span><span class="s1">c</span><span class="s5">, </span><span class="s1">instance_mapper</span><span class="s5">, </span><span class="s1">instance_state</span><span class="s5">, </span><span class="s1">instance_dict</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">_effective_sync_backref(self) -&gt; bool:</span>
        <span class="s3">if </span><span class="s1">self.viewonly:</span>
            <span class="s3">return False</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.sync_backref </span><span class="s3">is not False</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">_check_sync_backref(</span>
        <span class="s1">rel_a: RelationshipProperty[Any]</span><span class="s5">, </span><span class="s1">rel_b: RelationshipProperty[Any]</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">rel_a.viewonly </span><span class="s3">and </span><span class="s1">rel_b.sync_backref:</span>
            <span class="s3">raise </span><span class="s1">sa_exc.InvalidRequestError(</span>
                <span class="s4">&quot;Relationship %s cannot specify sync_backref=True since %s &quot;</span>
                <span class="s4">&quot;includes viewonly=True.&quot; </span><span class="s1">% (rel_b</span><span class="s5">, </span><span class="s1">rel_a)</span>
            <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">rel_a.viewonly</span>
            <span class="s3">and not </span><span class="s1">rel_b.viewonly</span>
            <span class="s3">and </span><span class="s1">rel_b.sync_backref </span><span class="s3">is not False</span>
        <span class="s1">):</span>
            <span class="s1">rel_b.sync_backref = </span><span class="s3">False</span>

    <span class="s3">def </span><span class="s1">_add_reverse_property(self</span><span class="s5">, </span><span class="s1">key: str) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">other = self.mapper.get_property(key</span><span class="s5">, </span><span class="s1">_configure_mappers=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s5">, </span><span class="s1">RelationshipProperty):</span>
            <span class="s3">raise </span><span class="s1">sa_exc.InvalidRequestError(</span>
                <span class="s4">&quot;back_populates on relationship '%s' refers to attribute '%s' &quot;</span>
                <span class="s4">&quot;that is not a relationship.  The back_populates parameter &quot;</span>
                <span class="s4">&quot;should refer to the name of a relationship on the target &quot;</span>
                <span class="s4">&quot;class.&quot; </span><span class="s1">% (self</span><span class="s5">, </span><span class="s1">other)</span>
            <span class="s1">)</span>
        <span class="s0"># viewonly and sync_backref cases</span>
        <span class="s0"># 1. self.viewonly==True and other.sync_backref==True -&gt; error</span>
        <span class="s0"># 2. self.viewonly==True and other.viewonly==False and</span>
        <span class="s0">#    other.sync_backref==None -&gt; warn sync_backref=False, set to False</span>
        <span class="s1">self._check_sync_backref(self</span><span class="s5">, </span><span class="s1">other)</span>
        <span class="s0"># 3. other.viewonly==True and self.sync_backref==True -&gt; error</span>
        <span class="s0"># 4. other.viewonly==True and self.viewonly==False and</span>
        <span class="s0">#    self.sync_backref==None -&gt; warn sync_backref=False, set to False</span>
        <span class="s1">self._check_sync_backref(other</span><span class="s5">, </span><span class="s1">self)</span>

        <span class="s1">self._reverse_property.add(other)</span>
        <span class="s1">other._reverse_property.add(self)</span>

        <span class="s1">other._setup_entity()</span>

        <span class="s3">if not </span><span class="s1">other.mapper.common_parent(self.parent):</span>
            <span class="s3">raise </span><span class="s1">sa_exc.ArgumentError(</span>
                <span class="s4">&quot;reverse_property %r on &quot;</span>
                <span class="s4">&quot;relationship %s references relationship %s, which &quot;</span>
                <span class="s4">&quot;does not reference mapper %s&quot;</span>
                <span class="s1">% (key</span><span class="s5">, </span><span class="s1">self</span><span class="s5">, </span><span class="s1">other</span><span class="s5">, </span><span class="s1">self.parent)</span>
            <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">other._configure_started</span>
            <span class="s3">and </span><span class="s1">self.direction </span><span class="s3">in </span><span class="s1">(ONETOMANY</span><span class="s5">, </span><span class="s1">MANYTOONE)</span>
            <span class="s3">and </span><span class="s1">self.direction == other.direction</span>
        <span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">sa_exc.ArgumentError(</span>
                <span class="s4">&quot;%s and back-reference %s are &quot;</span>
                <span class="s4">&quot;both of the same direction %r.  Did you mean to &quot;</span>
                <span class="s4">&quot;set remote_side on the many-to-one side ?&quot;</span>
                <span class="s1">% (other</span><span class="s5">, </span><span class="s1">self</span><span class="s5">, </span><span class="s1">self.direction)</span>
            <span class="s1">)</span>

    <span class="s1">@util.memoized_property</span>
    <span class="s3">def </span><span class="s1">entity(self) -&gt; _InternalEntityType[_T]:</span>
        <span class="s2">&quot;&quot;&quot;Return the target mapped entity, which is an inspect() of the 
        class or aliased class that is referenced by this 
        :class:`.RelationshipProperty`. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.parent._check_configure()</span>
        <span class="s3">return </span><span class="s1">self.entity</span>

    <span class="s1">@util.memoized_property</span>
    <span class="s3">def </span><span class="s1">mapper(self) -&gt; Mapper[_T]:</span>
        <span class="s2">&quot;&quot;&quot;Return the targeted :class:`_orm.Mapper` for this 
        :class:`.RelationshipProperty`. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.entity.mapper</span>

    <span class="s3">def </span><span class="s1">do_init(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">self._check_conflicts()</span>
        <span class="s1">self._process_dependent_arguments()</span>
        <span class="s1">self._setup_entity()</span>
        <span class="s1">self._setup_registry_dependencies()</span>
        <span class="s1">self._setup_join_conditions()</span>
        <span class="s1">self._check_cascade_settings(self._cascade)</span>
        <span class="s1">self._post_init()</span>
        <span class="s1">self._generate_backref()</span>
        <span class="s1">self._join_condition._warn_for_conflicting_sync_targets()</span>
        <span class="s1">super().do_init()</span>
        <span class="s1">self._lazy_strategy = cast(</span>
            <span class="s4">&quot;LazyLoader&quot;</span><span class="s5">, </span><span class="s1">self._get_strategy(((</span><span class="s4">&quot;lazy&quot;</span><span class="s5">, </span><span class="s4">&quot;select&quot;</span><span class="s1">)</span><span class="s5">,</span><span class="s1">))</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_setup_registry_dependencies(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">self.parent.mapper.registry._set_depends_on(</span>
            <span class="s1">self.entity.mapper.registry</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_process_dependent_arguments(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Convert incoming configuration arguments to their 
        proper form. 
 
        Callables are resolved, ORM annotations removed. 
 
        &quot;&quot;&quot;</span>

        <span class="s0"># accept callables for other attributes which may require</span>
        <span class="s0"># deferred initialization.  This technique is used</span>
        <span class="s0"># by declarative &quot;string configs&quot; and some recipes.</span>
        <span class="s1">init_args = self._init_args</span>

        <span class="s3">for </span><span class="s1">attr </span><span class="s3">in </span><span class="s1">(</span>
            <span class="s4">&quot;order_by&quot;</span><span class="s5">,</span>
            <span class="s4">&quot;primaryjoin&quot;</span><span class="s5">,</span>
            <span class="s4">&quot;secondaryjoin&quot;</span><span class="s5">,</span>
            <span class="s4">&quot;secondary&quot;</span><span class="s5">,</span>
            <span class="s4">&quot;foreign_keys&quot;</span><span class="s5">,</span>
            <span class="s4">&quot;remote_side&quot;</span><span class="s5">,</span>
        <span class="s1">):</span>
            <span class="s1">rel_arg = getattr(init_args</span><span class="s5">, </span><span class="s1">attr)</span>

            <span class="s1">rel_arg._resolve_against_registry(self._clsregistry_resolvers[</span><span class="s6">1</span><span class="s1">])</span>

        <span class="s0"># remove &quot;annotations&quot; which are present if mapped class</span>
        <span class="s0"># descriptors are used to create the join expression.</span>
        <span class="s3">for </span><span class="s1">attr </span><span class="s3">in </span><span class="s4">&quot;primaryjoin&quot;</span><span class="s5">, </span><span class="s4">&quot;secondaryjoin&quot;</span><span class="s1">:</span>
            <span class="s1">rel_arg = getattr(init_args</span><span class="s5">, </span><span class="s1">attr)</span>
            <span class="s1">val = rel_arg.resolved</span>
            <span class="s3">if </span><span class="s1">val </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">rel_arg.resolved = _orm_deannotate(</span>
                    <span class="s1">coercions.expect(</span>
                        <span class="s1">roles.ColumnArgumentRole</span><span class="s5">, </span><span class="s1">val</span><span class="s5">, </span><span class="s1">argname=attr</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>

        <span class="s1">secondary = init_args.secondary.resolved</span>
        <span class="s3">if </span><span class="s1">secondary </span><span class="s3">is not None and </span><span class="s1">_is_mapped_class(secondary):</span>
            <span class="s3">raise </span><span class="s1">sa_exc.ArgumentError(</span>
                <span class="s4">&quot;secondary argument %s passed to to relationship() %s must &quot;</span>
                <span class="s4">&quot;be a Table object or other FROM clause; can't send a mapped &quot;</span>
                <span class="s4">&quot;class directly as rows in 'secondary' are persisted &quot;</span>
                <span class="s4">&quot;independently of a class that is mapped &quot;</span>
                <span class="s4">&quot;to that same table.&quot; </span><span class="s1">% (secondary</span><span class="s5">, </span><span class="s1">self)</span>
            <span class="s1">)</span>

        <span class="s0"># ensure expressions in self.order_by, foreign_keys,</span>
        <span class="s0"># remote_side are all columns, not strings.</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">init_args.order_by.resolved </span><span class="s3">is not False</span>
            <span class="s3">and </span><span class="s1">init_args.order_by.resolved </span><span class="s3">is not None</span>
        <span class="s1">):</span>
            <span class="s1">self.order_by = tuple(</span>
                <span class="s1">coercions.expect(</span>
                    <span class="s1">roles.ColumnArgumentRole</span><span class="s5">, </span><span class="s1">x</span><span class="s5">, </span><span class="s1">argname=</span><span class="s4">&quot;order_by&quot;</span>
                <span class="s1">)</span>
                <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">util.to_list(init_args.order_by.resolved)</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.order_by = </span><span class="s3">False</span>

        <span class="s1">self._user_defined_foreign_keys = util.column_set(</span>
            <span class="s1">coercions.expect(</span>
                <span class="s1">roles.ColumnArgumentRole</span><span class="s5">, </span><span class="s1">x</span><span class="s5">, </span><span class="s1">argname=</span><span class="s4">&quot;foreign_keys&quot;</span>
            <span class="s1">)</span>
            <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">util.to_column_set(init_args.foreign_keys.resolved)</span>
        <span class="s1">)</span>

        <span class="s1">self.remote_side = util.column_set(</span>
            <span class="s1">coercions.expect(</span>
                <span class="s1">roles.ColumnArgumentRole</span><span class="s5">, </span><span class="s1">x</span><span class="s5">, </span><span class="s1">argname=</span><span class="s4">&quot;remote_side&quot;</span>
            <span class="s1">)</span>
            <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">util.to_column_set(init_args.remote_side.resolved)</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">declarative_scan(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">decl_scan: _ClassScanMapperConfig</span><span class="s5">,</span>
        <span class="s1">registry: _RegistryType</span><span class="s5">,</span>
        <span class="s1">cls: Type[Any]</span><span class="s5">,</span>
        <span class="s1">originating_module: Optional[str]</span><span class="s5">,</span>
        <span class="s1">key: str</span><span class="s5">,</span>
        <span class="s1">mapped_container: Optional[Type[Mapped[Any]]]</span><span class="s5">,</span>
        <span class="s1">annotation: Optional[_AnnotationScanType]</span><span class="s5">,</span>
        <span class="s1">extracted_mapped_annotation: Optional[_AnnotationScanType]</span><span class="s5">,</span>
        <span class="s1">is_dataclass_field: bool</span><span class="s5">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">argument = extracted_mapped_annotation</span>

        <span class="s3">if </span><span class="s1">extracted_mapped_annotation </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">self.argument </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">self._raise_for_required(key</span><span class="s5">, </span><span class="s1">cls)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return</span>

        <span class="s1">argument = extracted_mapped_annotation</span>
        <span class="s3">assert </span><span class="s1">originating_module </span><span class="s3">is not None</span>

        <span class="s3">if </span><span class="s1">mapped_container </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">is_write_only = issubclass(mapped_container</span><span class="s5">, </span><span class="s1">WriteOnlyMapped)</span>
            <span class="s1">is_dynamic = issubclass(mapped_container</span><span class="s5">, </span><span class="s1">DynamicMapped)</span>
            <span class="s3">if </span><span class="s1">is_write_only:</span>
                <span class="s1">self.lazy = </span><span class="s4">&quot;write_only&quot;</span>
                <span class="s1">self.strategy_key = ((</span><span class="s4">&quot;lazy&quot;</span><span class="s5">, </span><span class="s1">self.lazy)</span><span class="s5">,</span><span class="s1">)</span>
            <span class="s3">elif </span><span class="s1">is_dynamic:</span>
                <span class="s1">self.lazy = </span><span class="s4">&quot;dynamic&quot;</span>
                <span class="s1">self.strategy_key = ((</span><span class="s4">&quot;lazy&quot;</span><span class="s5">, </span><span class="s1">self.lazy)</span><span class="s5">,</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">is_write_only = is_dynamic = </span><span class="s3">False</span>

        <span class="s1">argument = de_optionalize_union_types(argument)</span>

        <span class="s3">if </span><span class="s1">hasattr(argument</span><span class="s5">, </span><span class="s4">&quot;__origin__&quot;</span><span class="s1">):</span>
            <span class="s1">arg_origin = argument.__origin__</span>
            <span class="s3">if </span><span class="s1">isinstance(arg_origin</span><span class="s5">, </span><span class="s1">type) </span><span class="s3">and </span><span class="s1">issubclass(</span>
                <span class="s1">arg_origin</span><span class="s5">, </span><span class="s1">abc.Collection</span>
            <span class="s1">):</span>
                <span class="s3">if </span><span class="s1">self.collection_class </span><span class="s3">is None</span><span class="s1">:</span>
                    <span class="s3">if </span><span class="s1">_py_inspect.isabstract(arg_origin):</span>
                        <span class="s3">raise </span><span class="s1">sa_exc.ArgumentError(</span>
                            <span class="s4">f&quot;Collection annotation type </span><span class="s7">{</span><span class="s1">arg_origin</span><span class="s7">} </span><span class="s4">cannot &quot;</span>
                            <span class="s4">&quot;be instantiated; please provide an explicit &quot;</span>
                            <span class="s4">&quot;'collection_class' parameter &quot;</span>
                            <span class="s4">&quot;(e.g. list, set, etc.) to the &quot;</span>
                            <span class="s4">&quot;relationship() function to accompany this &quot;</span>
                            <span class="s4">&quot;annotation&quot;</span>
                        <span class="s1">)</span>

                    <span class="s1">self.collection_class = arg_origin</span>

            <span class="s3">elif not </span><span class="s1">is_write_only </span><span class="s3">and not </span><span class="s1">is_dynamic:</span>
                <span class="s1">self.uselist = </span><span class="s3">False</span>

            <span class="s3">if </span><span class="s1">argument.__args__:  </span><span class="s0"># type: ignore</span>
                <span class="s3">if </span><span class="s1">isinstance(arg_origin</span><span class="s5">, </span><span class="s1">type) </span><span class="s3">and </span><span class="s1">issubclass(</span>
                    <span class="s1">arg_origin</span><span class="s5">, </span><span class="s1">typing.Mapping</span>
                <span class="s1">):</span>
                    <span class="s1">type_arg = argument.__args__[-</span><span class="s6">1</span><span class="s1">]  </span><span class="s0"># type: ignore</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">type_arg = argument.__args__[</span><span class="s6">0</span><span class="s1">]  </span><span class="s0"># type: ignore</span>
                <span class="s3">if </span><span class="s1">hasattr(type_arg</span><span class="s5">, </span><span class="s4">&quot;__forward_arg__&quot;</span><span class="s1">):</span>
                    <span class="s1">str_argument = type_arg.__forward_arg__</span>

                    <span class="s1">argument = resolve_name_to_real_class_name(</span>
                        <span class="s1">str_argument</span><span class="s5">, </span><span class="s1">originating_module</span>
                    <span class="s1">)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">argument = type_arg</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">sa_exc.ArgumentError(</span>
                    <span class="s4">f&quot;Generic alias </span><span class="s7">{</span><span class="s1">argument</span><span class="s7">} </span><span class="s4">requires an argument&quot;</span>
                <span class="s1">)</span>
        <span class="s3">elif </span><span class="s1">hasattr(argument</span><span class="s5">, </span><span class="s4">&quot;__forward_arg__&quot;</span><span class="s1">):</span>
            <span class="s1">argument = argument.__forward_arg__</span>

            <span class="s1">argument = resolve_name_to_real_class_name(</span>
                <span class="s1">argument</span><span class="s5">, </span><span class="s1">originating_module</span>
            <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">self.collection_class </span><span class="s3">is None</span>
            <span class="s3">and not </span><span class="s1">is_write_only</span>
            <span class="s3">and not </span><span class="s1">is_dynamic</span>
        <span class="s1">):</span>
            <span class="s1">self.uselist = </span><span class="s3">False</span>

        <span class="s0"># ticket #8759</span>
        <span class="s0"># if a lead argument was given to relationship(), like</span>
        <span class="s0"># `relationship(&quot;B&quot;)`, use that, don't replace it with class we</span>
        <span class="s0"># found in the annotation.  The declarative_scan() method call here is</span>
        <span class="s0"># still useful, as we continue to derive collection type and do</span>
        <span class="s0"># checking of the annotation in any case.</span>
        <span class="s3">if </span><span class="s1">self.argument </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.argument = cast(</span><span class="s4">&quot;_RelationshipArgumentType[_T]&quot;</span><span class="s5">, </span><span class="s1">argument)</span>

    <span class="s1">@util.preload_module(</span><span class="s4">&quot;sqlalchemy.orm.mapper&quot;</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">_setup_entity(self</span><span class="s5">, </span><span class="s1">__argument: Any = </span><span class="s3">None</span><span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s4">&quot;entity&quot; </span><span class="s3">in </span><span class="s1">self.__dict__:</span>
            <span class="s3">return</span>

        <span class="s1">mapperlib = util.preloaded.orm_mapper</span>

        <span class="s3">if </span><span class="s1">__argument:</span>
            <span class="s1">argument = __argument</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">argument = self.argument</span>

        <span class="s1">resolved_argument: _ExternalEntityType[Any]</span>

        <span class="s3">if </span><span class="s1">isinstance(argument</span><span class="s5">, </span><span class="s1">str):</span>
            <span class="s0"># we might want to cleanup clsregistry API to make this</span>
            <span class="s0"># more straightforward</span>
            <span class="s1">resolved_argument = cast(</span>
                <span class="s4">&quot;_ExternalEntityType[Any]&quot;</span><span class="s5">,</span>
                <span class="s1">self._clsregistry_resolve_name(argument)()</span><span class="s5">,</span>
            <span class="s1">)</span>
        <span class="s3">elif </span><span class="s1">callable(argument) </span><span class="s3">and not </span><span class="s1">isinstance(</span>
            <span class="s1">argument</span><span class="s5">, </span><span class="s1">(type</span><span class="s5">, </span><span class="s1">mapperlib.Mapper)</span>
        <span class="s1">):</span>
            <span class="s1">resolved_argument = argument()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">resolved_argument = argument</span>

        <span class="s1">entity: _InternalEntityType[Any]</span>

        <span class="s3">if </span><span class="s1">isinstance(resolved_argument</span><span class="s5">, </span><span class="s1">type):</span>
            <span class="s1">entity = class_mapper(resolved_argument</span><span class="s5">, </span><span class="s1">configure=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">entity = inspect(resolved_argument)</span>
            <span class="s3">except </span><span class="s1">sa_exc.NoInspectionAvailable:</span>
                <span class="s1">entity = </span><span class="s3">None  </span><span class="s0"># type: ignore</span>

            <span class="s3">if not </span><span class="s1">hasattr(entity</span><span class="s5">, </span><span class="s4">&quot;mapper&quot;</span><span class="s1">):</span>
                <span class="s3">raise </span><span class="s1">sa_exc.ArgumentError(</span>
                    <span class="s4">&quot;relationship '%s' expects &quot;</span>
                    <span class="s4">&quot;a class or a mapper argument (received: %s)&quot;</span>
                    <span class="s1">% (self.key</span><span class="s5">, </span><span class="s1">type(resolved_argument))</span>
                <span class="s1">)</span>

        <span class="s1">self.entity = entity</span>
        <span class="s1">self.target = self.entity.persist_selectable</span>

    <span class="s3">def </span><span class="s1">_setup_join_conditions(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">self._join_condition = jc = JoinCondition(</span>
            <span class="s1">parent_persist_selectable=self.parent.persist_selectable</span><span class="s5">,</span>
            <span class="s1">child_persist_selectable=self.entity.persist_selectable</span><span class="s5">,</span>
            <span class="s1">parent_local_selectable=self.parent.local_table</span><span class="s5">,</span>
            <span class="s1">child_local_selectable=self.entity.local_table</span><span class="s5">,</span>
            <span class="s1">primaryjoin=self._init_args.primaryjoin.resolved</span><span class="s5">,</span>
            <span class="s1">secondary=self._init_args.secondary.resolved</span><span class="s5">,</span>
            <span class="s1">secondaryjoin=self._init_args.secondaryjoin.resolved</span><span class="s5">,</span>
            <span class="s1">parent_equivalents=self.parent._equivalent_columns</span><span class="s5">,</span>
            <span class="s1">child_equivalents=self.mapper._equivalent_columns</span><span class="s5">,</span>
            <span class="s1">consider_as_foreign_keys=self._user_defined_foreign_keys</span><span class="s5">,</span>
            <span class="s1">local_remote_pairs=self.local_remote_pairs</span><span class="s5">,</span>
            <span class="s1">remote_side=self.remote_side</span><span class="s5">,</span>
            <span class="s1">self_referential=self._is_self_referential</span><span class="s5">,</span>
            <span class="s1">prop=self</span><span class="s5">,</span>
            <span class="s1">support_sync=</span><span class="s3">not </span><span class="s1">self.viewonly</span><span class="s5">,</span>
            <span class="s1">can_be_synced_fn=self._columns_are_mapped</span><span class="s5">,</span>
        <span class="s1">)</span>
        <span class="s1">self.primaryjoin = jc.primaryjoin</span>
        <span class="s1">self.secondaryjoin = jc.secondaryjoin</span>
        <span class="s1">self.secondary = jc.secondary</span>
        <span class="s1">self.direction = jc.direction</span>
        <span class="s1">self.local_remote_pairs = jc.local_remote_pairs</span>
        <span class="s1">self.remote_side = jc.remote_columns</span>
        <span class="s1">self.local_columns = jc.local_columns</span>
        <span class="s1">self.synchronize_pairs = jc.synchronize_pairs</span>
        <span class="s1">self._calculated_foreign_keys = jc.foreign_key_columns</span>
        <span class="s1">self.secondary_synchronize_pairs = jc.secondary_synchronize_pairs</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">_clsregistry_resolve_arg(</span>
        <span class="s1">self</span><span class="s5">,</span>
    <span class="s1">) -&gt; Callable[[str</span><span class="s5">, </span><span class="s1">bool]</span><span class="s5">, </span><span class="s1">_class_resolver]:</span>
        <span class="s3">return </span><span class="s1">self._clsregistry_resolvers[</span><span class="s6">1</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">_clsregistry_resolve_name(</span>
        <span class="s1">self</span><span class="s5">,</span>
    <span class="s1">) -&gt; Callable[[str]</span><span class="s5">, </span><span class="s1">Callable[[]</span><span class="s5">, </span><span class="s1">Union[Type[Any]</span><span class="s5">, </span><span class="s1">Table</span><span class="s5">, </span><span class="s1">_ModNS]]]:</span>
        <span class="s3">return </span><span class="s1">self._clsregistry_resolvers[</span><span class="s6">0</span><span class="s1">]</span>

    <span class="s1">@util.memoized_property</span>
    <span class="s1">@util.preload_module(</span><span class="s4">&quot;sqlalchemy.orm.clsregistry&quot;</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">_clsregistry_resolvers(</span>
        <span class="s1">self</span><span class="s5">,</span>
    <span class="s1">) -&gt; Tuple[</span>
        <span class="s1">Callable[[str]</span><span class="s5">, </span><span class="s1">Callable[[]</span><span class="s5">, </span><span class="s1">Union[Type[Any]</span><span class="s5">, </span><span class="s1">Table</span><span class="s5">, </span><span class="s1">_ModNS]]]</span><span class="s5">,</span>
        <span class="s1">Callable[[str</span><span class="s5">, </span><span class="s1">bool]</span><span class="s5">, </span><span class="s1">_class_resolver]</span><span class="s5">,</span>
    <span class="s1">]:</span>
        <span class="s1">_resolver = util.preloaded.orm_clsregistry._resolver</span>

        <span class="s3">return </span><span class="s1">_resolver(self.parent.class_</span><span class="s5">, </span><span class="s1">self)</span>

    <span class="s3">def </span><span class="s1">_check_conflicts(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Test that this relationship is legal, warn about 
        inheritance conflicts.&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.parent.non_primary </span><span class="s3">and not </span><span class="s1">class_mapper(</span>
            <span class="s1">self.parent.class_</span><span class="s5">, </span><span class="s1">configure=</span><span class="s3">False</span>
        <span class="s1">).has_property(self.key):</span>
            <span class="s3">raise </span><span class="s1">sa_exc.ArgumentError(</span>
                <span class="s4">&quot;Attempting to assign a new &quot;</span>
                <span class="s4">&quot;relationship '%s' to a non-primary mapper on &quot;</span>
                <span class="s4">&quot;class '%s'.  New relationships can only be added &quot;</span>
                <span class="s4">&quot;to the primary mapper, i.e. the very first mapper &quot;</span>
                <span class="s4">&quot;created for class '%s' &quot;</span>
                <span class="s1">% (</span>
                    <span class="s1">self.key</span><span class="s5">,</span>
                    <span class="s1">self.parent.class_.__name__</span><span class="s5">,</span>
                    <span class="s1">self.parent.class_.__name__</span><span class="s5">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">cascade(self) -&gt; CascadeOptions:</span>
        <span class="s2">&quot;&quot;&quot;Return the current cascade setting for this 
        :class:`.RelationshipProperty`. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._cascade</span>

    <span class="s1">@cascade.setter</span>
    <span class="s3">def </span><span class="s1">cascade(self</span><span class="s5">, </span><span class="s1">cascade: Union[str</span><span class="s5">, </span><span class="s1">CascadeOptions]) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">self._set_cascade(cascade)</span>

    <span class="s3">def </span><span class="s1">_set_cascade(self</span><span class="s5">, </span><span class="s1">cascade_arg: Union[str</span><span class="s5">, </span><span class="s1">CascadeOptions]) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">cascade = CascadeOptions(cascade_arg)</span>

        <span class="s3">if </span><span class="s1">self.viewonly:</span>
            <span class="s1">cascade = CascadeOptions(</span>
                <span class="s1">cascade.intersection(CascadeOptions._viewonly_cascades)</span>
            <span class="s1">)</span>

        <span class="s3">if </span><span class="s4">&quot;mapper&quot; </span><span class="s3">in </span><span class="s1">self.__dict__:</span>
            <span class="s1">self._check_cascade_settings(cascade)</span>
        <span class="s1">self._cascade = cascade</span>

        <span class="s3">if </span><span class="s1">self._dependency_processor:</span>
            <span class="s1">self._dependency_processor.cascade = cascade</span>

    <span class="s3">def </span><span class="s1">_check_cascade_settings(self</span><span class="s5">, </span><span class="s1">cascade: CascadeOptions) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">cascade.delete_orphan</span>
            <span class="s3">and not </span><span class="s1">self.single_parent</span>
            <span class="s3">and </span><span class="s1">(self.direction </span><span class="s3">is </span><span class="s1">MANYTOMANY </span><span class="s3">or </span><span class="s1">self.direction </span><span class="s3">is </span><span class="s1">MANYTOONE)</span>
        <span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">sa_exc.ArgumentError(</span>
                <span class="s4">&quot;For %(direction)s relationship %(rel)s, delete-orphan &quot;</span>
                <span class="s4">&quot;cascade is normally &quot;</span>
                <span class="s4">'configured only on the &quot;one&quot; side of a one-to-many '</span>
                <span class="s4">&quot;relationship, &quot;</span>
                <span class="s4">'and not on the &quot;many&quot; side of a many-to-one or many-to-many '</span>
                <span class="s4">&quot;relationship.  &quot;</span>
                <span class="s4">&quot;To force this relationship to allow a particular &quot;</span>
                <span class="s4">'&quot;%(relatedcls)s&quot; object to be referenced by only '</span>
                <span class="s4">'a single &quot;%(clsname)s&quot; object at a time via the '</span>
                <span class="s4">&quot;%(rel)s relationship, which &quot;</span>
                <span class="s4">&quot;would allow &quot;</span>
                <span class="s4">&quot;delete-orphan cascade to take place in this direction, set &quot;</span>
                <span class="s4">&quot;the single_parent=True flag.&quot;</span>
                <span class="s1">% {</span>
                    <span class="s4">&quot;rel&quot;</span><span class="s1">: self</span><span class="s5">,</span>
                    <span class="s4">&quot;direction&quot;</span><span class="s1">: (</span>
                        <span class="s4">&quot;many-to-one&quot;</span>
                        <span class="s3">if </span><span class="s1">self.direction </span><span class="s3">is </span><span class="s1">MANYTOONE</span>
                        <span class="s3">else </span><span class="s4">&quot;many-to-many&quot;</span>
                    <span class="s1">)</span><span class="s5">,</span>
                    <span class="s4">&quot;clsname&quot;</span><span class="s1">: self.parent.class_.__name__</span><span class="s5">,</span>
                    <span class="s4">&quot;relatedcls&quot;</span><span class="s1">: self.mapper.class_.__name__</span><span class="s5">,</span>
                <span class="s1">}</span><span class="s5">,</span>
                <span class="s1">code=</span><span class="s4">&quot;bbf0&quot;</span><span class="s5">,</span>
            <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">self.passive_deletes == </span><span class="s4">&quot;all&quot; </span><span class="s3">and </span><span class="s1">(</span>
            <span class="s4">&quot;delete&quot; </span><span class="s3">in </span><span class="s1">cascade </span><span class="s3">or </span><span class="s4">&quot;delete-orphan&quot; </span><span class="s3">in </span><span class="s1">cascade</span>
        <span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">sa_exc.ArgumentError(</span>
                <span class="s4">&quot;On %s, can't set passive_deletes='all' in conjunction &quot;</span>
                <span class="s4">&quot;with 'delete' or 'delete-orphan' cascade&quot; </span><span class="s1">% self</span>
            <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">cascade.delete_orphan:</span>
            <span class="s1">self.mapper.primary_mapper()._delete_orphans.append(</span>
                <span class="s1">(self.key</span><span class="s5">, </span><span class="s1">self.parent.class_)</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_persists_for(self</span><span class="s5">, </span><span class="s1">mapper: Mapper[Any]) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot;Return True if this property will persist values on behalf 
        of the given mapper. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">(</span>
            <span class="s1">self.key </span><span class="s3">in </span><span class="s1">mapper.relationships</span>
            <span class="s3">and </span><span class="s1">mapper.relationships[self.key] </span><span class="s3">is </span><span class="s1">self</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_columns_are_mapped(self</span><span class="s5">, </span><span class="s1">*cols: ColumnElement[Any]) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot;Return True if all columns in the given collection are 
        mapped by the tables referenced by this :class:`.RelationshipProperty`. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">secondary = self._init_args.secondary.resolved</span>
        <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">cols:</span>
            <span class="s3">if </span><span class="s1">secondary </span><span class="s3">is not None and </span><span class="s1">secondary.c.contains_column(c):</span>
                <span class="s3">continue</span>
            <span class="s3">if not </span><span class="s1">self.parent.persist_selectable.c.contains_column(</span>
                <span class="s1">c</span>
            <span class="s1">) </span><span class="s3">and not </span><span class="s1">self.target.c.contains_column(c):</span>
                <span class="s3">return False</span>
        <span class="s3">return True</span>

    <span class="s3">def </span><span class="s1">_generate_backref(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Interpret the 'backref' instruction to create a 
        :func:`_orm.relationship` complementary to this one.&quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">self.parent.non_primary:</span>
            <span class="s3">return</span>
        <span class="s3">if </span><span class="s1">self.backref </span><span class="s3">is not None and not </span><span class="s1">self.back_populates:</span>
            <span class="s1">kwargs: Dict[str</span><span class="s5">, </span><span class="s1">Any]</span>
            <span class="s3">if </span><span class="s1">isinstance(self.backref</span><span class="s5">, </span><span class="s1">str):</span>
                <span class="s1">backref_key</span><span class="s5">, </span><span class="s1">kwargs = self.backref</span><span class="s5">, </span><span class="s1">{}</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">backref_key</span><span class="s5">, </span><span class="s1">kwargs = self.backref</span>
            <span class="s1">mapper = self.mapper.primary_mapper()</span>

            <span class="s3">if not </span><span class="s1">mapper.concrete:</span>
                <span class="s1">check = set(mapper.iterate_to_root()).union(</span>
                    <span class="s1">mapper.self_and_descendants</span>
                <span class="s1">)</span>
                <span class="s3">for </span><span class="s1">m </span><span class="s3">in </span><span class="s1">check:</span>
                    <span class="s3">if </span><span class="s1">m.has_property(backref_key) </span><span class="s3">and not </span><span class="s1">m.concrete:</span>
                        <span class="s3">raise </span><span class="s1">sa_exc.ArgumentError(</span>
                            <span class="s4">&quot;Error creating backref &quot;</span>
                            <span class="s4">&quot;'%s' on relationship '%s': property of that &quot;</span>
                            <span class="s4">&quot;name exists on mapper '%s'&quot;</span>
                            <span class="s1">% (backref_key</span><span class="s5">, </span><span class="s1">self</span><span class="s5">, </span><span class="s1">m)</span>
                        <span class="s1">)</span>

            <span class="s0"># determine primaryjoin/secondaryjoin for the</span>
            <span class="s0"># backref.  Use the one we had, so that</span>
            <span class="s0"># a custom join doesn't have to be specified in</span>
            <span class="s0"># both directions.</span>
            <span class="s3">if </span><span class="s1">self.secondary </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s0"># for many to many, just switch primaryjoin/</span>
                <span class="s0"># secondaryjoin.   use the annotated</span>
                <span class="s0"># pj/sj on the _join_condition.</span>
                <span class="s1">pj = kwargs.pop(</span>
                    <span class="s4">&quot;primaryjoin&quot;</span><span class="s5">,</span>
                    <span class="s1">self._join_condition.secondaryjoin_minus_local</span><span class="s5">,</span>
                <span class="s1">)</span>
                <span class="s1">sj = kwargs.pop(</span>
                    <span class="s4">&quot;secondaryjoin&quot;</span><span class="s5">,</span>
                    <span class="s1">self._join_condition.primaryjoin_minus_local</span><span class="s5">,</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">pj = kwargs.pop(</span>
                    <span class="s4">&quot;primaryjoin&quot;</span><span class="s5">,</span>
                    <span class="s1">self._join_condition.primaryjoin_reverse_remote</span><span class="s5">,</span>
                <span class="s1">)</span>
                <span class="s1">sj = kwargs.pop(</span><span class="s4">&quot;secondaryjoin&quot;</span><span class="s5">, </span><span class="s3">None</span><span class="s1">)</span>
                <span class="s3">if </span><span class="s1">sj:</span>
                    <span class="s3">raise </span><span class="s1">sa_exc.InvalidRequestError(</span>
                        <span class="s4">&quot;Can't assign 'secondaryjoin' on a backref &quot;</span>
                        <span class="s4">&quot;against a non-secondary relationship.&quot;</span>
                    <span class="s1">)</span>

            <span class="s1">foreign_keys = kwargs.pop(</span>
                <span class="s4">&quot;foreign_keys&quot;</span><span class="s5">, </span><span class="s1">self._user_defined_foreign_keys</span>
            <span class="s1">)</span>
            <span class="s1">parent = self.parent.primary_mapper()</span>
            <span class="s1">kwargs.setdefault(</span><span class="s4">&quot;viewonly&quot;</span><span class="s5">, </span><span class="s1">self.viewonly)</span>
            <span class="s1">kwargs.setdefault(</span><span class="s4">&quot;post_update&quot;</span><span class="s5">, </span><span class="s1">self.post_update)</span>
            <span class="s1">kwargs.setdefault(</span><span class="s4">&quot;passive_updates&quot;</span><span class="s5">, </span><span class="s1">self.passive_updates)</span>
            <span class="s1">kwargs.setdefault(</span><span class="s4">&quot;sync_backref&quot;</span><span class="s5">, </span><span class="s1">self.sync_backref)</span>
            <span class="s1">self.back_populates = backref_key</span>
            <span class="s1">relationship = RelationshipProperty(</span>
                <span class="s1">parent</span><span class="s5">,</span>
                <span class="s1">self.secondary</span><span class="s5">,</span>
                <span class="s1">primaryjoin=pj</span><span class="s5">,</span>
                <span class="s1">secondaryjoin=sj</span><span class="s5">,</span>
                <span class="s1">foreign_keys=foreign_keys</span><span class="s5">,</span>
                <span class="s1">back_populates=self.key</span><span class="s5">,</span>
                <span class="s1">**kwargs</span><span class="s5">,</span>
            <span class="s1">)</span>
            <span class="s1">mapper._configure_property(</span>
                <span class="s1">backref_key</span><span class="s5">, </span><span class="s1">relationship</span><span class="s5">, </span><span class="s1">warn_for_existing=</span><span class="s3">True</span>
            <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">self.back_populates:</span>
            <span class="s1">self._add_reverse_property(self.back_populates)</span>

    <span class="s1">@util.preload_module(</span><span class="s4">&quot;sqlalchemy.orm.dependency&quot;</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">_post_init(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">dependency = util.preloaded.orm_dependency</span>

        <span class="s3">if </span><span class="s1">self.uselist </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.uselist = self.direction </span><span class="s3">is not </span><span class="s1">MANYTOONE</span>
        <span class="s3">if not </span><span class="s1">self.viewonly:</span>
            <span class="s1">self._dependency_processor = (  </span><span class="s0"># type: ignore</span>
                <span class="s1">dependency.DependencyProcessor.from_relationship</span>
            <span class="s1">)(self)</span>

    <span class="s1">@util.memoized_property</span>
    <span class="s3">def </span><span class="s1">_use_get(self) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot;memoize the 'use_get' attribute of this RelationshipLoader's 
        lazyloader.&quot;&quot;&quot;</span>

        <span class="s1">strategy = self._lazy_strategy</span>
        <span class="s3">return </span><span class="s1">strategy.use_get</span>

    <span class="s1">@util.memoized_property</span>
    <span class="s3">def </span><span class="s1">_is_self_referential(self) -&gt; bool:</span>
        <span class="s3">return </span><span class="s1">self.mapper.common_parent(self.parent)</span>

    <span class="s3">def </span><span class="s1">_create_joins(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">source_polymorphic: bool = </span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">source_selectable: Optional[FromClause] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">dest_selectable: Optional[FromClause] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">of_type_entity: Optional[_InternalEntityType[Any]] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">alias_secondary: bool = </span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">extra_criteria: Tuple[ColumnElement[bool]</span><span class="s5">, </span><span class="s1">...] = ()</span><span class="s5">,</span>
    <span class="s1">) -&gt; Tuple[</span>
        <span class="s1">ColumnElement[bool]</span><span class="s5">,</span>
        <span class="s1">Optional[ColumnElement[bool]]</span><span class="s5">,</span>
        <span class="s1">FromClause</span><span class="s5">,</span>
        <span class="s1">FromClause</span><span class="s5">,</span>
        <span class="s1">Optional[FromClause]</span><span class="s5">,</span>
        <span class="s1">Optional[ClauseAdapter]</span><span class="s5">,</span>
    <span class="s1">]:</span>
        <span class="s1">aliased = </span><span class="s3">False</span>

        <span class="s3">if </span><span class="s1">alias_secondary </span><span class="s3">and </span><span class="s1">self.secondary </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">aliased = </span><span class="s3">True</span>

        <span class="s3">if </span><span class="s1">source_selectable </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">source_polymorphic </span><span class="s3">and </span><span class="s1">self.parent.with_polymorphic:</span>
                <span class="s1">source_selectable = self.parent._with_polymorphic_selectable</span>

        <span class="s3">if </span><span class="s1">of_type_entity:</span>
            <span class="s1">dest_mapper = of_type_entity.mapper</span>
            <span class="s3">if </span><span class="s1">dest_selectable </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">dest_selectable = of_type_entity.selectable</span>
                <span class="s1">aliased = </span><span class="s3">True</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">dest_mapper = self.mapper</span>

        <span class="s3">if </span><span class="s1">dest_selectable </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">dest_selectable = self.entity.selectable</span>
            <span class="s3">if </span><span class="s1">self.mapper.with_polymorphic:</span>
                <span class="s1">aliased = </span><span class="s3">True</span>

            <span class="s3">if </span><span class="s1">self._is_self_referential </span><span class="s3">and </span><span class="s1">source_selectable </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">dest_selectable = dest_selectable._anonymous_fromclause()</span>
                <span class="s1">aliased = </span><span class="s3">True</span>
        <span class="s3">elif </span><span class="s1">(</span>
            <span class="s1">dest_selectable </span><span class="s3">is not </span><span class="s1">self.mapper._with_polymorphic_selectable</span>
            <span class="s3">or </span><span class="s1">self.mapper.with_polymorphic</span>
        <span class="s1">):</span>
            <span class="s1">aliased = </span><span class="s3">True</span>

        <span class="s1">single_crit = dest_mapper._single_table_criterion</span>
        <span class="s1">aliased = aliased </span><span class="s3">or </span><span class="s1">(</span>
            <span class="s1">source_selectable </span><span class="s3">is not None</span>
            <span class="s3">and </span><span class="s1">(</span>
                <span class="s1">source_selectable</span>
                <span class="s3">is not </span><span class="s1">self.parent._with_polymorphic_selectable</span>
                <span class="s3">or </span><span class="s1">source_selectable._is_subquery</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s1">(</span>
            <span class="s1">primaryjoin</span><span class="s5">,</span>
            <span class="s1">secondaryjoin</span><span class="s5">,</span>
            <span class="s1">secondary</span><span class="s5">,</span>
            <span class="s1">target_adapter</span><span class="s5">,</span>
            <span class="s1">dest_selectable</span><span class="s5">,</span>
        <span class="s1">) = self._join_condition.join_targets(</span>
            <span class="s1">source_selectable</span><span class="s5">,</span>
            <span class="s1">dest_selectable</span><span class="s5">,</span>
            <span class="s1">aliased</span><span class="s5">,</span>
            <span class="s1">single_crit</span><span class="s5">,</span>
            <span class="s1">extra_criteria</span><span class="s5">,</span>
        <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">source_selectable </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">source_selectable = self.parent.local_table</span>
        <span class="s3">if </span><span class="s1">dest_selectable </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">dest_selectable = self.entity.local_table</span>
        <span class="s3">return </span><span class="s1">(</span>
            <span class="s1">primaryjoin</span><span class="s5">,</span>
            <span class="s1">secondaryjoin</span><span class="s5">,</span>
            <span class="s1">source_selectable</span><span class="s5">,</span>
            <span class="s1">dest_selectable</span><span class="s5">,</span>
            <span class="s1">secondary</span><span class="s5">,</span>
            <span class="s1">target_adapter</span><span class="s5">,</span>
        <span class="s1">)</span>


<span class="s3">def </span><span class="s1">_annotate_columns(element: _CE</span><span class="s5">, </span><span class="s1">annotations: _AnnotationDict) -&gt; _CE:</span>
    <span class="s3">def </span><span class="s1">clone(elem: _CE) -&gt; _CE:</span>
        <span class="s3">if </span><span class="s1">isinstance(elem</span><span class="s5">, </span><span class="s1">expression.ColumnClause):</span>
            <span class="s1">elem = elem._annotate(annotations.copy())  </span><span class="s0"># type: ignore</span>
        <span class="s1">elem._copy_internals(clone=clone)</span>
        <span class="s3">return </span><span class="s1">elem</span>

    <span class="s3">if </span><span class="s1">element </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">element = clone(element)</span>
    <span class="s1">clone = </span><span class="s3">None  </span><span class="s0"># type: ignore # remove gc cycles</span>
    <span class="s3">return </span><span class="s1">element</span>


<span class="s3">class </span><span class="s1">JoinCondition:</span>
    <span class="s1">primaryjoin_initial: Optional[ColumnElement[bool]]</span>
    <span class="s1">primaryjoin: ColumnElement[bool]</span>
    <span class="s1">secondaryjoin: Optional[ColumnElement[bool]]</span>
    <span class="s1">secondary: Optional[FromClause]</span>
    <span class="s1">prop: RelationshipProperty[Any]</span>

    <span class="s1">synchronize_pairs: _ColumnPairs</span>
    <span class="s1">secondary_synchronize_pairs: _ColumnPairs</span>
    <span class="s1">direction: RelationshipDirection</span>

    <span class="s1">parent_persist_selectable: FromClause</span>
    <span class="s1">child_persist_selectable: FromClause</span>
    <span class="s1">parent_local_selectable: FromClause</span>
    <span class="s1">child_local_selectable: FromClause</span>

    <span class="s1">_local_remote_pairs: Optional[_ColumnPairs]</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">parent_persist_selectable: FromClause</span><span class="s5">,</span>
        <span class="s1">child_persist_selectable: FromClause</span><span class="s5">,</span>
        <span class="s1">parent_local_selectable: FromClause</span><span class="s5">,</span>
        <span class="s1">child_local_selectable: FromClause</span><span class="s5">,</span>
        <span class="s1">*</span><span class="s5">,</span>
        <span class="s1">primaryjoin: Optional[ColumnElement[bool]] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">secondary: Optional[FromClause] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">secondaryjoin: Optional[ColumnElement[bool]] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">parent_equivalents: Optional[_EquivalentColumnMap] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">child_equivalents: Optional[_EquivalentColumnMap] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">consider_as_foreign_keys: Any = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">local_remote_pairs: Optional[_ColumnPairs] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">remote_side: Any = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">self_referential: Any = </span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">prop: RelationshipProperty[Any]</span><span class="s5">,</span>
        <span class="s1">support_sync: bool = </span><span class="s3">True</span><span class="s5">,</span>
        <span class="s1">can_be_synced_fn: Callable[...</span><span class="s5">, </span><span class="s1">bool] = </span><span class="s3">lambda </span><span class="s1">*c: </span><span class="s3">True</span><span class="s5">,</span>
    <span class="s1">):</span>
        <span class="s1">self.parent_persist_selectable = parent_persist_selectable</span>
        <span class="s1">self.parent_local_selectable = parent_local_selectable</span>
        <span class="s1">self.child_persist_selectable = child_persist_selectable</span>
        <span class="s1">self.child_local_selectable = child_local_selectable</span>
        <span class="s1">self.parent_equivalents = parent_equivalents</span>
        <span class="s1">self.child_equivalents = child_equivalents</span>
        <span class="s1">self.primaryjoin_initial = primaryjoin</span>
        <span class="s1">self.secondaryjoin = secondaryjoin</span>
        <span class="s1">self.secondary = secondary</span>
        <span class="s1">self.consider_as_foreign_keys = consider_as_foreign_keys</span>
        <span class="s1">self._local_remote_pairs = local_remote_pairs</span>
        <span class="s1">self._remote_side = remote_side</span>
        <span class="s1">self.prop = prop</span>
        <span class="s1">self.self_referential = self_referential</span>
        <span class="s1">self.support_sync = support_sync</span>
        <span class="s1">self.can_be_synced_fn = can_be_synced_fn</span>

        <span class="s1">self._determine_joins()</span>
        <span class="s3">assert </span><span class="s1">self.primaryjoin </span><span class="s3">is not None</span>

        <span class="s1">self._sanitize_joins()</span>
        <span class="s1">self._annotate_fks()</span>
        <span class="s1">self._annotate_remote()</span>
        <span class="s1">self._annotate_local()</span>
        <span class="s1">self._annotate_parentmapper()</span>
        <span class="s1">self._setup_pairs()</span>
        <span class="s1">self._check_foreign_cols(self.primaryjoin</span><span class="s5">, </span><span class="s3">True</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">self.secondaryjoin </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self._check_foreign_cols(self.secondaryjoin</span><span class="s5">, </span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">self._determine_direction()</span>
        <span class="s1">self._check_remote_side()</span>
        <span class="s1">self._log_joins()</span>

    <span class="s3">def </span><span class="s1">_log_joins(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">log = self.prop.logger</span>
        <span class="s1">log.info(</span><span class="s4">&quot;%s setup primary join %s&quot;</span><span class="s5">, </span><span class="s1">self.prop</span><span class="s5">, </span><span class="s1">self.primaryjoin)</span>
        <span class="s1">log.info(</span><span class="s4">&quot;%s setup secondary join %s&quot;</span><span class="s5">, </span><span class="s1">self.prop</span><span class="s5">, </span><span class="s1">self.secondaryjoin)</span>
        <span class="s1">log.info(</span>
            <span class="s4">&quot;%s synchronize pairs [%s]&quot;</span><span class="s5">,</span>
            <span class="s1">self.prop</span><span class="s5">,</span>
            <span class="s4">&quot;,&quot;</span><span class="s1">.join(</span>
                <span class="s4">&quot;(%s =&gt; %s)&quot; </span><span class="s1">% (l</span><span class="s5">, </span><span class="s1">r) </span><span class="s3">for </span><span class="s1">(l</span><span class="s5">, </span><span class="s1">r) </span><span class="s3">in </span><span class="s1">self.synchronize_pairs</span>
            <span class="s1">)</span><span class="s5">,</span>
        <span class="s1">)</span>
        <span class="s1">log.info(</span>
            <span class="s4">&quot;%s secondary synchronize pairs [%s]&quot;</span><span class="s5">,</span>
            <span class="s1">self.prop</span><span class="s5">,</span>
            <span class="s4">&quot;,&quot;</span><span class="s1">.join(</span>
                <span class="s4">&quot;(%s =&gt; %s)&quot; </span><span class="s1">% (l</span><span class="s5">, </span><span class="s1">r)</span>
                <span class="s3">for </span><span class="s1">(l</span><span class="s5">, </span><span class="s1">r) </span><span class="s3">in </span><span class="s1">self.secondary_synchronize_pairs </span><span class="s3">or </span><span class="s1">[]</span>
            <span class="s1">)</span><span class="s5">,</span>
        <span class="s1">)</span>
        <span class="s1">log.info(</span>
            <span class="s4">&quot;%s local/remote pairs [%s]&quot;</span><span class="s5">,</span>
            <span class="s1">self.prop</span><span class="s5">,</span>
            <span class="s4">&quot;,&quot;</span><span class="s1">.join(</span>
                <span class="s4">&quot;(%s / %s)&quot; </span><span class="s1">% (l</span><span class="s5">, </span><span class="s1">r) </span><span class="s3">for </span><span class="s1">(l</span><span class="s5">, </span><span class="s1">r) </span><span class="s3">in </span><span class="s1">self.local_remote_pairs</span>
            <span class="s1">)</span><span class="s5">,</span>
        <span class="s1">)</span>
        <span class="s1">log.info(</span>
            <span class="s4">&quot;%s remote columns [%s]&quot;</span><span class="s5">,</span>
            <span class="s1">self.prop</span><span class="s5">,</span>
            <span class="s4">&quot;,&quot;</span><span class="s1">.join(</span><span class="s4">&quot;%s&quot; </span><span class="s1">% col </span><span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">self.remote_columns)</span><span class="s5">,</span>
        <span class="s1">)</span>
        <span class="s1">log.info(</span>
            <span class="s4">&quot;%s local columns [%s]&quot;</span><span class="s5">,</span>
            <span class="s1">self.prop</span><span class="s5">,</span>
            <span class="s4">&quot;,&quot;</span><span class="s1">.join(</span><span class="s4">&quot;%s&quot; </span><span class="s1">% col </span><span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">self.local_columns)</span><span class="s5">,</span>
        <span class="s1">)</span>
        <span class="s1">log.info(</span><span class="s4">&quot;%s relationship direction %s&quot;</span><span class="s5">, </span><span class="s1">self.prop</span><span class="s5">, </span><span class="s1">self.direction)</span>

    <span class="s3">def </span><span class="s1">_sanitize_joins(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;remove the parententity annotation from our join conditions which 
        can leak in here based on some declarative patterns and maybe others. 
 
        &quot;parentmapper&quot; is relied upon both by the ORM evaluator as well as 
        the use case in _join_fixture_inh_selfref_w_entity 
        that relies upon it being present, see :ticket:`3364`. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">self.primaryjoin = _deep_deannotate(</span>
            <span class="s1">self.primaryjoin</span><span class="s5">, </span><span class="s1">values=(</span><span class="s4">&quot;parententity&quot;</span><span class="s5">, </span><span class="s4">&quot;proxy_key&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">self.secondaryjoin </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.secondaryjoin = _deep_deannotate(</span>
                <span class="s1">self.secondaryjoin</span><span class="s5">, </span><span class="s1">values=(</span><span class="s4">&quot;parententity&quot;</span><span class="s5">, </span><span class="s4">&quot;proxy_key&quot;</span><span class="s1">)</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_determine_joins(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Determine the 'primaryjoin' and 'secondaryjoin' attributes, 
        if not passed to the constructor already. 
 
        This is based on analysis of the foreign key relationships 
        between the parent and target mapped selectables. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.secondaryjoin </span><span class="s3">is not None and </span><span class="s1">self.secondary </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">sa_exc.ArgumentError(</span>
                <span class="s4">&quot;Property %s specified with secondary &quot;</span>
                <span class="s4">&quot;join condition but &quot;</span>
                <span class="s4">&quot;no secondary argument&quot; </span><span class="s1">% self.prop</span>
            <span class="s1">)</span>

        <span class="s0"># find a join between the given mapper's mapped table and</span>
        <span class="s0"># the given table. will try the mapper's local table first</span>
        <span class="s0"># for more specificity, then if not found will try the more</span>
        <span class="s0"># general mapped table, which in the case of inheritance is</span>
        <span class="s0"># a join.</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">consider_as_foreign_keys = self.consider_as_foreign_keys </span><span class="s3">or None</span>
            <span class="s3">if </span><span class="s1">self.secondary </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">self.secondaryjoin </span><span class="s3">is None</span><span class="s1">:</span>
                    <span class="s1">self.secondaryjoin = join_condition(</span>
                        <span class="s1">self.child_persist_selectable</span><span class="s5">,</span>
                        <span class="s1">self.secondary</span><span class="s5">,</span>
                        <span class="s1">a_subset=self.child_local_selectable</span><span class="s5">,</span>
                        <span class="s1">consider_as_foreign_keys=consider_as_foreign_keys</span><span class="s5">,</span>
                    <span class="s1">)</span>
                <span class="s3">if </span><span class="s1">self.primaryjoin_initial </span><span class="s3">is None</span><span class="s1">:</span>
                    <span class="s1">self.primaryjoin = join_condition(</span>
                        <span class="s1">self.parent_persist_selectable</span><span class="s5">,</span>
                        <span class="s1">self.secondary</span><span class="s5">,</span>
                        <span class="s1">a_subset=self.parent_local_selectable</span><span class="s5">,</span>
                        <span class="s1">consider_as_foreign_keys=consider_as_foreign_keys</span><span class="s5">,</span>
                    <span class="s1">)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">self.primaryjoin = self.primaryjoin_initial</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">self.primaryjoin_initial </span><span class="s3">is None</span><span class="s1">:</span>
                    <span class="s1">self.primaryjoin = join_condition(</span>
                        <span class="s1">self.parent_persist_selectable</span><span class="s5">,</span>
                        <span class="s1">self.child_persist_selectable</span><span class="s5">,</span>
                        <span class="s1">a_subset=self.parent_local_selectable</span><span class="s5">,</span>
                        <span class="s1">consider_as_foreign_keys=consider_as_foreign_keys</span><span class="s5">,</span>
                    <span class="s1">)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">self.primaryjoin = self.primaryjoin_initial</span>
        <span class="s3">except </span><span class="s1">sa_exc.NoForeignKeysError </span><span class="s3">as </span><span class="s1">nfe:</span>
            <span class="s3">if </span><span class="s1">self.secondary </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">sa_exc.NoForeignKeysError(</span>
                    <span class="s4">&quot;Could not determine join &quot;</span>
                    <span class="s4">&quot;condition between parent/child tables on &quot;</span>
                    <span class="s4">&quot;relationship %s - there are no foreign keys &quot;</span>
                    <span class="s4">&quot;linking these tables via secondary table '%s'.  &quot;</span>
                    <span class="s4">&quot;Ensure that referencing columns are associated &quot;</span>
                    <span class="s4">&quot;with a ForeignKey or ForeignKeyConstraint, or &quot;</span>
                    <span class="s4">&quot;specify 'primaryjoin' and 'secondaryjoin' &quot;</span>
                    <span class="s4">&quot;expressions.&quot; </span><span class="s1">% (self.prop</span><span class="s5">, </span><span class="s1">self.secondary)</span>
                <span class="s1">) </span><span class="s3">from </span><span class="s1">nfe</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">sa_exc.NoForeignKeysError(</span>
                    <span class="s4">&quot;Could not determine join &quot;</span>
                    <span class="s4">&quot;condition between parent/child tables on &quot;</span>
                    <span class="s4">&quot;relationship %s - there are no foreign keys &quot;</span>
                    <span class="s4">&quot;linking these tables.  &quot;</span>
                    <span class="s4">&quot;Ensure that referencing columns are associated &quot;</span>
                    <span class="s4">&quot;with a ForeignKey or ForeignKeyConstraint, or &quot;</span>
                    <span class="s4">&quot;specify a 'primaryjoin' expression.&quot; </span><span class="s1">% self.prop</span>
                <span class="s1">) </span><span class="s3">from </span><span class="s1">nfe</span>
        <span class="s3">except </span><span class="s1">sa_exc.AmbiguousForeignKeysError </span><span class="s3">as </span><span class="s1">afe:</span>
            <span class="s3">if </span><span class="s1">self.secondary </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">sa_exc.AmbiguousForeignKeysError(</span>
                    <span class="s4">&quot;Could not determine join &quot;</span>
                    <span class="s4">&quot;condition between parent/child tables on &quot;</span>
                    <span class="s4">&quot;relationship %s - there are multiple foreign key &quot;</span>
                    <span class="s4">&quot;paths linking the tables via secondary table '%s'.  &quot;</span>
                    <span class="s4">&quot;Specify the 'foreign_keys' &quot;</span>
                    <span class="s4">&quot;argument, providing a list of those columns which &quot;</span>
                    <span class="s4">&quot;should be counted as containing a foreign key &quot;</span>
                    <span class="s4">&quot;reference from the secondary table to each of the &quot;</span>
                    <span class="s4">&quot;parent and child tables.&quot; </span><span class="s1">% (self.prop</span><span class="s5">, </span><span class="s1">self.secondary)</span>
                <span class="s1">) </span><span class="s3">from </span><span class="s1">afe</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">sa_exc.AmbiguousForeignKeysError(</span>
                    <span class="s4">&quot;Could not determine join &quot;</span>
                    <span class="s4">&quot;condition between parent/child tables on &quot;</span>
                    <span class="s4">&quot;relationship %s - there are multiple foreign key &quot;</span>
                    <span class="s4">&quot;paths linking the tables.  Specify the &quot;</span>
                    <span class="s4">&quot;'foreign_keys' argument, providing a list of those &quot;</span>
                    <span class="s4">&quot;columns which should be counted as containing a &quot;</span>
                    <span class="s4">&quot;foreign key reference to the parent table.&quot; </span><span class="s1">% self.prop</span>
                <span class="s1">) </span><span class="s3">from </span><span class="s1">afe</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">primaryjoin_minus_local(self) -&gt; ColumnElement[bool]:</span>
        <span class="s3">return </span><span class="s1">_deep_deannotate(self.primaryjoin</span><span class="s5">, </span><span class="s1">values=(</span><span class="s4">&quot;local&quot;</span><span class="s5">, </span><span class="s4">&quot;remote&quot;</span><span class="s1">))</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">secondaryjoin_minus_local(self) -&gt; ColumnElement[bool]:</span>
        <span class="s3">assert </span><span class="s1">self.secondaryjoin </span><span class="s3">is not None</span>
        <span class="s3">return </span><span class="s1">_deep_deannotate(self.secondaryjoin</span><span class="s5">, </span><span class="s1">values=(</span><span class="s4">&quot;local&quot;</span><span class="s5">, </span><span class="s4">&quot;remote&quot;</span><span class="s1">))</span>

    <span class="s1">@util.memoized_property</span>
    <span class="s3">def </span><span class="s1">primaryjoin_reverse_remote(self) -&gt; ColumnElement[bool]:</span>
        <span class="s2">&quot;&quot;&quot;Return the primaryjoin condition suitable for the 
        &quot;reverse&quot; direction. 
 
        If the primaryjoin was delivered here with pre-existing 
        &quot;remote&quot; annotations, the local/remote annotations 
        are reversed.  Otherwise, the local/remote annotations 
        are removed. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self._has_remote_annotations:</span>

            <span class="s3">def </span><span class="s1">replace(element: _CE</span><span class="s5">, </span><span class="s1">**kw: Any) -&gt; Optional[_CE]:</span>
                <span class="s3">if </span><span class="s4">&quot;remote&quot; </span><span class="s3">in </span><span class="s1">element._annotations:</span>
                    <span class="s1">v = dict(element._annotations)</span>
                    <span class="s3">del </span><span class="s1">v[</span><span class="s4">&quot;remote&quot;</span><span class="s1">]</span>
                    <span class="s1">v[</span><span class="s4">&quot;local&quot;</span><span class="s1">] = </span><span class="s3">True</span>
                    <span class="s3">return </span><span class="s1">element._with_annotations(v)</span>
                <span class="s3">elif </span><span class="s4">&quot;local&quot; </span><span class="s3">in </span><span class="s1">element._annotations:</span>
                    <span class="s1">v = dict(element._annotations)</span>
                    <span class="s3">del </span><span class="s1">v[</span><span class="s4">&quot;local&quot;</span><span class="s1">]</span>
                    <span class="s1">v[</span><span class="s4">&quot;remote&quot;</span><span class="s1">] = </span><span class="s3">True</span>
                    <span class="s3">return </span><span class="s1">element._with_annotations(v)</span>

                <span class="s3">return None</span>

            <span class="s3">return </span><span class="s1">visitors.replacement_traverse(self.primaryjoin</span><span class="s5">, </span><span class="s1">{}</span><span class="s5">, </span><span class="s1">replace)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">self._has_foreign_annotations:</span>
                <span class="s0"># TODO: coverage</span>
                <span class="s3">return </span><span class="s1">_deep_deannotate(</span>
                    <span class="s1">self.primaryjoin</span><span class="s5">, </span><span class="s1">values=(</span><span class="s4">&quot;local&quot;</span><span class="s5">, </span><span class="s4">&quot;remote&quot;</span><span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">_deep_deannotate(self.primaryjoin)</span>

    <span class="s3">def </span><span class="s1">_has_annotation(self</span><span class="s5">, </span><span class="s1">clause: ClauseElement</span><span class="s5">, </span><span class="s1">annotation: str) -&gt; bool:</span>
        <span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">visitors.iterate(clause</span><span class="s5">, </span><span class="s1">{}):</span>
            <span class="s3">if </span><span class="s1">annotation </span><span class="s3">in </span><span class="s1">col._annotations:</span>
                <span class="s3">return True</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return False</span>

    <span class="s1">@util.memoized_property</span>
    <span class="s3">def </span><span class="s1">_has_foreign_annotations(self) -&gt; bool:</span>
        <span class="s3">return </span><span class="s1">self._has_annotation(self.primaryjoin</span><span class="s5">, </span><span class="s4">&quot;foreign&quot;</span><span class="s1">)</span>

    <span class="s1">@util.memoized_property</span>
    <span class="s3">def </span><span class="s1">_has_remote_annotations(self) -&gt; bool:</span>
        <span class="s3">return </span><span class="s1">self._has_annotation(self.primaryjoin</span><span class="s5">, </span><span class="s4">&quot;remote&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_annotate_fks(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Annotate the primaryjoin and secondaryjoin 
        structures with 'foreign' annotations marking columns 
        considered as foreign. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self._has_foreign_annotations:</span>
            <span class="s3">return</span>

        <span class="s3">if </span><span class="s1">self.consider_as_foreign_keys:</span>
            <span class="s1">self._annotate_from_fk_list()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self._annotate_present_fks()</span>

    <span class="s3">def </span><span class="s1">_annotate_from_fk_list(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">def </span><span class="s1">check_fk(element: _CE</span><span class="s5">, </span><span class="s1">**kw: Any) -&gt; Optional[_CE]:</span>
            <span class="s3">if </span><span class="s1">element </span><span class="s3">in </span><span class="s1">self.consider_as_foreign_keys:</span>
                <span class="s3">return </span><span class="s1">element._annotate({</span><span class="s4">&quot;foreign&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">})</span>
            <span class="s3">return None</span>

        <span class="s1">self.primaryjoin = visitors.replacement_traverse(</span>
            <span class="s1">self.primaryjoin</span><span class="s5">, </span><span class="s1">{}</span><span class="s5">, </span><span class="s1">check_fk</span>
        <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">self.secondaryjoin </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.secondaryjoin = visitors.replacement_traverse(</span>
                <span class="s1">self.secondaryjoin</span><span class="s5">, </span><span class="s1">{}</span><span class="s5">, </span><span class="s1">check_fk</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_annotate_present_fks(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">self.secondary </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">secondarycols = util.column_set(self.secondary.c)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">secondarycols = set()</span>

        <span class="s3">def </span><span class="s1">is_foreign(</span>
            <span class="s1">a: ColumnElement[Any]</span><span class="s5">, </span><span class="s1">b: ColumnElement[Any]</span>
        <span class="s1">) -&gt; Optional[ColumnElement[Any]]:</span>
            <span class="s3">if </span><span class="s1">isinstance(a</span><span class="s5">, </span><span class="s1">schema.Column) </span><span class="s3">and </span><span class="s1">isinstance(b</span><span class="s5">, </span><span class="s1">schema.Column):</span>
                <span class="s3">if </span><span class="s1">a.references(b):</span>
                    <span class="s3">return </span><span class="s1">a</span>
                <span class="s3">elif </span><span class="s1">b.references(a):</span>
                    <span class="s3">return </span><span class="s1">b</span>

            <span class="s3">if </span><span class="s1">secondarycols:</span>
                <span class="s3">if </span><span class="s1">a </span><span class="s3">in </span><span class="s1">secondarycols </span><span class="s3">and </span><span class="s1">b </span><span class="s3">not in </span><span class="s1">secondarycols:</span>
                    <span class="s3">return </span><span class="s1">a</span>
                <span class="s3">elif </span><span class="s1">b </span><span class="s3">in </span><span class="s1">secondarycols </span><span class="s3">and </span><span class="s1">a </span><span class="s3">not in </span><span class="s1">secondarycols:</span>
                    <span class="s3">return </span><span class="s1">b</span>

            <span class="s3">return None</span>

        <span class="s3">def </span><span class="s1">visit_binary(binary: BinaryExpression[Any]) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
            <span class="s3">if not </span><span class="s1">isinstance(</span>
                <span class="s1">binary.left</span><span class="s5">, </span><span class="s1">sql.ColumnElement</span>
            <span class="s1">) </span><span class="s3">or not </span><span class="s1">isinstance(binary.right</span><span class="s5">, </span><span class="s1">sql.ColumnElement):</span>
                <span class="s3">return</span>

            <span class="s3">if </span><span class="s1">(</span>
                <span class="s4">&quot;foreign&quot; </span><span class="s3">not in </span><span class="s1">binary.left._annotations</span>
                <span class="s3">and </span><span class="s4">&quot;foreign&quot; </span><span class="s3">not in </span><span class="s1">binary.right._annotations</span>
            <span class="s1">):</span>
                <span class="s1">col = is_foreign(binary.left</span><span class="s5">, </span><span class="s1">binary.right)</span>
                <span class="s3">if </span><span class="s1">col </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s3">if </span><span class="s1">col.compare(binary.left):</span>
                        <span class="s1">binary.left = binary.left._annotate({</span><span class="s4">&quot;foreign&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">})</span>
                    <span class="s3">elif </span><span class="s1">col.compare(binary.right):</span>
                        <span class="s1">binary.right = binary.right._annotate(</span>
                            <span class="s1">{</span><span class="s4">&quot;foreign&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">}</span>
                        <span class="s1">)</span>

        <span class="s1">self.primaryjoin = visitors.cloned_traverse(</span>
            <span class="s1">self.primaryjoin</span><span class="s5">, </span><span class="s1">{}</span><span class="s5">, </span><span class="s1">{</span><span class="s4">&quot;binary&quot;</span><span class="s1">: visit_binary}</span>
        <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">self.secondaryjoin </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.secondaryjoin = visitors.cloned_traverse(</span>
                <span class="s1">self.secondaryjoin</span><span class="s5">, </span><span class="s1">{}</span><span class="s5">, </span><span class="s1">{</span><span class="s4">&quot;binary&quot;</span><span class="s1">: visit_binary}</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_refers_to_parent_table(self) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot;Return True if the join condition contains column 
        comparisons where both columns are in both tables. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">pt = self.parent_persist_selectable</span>
        <span class="s1">mt = self.child_persist_selectable</span>
        <span class="s1">result = </span><span class="s3">False</span>

        <span class="s3">def </span><span class="s1">visit_binary(binary: BinaryExpression[Any]) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
            <span class="s3">nonlocal </span><span class="s1">result</span>
            <span class="s1">c</span><span class="s5">, </span><span class="s1">f = binary.left</span><span class="s5">, </span><span class="s1">binary.right</span>
            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">isinstance(c</span><span class="s5">, </span><span class="s1">expression.ColumnClause)</span>
                <span class="s3">and </span><span class="s1">isinstance(f</span><span class="s5">, </span><span class="s1">expression.ColumnClause)</span>
                <span class="s3">and </span><span class="s1">pt.is_derived_from(c.table)</span>
                <span class="s3">and </span><span class="s1">pt.is_derived_from(f.table)</span>
                <span class="s3">and </span><span class="s1">mt.is_derived_from(c.table)</span>
                <span class="s3">and </span><span class="s1">mt.is_derived_from(f.table)</span>
            <span class="s1">):</span>
                <span class="s1">result = </span><span class="s3">True</span>

        <span class="s1">visitors.traverse(self.primaryjoin</span><span class="s5">, </span><span class="s1">{}</span><span class="s5">, </span><span class="s1">{</span><span class="s4">&quot;binary&quot;</span><span class="s1">: visit_binary})</span>
        <span class="s3">return </span><span class="s1">result</span>

    <span class="s3">def </span><span class="s1">_tables_overlap(self) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot;Return True if parent/child tables have some overlap.&quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">selectables_overlap(</span>
            <span class="s1">self.parent_persist_selectable</span><span class="s5">, </span><span class="s1">self.child_persist_selectable</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_annotate_remote(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Annotate the primaryjoin and secondaryjoin 
        structures with 'remote' annotations marking columns 
        considered as part of the 'remote' side. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self._has_remote_annotations:</span>
            <span class="s3">return</span>

        <span class="s3">if </span><span class="s1">self.secondary </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self._annotate_remote_secondary()</span>
        <span class="s3">elif </span><span class="s1">self._local_remote_pairs </span><span class="s3">or </span><span class="s1">self._remote_side:</span>
            <span class="s1">self._annotate_remote_from_args()</span>
        <span class="s3">elif </span><span class="s1">self._refers_to_parent_table():</span>
            <span class="s1">self._annotate_selfref(</span>
                <span class="s3">lambda </span><span class="s1">col: </span><span class="s4">&quot;foreign&quot; </span><span class="s3">in </span><span class="s1">col._annotations</span><span class="s5">, </span><span class="s3">False</span>
            <span class="s1">)</span>
        <span class="s3">elif </span><span class="s1">self._tables_overlap():</span>
            <span class="s1">self._annotate_remote_with_overlap()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self._annotate_remote_distinct_selectables()</span>

    <span class="s3">def </span><span class="s1">_annotate_remote_secondary(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;annotate 'remote' in primaryjoin, secondaryjoin 
        when 'secondary' is present. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">assert </span><span class="s1">self.secondary </span><span class="s3">is not None</span>
        <span class="s1">fixed_secondary = self.secondary</span>

        <span class="s3">def </span><span class="s1">repl(element: _CE</span><span class="s5">, </span><span class="s1">**kw: Any) -&gt; Optional[_CE]:</span>
            <span class="s3">if </span><span class="s1">fixed_secondary.c.contains_column(element):</span>
                <span class="s3">return </span><span class="s1">element._annotate({</span><span class="s4">&quot;remote&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">})</span>
            <span class="s3">return None</span>

        <span class="s1">self.primaryjoin = visitors.replacement_traverse(</span>
            <span class="s1">self.primaryjoin</span><span class="s5">, </span><span class="s1">{}</span><span class="s5">, </span><span class="s1">repl</span>
        <span class="s1">)</span>

        <span class="s3">assert </span><span class="s1">self.secondaryjoin </span><span class="s3">is not None</span>
        <span class="s1">self.secondaryjoin = visitors.replacement_traverse(</span>
            <span class="s1">self.secondaryjoin</span><span class="s5">, </span><span class="s1">{}</span><span class="s5">, </span><span class="s1">repl</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_annotate_selfref(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">fn: Callable[[ColumnElement[Any]]</span><span class="s5">, </span><span class="s1">bool]</span><span class="s5">, </span><span class="s1">remote_side_given: bool</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;annotate 'remote' in primaryjoin, secondaryjoin 
        when the relationship is detected as self-referential. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">def </span><span class="s1">visit_binary(binary: BinaryExpression[Any]) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
            <span class="s1">equated = binary.left.compare(binary.right)</span>
            <span class="s3">if </span><span class="s1">isinstance(binary.left</span><span class="s5">, </span><span class="s1">expression.ColumnClause) </span><span class="s3">and </span><span class="s1">isinstance(</span>
                <span class="s1">binary.right</span><span class="s5">, </span><span class="s1">expression.ColumnClause</span>
            <span class="s1">):</span>
                <span class="s0"># assume one to many - FKs are &quot;remote&quot;</span>
                <span class="s3">if </span><span class="s1">fn(binary.left):</span>
                    <span class="s1">binary.left = binary.left._annotate({</span><span class="s4">&quot;remote&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">})</span>
                <span class="s3">if </span><span class="s1">fn(binary.right) </span><span class="s3">and not </span><span class="s1">equated:</span>
                    <span class="s1">binary.right = binary.right._annotate({</span><span class="s4">&quot;remote&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">})</span>
            <span class="s3">elif not </span><span class="s1">remote_side_given:</span>
                <span class="s1">self._warn_non_column_elements()</span>

        <span class="s1">self.primaryjoin = visitors.cloned_traverse(</span>
            <span class="s1">self.primaryjoin</span><span class="s5">, </span><span class="s1">{}</span><span class="s5">, </span><span class="s1">{</span><span class="s4">&quot;binary&quot;</span><span class="s1">: visit_binary}</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_annotate_remote_from_args(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;annotate 'remote' in primaryjoin, secondaryjoin 
        when the 'remote_side' or '_local_remote_pairs' 
        arguments are used. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self._local_remote_pairs:</span>
            <span class="s3">if </span><span class="s1">self._remote_side:</span>
                <span class="s3">raise </span><span class="s1">sa_exc.ArgumentError(</span>
                    <span class="s4">&quot;remote_side argument is redundant &quot;</span>
                    <span class="s4">&quot;against more detailed _local_remote_side &quot;</span>
                    <span class="s4">&quot;argument.&quot;</span>
                <span class="s1">)</span>

            <span class="s1">remote_side = [r </span><span class="s3">for </span><span class="s1">(l</span><span class="s5">, </span><span class="s1">r) </span><span class="s3">in </span><span class="s1">self._local_remote_pairs]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">remote_side = self._remote_side</span>

        <span class="s3">if </span><span class="s1">self._refers_to_parent_table():</span>
            <span class="s1">self._annotate_selfref(</span><span class="s3">lambda </span><span class="s1">col: col </span><span class="s3">in </span><span class="s1">remote_side</span><span class="s5">, </span><span class="s3">True</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>

            <span class="s3">def </span><span class="s1">repl(element: _CE</span><span class="s5">, </span><span class="s1">**kw: Any) -&gt; Optional[_CE]:</span>
                <span class="s0"># use set() to avoid generating ``__eq__()`` expressions</span>
                <span class="s0"># against each element</span>
                <span class="s3">if </span><span class="s1">element </span><span class="s3">in </span><span class="s1">set(remote_side):</span>
                    <span class="s3">return </span><span class="s1">element._annotate({</span><span class="s4">&quot;remote&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">})</span>
                <span class="s3">return None</span>

            <span class="s1">self.primaryjoin = visitors.replacement_traverse(</span>
                <span class="s1">self.primaryjoin</span><span class="s5">, </span><span class="s1">{}</span><span class="s5">, </span><span class="s1">repl</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_annotate_remote_with_overlap(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;annotate 'remote' in primaryjoin, secondaryjoin 
        when the parent/child tables have some set of 
        tables in common, though is not a fully self-referential 
        relationship. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">def </span><span class="s1">visit_binary(binary: BinaryExpression[Any]) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
            <span class="s1">binary.left</span><span class="s5">, </span><span class="s1">binary.right = proc_left_right(</span>
                <span class="s1">binary.left</span><span class="s5">, </span><span class="s1">binary.right</span>
            <span class="s1">)</span>
            <span class="s1">binary.right</span><span class="s5">, </span><span class="s1">binary.left = proc_left_right(</span>
                <span class="s1">binary.right</span><span class="s5">, </span><span class="s1">binary.left</span>
            <span class="s1">)</span>

        <span class="s1">check_entities = (</span>
            <span class="s1">self.prop </span><span class="s3">is not None and </span><span class="s1">self.prop.mapper </span><span class="s3">is not </span><span class="s1">self.prop.parent</span>
        <span class="s1">)</span>

        <span class="s3">def </span><span class="s1">proc_left_right(</span>
            <span class="s1">left: ColumnElement[Any]</span><span class="s5">, </span><span class="s1">right: ColumnElement[Any]</span>
        <span class="s1">) -&gt; Tuple[ColumnElement[Any]</span><span class="s5">, </span><span class="s1">ColumnElement[Any]]:</span>
            <span class="s3">if </span><span class="s1">isinstance(left</span><span class="s5">, </span><span class="s1">expression.ColumnClause) </span><span class="s3">and </span><span class="s1">isinstance(</span>
                <span class="s1">right</span><span class="s5">, </span><span class="s1">expression.ColumnClause</span>
            <span class="s1">):</span>
                <span class="s3">if </span><span class="s1">self.child_persist_selectable.c.contains_column(</span>
                    <span class="s1">right</span>
                <span class="s1">) </span><span class="s3">and </span><span class="s1">self.parent_persist_selectable.c.contains_column(left):</span>
                    <span class="s1">right = right._annotate({</span><span class="s4">&quot;remote&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">})</span>
            <span class="s3">elif </span><span class="s1">(</span>
                <span class="s1">check_entities</span>
                <span class="s3">and </span><span class="s1">right._annotations.get(</span><span class="s4">&quot;parentmapper&quot;</span><span class="s1">) </span><span class="s3">is </span><span class="s1">self.prop.mapper</span>
            <span class="s1">):</span>
                <span class="s1">right = right._annotate({</span><span class="s4">&quot;remote&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">})</span>
            <span class="s3">elif </span><span class="s1">(</span>
                <span class="s1">check_entities</span>
                <span class="s3">and </span><span class="s1">left._annotations.get(</span><span class="s4">&quot;parentmapper&quot;</span><span class="s1">) </span><span class="s3">is </span><span class="s1">self.prop.mapper</span>
            <span class="s1">):</span>
                <span class="s1">left = left._annotate({</span><span class="s4">&quot;remote&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">})</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self._warn_non_column_elements()</span>

            <span class="s3">return </span><span class="s1">left</span><span class="s5">, </span><span class="s1">right</span>

        <span class="s1">self.primaryjoin = visitors.cloned_traverse(</span>
            <span class="s1">self.primaryjoin</span><span class="s5">, </span><span class="s1">{}</span><span class="s5">, </span><span class="s1">{</span><span class="s4">&quot;binary&quot;</span><span class="s1">: visit_binary}</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_annotate_remote_distinct_selectables(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;annotate 'remote' in primaryjoin, secondaryjoin 
        when the parent/child tables are entirely 
        separate. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">def </span><span class="s1">repl(element: _CE</span><span class="s5">, </span><span class="s1">**kw: Any) -&gt; Optional[_CE]:</span>
            <span class="s3">if </span><span class="s1">self.child_persist_selectable.c.contains_column(element) </span><span class="s3">and </span><span class="s1">(</span>
                <span class="s3">not </span><span class="s1">self.parent_local_selectable.c.contains_column(element)</span>
                <span class="s3">or </span><span class="s1">self.child_local_selectable.c.contains_column(element)</span>
            <span class="s1">):</span>
                <span class="s3">return </span><span class="s1">element._annotate({</span><span class="s4">&quot;remote&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">})</span>
            <span class="s3">return None</span>

        <span class="s1">self.primaryjoin = visitors.replacement_traverse(</span>
            <span class="s1">self.primaryjoin</span><span class="s5">, </span><span class="s1">{}</span><span class="s5">, </span><span class="s1">repl</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_warn_non_column_elements(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">util.warn(</span>
            <span class="s4">&quot;Non-simple column elements in primary &quot;</span>
            <span class="s4">&quot;join condition for property %s - consider using &quot;</span>
            <span class="s4">&quot;remote() annotations to mark the remote side.&quot; </span><span class="s1">% self.prop</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_annotate_local(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Annotate the primaryjoin and secondaryjoin 
        structures with 'local' annotations. 
 
        This annotates all column elements found 
        simultaneously in the parent table 
        and the join condition that don't have a 
        'remote' annotation set up from 
        _annotate_remote() or user-defined. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self._has_annotation(self.primaryjoin</span><span class="s5">, </span><span class="s4">&quot;local&quot;</span><span class="s1">):</span>
            <span class="s3">return</span>

        <span class="s3">if </span><span class="s1">self._local_remote_pairs:</span>
            <span class="s1">local_side = util.column_set(</span>
                <span class="s1">[l </span><span class="s3">for </span><span class="s1">(l</span><span class="s5">, </span><span class="s1">r) </span><span class="s3">in </span><span class="s1">self._local_remote_pairs]</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">local_side = util.column_set(self.parent_persist_selectable.c)</span>

        <span class="s3">def </span><span class="s1">locals_(element: _CE</span><span class="s5">, </span><span class="s1">**kw: Any) -&gt; Optional[_CE]:</span>
            <span class="s3">if </span><span class="s4">&quot;remote&quot; </span><span class="s3">not in </span><span class="s1">element._annotations </span><span class="s3">and </span><span class="s1">element </span><span class="s3">in </span><span class="s1">local_side:</span>
                <span class="s3">return </span><span class="s1">element._annotate({</span><span class="s4">&quot;local&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">})</span>
            <span class="s3">return None</span>

        <span class="s1">self.primaryjoin = visitors.replacement_traverse(</span>
            <span class="s1">self.primaryjoin</span><span class="s5">, </span><span class="s1">{}</span><span class="s5">, </span><span class="s1">locals_</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_annotate_parentmapper(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">def </span><span class="s1">parentmappers_(element: _CE</span><span class="s5">, </span><span class="s1">**kw: Any) -&gt; Optional[_CE]:</span>
            <span class="s3">if </span><span class="s4">&quot;remote&quot; </span><span class="s3">in </span><span class="s1">element._annotations:</span>
                <span class="s3">return </span><span class="s1">element._annotate({</span><span class="s4">&quot;parentmapper&quot;</span><span class="s1">: self.prop.mapper})</span>
            <span class="s3">elif </span><span class="s4">&quot;local&quot; </span><span class="s3">in </span><span class="s1">element._annotations:</span>
                <span class="s3">return </span><span class="s1">element._annotate({</span><span class="s4">&quot;parentmapper&quot;</span><span class="s1">: self.prop.parent})</span>
            <span class="s3">return None</span>

        <span class="s1">self.primaryjoin = visitors.replacement_traverse(</span>
            <span class="s1">self.primaryjoin</span><span class="s5">, </span><span class="s1">{}</span><span class="s5">, </span><span class="s1">parentmappers_</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_check_remote_side(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">if not </span><span class="s1">self.local_remote_pairs:</span>
            <span class="s3">raise </span><span class="s1">sa_exc.ArgumentError(</span>
                <span class="s4">&quot;Relationship %s could &quot;</span>
                <span class="s4">&quot;not determine any unambiguous local/remote column &quot;</span>
                <span class="s4">&quot;pairs based on join condition and remote_side &quot;</span>
                <span class="s4">&quot;arguments.  &quot;</span>
                <span class="s4">&quot;Consider using the remote() annotation to &quot;</span>
                <span class="s4">&quot;accurately mark those elements of the join &quot;</span>
                <span class="s4">&quot;condition that are on the remote side of &quot;</span>
                <span class="s4">&quot;the relationship.&quot; </span><span class="s1">% (self.prop</span><span class="s5">,</span><span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">not_target = util.column_set(</span>
                <span class="s1">self.parent_persist_selectable.c</span>
            <span class="s1">).difference(self.child_persist_selectable.c)</span>

            <span class="s3">for </span><span class="s1">_</span><span class="s5">, </span><span class="s1">rmt </span><span class="s3">in </span><span class="s1">self.local_remote_pairs:</span>
                <span class="s3">if </span><span class="s1">rmt </span><span class="s3">in </span><span class="s1">not_target:</span>
                    <span class="s1">util.warn(</span>
                        <span class="s4">&quot;Expression %s is marked as 'remote', but these &quot;</span>
                        <span class="s4">&quot;column(s) are local to the local side.  The &quot;</span>
                        <span class="s4">&quot;remote() annotation is needed only for a &quot;</span>
                        <span class="s4">&quot;self-referential relationship where both sides &quot;</span>
                        <span class="s4">&quot;of the relationship refer to the same tables.&quot;</span>
                        <span class="s1">% (rmt</span><span class="s5">,</span><span class="s1">)</span>
                    <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_check_foreign_cols(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">join_condition: ColumnElement[bool]</span><span class="s5">, </span><span class="s1">primary: bool</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Check the foreign key columns collected and emit error 
        messages.&quot;&quot;&quot;</span>

        <span class="s1">can_sync = </span><span class="s3">False</span>

        <span class="s1">foreign_cols = self._gather_columns_with_annotation(</span>
            <span class="s1">join_condition</span><span class="s5">, </span><span class="s4">&quot;foreign&quot;</span>
        <span class="s1">)</span>

        <span class="s1">has_foreign = bool(foreign_cols)</span>

        <span class="s3">if </span><span class="s1">primary:</span>
            <span class="s1">can_sync = bool(self.synchronize_pairs)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">can_sync = bool(self.secondary_synchronize_pairs)</span>

        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">self.support_sync</span>
            <span class="s3">and </span><span class="s1">can_sync</span>
            <span class="s3">or </span><span class="s1">(</span><span class="s3">not </span><span class="s1">self.support_sync </span><span class="s3">and </span><span class="s1">has_foreign)</span>
        <span class="s1">):</span>
            <span class="s3">return</span>

        <span class="s0"># from here below is just determining the best error message</span>
        <span class="s0"># to report.  Check for a join condition using any operator</span>
        <span class="s0"># (not just ==), perhaps they need to turn on &quot;viewonly=True&quot;.</span>
        <span class="s3">if </span><span class="s1">self.support_sync </span><span class="s3">and </span><span class="s1">has_foreign </span><span class="s3">and not </span><span class="s1">can_sync:</span>
            <span class="s1">err = (</span>
                <span class="s4">&quot;Could not locate any simple equality expressions &quot;</span>
                <span class="s4">&quot;involving locally mapped foreign key columns for &quot;</span>
                <span class="s4">&quot;%s join condition &quot;</span>
                <span class="s4">&quot;'%s' on relationship %s.&quot;</span>
                <span class="s1">% (</span>
                    <span class="s1">primary </span><span class="s3">and </span><span class="s4">&quot;primary&quot; </span><span class="s3">or </span><span class="s4">&quot;secondary&quot;</span><span class="s5">,</span>
                    <span class="s1">join_condition</span><span class="s5">,</span>
                    <span class="s1">self.prop</span><span class="s5">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s1">err += (</span>
                <span class="s4">&quot;  Ensure that referencing columns are associated &quot;</span>
                <span class="s4">&quot;with a ForeignKey or ForeignKeyConstraint, or are &quot;</span>
                <span class="s4">&quot;annotated in the join condition with the foreign() &quot;</span>
                <span class="s4">&quot;annotation. To allow comparison operators other than &quot;</span>
                <span class="s4">&quot;'==', the relationship can be marked as viewonly=True.&quot;</span>
            <span class="s1">)</span>

            <span class="s3">raise </span><span class="s1">sa_exc.ArgumentError(err)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">err = (</span>
                <span class="s4">&quot;Could not locate any relevant foreign key columns &quot;</span>
                <span class="s4">&quot;for %s join condition '%s' on relationship %s.&quot;</span>
                <span class="s1">% (</span>
                    <span class="s1">primary </span><span class="s3">and </span><span class="s4">&quot;primary&quot; </span><span class="s3">or </span><span class="s4">&quot;secondary&quot;</span><span class="s5">,</span>
                    <span class="s1">join_condition</span><span class="s5">,</span>
                    <span class="s1">self.prop</span><span class="s5">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s1">err += (</span>
                <span class="s4">&quot;  Ensure that referencing columns are associated &quot;</span>
                <span class="s4">&quot;with a ForeignKey or ForeignKeyConstraint, or are &quot;</span>
                <span class="s4">&quot;annotated in the join condition with the foreign() &quot;</span>
                <span class="s4">&quot;annotation.&quot;</span>
            <span class="s1">)</span>
            <span class="s3">raise </span><span class="s1">sa_exc.ArgumentError(err)</span>

    <span class="s3">def </span><span class="s1">_determine_direction(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Determine if this relationship is one to many, many to one, 
        many to many. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.secondaryjoin </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.direction = MANYTOMANY</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">parentcols = util.column_set(self.parent_persist_selectable.c)</span>
            <span class="s1">targetcols = util.column_set(self.child_persist_selectable.c)</span>

            <span class="s0"># fk collection which suggests ONETOMANY.</span>
            <span class="s1">onetomany_fk = targetcols.intersection(self.foreign_key_columns)</span>

            <span class="s0"># fk collection which suggests MANYTOONE.</span>

            <span class="s1">manytoone_fk = parentcols.intersection(self.foreign_key_columns)</span>

            <span class="s3">if </span><span class="s1">onetomany_fk </span><span class="s3">and </span><span class="s1">manytoone_fk:</span>
                <span class="s0"># fks on both sides.  test for overlap of local/remote</span>
                <span class="s0"># with foreign key.</span>
                <span class="s0"># we will gather columns directly from their annotations</span>
                <span class="s0"># without deannotating, so that we can distinguish on a column</span>
                <span class="s0"># that refers to itself.</span>

                <span class="s0"># 1. columns that are both remote and FK suggest</span>
                <span class="s0"># onetomany.</span>
                <span class="s1">onetomany_local = self._gather_columns_with_annotation(</span>
                    <span class="s1">self.primaryjoin</span><span class="s5">, </span><span class="s4">&quot;remote&quot;</span><span class="s5">, </span><span class="s4">&quot;foreign&quot;</span>
                <span class="s1">)</span>

                <span class="s0"># 2. columns that are FK but are not remote (e.g. local)</span>
                <span class="s0"># suggest manytoone.</span>
                <span class="s1">manytoone_local = {</span>
                    <span class="s1">c</span>
                    <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">self._gather_columns_with_annotation(</span>
                        <span class="s1">self.primaryjoin</span><span class="s5">, </span><span class="s4">&quot;foreign&quot;</span>
                    <span class="s1">)</span>
                    <span class="s3">if </span><span class="s4">&quot;remote&quot; </span><span class="s3">not in </span><span class="s1">c._annotations</span>
                <span class="s1">}</span>

                <span class="s0"># 3. if both collections are present, remove columns that</span>
                <span class="s0"># refer to themselves.  This is for the case of</span>
                <span class="s0"># and_(Me.id == Me.remote_id, Me.version == Me.version)</span>
                <span class="s3">if </span><span class="s1">onetomany_local </span><span class="s3">and </span><span class="s1">manytoone_local:</span>
                    <span class="s1">self_equated = self.remote_columns.intersection(</span>
                        <span class="s1">self.local_columns</span>
                    <span class="s1">)</span>
                    <span class="s1">onetomany_local = onetomany_local.difference(self_equated)</span>
                    <span class="s1">manytoone_local = manytoone_local.difference(self_equated)</span>

                <span class="s0"># at this point, if only one or the other collection is</span>
                <span class="s0"># present, we know the direction, otherwise it's still</span>
                <span class="s0"># ambiguous.</span>

                <span class="s3">if </span><span class="s1">onetomany_local </span><span class="s3">and not </span><span class="s1">manytoone_local:</span>
                    <span class="s1">self.direction = ONETOMANY</span>
                <span class="s3">elif </span><span class="s1">manytoone_local </span><span class="s3">and not </span><span class="s1">onetomany_local:</span>
                    <span class="s1">self.direction = MANYTOONE</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">raise </span><span class="s1">sa_exc.ArgumentError(</span>
                        <span class="s4">&quot;Can't determine relationship&quot;</span>
                        <span class="s4">&quot; direction for relationship '%s' - foreign &quot;</span>
                        <span class="s4">&quot;key columns within the join condition are present &quot;</span>
                        <span class="s4">&quot;in both the parent and the child's mapped tables.  &quot;</span>
                        <span class="s4">&quot;Ensure that only those columns referring &quot;</span>
                        <span class="s4">&quot;to a parent column are marked as foreign, &quot;</span>
                        <span class="s4">&quot;either via the foreign() annotation or &quot;</span>
                        <span class="s4">&quot;via the foreign_keys argument.&quot; </span><span class="s1">% self.prop</span>
                    <span class="s1">)</span>
            <span class="s3">elif </span><span class="s1">onetomany_fk:</span>
                <span class="s1">self.direction = ONETOMANY</span>
            <span class="s3">elif </span><span class="s1">manytoone_fk:</span>
                <span class="s1">self.direction = MANYTOONE</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">sa_exc.ArgumentError(</span>
                    <span class="s4">&quot;Can't determine relationship &quot;</span>
                    <span class="s4">&quot;direction for relationship '%s' - foreign &quot;</span>
                    <span class="s4">&quot;key columns are present in neither the parent &quot;</span>
                    <span class="s4">&quot;nor the child's mapped tables&quot; </span><span class="s1">% self.prop</span>
                <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_deannotate_pairs(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">collection: _ColumnPairIterable</span>
    <span class="s1">) -&gt; _MutableColumnPairs:</span>
        <span class="s2">&quot;&quot;&quot;provide deannotation for the various lists of 
        pairs, so that using them in hashes doesn't incur 
        high-overhead __eq__() comparisons against 
        original columns mapped. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">[(x._deannotate()</span><span class="s5">, </span><span class="s1">y._deannotate()) </span><span class="s3">for </span><span class="s1">x</span><span class="s5">, </span><span class="s1">y </span><span class="s3">in </span><span class="s1">collection]</span>

    <span class="s3">def </span><span class="s1">_setup_pairs(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">sync_pairs: _MutableColumnPairs = []</span>
        <span class="s1">lrp: util.OrderedSet[Tuple[ColumnElement[Any]</span><span class="s5">, </span><span class="s1">ColumnElement[Any]]] = (</span>
            <span class="s1">util.OrderedSet([])</span>
        <span class="s1">)</span>
        <span class="s1">secondary_sync_pairs: _MutableColumnPairs = []</span>

        <span class="s3">def </span><span class="s1">go(</span>
            <span class="s1">joincond: ColumnElement[bool]</span><span class="s5">,</span>
            <span class="s1">collection: _MutableColumnPairs</span><span class="s5">,</span>
        <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
            <span class="s3">def </span><span class="s1">visit_binary(</span>
                <span class="s1">binary: BinaryExpression[Any]</span><span class="s5">,</span>
                <span class="s1">left: ColumnElement[Any]</span><span class="s5">,</span>
                <span class="s1">right: ColumnElement[Any]</span><span class="s5">,</span>
            <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">(</span>
                    <span class="s4">&quot;remote&quot; </span><span class="s3">in </span><span class="s1">right._annotations</span>
                    <span class="s3">and </span><span class="s4">&quot;remote&quot; </span><span class="s3">not in </span><span class="s1">left._annotations</span>
                    <span class="s3">and </span><span class="s1">self.can_be_synced_fn(left)</span>
                <span class="s1">):</span>
                    <span class="s1">lrp.add((left</span><span class="s5">, </span><span class="s1">right))</span>
                <span class="s3">elif </span><span class="s1">(</span>
                    <span class="s4">&quot;remote&quot; </span><span class="s3">in </span><span class="s1">left._annotations</span>
                    <span class="s3">and </span><span class="s4">&quot;remote&quot; </span><span class="s3">not in </span><span class="s1">right._annotations</span>
                    <span class="s3">and </span><span class="s1">self.can_be_synced_fn(right)</span>
                <span class="s1">):</span>
                    <span class="s1">lrp.add((right</span><span class="s5">, </span><span class="s1">left))</span>
                <span class="s3">if </span><span class="s1">binary.operator </span><span class="s3">is </span><span class="s1">operators.eq </span><span class="s3">and </span><span class="s1">self.can_be_synced_fn(</span>
                    <span class="s1">left</span><span class="s5">, </span><span class="s1">right</span>
                <span class="s1">):</span>
                    <span class="s3">if </span><span class="s4">&quot;foreign&quot; </span><span class="s3">in </span><span class="s1">right._annotations:</span>
                        <span class="s1">collection.append((left</span><span class="s5">, </span><span class="s1">right))</span>
                    <span class="s3">elif </span><span class="s4">&quot;foreign&quot; </span><span class="s3">in </span><span class="s1">left._annotations:</span>
                        <span class="s1">collection.append((right</span><span class="s5">, </span><span class="s1">left))</span>

            <span class="s1">visit_binary_product(visit_binary</span><span class="s5">, </span><span class="s1">joincond)</span>

        <span class="s3">for </span><span class="s1">joincond</span><span class="s5">, </span><span class="s1">collection </span><span class="s3">in </span><span class="s1">[</span>
            <span class="s1">(self.primaryjoin</span><span class="s5">, </span><span class="s1">sync_pairs)</span><span class="s5">,</span>
            <span class="s1">(self.secondaryjoin</span><span class="s5">, </span><span class="s1">secondary_sync_pairs)</span><span class="s5">,</span>
        <span class="s1">]:</span>
            <span class="s3">if </span><span class="s1">joincond </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">continue</span>
            <span class="s1">go(joincond</span><span class="s5">, </span><span class="s1">collection)</span>

        <span class="s1">self.local_remote_pairs = self._deannotate_pairs(lrp)</span>
        <span class="s1">self.synchronize_pairs = self._deannotate_pairs(sync_pairs)</span>
        <span class="s1">self.secondary_synchronize_pairs = self._deannotate_pairs(</span>
            <span class="s1">secondary_sync_pairs</span>
        <span class="s1">)</span>

    <span class="s1">_track_overlapping_sync_targets: weakref.WeakKeyDictionary[</span>
        <span class="s1">ColumnElement[Any]</span><span class="s5">,</span>
        <span class="s1">weakref.WeakKeyDictionary[</span>
            <span class="s1">RelationshipProperty[Any]</span><span class="s5">, </span><span class="s1">ColumnElement[Any]</span>
        <span class="s1">]</span><span class="s5">,</span>
    <span class="s1">] = weakref.WeakKeyDictionary()</span>

    <span class="s3">def </span><span class="s1">_warn_for_conflicting_sync_targets(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">if not </span><span class="s1">self.support_sync:</span>
            <span class="s3">return</span>

        <span class="s0"># we would like to detect if we are synchronizing any column</span>
        <span class="s0"># pairs in conflict with another relationship that wishes to sync</span>
        <span class="s0"># an entirely different column to the same target.   This is a</span>
        <span class="s0"># very rare edge case so we will try to minimize the memory/overhead</span>
        <span class="s0"># impact of this check</span>
        <span class="s3">for </span><span class="s1">from_</span><span class="s5">, </span><span class="s1">to_ </span><span class="s3">in </span><span class="s1">[</span>
            <span class="s1">(from_</span><span class="s5">, </span><span class="s1">to_) </span><span class="s3">for </span><span class="s1">(from_</span><span class="s5">, </span><span class="s1">to_) </span><span class="s3">in </span><span class="s1">self.synchronize_pairs</span>
        <span class="s1">] + [</span>
            <span class="s1">(from_</span><span class="s5">, </span><span class="s1">to_) </span><span class="s3">for </span><span class="s1">(from_</span><span class="s5">, </span><span class="s1">to_) </span><span class="s3">in </span><span class="s1">self.secondary_synchronize_pairs</span>
        <span class="s1">]:</span>
            <span class="s0"># save ourselves a ton of memory and overhead by only</span>
            <span class="s0"># considering columns that are subject to a overlapping</span>
            <span class="s0"># FK constraints at the core level.   This condition can arise</span>
            <span class="s0"># if multiple relationships overlap foreign() directly, but</span>
            <span class="s0"># we're going to assume it's typically a ForeignKeyConstraint-</span>
            <span class="s0"># level configuration that benefits from this warning.</span>

            <span class="s3">if </span><span class="s1">to_ </span><span class="s3">not in </span><span class="s1">self._track_overlapping_sync_targets:</span>
                <span class="s1">self._track_overlapping_sync_targets[to_] = (</span>
                    <span class="s1">weakref.WeakKeyDictionary({self.prop: from_})</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">other_props = []</span>
                <span class="s1">prop_to_from = self._track_overlapping_sync_targets[to_]</span>

                <span class="s3">for </span><span class="s1">pr</span><span class="s5">, </span><span class="s1">fr_ </span><span class="s3">in </span><span class="s1">prop_to_from.items():</span>
                    <span class="s3">if </span><span class="s1">(</span>
                        <span class="s3">not </span><span class="s1">pr.mapper._dispose_called</span>
                        <span class="s3">and </span><span class="s1">pr </span><span class="s3">not in </span><span class="s1">self.prop._reverse_property</span>
                        <span class="s3">and </span><span class="s1">pr.key </span><span class="s3">not in </span><span class="s1">self.prop._overlaps</span>
                        <span class="s3">and </span><span class="s1">self.prop.key </span><span class="s3">not in </span><span class="s1">pr._overlaps</span>
                        <span class="s0"># note: the &quot;__*&quot; symbol is used internally by</span>
                        <span class="s0"># SQLAlchemy as a general means of suppressing the</span>
                        <span class="s0"># overlaps warning for some extension cases, however</span>
                        <span class="s0"># this is not currently</span>
                        <span class="s0"># a publicly supported symbol and may change at</span>
                        <span class="s0"># any time.</span>
                        <span class="s3">and </span><span class="s4">&quot;__*&quot; </span><span class="s3">not in </span><span class="s1">self.prop._overlaps</span>
                        <span class="s3">and </span><span class="s4">&quot;__*&quot; </span><span class="s3">not in </span><span class="s1">pr._overlaps</span>
                        <span class="s3">and not </span><span class="s1">self.prop.parent.is_sibling(pr.parent)</span>
                        <span class="s3">and not </span><span class="s1">self.prop.mapper.is_sibling(pr.mapper)</span>
                        <span class="s3">and not </span><span class="s1">self.prop.parent.is_sibling(pr.mapper)</span>
                        <span class="s3">and not </span><span class="s1">self.prop.mapper.is_sibling(pr.parent)</span>
                        <span class="s3">and </span><span class="s1">(</span>
                            <span class="s1">self.prop.key != pr.key</span>
                            <span class="s3">or not </span><span class="s1">self.prop.parent.common_parent(pr.parent)</span>
                        <span class="s1">)</span>
                    <span class="s1">):</span>
                        <span class="s1">other_props.append((pr</span><span class="s5">, </span><span class="s1">fr_))</span>

                <span class="s3">if </span><span class="s1">other_props:</span>
                    <span class="s1">util.warn(</span>
                        <span class="s4">&quot;relationship '%s' will copy column %s to column %s, &quot;</span>
                        <span class="s4">&quot;which conflicts with relationship(s): %s. &quot;</span>
                        <span class="s4">&quot;If this is not the intention, consider if these &quot;</span>
                        <span class="s4">&quot;relationships should be linked with &quot;</span>
                        <span class="s4">&quot;back_populates, or if viewonly=True should be &quot;</span>
                        <span class="s4">&quot;applied to one or more if they are read-only. &quot;</span>
                        <span class="s4">&quot;For the less common case that foreign key &quot;</span>
                        <span class="s4">&quot;constraints are partially overlapping, the &quot;</span>
                        <span class="s4">&quot;orm.foreign() &quot;</span>
                        <span class="s4">&quot;annotation can be used to isolate the columns that &quot;</span>
                        <span class="s4">&quot;should be written towards.   To silence this &quot;</span>
                        <span class="s4">&quot;warning, add the parameter 'overlaps=</span><span class="s7">\&quot;</span><span class="s4">%s</span><span class="s7">\&quot;</span><span class="s4">' to the &quot;</span>
                        <span class="s4">&quot;'%s' relationship.&quot;</span>
                        <span class="s1">% (</span>
                            <span class="s1">self.prop</span><span class="s5">,</span>
                            <span class="s1">from_</span><span class="s5">,</span>
                            <span class="s1">to_</span><span class="s5">,</span>
                            <span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
                                <span class="s1">sorted(</span>
                                    <span class="s4">&quot;'%s' (copies %s to %s)&quot; </span><span class="s1">% (pr</span><span class="s5">, </span><span class="s1">fr_</span><span class="s5">, </span><span class="s1">to_)</span>
                                    <span class="s3">for </span><span class="s1">(pr</span><span class="s5">, </span><span class="s1">fr_) </span><span class="s3">in </span><span class="s1">other_props</span>
                                <span class="s1">)</span>
                            <span class="s1">)</span><span class="s5">,</span>
                            <span class="s4">&quot;,&quot;</span><span class="s1">.join(sorted(pr.key </span><span class="s3">for </span><span class="s1">pr</span><span class="s5">, </span><span class="s1">fr </span><span class="s3">in </span><span class="s1">other_props))</span><span class="s5">,</span>
                            <span class="s1">self.prop</span><span class="s5">,</span>
                        <span class="s1">)</span><span class="s5">,</span>
                        <span class="s1">code=</span><span class="s4">&quot;qzyx&quot;</span><span class="s5">,</span>
                    <span class="s1">)</span>
                <span class="s1">self._track_overlapping_sync_targets[to_][self.prop] = from_</span>

    <span class="s1">@util.memoized_property</span>
    <span class="s3">def </span><span class="s1">remote_columns(self) -&gt; Set[ColumnElement[Any]]:</span>
        <span class="s3">return </span><span class="s1">self._gather_join_annotations(</span><span class="s4">&quot;remote&quot;</span><span class="s1">)</span>

    <span class="s1">@util.memoized_property</span>
    <span class="s3">def </span><span class="s1">local_columns(self) -&gt; Set[ColumnElement[Any]]:</span>
        <span class="s3">return </span><span class="s1">self._gather_join_annotations(</span><span class="s4">&quot;local&quot;</span><span class="s1">)</span>

    <span class="s1">@util.memoized_property</span>
    <span class="s3">def </span><span class="s1">foreign_key_columns(self) -&gt; Set[ColumnElement[Any]]:</span>
        <span class="s3">return </span><span class="s1">self._gather_join_annotations(</span><span class="s4">&quot;foreign&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_gather_join_annotations(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">annotation: str</span>
    <span class="s1">) -&gt; Set[ColumnElement[Any]]:</span>
        <span class="s1">s = set(</span>
            <span class="s1">self._gather_columns_with_annotation(self.primaryjoin</span><span class="s5">, </span><span class="s1">annotation)</span>
        <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">self.secondaryjoin </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">s.update(</span>
                <span class="s1">self._gather_columns_with_annotation(</span>
                    <span class="s1">self.secondaryjoin</span><span class="s5">, </span><span class="s1">annotation</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">{x._deannotate() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">s}</span>

    <span class="s3">def </span><span class="s1">_gather_columns_with_annotation(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">clause: ColumnElement[Any]</span><span class="s5">, </span><span class="s1">*annotation: Iterable[str]</span>
    <span class="s1">) -&gt; Set[ColumnElement[Any]]:</span>
        <span class="s1">annotation_set = set(annotation)</span>
        <span class="s3">return </span><span class="s1">{</span>
            <span class="s1">cast(ColumnElement[Any]</span><span class="s5">, </span><span class="s1">col)</span>
            <span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">visitors.iterate(clause</span><span class="s5">, </span><span class="s1">{})</span>
            <span class="s3">if </span><span class="s1">annotation_set.issubset(col._annotations)</span>
        <span class="s1">}</span>

    <span class="s1">@util.memoized_property</span>
    <span class="s3">def </span><span class="s1">_secondary_lineage_set(self) -&gt; FrozenSet[ColumnElement[Any]]:</span>
        <span class="s3">if </span><span class="s1">self.secondary </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">frozenset(</span>
                <span class="s1">itertools.chain(*[c.proxy_set </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">self.secondary.c])</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">util.EMPTY_SET</span>

    <span class="s3">def </span><span class="s1">join_targets(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">source_selectable: Optional[FromClause]</span><span class="s5">,</span>
        <span class="s1">dest_selectable: FromClause</span><span class="s5">,</span>
        <span class="s1">aliased: bool</span><span class="s5">,</span>
        <span class="s1">single_crit: Optional[ColumnElement[bool]] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">extra_criteria: Tuple[ColumnElement[bool]</span><span class="s5">, </span><span class="s1">...] = ()</span><span class="s5">,</span>
    <span class="s1">) -&gt; Tuple[</span>
        <span class="s1">ColumnElement[bool]</span><span class="s5">,</span>
        <span class="s1">Optional[ColumnElement[bool]]</span><span class="s5">,</span>
        <span class="s1">Optional[FromClause]</span><span class="s5">,</span>
        <span class="s1">Optional[ClauseAdapter]</span><span class="s5">,</span>
        <span class="s1">FromClause</span><span class="s5">,</span>
    <span class="s1">]:</span>
        <span class="s2">&quot;&quot;&quot;Given a source and destination selectable, create a 
        join between them. 
 
        This takes into account aliasing the join clause 
        to reference the appropriate corresponding columns 
        in the target objects, as well as the extra child 
        criterion, equivalent column sets, etc. 
 
        &quot;&quot;&quot;</span>
        <span class="s0"># place a barrier on the destination such that</span>
        <span class="s0"># replacement traversals won't ever dig into it.</span>
        <span class="s0"># its internal structure remains fixed</span>
        <span class="s0"># regardless of context.</span>
        <span class="s1">dest_selectable = _shallow_annotate(</span>
            <span class="s1">dest_selectable</span><span class="s5">, </span><span class="s1">{</span><span class="s4">&quot;no_replacement_traverse&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">}</span>
        <span class="s1">)</span>

        <span class="s1">primaryjoin</span><span class="s5">, </span><span class="s1">secondaryjoin</span><span class="s5">, </span><span class="s1">secondary = (</span>
            <span class="s1">self.primaryjoin</span><span class="s5">,</span>
            <span class="s1">self.secondaryjoin</span><span class="s5">,</span>
            <span class="s1">self.secondary</span><span class="s5">,</span>
        <span class="s1">)</span>

        <span class="s0"># adjust the join condition for single table inheritance,</span>
        <span class="s0"># in the case that the join is to a subclass</span>
        <span class="s0"># this is analogous to the</span>
        <span class="s0"># &quot;_adjust_for_single_table_inheritance()&quot; method in Query.</span>

        <span class="s3">if </span><span class="s1">single_crit </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">secondaryjoin </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">secondaryjoin = secondaryjoin &amp; single_crit</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">primaryjoin = primaryjoin &amp; single_crit</span>

        <span class="s3">if </span><span class="s1">extra_criteria:</span>

            <span class="s3">def </span><span class="s1">mark_exclude_cols(</span>
                <span class="s1">elem: SupportsAnnotations</span><span class="s5">, </span><span class="s1">annotations: _AnnotationDict</span>
            <span class="s1">) -&gt; SupportsAnnotations:</span>
                <span class="s2">&quot;&quot;&quot;note unrelated columns in the &quot;extra criteria&quot; as either 
                should be adapted or not adapted, even though they are not 
                part of our &quot;local&quot; or &quot;remote&quot; side. 
 
                see #9779 for this case, as well as #11010 for a follow up 
 
                &quot;&quot;&quot;</span>

                <span class="s1">parentmapper_for_element = elem._annotations.get(</span>
                    <span class="s4">&quot;parentmapper&quot;</span><span class="s5">, </span><span class="s3">None</span>
                <span class="s1">)</span>

                <span class="s3">if </span><span class="s1">(</span>
                    <span class="s1">parentmapper_for_element </span><span class="s3">is not </span><span class="s1">self.prop.parent</span>
                    <span class="s3">and </span><span class="s1">parentmapper_for_element </span><span class="s3">is not </span><span class="s1">self.prop.mapper</span>
                    <span class="s3">and </span><span class="s1">elem </span><span class="s3">not in </span><span class="s1">self._secondary_lineage_set</span>
                <span class="s1">):</span>
                    <span class="s3">return </span><span class="s1">_safe_annotate(elem</span><span class="s5">, </span><span class="s1">annotations)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s1">elem</span>

            <span class="s1">extra_criteria = tuple(</span>
                <span class="s1">_deep_annotate(</span>
                    <span class="s1">elem</span><span class="s5">,</span>
                    <span class="s1">{</span><span class="s4">&quot;should_not_adapt&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">}</span><span class="s5">,</span>
                    <span class="s1">annotate_callable=mark_exclude_cols</span><span class="s5">,</span>
                <span class="s1">)</span>
                <span class="s3">for </span><span class="s1">elem </span><span class="s3">in </span><span class="s1">extra_criteria</span>
            <span class="s1">)</span>

            <span class="s3">if </span><span class="s1">secondaryjoin </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">secondaryjoin = secondaryjoin &amp; sql.and_(*extra_criteria)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">primaryjoin = primaryjoin &amp; sql.and_(*extra_criteria)</span>

        <span class="s3">if </span><span class="s1">aliased:</span>
            <span class="s3">if </span><span class="s1">secondary </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">secondary = secondary._anonymous_fromclause(flat=</span><span class="s3">True</span><span class="s1">)</span>
                <span class="s1">primary_aliasizer = ClauseAdapter(</span>
                    <span class="s1">secondary</span><span class="s5">,</span>
                    <span class="s1">exclude_fn=_local_col_exclude</span><span class="s5">,</span>
                <span class="s1">)</span>
                <span class="s1">secondary_aliasizer = ClauseAdapter(</span>
                    <span class="s1">dest_selectable</span><span class="s5">, </span><span class="s1">equivalents=self.child_equivalents</span>
                <span class="s1">).chain(primary_aliasizer)</span>
                <span class="s3">if </span><span class="s1">source_selectable </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">primary_aliasizer = ClauseAdapter(</span>
                        <span class="s1">secondary</span><span class="s5">,</span>
                        <span class="s1">exclude_fn=_local_col_exclude</span><span class="s5">,</span>
                    <span class="s1">).chain(</span>
                        <span class="s1">ClauseAdapter(</span>
                            <span class="s1">source_selectable</span><span class="s5">,</span>
                            <span class="s1">equivalents=self.parent_equivalents</span><span class="s5">,</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>

                <span class="s1">secondaryjoin = secondary_aliasizer.traverse(secondaryjoin)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">primary_aliasizer = ClauseAdapter(</span>
                    <span class="s1">dest_selectable</span><span class="s5">,</span>
                    <span class="s1">exclude_fn=_local_col_exclude</span><span class="s5">,</span>
                    <span class="s1">equivalents=self.child_equivalents</span><span class="s5">,</span>
                <span class="s1">)</span>
                <span class="s3">if </span><span class="s1">source_selectable </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">primary_aliasizer.chain(</span>
                        <span class="s1">ClauseAdapter(</span>
                            <span class="s1">source_selectable</span><span class="s5">,</span>
                            <span class="s1">exclude_fn=_remote_col_exclude</span><span class="s5">,</span>
                            <span class="s1">equivalents=self.parent_equivalents</span><span class="s5">,</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>
                <span class="s1">secondary_aliasizer = </span><span class="s3">None</span>

            <span class="s1">primaryjoin = primary_aliasizer.traverse(primaryjoin)</span>
            <span class="s1">target_adapter = secondary_aliasizer </span><span class="s3">or </span><span class="s1">primary_aliasizer</span>
            <span class="s1">target_adapter.exclude_fn = </span><span class="s3">None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">target_adapter = </span><span class="s3">None</span>
        <span class="s3">return </span><span class="s1">(</span>
            <span class="s1">primaryjoin</span><span class="s5">,</span>
            <span class="s1">secondaryjoin</span><span class="s5">,</span>
            <span class="s1">secondary</span><span class="s5">,</span>
            <span class="s1">target_adapter</span><span class="s5">,</span>
            <span class="s1">dest_selectable</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">create_lazy_clause(self</span><span class="s5">, </span><span class="s1">reverse_direction: bool = </span><span class="s3">False</span><span class="s1">) -&gt; Tuple[</span>
        <span class="s1">ColumnElement[bool]</span><span class="s5">,</span>
        <span class="s1">Dict[str</span><span class="s5">, </span><span class="s1">ColumnElement[Any]]</span><span class="s5">,</span>
        <span class="s1">Dict[ColumnElement[Any]</span><span class="s5">, </span><span class="s1">ColumnElement[Any]]</span><span class="s5">,</span>
    <span class="s1">]:</span>
        <span class="s1">binds: Dict[ColumnElement[Any]</span><span class="s5">, </span><span class="s1">BindParameter[Any]] = {}</span>
        <span class="s1">equated_columns: Dict[ColumnElement[Any]</span><span class="s5">, </span><span class="s1">ColumnElement[Any]] = {}</span>

        <span class="s1">has_secondary = self.secondaryjoin </span><span class="s3">is not None</span>

        <span class="s3">if </span><span class="s1">has_secondary:</span>
            <span class="s1">lookup = collections.defaultdict(list)</span>
            <span class="s3">for </span><span class="s1">l</span><span class="s5">, </span><span class="s1">r </span><span class="s3">in </span><span class="s1">self.local_remote_pairs:</span>
                <span class="s1">lookup[l].append((l</span><span class="s5">, </span><span class="s1">r))</span>
                <span class="s1">equated_columns[r] = l</span>
        <span class="s3">elif not </span><span class="s1">reverse_direction:</span>
            <span class="s3">for </span><span class="s1">l</span><span class="s5">, </span><span class="s1">r </span><span class="s3">in </span><span class="s1">self.local_remote_pairs:</span>
                <span class="s1">equated_columns[r] = l</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">for </span><span class="s1">l</span><span class="s5">, </span><span class="s1">r </span><span class="s3">in </span><span class="s1">self.local_remote_pairs:</span>
                <span class="s1">equated_columns[l] = r</span>

        <span class="s3">def </span><span class="s1">col_to_bind(</span>
            <span class="s1">element: ColumnElement[Any]</span><span class="s5">, </span><span class="s1">**kw: Any</span>
        <span class="s1">) -&gt; Optional[BindParameter[Any]]:</span>
            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">(</span><span class="s3">not </span><span class="s1">reverse_direction </span><span class="s3">and </span><span class="s4">&quot;local&quot; </span><span class="s3">in </span><span class="s1">element._annotations)</span>
                <span class="s3">or </span><span class="s1">reverse_direction</span>
                <span class="s3">and </span><span class="s1">(</span>
                    <span class="s1">(has_secondary </span><span class="s3">and </span><span class="s1">element </span><span class="s3">in </span><span class="s1">lookup)</span>
                    <span class="s3">or </span><span class="s1">(</span><span class="s3">not </span><span class="s1">has_secondary </span><span class="s3">and </span><span class="s4">&quot;remote&quot; </span><span class="s3">in </span><span class="s1">element._annotations)</span>
                <span class="s1">)</span>
            <span class="s1">):</span>
                <span class="s3">if </span><span class="s1">element </span><span class="s3">not in </span><span class="s1">binds:</span>
                    <span class="s1">binds[element] = sql.bindparam(</span>
                        <span class="s3">None</span><span class="s5">, </span><span class="s3">None</span><span class="s5">, </span><span class="s1">type_=element.type</span><span class="s5">, </span><span class="s1">unique=</span><span class="s3">True</span>
                    <span class="s1">)</span>
                <span class="s3">return </span><span class="s1">binds[element]</span>
            <span class="s3">return None</span>

        <span class="s1">lazywhere = self.primaryjoin</span>
        <span class="s3">if </span><span class="s1">self.secondaryjoin </span><span class="s3">is None or not </span><span class="s1">reverse_direction:</span>
            <span class="s1">lazywhere = visitors.replacement_traverse(</span>
                <span class="s1">lazywhere</span><span class="s5">, </span><span class="s1">{}</span><span class="s5">, </span><span class="s1">col_to_bind</span>
            <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">self.secondaryjoin </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">secondaryjoin = self.secondaryjoin</span>
            <span class="s3">if </span><span class="s1">reverse_direction:</span>
                <span class="s1">secondaryjoin = visitors.replacement_traverse(</span>
                    <span class="s1">secondaryjoin</span><span class="s5">, </span><span class="s1">{}</span><span class="s5">, </span><span class="s1">col_to_bind</span>
                <span class="s1">)</span>
            <span class="s1">lazywhere = sql.and_(lazywhere</span><span class="s5">, </span><span class="s1">secondaryjoin)</span>

        <span class="s1">bind_to_col = {binds[col].key: col </span><span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">binds}</span>

        <span class="s3">return </span><span class="s1">lazywhere</span><span class="s5">, </span><span class="s1">bind_to_col</span><span class="s5">, </span><span class="s1">equated_columns</span>


<span class="s3">class </span><span class="s1">_ColInAnnotations:</span>
    <span class="s2">&quot;&quot;&quot;Serializable object that tests for names in c._annotations. 
 
    TODO: does this need to be serializable anymore?  can we find what the 
    use case was for that? 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = (</span><span class="s4">&quot;names&quot;</span><span class="s5">,</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s5">, </span><span class="s1">*names: str):</span>
        <span class="s1">self.names = frozenset(names)</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s5">, </span><span class="s1">c: ClauseElement) -&gt; bool:</span>
        <span class="s3">return </span><span class="s1">bool(self.names.intersection(c._annotations))</span>


<span class="s1">_local_col_exclude = _ColInAnnotations(</span><span class="s4">&quot;local&quot;</span><span class="s5">, </span><span class="s4">&quot;should_not_adapt&quot;</span><span class="s1">)</span>
<span class="s1">_remote_col_exclude = _ColInAnnotations(</span><span class="s4">&quot;remote&quot;</span><span class="s5">, </span><span class="s4">&quot;should_not_adapt&quot;</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">Relationship(</span>
    <span class="s1">RelationshipProperty[_T]</span><span class="s5">,</span>
    <span class="s1">_DeclarativeMapped[_T]</span><span class="s5">,</span>
<span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Describes an object property that holds a single item or list 
    of items that correspond to a related database table. 
 
    Public constructor is the :func:`_orm.relationship` function. 
 
    .. seealso:: 
 
        :ref:`relationship_config_toplevel` 
 
    .. versionchanged:: 2.0 Added :class:`_orm.Relationship` as a Declarative 
       compatible subclass for :class:`_orm.RelationshipProperty`. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">inherit_cache = </span><span class="s3">True</span>
    <span class="s4">&quot;&quot;&quot;:meta private:&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">_RelationshipDeclared(  </span><span class="s0"># type: ignore[misc]</span>
    <span class="s1">Relationship[_T]</span><span class="s5">,</span>
    <span class="s1">WriteOnlyMapped[_T]</span><span class="s5">,  </span><span class="s0"># not compatible with Mapped[_T]</span>
    <span class="s1">DynamicMapped[_T]</span><span class="s5">,  </span><span class="s0"># not compatible with Mapped[_T]</span>
<span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Relationship subclass used implicitly for declarative mapping.&quot;&quot;&quot;</span>

    <span class="s1">inherit_cache = </span><span class="s3">True</span>
    <span class="s4">&quot;&quot;&quot;:meta private:&quot;&quot;&quot;</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_mapper_property_name(cls) -&gt; str:</span>
        <span class="s3">return </span><span class="s4">&quot;Relationship&quot;</span>
</pre>
</body>
</html>