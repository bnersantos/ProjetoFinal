<html>
<head>
<title>url.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5d69bb;}
.s1 { color: #d8d8d8;}
.s2 { color: #717ed3; font-style: italic;}
.s3 { color: #cc8b60;}
.s4 { color: #96bf7d;}
.s5 { color: #cc7832;}
.s6 { color: #d7539b; font-weight: bold;}
.s7 { color: #bbb55b;}
</style>
</head>
<body bgcolor="#1a1a25">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
url.py</font>
</center></td></tr></table>
<pre><span class="s0"># engine/url.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>

<span class="s2">&quot;&quot;&quot;Provides the :class:`~sqlalchemy.engine.url.URL` class which encapsulates 
information about a database connection specification. 
 
The URL object is created automatically when 
:func:`~sqlalchemy.engine.create_engine` is called with a string 
argument; alternatively, the URL is a public-facing construct which can 
be used directly and is also accepted directly by ``create_engine()``. 
&quot;&quot;&quot;</span>

<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">annotations</span>

<span class="s3">import </span><span class="s1">collections.abc </span><span class="s3">as </span><span class="s1">collections_abc</span>
<span class="s3">import </span><span class="s1">re</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">cast</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Dict</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Iterable</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">List</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Mapping</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">NamedTuple</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Optional</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">overload</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Sequence</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Tuple</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Type</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Union</span>
<span class="s3">from </span><span class="s1">urllib.parse </span><span class="s3">import </span><span class="s1">parse_qsl</span>
<span class="s3">from </span><span class="s1">urllib.parse </span><span class="s3">import </span><span class="s1">quote</span>
<span class="s3">from </span><span class="s1">urllib.parse </span><span class="s3">import </span><span class="s1">quote_plus</span>
<span class="s3">from </span><span class="s1">urllib.parse </span><span class="s3">import </span><span class="s1">unquote</span>

<span class="s3">from </span><span class="s1">.interfaces </span><span class="s3">import </span><span class="s1">Dialect</span>
<span class="s3">from </span><span class="s1">.. </span><span class="s3">import </span><span class="s1">exc</span>
<span class="s3">from </span><span class="s1">.. </span><span class="s3">import </span><span class="s1">util</span>
<span class="s3">from </span><span class="s1">..dialects </span><span class="s3">import </span><span class="s1">plugins</span>
<span class="s3">from </span><span class="s1">..dialects </span><span class="s3">import </span><span class="s1">registry</span>


<span class="s3">class </span><span class="s1">URL(NamedTuple):</span>
    <span class="s2">&quot;&quot;&quot; 
    Represent the components of a URL used to connect to a database. 
 
    URLs are typically constructed from a fully formatted URL string, where the 
    :func:`.make_url` function is used internally by the 
    :func:`_sa.create_engine` function in order to parse the URL string into 
    its individual components, which are then used to construct a new 
    :class:`.URL` object. When parsing from a formatted URL string, the parsing 
    format generally follows 
    `RFC-1738 &lt;https://www.ietf.org/rfc/rfc1738.txt&gt;`_, with some exceptions. 
 
    A :class:`_engine.URL` object may also be produced directly, either by 
    using the :func:`.make_url` function with a fully formed URL string, or 
    by using the :meth:`_engine.URL.create` constructor in order 
    to construct a :class:`_engine.URL` programmatically given individual 
    fields. The resulting :class:`.URL` object may be passed directly to 
    :func:`_sa.create_engine` in place of a string argument, which will bypass 
    the usage of :func:`.make_url` within the engine's creation process. 
 
    .. versionchanged:: 1.4 
 
        The :class:`_engine.URL` object is now an immutable object.  To 
        create a URL, use the :func:`_engine.make_url` or 
        :meth:`_engine.URL.create` function / method.  To modify 
        a :class:`_engine.URL`, use methods like 
        :meth:`_engine.URL.set` and 
        :meth:`_engine.URL.update_query_dict` to return a new 
        :class:`_engine.URL` object with modifications.   See notes for this 
        change at :ref:`change_5526`. 
 
    .. seealso:: 
 
        :ref:`database_urls` 
 
    :class:`_engine.URL` contains the following attributes: 
 
    * :attr:`_engine.URL.drivername`: database backend and driver name, such as 
      ``postgresql+psycopg2`` 
    * :attr:`_engine.URL.username`: username string 
    * :attr:`_engine.URL.password`: password string 
    * :attr:`_engine.URL.host`: string hostname 
    * :attr:`_engine.URL.port`: integer port number 
    * :attr:`_engine.URL.database`: string database name 
    * :attr:`_engine.URL.query`: an immutable mapping representing the query 
      string.  contains strings for keys and either strings or tuples of 
      strings for values. 
 
 
    &quot;&quot;&quot;</span>

    <span class="s1">drivername: str</span>
    <span class="s4">&quot;&quot;&quot;database backend and driver name, such as 
    ``postgresql+psycopg2`` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">username: Optional[str]</span>
    <span class="s4">&quot;username string&quot;</span>

    <span class="s1">password: Optional[str]</span>
    <span class="s4">&quot;&quot;&quot;password, which is normally a string but may also be any 
    object that has a ``__str__()`` method.&quot;&quot;&quot;</span>

    <span class="s1">host: Optional[str]</span>
    <span class="s4">&quot;&quot;&quot;hostname or IP number.  May also be a data source name for some 
    drivers.&quot;&quot;&quot;</span>

    <span class="s1">port: Optional[int]</span>
    <span class="s4">&quot;&quot;&quot;integer port number&quot;&quot;&quot;</span>

    <span class="s1">database: Optional[str]</span>
    <span class="s4">&quot;&quot;&quot;database name&quot;&quot;&quot;</span>

    <span class="s1">query: util.immutabledict[str</span><span class="s5">, </span><span class="s1">Union[Tuple[str</span><span class="s5">, </span><span class="s1">...]</span><span class="s5">, </span><span class="s1">str]]</span>
    <span class="s4">&quot;&quot;&quot;an immutable mapping representing the query string.  contains strings 
       for keys and either strings or tuples of strings for values, e.g.:: 
 
            &gt;&gt;&gt; from sqlalchemy.engine import make_url 
            &gt;&gt;&gt; url = make_url(&quot;postgresql+psycopg2://user:pass@host/dbname?alt_host=host1&amp;alt_host=host2&amp;ssl_cipher=%2Fpath%2Fto%2Fcrt&quot;) 
            &gt;&gt;&gt; url.query 
            immutabledict({'alt_host': ('host1', 'host2'), 'ssl_cipher': '/path/to/crt'}) 
 
         To create a mutable copy of this mapping, use the ``dict`` constructor:: 
 
            mutable_query_opts = dict(url.query) 
 
       .. seealso:: 
 
          :attr:`_engine.URL.normalized_query` - normalizes all values into sequences 
          for consistent processing 
 
          Methods for altering the contents of :attr:`_engine.URL.query`: 
 
          :meth:`_engine.URL.update_query_dict` 
 
          :meth:`_engine.URL.update_query_string` 
 
          :meth:`_engine.URL.update_query_pairs` 
 
          :meth:`_engine.URL.difference_update_query` 
 
    &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">create(</span>
        <span class="s1">cls</span><span class="s5">,</span>
        <span class="s1">drivername: str</span><span class="s5">,</span>
        <span class="s1">username: Optional[str] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">password: Optional[str] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">host: Optional[str] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">port: Optional[int] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">database: Optional[str] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">query: Mapping[str</span><span class="s5">, </span><span class="s1">Union[Sequence[str]</span><span class="s5">, </span><span class="s1">str]] = util.EMPTY_DICT</span><span class="s5">,</span>
    <span class="s1">) -&gt; URL:</span>
        <span class="s2">&quot;&quot;&quot;Create a new :class:`_engine.URL` object. 
 
        .. seealso:: 
 
            :ref:`database_urls` 
 
        :param drivername: the name of the database backend. This name will 
          correspond to a module in sqlalchemy/databases or a third party 
          plug-in. 
        :param username: The user name. 
        :param password: database password.  Is typically a string, but may 
          also be an object that can be stringified with ``str()``. 
 
          .. note:: The password string should **not** be URL encoded when 
             passed as an argument to :meth:`_engine.URL.create`; the string 
             should contain the password characters exactly as they would be 
             typed. 
 
          .. note::  A password-producing object will be stringified only 
             **once** per :class:`_engine.Engine` object.  For dynamic password 
             generation per connect, see :ref:`engines_dynamic_tokens`. 
 
        :param host: The name of the host. 
        :param port: The port number. 
        :param database: The database name. 
        :param query: A dictionary of string keys to string values to be passed 
          to the dialect and/or the DBAPI upon connect.   To specify non-string 
          parameters to a Python DBAPI directly, use the 
          :paramref:`_sa.create_engine.connect_args` parameter to 
          :func:`_sa.create_engine`.   See also 
          :attr:`_engine.URL.normalized_query` for a dictionary that is 
          consistently string-&gt;list of string. 
        :return: new :class:`_engine.URL` object. 
 
        .. versionadded:: 1.4 
 
            The :class:`_engine.URL` object is now an **immutable named 
            tuple**.  In addition, the ``query`` dictionary is also immutable. 
            To create a URL, use the :func:`_engine.url.make_url` or 
            :meth:`_engine.URL.create` function/ method.  To modify a 
            :class:`_engine.URL`, use the :meth:`_engine.URL.set` and 
            :meth:`_engine.URL.update_query` methods. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">cls(</span>
            <span class="s1">cls._assert_str(drivername</span><span class="s5">, </span><span class="s4">&quot;drivername&quot;</span><span class="s1">)</span><span class="s5">,</span>
            <span class="s1">cls._assert_none_str(username</span><span class="s5">, </span><span class="s4">&quot;username&quot;</span><span class="s1">)</span><span class="s5">,</span>
            <span class="s1">password</span><span class="s5">,</span>
            <span class="s1">cls._assert_none_str(host</span><span class="s5">, </span><span class="s4">&quot;host&quot;</span><span class="s1">)</span><span class="s5">,</span>
            <span class="s1">cls._assert_port(port)</span><span class="s5">,</span>
            <span class="s1">cls._assert_none_str(database</span><span class="s5">, </span><span class="s4">&quot;database&quot;</span><span class="s1">)</span><span class="s5">,</span>
            <span class="s1">cls._str_dict(query)</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_assert_port(cls</span><span class="s5">, </span><span class="s1">port: Optional[int]) -&gt; Optional[int]:</span>
        <span class="s3">if </span><span class="s1">port </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return None</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">int(port)</span>
        <span class="s3">except </span><span class="s1">TypeError:</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Port argument must be an integer or None&quot;</span><span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_assert_str(cls</span><span class="s5">, </span><span class="s1">v: str</span><span class="s5">, </span><span class="s1">paramname: str) -&gt; str:</span>
        <span class="s3">if not </span><span class="s1">isinstance(v</span><span class="s5">, </span><span class="s1">str):</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;%s must be a string&quot; </span><span class="s1">% paramname)</span>
        <span class="s3">return </span><span class="s1">v</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_assert_none_str(</span>
        <span class="s1">cls</span><span class="s5">, </span><span class="s1">v: Optional[str]</span><span class="s5">, </span><span class="s1">paramname: str</span>
    <span class="s1">) -&gt; Optional[str]:</span>
        <span class="s3">if </span><span class="s1">v </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">v</span>

        <span class="s3">return </span><span class="s1">cls._assert_str(v</span><span class="s5">, </span><span class="s1">paramname)</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_str_dict(</span>
        <span class="s1">cls</span><span class="s5">,</span>
        <span class="s1">dict_: Optional[</span>
            <span class="s1">Union[</span>
                <span class="s1">Sequence[Tuple[str</span><span class="s5">, </span><span class="s1">Union[Sequence[str]</span><span class="s5">, </span><span class="s1">str]]]</span><span class="s5">,</span>
                <span class="s1">Mapping[str</span><span class="s5">, </span><span class="s1">Union[Sequence[str]</span><span class="s5">, </span><span class="s1">str]]</span><span class="s5">,</span>
            <span class="s1">]</span>
        <span class="s1">]</span><span class="s5">,</span>
    <span class="s1">) -&gt; util.immutabledict[str</span><span class="s5">, </span><span class="s1">Union[Tuple[str</span><span class="s5">, </span><span class="s1">...]</span><span class="s5">, </span><span class="s1">str]]:</span>
        <span class="s3">if </span><span class="s1">dict_ </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">util.EMPTY_DICT</span>

        <span class="s1">@overload</span>
        <span class="s3">def </span><span class="s1">_assert_value(</span>
            <span class="s1">val: str</span><span class="s5">,</span>
        <span class="s1">) -&gt; str: ...</span>

        <span class="s1">@overload</span>
        <span class="s3">def </span><span class="s1">_assert_value(</span>
            <span class="s1">val: Sequence[str]</span><span class="s5">,</span>
        <span class="s1">) -&gt; Union[str</span><span class="s5">, </span><span class="s1">Tuple[str</span><span class="s5">, </span><span class="s1">...]]: ...</span>

        <span class="s3">def </span><span class="s1">_assert_value(</span>
            <span class="s1">val: Union[str</span><span class="s5">, </span><span class="s1">Sequence[str]]</span><span class="s5">,</span>
        <span class="s1">) -&gt; Union[str</span><span class="s5">, </span><span class="s1">Tuple[str</span><span class="s5">, </span><span class="s1">...]]:</span>
            <span class="s3">if </span><span class="s1">isinstance(val</span><span class="s5">, </span><span class="s1">str):</span>
                <span class="s3">return </span><span class="s1">val</span>
            <span class="s3">elif </span><span class="s1">isinstance(val</span><span class="s5">, </span><span class="s1">collections_abc.Sequence):</span>
                <span class="s3">return </span><span class="s1">tuple(_assert_value(elem) </span><span class="s3">for </span><span class="s1">elem </span><span class="s3">in </span><span class="s1">val)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">TypeError(</span>
                    <span class="s4">&quot;Query dictionary values must be strings or &quot;</span>
                    <span class="s4">&quot;sequences of strings&quot;</span>
                <span class="s1">)</span>

        <span class="s3">def </span><span class="s1">_assert_str(v: str) -&gt; str:</span>
            <span class="s3">if not </span><span class="s1">isinstance(v</span><span class="s5">, </span><span class="s1">str):</span>
                <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Query dictionary keys must be strings&quot;</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">v</span>

        <span class="s1">dict_items: Iterable[Tuple[str</span><span class="s5">, </span><span class="s1">Union[Sequence[str]</span><span class="s5">, </span><span class="s1">str]]]</span>
        <span class="s3">if </span><span class="s1">isinstance(dict_</span><span class="s5">, </span><span class="s1">collections_abc.Sequence):</span>
            <span class="s1">dict_items = dict_</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">dict_items = dict_.items()</span>

        <span class="s3">return </span><span class="s1">util.immutabledict(</span>
            <span class="s1">{</span>
                <span class="s1">_assert_str(key): _assert_value(</span>
                    <span class="s1">value</span><span class="s5">,</span>
                <span class="s1">)</span>
                <span class="s3">for </span><span class="s1">key</span><span class="s5">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">dict_items</span>
            <span class="s1">}</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">set(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">drivername: Optional[str] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">username: Optional[str] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">password: Optional[str] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">host: Optional[str] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">port: Optional[int] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">database: Optional[str] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">query: Optional[Mapping[str</span><span class="s5">, </span><span class="s1">Union[Sequence[str]</span><span class="s5">, </span><span class="s1">str]]] = </span><span class="s3">None</span><span class="s5">,</span>
    <span class="s1">) -&gt; URL:</span>
        <span class="s2">&quot;&quot;&quot;return a new :class:`_engine.URL` object with modifications. 
 
        Values are used if they are non-None.  To set a value to ``None`` 
        explicitly, use the :meth:`_engine.URL._replace` method adapted 
        from ``namedtuple``. 
 
        :param drivername: new drivername 
        :param username: new username 
        :param password: new password 
        :param host: new hostname 
        :param port: new port 
        :param query: new query parameters, passed a dict of string keys 
         referring to string or sequence of string values.  Fully 
         replaces the previous list of arguments. 
 
        :return: new :class:`_engine.URL` object. 
 
        .. versionadded:: 1.4 
 
        .. seealso:: 
 
            :meth:`_engine.URL.update_query_dict` 
 
        &quot;&quot;&quot;</span>

        <span class="s1">kw: Dict[str</span><span class="s5">, </span><span class="s1">Any] = {}</span>
        <span class="s3">if </span><span class="s1">drivername </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">kw[</span><span class="s4">&quot;drivername&quot;</span><span class="s1">] = drivername</span>
        <span class="s3">if </span><span class="s1">username </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">kw[</span><span class="s4">&quot;username&quot;</span><span class="s1">] = username</span>
        <span class="s3">if </span><span class="s1">password </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">kw[</span><span class="s4">&quot;password&quot;</span><span class="s1">] = password</span>
        <span class="s3">if </span><span class="s1">host </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">kw[</span><span class="s4">&quot;host&quot;</span><span class="s1">] = host</span>
        <span class="s3">if </span><span class="s1">port </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">kw[</span><span class="s4">&quot;port&quot;</span><span class="s1">] = port</span>
        <span class="s3">if </span><span class="s1">database </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">kw[</span><span class="s4">&quot;database&quot;</span><span class="s1">] = database</span>
        <span class="s3">if </span><span class="s1">query </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">kw[</span><span class="s4">&quot;query&quot;</span><span class="s1">] = query</span>

        <span class="s3">return </span><span class="s1">self._assert_replace(**kw)</span>

    <span class="s3">def </span><span class="s1">_assert_replace(self</span><span class="s5">, </span><span class="s1">**kw: Any) -&gt; URL:</span>
        <span class="s2">&quot;&quot;&quot;argument checks before calling _replace()&quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s4">&quot;drivername&quot; </span><span class="s3">in </span><span class="s1">kw:</span>
            <span class="s1">self._assert_str(kw[</span><span class="s4">&quot;drivername&quot;</span><span class="s1">]</span><span class="s5">, </span><span class="s4">&quot;drivername&quot;</span><span class="s1">)</span>
        <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s4">&quot;username&quot;</span><span class="s5">, </span><span class="s4">&quot;host&quot;</span><span class="s5">, </span><span class="s4">&quot;database&quot;</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">kw:</span>
                <span class="s1">self._assert_none_str(kw[name]</span><span class="s5">, </span><span class="s1">name)</span>
        <span class="s3">if </span><span class="s4">&quot;port&quot; </span><span class="s3">in </span><span class="s1">kw:</span>
            <span class="s1">self._assert_port(kw[</span><span class="s4">&quot;port&quot;</span><span class="s1">])</span>
        <span class="s3">if </span><span class="s4">&quot;query&quot; </span><span class="s3">in </span><span class="s1">kw:</span>
            <span class="s1">kw[</span><span class="s4">&quot;query&quot;</span><span class="s1">] = self._str_dict(kw[</span><span class="s4">&quot;query&quot;</span><span class="s1">])</span>

        <span class="s3">return </span><span class="s1">self._replace(**kw)</span>

    <span class="s3">def </span><span class="s1">update_query_string(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">query_string: str</span><span class="s5">, </span><span class="s1">append: bool = </span><span class="s3">False</span>
    <span class="s1">) -&gt; URL:</span>
        <span class="s4">&quot;&quot;&quot;Return a new :class:`_engine.URL` object with the :attr:`_engine.URL.query` 
        parameter dictionary updated by the given query string. 
 
        E.g.:: 
 
            &gt;&gt;&gt; from sqlalchemy.engine import make_url 
            &gt;&gt;&gt; url = make_url(&quot;postgresql+psycopg2://user:pass@host/dbname&quot;) 
            &gt;&gt;&gt; url = url.update_query_string(&quot;alt_host=host1&amp;alt_host=host2&amp;ssl_cipher=%2Fpath%2Fto%2Fcrt&quot;) 
            &gt;&gt;&gt; str(url) 
            'postgresql+psycopg2://user:pass@host/dbname?alt_host=host1&amp;alt_host=host2&amp;ssl_cipher=%2Fpath%2Fto%2Fcrt' 
 
        :param query_string: a URL escaped query string, not including the 
         question mark. 
 
        :param append: if True, parameters in the existing query string will 
         not be removed; new parameters will be in addition to those present. 
         If left at its default of False, keys present in the given query 
         parameters will replace those of the existing query string. 
 
        .. versionadded:: 1.4 
 
        .. seealso:: 
 
            :attr:`_engine.URL.query` 
 
            :meth:`_engine.URL.update_query_dict` 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>
        <span class="s3">return </span><span class="s1">self.update_query_pairs(parse_qsl(query_string)</span><span class="s5">, </span><span class="s1">append=append)</span>

    <span class="s3">def </span><span class="s1">update_query_pairs(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">key_value_pairs: Iterable[Tuple[str</span><span class="s5">, </span><span class="s1">Union[str</span><span class="s5">, </span><span class="s1">List[str]]]]</span><span class="s5">,</span>
        <span class="s1">append: bool = </span><span class="s3">False</span><span class="s5">,</span>
    <span class="s1">) -&gt; URL:</span>
        <span class="s4">&quot;&quot;&quot;Return a new :class:`_engine.URL` object with the 
        :attr:`_engine.URL.query` 
        parameter dictionary updated by the given sequence of key/value pairs 
 
        E.g.:: 
 
            &gt;&gt;&gt; from sqlalchemy.engine import make_url 
            &gt;&gt;&gt; url = make_url(&quot;postgresql+psycopg2://user:pass@host/dbname&quot;) 
            &gt;&gt;&gt; url = url.update_query_pairs([(&quot;alt_host&quot;, &quot;host1&quot;), (&quot;alt_host&quot;, &quot;host2&quot;), (&quot;ssl_cipher&quot;, &quot;/path/to/crt&quot;)]) 
            &gt;&gt;&gt; str(url) 
            'postgresql+psycopg2://user:pass@host/dbname?alt_host=host1&amp;alt_host=host2&amp;ssl_cipher=%2Fpath%2Fto%2Fcrt' 
 
        :param key_value_pairs: A sequence of tuples containing two strings 
         each. 
 
        :param append: if True, parameters in the existing query string will 
         not be removed; new parameters will be in addition to those present. 
         If left at its default of False, keys present in the given query 
         parameters will replace those of the existing query string. 
 
        .. versionadded:: 1.4 
 
        .. seealso:: 
 
            :attr:`_engine.URL.query` 
 
            :meth:`_engine.URL.difference_update_query` 
 
            :meth:`_engine.URL.set` 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s1">existing_query = self.query</span>
        <span class="s1">new_keys: Dict[str</span><span class="s5">, </span><span class="s1">Union[str</span><span class="s5">, </span><span class="s1">List[str]]] = {}</span>

        <span class="s3">for </span><span class="s1">key</span><span class="s5">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">key_value_pairs:</span>
            <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">new_keys:</span>
                <span class="s1">new_keys[key] = util.to_list(new_keys[key])</span>
                <span class="s1">cast(</span><span class="s4">&quot;List[str]&quot;</span><span class="s5">, </span><span class="s1">new_keys[key]).append(cast(str</span><span class="s5">, </span><span class="s1">value))</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">new_keys[key] = (</span>
                    <span class="s1">list(value) </span><span class="s3">if </span><span class="s1">isinstance(value</span><span class="s5">, </span><span class="s1">(list</span><span class="s5">, </span><span class="s1">tuple)) </span><span class="s3">else </span><span class="s1">value</span>
                <span class="s1">)</span>

        <span class="s1">new_query: Mapping[str</span><span class="s5">, </span><span class="s1">Union[str</span><span class="s5">, </span><span class="s1">Sequence[str]]]</span>
        <span class="s3">if </span><span class="s1">append:</span>
            <span class="s1">new_query = {}</span>

            <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">new_keys:</span>
                <span class="s3">if </span><span class="s1">k </span><span class="s3">in </span><span class="s1">existing_query:</span>
                    <span class="s1">new_query[k] = tuple(</span>
                        <span class="s1">util.to_list(existing_query[k])</span>
                        <span class="s1">+ util.to_list(new_keys[k])</span>
                    <span class="s1">)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">new_query[k] = new_keys[k]</span>

            <span class="s1">new_query.update(</span>
                <span class="s1">{</span>
                    <span class="s1">k: existing_query[k]</span>
                    <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">set(existing_query).difference(new_keys)</span>
                <span class="s1">}</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">new_query = self.query.union(</span>
                <span class="s1">{</span>
                    <span class="s1">k: tuple(v) </span><span class="s3">if </span><span class="s1">isinstance(v</span><span class="s5">, </span><span class="s1">list) </span><span class="s3">else </span><span class="s1">v</span>
                    <span class="s3">for </span><span class="s1">k</span><span class="s5">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">new_keys.items()</span>
                <span class="s1">}</span>
            <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self.set(query=new_query)</span>

    <span class="s3">def </span><span class="s1">update_query_dict(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">query_parameters: Mapping[str</span><span class="s5">, </span><span class="s1">Union[str</span><span class="s5">, </span><span class="s1">List[str]]]</span><span class="s5">,</span>
        <span class="s1">append: bool = </span><span class="s3">False</span><span class="s5">,</span>
    <span class="s1">) -&gt; URL:</span>
        <span class="s4">&quot;&quot;&quot;Return a new :class:`_engine.URL` object with the 
        :attr:`_engine.URL.query` parameter dictionary updated by the given 
        dictionary. 
 
        The dictionary typically contains string keys and string values. 
        In order to represent a query parameter that is expressed multiple 
        times, pass a sequence of string values. 
 
        E.g.:: 
 
 
            &gt;&gt;&gt; from sqlalchemy.engine import make_url 
            &gt;&gt;&gt; url = make_url(&quot;postgresql+psycopg2://user:pass@host/dbname&quot;) 
            &gt;&gt;&gt; url = url.update_query_dict({&quot;alt_host&quot;: [&quot;host1&quot;, &quot;host2&quot;], &quot;ssl_cipher&quot;: &quot;/path/to/crt&quot;}) 
            &gt;&gt;&gt; str(url) 
            'postgresql+psycopg2://user:pass@host/dbname?alt_host=host1&amp;alt_host=host2&amp;ssl_cipher=%2Fpath%2Fto%2Fcrt' 
 
 
        :param query_parameters: A dictionary with string keys and values 
         that are either strings, or sequences of strings. 
 
        :param append: if True, parameters in the existing query string will 
         not be removed; new parameters will be in addition to those present. 
         If left at its default of False, keys present in the given query 
         parameters will replace those of the existing query string. 
 
 
        .. versionadded:: 1.4 
 
        .. seealso:: 
 
            :attr:`_engine.URL.query` 
 
            :meth:`_engine.URL.update_query_string` 
 
            :meth:`_engine.URL.update_query_pairs` 
 
            :meth:`_engine.URL.difference_update_query` 
 
            :meth:`_engine.URL.set` 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>
        <span class="s3">return </span><span class="s1">self.update_query_pairs(query_parameters.items()</span><span class="s5">, </span><span class="s1">append=append)</span>

    <span class="s3">def </span><span class="s1">difference_update_query(self</span><span class="s5">, </span><span class="s1">names: Iterable[str]) -&gt; URL:</span>
        <span class="s2">&quot;&quot;&quot; 
        Remove the given names from the :attr:`_engine.URL.query` dictionary, 
        returning the new :class:`_engine.URL`. 
 
        E.g.:: 
 
            url = url.difference_update_query(['foo', 'bar']) 
 
        Equivalent to using :meth:`_engine.URL.set` as follows:: 
 
            url = url.set( 
                query={ 
                    key: url.query[key] 
                    for key in set(url.query).difference(['foo', 'bar']) 
                } 
            ) 
 
        .. versionadded:: 1.4 
 
        .. seealso:: 
 
            :attr:`_engine.URL.query` 
 
            :meth:`_engine.URL.update_query_dict` 
 
            :meth:`_engine.URL.set` 
 
        &quot;&quot;&quot;</span>

        <span class="s3">if not </span><span class="s1">set(names).intersection(self.query):</span>
            <span class="s3">return </span><span class="s1">self</span>

        <span class="s3">return </span><span class="s1">URL(</span>
            <span class="s1">self.drivername</span><span class="s5">,</span>
            <span class="s1">self.username</span><span class="s5">,</span>
            <span class="s1">self.password</span><span class="s5">,</span>
            <span class="s1">self.host</span><span class="s5">,</span>
            <span class="s1">self.port</span><span class="s5">,</span>
            <span class="s1">self.database</span><span class="s5">,</span>
            <span class="s1">util.immutabledict(</span>
                <span class="s1">{</span>
                    <span class="s1">key: self.query[key]</span>
                    <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">set(self.query).difference(names)</span>
                <span class="s1">}</span>
            <span class="s1">)</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">normalized_query(self) -&gt; Mapping[str</span><span class="s5">, </span><span class="s1">Sequence[str]]:</span>
        <span class="s4">&quot;&quot;&quot;Return the :attr:`_engine.URL.query` dictionary with values normalized 
        into sequences. 
 
        As the :attr:`_engine.URL.query` dictionary may contain either 
        string values or sequences of string values to differentiate between 
        parameters that are specified multiple times in the query string, 
        code that needs to handle multiple parameters generically will wish 
        to use this attribute so that all parameters present are presented 
        as sequences.   Inspiration is from Python's ``urllib.parse.parse_qs`` 
        function.  E.g.:: 
 
 
            &gt;&gt;&gt; from sqlalchemy.engine import make_url 
            &gt;&gt;&gt; url = make_url(&quot;postgresql+psycopg2://user:pass@host/dbname?alt_host=host1&amp;alt_host=host2&amp;ssl_cipher=%2Fpath%2Fto%2Fcrt&quot;) 
            &gt;&gt;&gt; url.query 
            immutabledict({'alt_host': ('host1', 'host2'), 'ssl_cipher': '/path/to/crt'}) 
            &gt;&gt;&gt; url.normalized_query 
            immutabledict({'alt_host': ('host1', 'host2'), 'ssl_cipher': ('/path/to/crt',)}) 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s3">return </span><span class="s1">util.immutabledict(</span>
            <span class="s1">{</span>
                <span class="s1">k: (v</span><span class="s5">,</span><span class="s1">) </span><span class="s3">if not </span><span class="s1">isinstance(v</span><span class="s5">, </span><span class="s1">tuple) </span><span class="s3">else </span><span class="s1">v</span>
                <span class="s3">for </span><span class="s1">k</span><span class="s5">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">self.query.items()</span>
            <span class="s1">}</span>
        <span class="s1">)</span>

    <span class="s1">@util.deprecated(</span>
        <span class="s4">&quot;1.4&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;The :meth:`_engine.URL.__to_string__ method is deprecated and will &quot;</span>
        <span class="s4">&quot;be removed in a future release.  Please use the &quot;</span>
        <span class="s4">&quot;:meth:`_engine.URL.render_as_string` method.&quot;</span><span class="s5">,</span>
    <span class="s1">)</span>
    <span class="s3">def </span><span class="s1">__to_string__(self</span><span class="s5">, </span><span class="s1">hide_password: bool = </span><span class="s3">True</span><span class="s1">) -&gt; str:</span>
        <span class="s2">&quot;&quot;&quot;Render this :class:`_engine.URL` object as a string. 
 
        :param hide_password: Defaults to True.   The password is not shown 
         in the string unless this is set to False. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.render_as_string(hide_password=hide_password)</span>

    <span class="s3">def </span><span class="s1">render_as_string(self</span><span class="s5">, </span><span class="s1">hide_password: bool = </span><span class="s3">True</span><span class="s1">) -&gt; str:</span>
        <span class="s2">&quot;&quot;&quot;Render this :class:`_engine.URL` object as a string. 
 
        This method is used when the ``__str__()`` or ``__repr__()`` 
        methods are used.   The method directly includes additional options. 
 
        :param hide_password: Defaults to True.   The password is not shown 
         in the string unless this is set to False. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">s = self.drivername + </span><span class="s4">&quot;://&quot;</span>
        <span class="s3">if </span><span class="s1">self.username </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">s += quote(self.username</span><span class="s5">, </span><span class="s1">safe=</span><span class="s4">&quot; +&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">self.password </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">s += </span><span class="s4">&quot;:&quot; </span><span class="s1">+ (</span>
                    <span class="s4">&quot;***&quot;</span>
                    <span class="s3">if </span><span class="s1">hide_password</span>
                    <span class="s3">else </span><span class="s1">quote(str(self.password)</span><span class="s5">, </span><span class="s1">safe=</span><span class="s4">&quot; +&quot;</span><span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s1">s += </span><span class="s4">&quot;@&quot;</span>
        <span class="s3">if </span><span class="s1">self.host </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s4">&quot;:&quot; </span><span class="s3">in </span><span class="s1">self.host:</span>
                <span class="s1">s += </span><span class="s4">f&quot;[</span><span class="s6">{</span><span class="s1">self.host</span><span class="s6">}</span><span class="s4">]&quot;</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">s += self.host</span>
        <span class="s3">if </span><span class="s1">self.port </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">s += </span><span class="s4">&quot;:&quot; </span><span class="s1">+ str(self.port)</span>
        <span class="s3">if </span><span class="s1">self.database </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">s += </span><span class="s4">&quot;/&quot; </span><span class="s1">+ self.database</span>
        <span class="s3">if </span><span class="s1">self.query:</span>
            <span class="s1">keys = list(self.query)</span>
            <span class="s1">keys.sort()</span>
            <span class="s1">s += </span><span class="s4">&quot;?&quot; </span><span class="s1">+ </span><span class="s4">&quot;&amp;&quot;</span><span class="s1">.join(</span>
                <span class="s4">f&quot;</span><span class="s6">{</span><span class="s1">quote_plus(k)</span><span class="s6">}</span><span class="s4">=</span><span class="s6">{</span><span class="s1">quote_plus(element)</span><span class="s6">}</span><span class="s4">&quot;</span>
                <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">keys</span>
                <span class="s3">for </span><span class="s1">element </span><span class="s3">in </span><span class="s1">util.to_list(self.query[k])</span>
            <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">s</span>

    <span class="s3">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s3">return </span><span class="s1">self.render_as_string()</span>

    <span class="s3">def </span><span class="s1">__copy__(self) -&gt; URL:</span>
        <span class="s3">return </span><span class="s1">self.__class__.create(</span>
            <span class="s1">self.drivername</span><span class="s5">,</span>
            <span class="s1">self.username</span><span class="s5">,</span>
            <span class="s1">self.password</span><span class="s5">,</span>
            <span class="s1">self.host</span><span class="s5">,</span>
            <span class="s1">self.port</span><span class="s5">,</span>
            <span class="s1">self.database</span><span class="s5">,</span>
            <span class="s0"># note this is an immutabledict of str-&gt; str / tuple of str,</span>
            <span class="s0"># also fully immutable.  does not require deepcopy</span>
            <span class="s1">self.query</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__deepcopy__(self</span><span class="s5">, </span><span class="s1">memo: Any) -&gt; URL:</span>
        <span class="s3">return </span><span class="s1">self.__copy__()</span>

    <span class="s3">def </span><span class="s1">__hash__(self) -&gt; int:</span>
        <span class="s3">return </span><span class="s1">hash(str(self))</span>

    <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s5">, </span><span class="s1">other: Any) -&gt; bool:</span>
        <span class="s3">return </span><span class="s1">(</span>
            <span class="s1">isinstance(other</span><span class="s5">, </span><span class="s1">URL)</span>
            <span class="s3">and </span><span class="s1">self.drivername == other.drivername</span>
            <span class="s3">and </span><span class="s1">self.username == other.username</span>
            <span class="s3">and </span><span class="s1">self.password == other.password</span>
            <span class="s3">and </span><span class="s1">self.host == other.host</span>
            <span class="s3">and </span><span class="s1">self.database == other.database</span>
            <span class="s3">and </span><span class="s1">self.query == other.query</span>
            <span class="s3">and </span><span class="s1">self.port == other.port</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__ne__(self</span><span class="s5">, </span><span class="s1">other: Any) -&gt; bool:</span>
        <span class="s3">return not </span><span class="s1">self == other</span>

    <span class="s3">def </span><span class="s1">get_backend_name(self) -&gt; str:</span>
        <span class="s2">&quot;&quot;&quot;Return the backend name. 
 
        This is the name that corresponds to the database backend in 
        use, and is the portion of the :attr:`_engine.URL.drivername` 
        that is to the left of the plus sign. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s4">&quot;+&quot; </span><span class="s3">not in </span><span class="s1">self.drivername:</span>
            <span class="s3">return </span><span class="s1">self.drivername</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.drivername.split(</span><span class="s4">&quot;+&quot;</span><span class="s1">)[</span><span class="s7">0</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">get_driver_name(self) -&gt; str:</span>
        <span class="s2">&quot;&quot;&quot;Return the backend name. 
 
        This is the name that corresponds to the DBAPI driver in 
        use, and is the portion of the :attr:`_engine.URL.drivername` 
        that is to the right of the plus sign. 
 
        If the :attr:`_engine.URL.drivername` does not include a plus sign, 
        then the default :class:`_engine.Dialect` for this :class:`_engine.URL` 
        is imported in order to get the driver name. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s4">&quot;+&quot; </span><span class="s3">not in </span><span class="s1">self.drivername:</span>
            <span class="s3">return </span><span class="s1">self.get_dialect().driver</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.drivername.split(</span><span class="s4">&quot;+&quot;</span><span class="s1">)[</span><span class="s7">1</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">_instantiate_plugins(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">kwargs: Mapping[str</span><span class="s5">, </span><span class="s1">Any]</span>
    <span class="s1">) -&gt; Tuple[URL</span><span class="s5">, </span><span class="s1">List[Any]</span><span class="s5">, </span><span class="s1">Dict[str</span><span class="s5">, </span><span class="s1">Any]]:</span>
        <span class="s1">plugin_names = util.to_list(self.query.get(</span><span class="s4">&quot;plugin&quot;</span><span class="s5">, </span><span class="s1">()))</span>
        <span class="s1">plugin_names += kwargs.get(</span><span class="s4">&quot;plugins&quot;</span><span class="s5">, </span><span class="s1">[])</span>

        <span class="s1">kwargs = dict(kwargs)</span>

        <span class="s1">loaded_plugins = [</span>
            <span class="s1">plugins.load(plugin_name)(self</span><span class="s5">, </span><span class="s1">kwargs)</span>
            <span class="s3">for </span><span class="s1">plugin_name </span><span class="s3">in </span><span class="s1">plugin_names</span>
        <span class="s1">]</span>

        <span class="s1">u = self.difference_update_query([</span><span class="s4">&quot;plugin&quot;</span><span class="s5">, </span><span class="s4">&quot;plugins&quot;</span><span class="s1">])</span>

        <span class="s3">for </span><span class="s1">plugin </span><span class="s3">in </span><span class="s1">loaded_plugins:</span>
            <span class="s1">new_u = plugin.update_url(u)</span>
            <span class="s3">if </span><span class="s1">new_u </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">u = new_u</span>

        <span class="s1">kwargs.pop(</span><span class="s4">&quot;plugins&quot;</span><span class="s5">, </span><span class="s3">None</span><span class="s1">)</span>

        <span class="s3">return </span><span class="s1">u</span><span class="s5">, </span><span class="s1">loaded_plugins</span><span class="s5">, </span><span class="s1">kwargs</span>

    <span class="s3">def </span><span class="s1">_get_entrypoint(self) -&gt; Type[Dialect]:</span>
        <span class="s2">&quot;&quot;&quot;Return the &quot;entry point&quot; dialect class. 
 
        This is normally the dialect itself except in the case when the 
        returned class implements the get_dialect_cls() method. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s4">&quot;+&quot; </span><span class="s3">not in </span><span class="s1">self.drivername:</span>
            <span class="s1">name = self.drivername</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">name = self.drivername.replace(</span><span class="s4">&quot;+&quot;</span><span class="s5">, </span><span class="s4">&quot;.&quot;</span><span class="s1">)</span>
        <span class="s1">cls = registry.load(name)</span>
        <span class="s0"># check for legacy dialects that</span>
        <span class="s0"># would return a module with 'dialect' as the</span>
        <span class="s0"># actual class</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">hasattr(cls</span><span class="s5">, </span><span class="s4">&quot;dialect&quot;</span><span class="s1">)</span>
            <span class="s3">and </span><span class="s1">isinstance(cls.dialect</span><span class="s5">, </span><span class="s1">type)</span>
            <span class="s3">and </span><span class="s1">issubclass(cls.dialect</span><span class="s5">, </span><span class="s1">Dialect)</span>
        <span class="s1">):</span>
            <span class="s3">return </span><span class="s1">cls.dialect</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">cast(</span><span class="s4">&quot;Type[Dialect]&quot;</span><span class="s5">, </span><span class="s1">cls)</span>

    <span class="s3">def </span><span class="s1">get_dialect(self</span><span class="s5">, </span><span class="s1">_is_async: bool = </span><span class="s3">False</span><span class="s1">) -&gt; Type[Dialect]:</span>
        <span class="s2">&quot;&quot;&quot;Return the SQLAlchemy :class:`_engine.Dialect` class corresponding 
        to this URL's driver name. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">entrypoint = self._get_entrypoint()</span>
        <span class="s3">if </span><span class="s1">_is_async:</span>
            <span class="s1">dialect_cls = entrypoint.get_async_dialect_cls(self)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">dialect_cls = entrypoint.get_dialect_cls(self)</span>
        <span class="s3">return </span><span class="s1">dialect_cls</span>

    <span class="s3">def </span><span class="s1">translate_connect_args(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">names: Optional[List[str]] = </span><span class="s3">None</span><span class="s5">, </span><span class="s1">**kw: Any</span>
    <span class="s1">) -&gt; Dict[str</span><span class="s5">, </span><span class="s1">Any]:</span>
        <span class="s2">r&quot;&quot;&quot;Translate url attributes into a dictionary of connection arguments. 
 
        Returns attributes of this url (`host`, `database`, `username`, 
        `password`, `port`) as a plain dictionary.  The attribute names are 
        used as the keys by default.  Unset or false attributes are omitted 
        from the final dictionary. 
 
        :param \**kw: Optional, alternate key names for url attributes. 
 
        :param names: Deprecated.  Same purpose as the keyword-based alternate 
            names, but correlates the name to the original positionally. 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">names </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">util.warn_deprecated(</span>
                <span class="s4">&quot;The `URL.translate_connect_args.name`s parameter is &quot;</span>
                <span class="s4">&quot;deprecated. Please pass the &quot;</span>
                <span class="s4">&quot;alternate names as kw arguments.&quot;</span><span class="s5">,</span>
                <span class="s4">&quot;1.4&quot;</span><span class="s5">,</span>
            <span class="s1">)</span>

        <span class="s1">translated = {}</span>
        <span class="s1">attribute_names = [</span><span class="s4">&quot;host&quot;</span><span class="s5">, </span><span class="s4">&quot;database&quot;</span><span class="s5">, </span><span class="s4">&quot;username&quot;</span><span class="s5">, </span><span class="s4">&quot;password&quot;</span><span class="s5">, </span><span class="s4">&quot;port&quot;</span><span class="s1">]</span>
        <span class="s3">for </span><span class="s1">sname </span><span class="s3">in </span><span class="s1">attribute_names:</span>
            <span class="s3">if </span><span class="s1">names:</span>
                <span class="s1">name = names.pop(</span><span class="s7">0</span><span class="s1">)</span>
            <span class="s3">elif </span><span class="s1">sname </span><span class="s3">in </span><span class="s1">kw:</span>
                <span class="s1">name = kw[sname]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">name = sname</span>
            <span class="s3">if </span><span class="s1">name </span><span class="s3">is not None and </span><span class="s1">getattr(self</span><span class="s5">, </span><span class="s1">sname</span><span class="s5">, </span><span class="s3">False</span><span class="s1">):</span>
                <span class="s3">if </span><span class="s1">sname == </span><span class="s4">&quot;password&quot;</span><span class="s1">:</span>
                    <span class="s1">translated[name] = str(getattr(self</span><span class="s5">, </span><span class="s1">sname))</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">translated[name] = getattr(self</span><span class="s5">, </span><span class="s1">sname)</span>

        <span class="s3">return </span><span class="s1">translated</span>


<span class="s3">def </span><span class="s1">make_url(name_or_url: Union[str</span><span class="s5">, </span><span class="s1">URL]) -&gt; URL:</span>
    <span class="s2">&quot;&quot;&quot;Given a string, produce a new URL instance. 
 
    The format of the URL generally follows `RFC-1738 
    &lt;https://www.ietf.org/rfc/rfc1738.txt&gt;`_, with some exceptions, including 
    that underscores, and not dashes or periods, are accepted within the 
    &quot;scheme&quot; portion. 
 
    If a :class:`.URL` object is passed, it is returned as is. 
 
    .. seealso:: 
 
        :ref:`database_urls` 
 
    &quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">isinstance(name_or_url</span><span class="s5">, </span><span class="s1">str):</span>
        <span class="s3">return </span><span class="s1">_parse_url(name_or_url)</span>
    <span class="s3">elif not </span><span class="s1">isinstance(name_or_url</span><span class="s5">, </span><span class="s1">URL) </span><span class="s3">and not </span><span class="s1">hasattr(</span>
        <span class="s1">name_or_url</span><span class="s5">, </span><span class="s4">&quot;_sqla_is_testing_if_this_is_a_mock_object&quot;</span>
    <span class="s1">):</span>
        <span class="s3">raise </span><span class="s1">exc.ArgumentError(</span>
            <span class="s4">f&quot;Expected string or URL object, got </span><span class="s6">{</span><span class="s1">name_or_url</span><span class="s6">!r}</span><span class="s4">&quot;</span>
        <span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">name_or_url</span>


<span class="s3">def </span><span class="s1">_parse_url(name: str) -&gt; URL:</span>
    <span class="s1">pattern = re.compile(</span>
        <span class="s4">r&quot;&quot;&quot; 
            (?P&lt;name&gt;[\w\+]+):// 
            (?: 
                (?P&lt;username&gt;[^:/]*) 
                (?::(?P&lt;password&gt;[^@]*))? 
            @)? 
            (?: 
                (?: 
                    \[(?P&lt;ipv6host&gt;[^/\?]+)\] | 
                    (?P&lt;ipv4host&gt;[^/:\?]+) 
                )? 
                (?::(?P&lt;port&gt;[^/\?]*))? 
            )? 
            (?:/(?P&lt;database&gt;[^\?]*))? 
            (?:\?(?P&lt;query&gt;.*))? 
            &quot;&quot;&quot;</span><span class="s5">,</span>
        <span class="s1">re.X</span><span class="s5">,</span>
    <span class="s1">)</span>

    <span class="s1">m = pattern.match(name)</span>
    <span class="s3">if </span><span class="s1">m </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">components = m.groupdict()</span>
        <span class="s1">query: Optional[Dict[str</span><span class="s5">, </span><span class="s1">Union[str</span><span class="s5">, </span><span class="s1">List[str]]]]</span>
        <span class="s3">if </span><span class="s1">components[</span><span class="s4">&quot;query&quot;</span><span class="s1">] </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">query = {}</span>

            <span class="s3">for </span><span class="s1">key</span><span class="s5">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">parse_qsl(components[</span><span class="s4">&quot;query&quot;</span><span class="s1">]):</span>
                <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">query:</span>
                    <span class="s1">query[key] = util.to_list(query[key])</span>
                    <span class="s1">cast(</span><span class="s4">&quot;List[str]&quot;</span><span class="s5">, </span><span class="s1">query[key]).append(value)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">query[key] = value</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">query = </span><span class="s3">None</span>
        <span class="s1">components[</span><span class="s4">&quot;query&quot;</span><span class="s1">] = query</span>

        <span class="s3">if </span><span class="s1">components[</span><span class="s4">&quot;username&quot;</span><span class="s1">] </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">components[</span><span class="s4">&quot;username&quot;</span><span class="s1">] = unquote(components[</span><span class="s4">&quot;username&quot;</span><span class="s1">])</span>

        <span class="s3">if </span><span class="s1">components[</span><span class="s4">&quot;password&quot;</span><span class="s1">] </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">components[</span><span class="s4">&quot;password&quot;</span><span class="s1">] = unquote(components[</span><span class="s4">&quot;password&quot;</span><span class="s1">])</span>

        <span class="s1">ipv4host = components.pop(</span><span class="s4">&quot;ipv4host&quot;</span><span class="s1">)</span>
        <span class="s1">ipv6host = components.pop(</span><span class="s4">&quot;ipv6host&quot;</span><span class="s1">)</span>
        <span class="s1">components[</span><span class="s4">&quot;host&quot;</span><span class="s1">] = ipv4host </span><span class="s3">or </span><span class="s1">ipv6host</span>
        <span class="s1">name = components.pop(</span><span class="s4">&quot;name&quot;</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">components[</span><span class="s4">&quot;port&quot;</span><span class="s1">]:</span>
            <span class="s1">components[</span><span class="s4">&quot;port&quot;</span><span class="s1">] = int(components[</span><span class="s4">&quot;port&quot;</span><span class="s1">])</span>

        <span class="s3">return </span><span class="s1">URL.create(name</span><span class="s5">, </span><span class="s1">**components)  </span><span class="s0"># type: ignore</span>

    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">exc.ArgumentError(</span>
            <span class="s4">&quot;Could not parse SQLAlchemy URL from string '%s'&quot; </span><span class="s1">% name</span>
        <span class="s1">)</span>
</pre>
</body>
</html>