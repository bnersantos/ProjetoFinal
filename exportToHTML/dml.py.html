<html>
<head>
<title>dml.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5d69bb;}
.s1 { color: #d8d8d8;}
.s2 { color: #cc8b60;}
.s3 { color: #96bf7d;}
.s4 { color: #cc7832;}
.s5 { color: #717ed3; font-style: italic;}
</style>
</head>
<body bgcolor="#1a1a25">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
dml.py</font>
</center></td></tr></table>
<pre><span class="s0"># dialects/postgresql/dml.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Any</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Optional</span>

<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">ext</span>
<span class="s2">from </span><span class="s1">.._typing </span><span class="s2">import </span><span class="s1">_OnConflictConstraintT</span>
<span class="s2">from </span><span class="s1">.._typing </span><span class="s2">import </span><span class="s1">_OnConflictIndexElementsT</span>
<span class="s2">from </span><span class="s1">.._typing </span><span class="s2">import </span><span class="s1">_OnConflictIndexWhereT</span>
<span class="s2">from </span><span class="s1">.._typing </span><span class="s2">import </span><span class="s1">_OnConflictSetT</span>
<span class="s2">from </span><span class="s1">.._typing </span><span class="s2">import </span><span class="s1">_OnConflictWhereT</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">util</span>
<span class="s2">from </span><span class="s1">...sql </span><span class="s2">import </span><span class="s1">coercions</span>
<span class="s2">from </span><span class="s1">...sql </span><span class="s2">import </span><span class="s1">roles</span>
<span class="s2">from </span><span class="s1">...sql </span><span class="s2">import </span><span class="s1">schema</span>
<span class="s2">from </span><span class="s1">...sql._typing </span><span class="s2">import </span><span class="s1">_DMLTableArgument</span>
<span class="s2">from </span><span class="s1">...sql.base </span><span class="s2">import </span><span class="s1">_exclusive_against</span>
<span class="s2">from </span><span class="s1">...sql.base </span><span class="s2">import </span><span class="s1">_generative</span>
<span class="s2">from </span><span class="s1">...sql.base </span><span class="s2">import </span><span class="s1">ColumnCollection</span>
<span class="s2">from </span><span class="s1">...sql.base </span><span class="s2">import </span><span class="s1">ReadOnlyColumnCollection</span>
<span class="s2">from </span><span class="s1">...sql.dml </span><span class="s2">import </span><span class="s1">Insert </span><span class="s2">as </span><span class="s1">StandardInsert</span>
<span class="s2">from </span><span class="s1">...sql.elements </span><span class="s2">import </span><span class="s1">ClauseElement</span>
<span class="s2">from </span><span class="s1">...sql.elements </span><span class="s2">import </span><span class="s1">KeyedColumnElement</span>
<span class="s2">from </span><span class="s1">...sql.expression </span><span class="s2">import </span><span class="s1">alias</span>
<span class="s2">from </span><span class="s1">...util.typing </span><span class="s2">import </span><span class="s1">Self</span>


<span class="s1">__all__ = (</span><span class="s3">&quot;Insert&quot;</span><span class="s4">, </span><span class="s3">&quot;insert&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">insert(table: _DMLTableArgument) -&gt; Insert:</span>
    <span class="s5">&quot;&quot;&quot;Construct a PostgreSQL-specific variant :class:`_postgresql.Insert` 
    construct. 
 
    .. container:: inherited_member 
 
        The :func:`sqlalchemy.dialects.postgresql.insert` function creates 
        a :class:`sqlalchemy.dialects.postgresql.Insert`.  This class is based 
        on the dialect-agnostic :class:`_sql.Insert` construct which may 
        be constructed using the :func:`_sql.insert` function in 
        SQLAlchemy Core. 
 
    The :class:`_postgresql.Insert` construct includes additional methods 
    :meth:`_postgresql.Insert.on_conflict_do_update`, 
    :meth:`_postgresql.Insert.on_conflict_do_nothing`. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">Insert(table)</span>


<span class="s2">class </span><span class="s1">Insert(StandardInsert):</span>
    <span class="s5">&quot;&quot;&quot;PostgreSQL-specific implementation of INSERT. 
 
    Adds methods for PG-specific syntaxes such as ON CONFLICT. 
 
    The :class:`_postgresql.Insert` object is created using the 
    :func:`sqlalchemy.dialects.postgresql.insert` function. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">stringify_dialect = </span><span class="s3">&quot;postgresql&quot;</span>
    <span class="s1">inherit_cache = </span><span class="s2">False</span>

    <span class="s1">@util.memoized_property</span>
    <span class="s2">def </span><span class="s1">excluded(</span>
        <span class="s1">self</span><span class="s4">,</span>
    <span class="s1">) -&gt; ReadOnlyColumnCollection[str</span><span class="s4">, </span><span class="s1">KeyedColumnElement[Any]]:</span>
        <span class="s5">&quot;&quot;&quot;Provide the ``excluded`` namespace for an ON CONFLICT statement 
 
        PG's ON CONFLICT clause allows reference to the row that would 
        be inserted, known as ``excluded``.  This attribute provides 
        all columns in this row to be referenceable. 
 
        .. tip::  The :attr:`_postgresql.Insert.excluded` attribute is an 
            instance of :class:`_expression.ColumnCollection`, which provides 
            an interface the same as that of the :attr:`_schema.Table.c` 
            collection described at :ref:`metadata_tables_and_columns`. 
            With this collection, ordinary names are accessible like attributes 
            (e.g. ``stmt.excluded.some_column``), but special names and 
            dictionary method names should be accessed using indexed access, 
            such as ``stmt.excluded[&quot;column name&quot;]`` or 
            ``stmt.excluded[&quot;values&quot;]``.   See the docstring for 
            :class:`_expression.ColumnCollection` for further examples. 
 
        .. seealso:: 
 
            :ref:`postgresql_insert_on_conflict` - example of how 
            to use :attr:`_expression.Insert.excluded` 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">alias(self.table</span><span class="s4">, </span><span class="s1">name=</span><span class="s3">&quot;excluded&quot;</span><span class="s1">).columns</span>

    <span class="s1">_on_conflict_exclusive = _exclusive_against(</span>
        <span class="s3">&quot;_post_values_clause&quot;</span><span class="s4">,</span>
        <span class="s1">msgs={</span>
            <span class="s3">&quot;_post_values_clause&quot;</span><span class="s1">: </span><span class="s3">&quot;This Insert construct already has &quot;</span>
            <span class="s3">&quot;an ON CONFLICT clause established&quot;</span>
        <span class="s1">}</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">@_generative</span>
    <span class="s1">@_on_conflict_exclusive</span>
    <span class="s2">def </span><span class="s1">on_conflict_do_update(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">constraint: _OnConflictConstraintT = </span><span class="s2">None</span><span class="s4">,</span>
        <span class="s1">index_elements: _OnConflictIndexElementsT = </span><span class="s2">None</span><span class="s4">,</span>
        <span class="s1">index_where: _OnConflictIndexWhereT = </span><span class="s2">None</span><span class="s4">,</span>
        <span class="s1">set_: _OnConflictSetT = </span><span class="s2">None</span><span class="s4">,</span>
        <span class="s1">where: _OnConflictWhereT = </span><span class="s2">None</span><span class="s4">,</span>
    <span class="s1">) -&gt; Self:</span>
        <span class="s5">r&quot;&quot;&quot; 
        Specifies a DO UPDATE SET action for ON CONFLICT clause. 
 
        Either the ``constraint`` or ``index_elements`` argument is 
        required, but only one of these can be specified. 
 
        :param constraint: 
         The name of a unique or exclusion constraint on the table, 
         or the constraint object itself if it has a .name attribute. 
 
        :param index_elements: 
         A sequence consisting of string column names, :class:`_schema.Column` 
         objects, or other column expression objects that will be used 
         to infer a target index. 
 
        :param index_where: 
         Additional WHERE criterion that can be used to infer a 
         conditional target index. 
 
        :param set\_: 
         A dictionary or other mapping object 
         where the keys are either names of columns in the target table, 
         or :class:`_schema.Column` objects or other ORM-mapped columns 
         matching that of the target table, and expressions or literals 
         as values, specifying the ``SET`` actions to take. 
 
         .. versionadded:: 1.4 The 
            :paramref:`_postgresql.Insert.on_conflict_do_update.set_` 
            parameter supports :class:`_schema.Column` objects from the target 
            :class:`_schema.Table` as keys. 
 
         .. warning:: This dictionary does **not** take into account 
            Python-specified default UPDATE values or generation functions, 
            e.g. those specified using :paramref:`_schema.Column.onupdate`. 
            These values will not be exercised for an ON CONFLICT style of 
            UPDATE, unless they are manually specified in the 
            :paramref:`.Insert.on_conflict_do_update.set_` dictionary. 
 
        :param where: 
         Optional argument. If present, can be a literal SQL 
         string or an acceptable expression for a ``WHERE`` clause 
         that restricts the rows affected by ``DO UPDATE SET``. Rows 
         not meeting the ``WHERE`` condition will not be updated 
         (effectively a ``DO NOTHING`` for those rows). 
 
 
        .. seealso:: 
 
            :ref:`postgresql_insert_on_conflict` 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._post_values_clause = OnConflictDoUpdate(</span>
            <span class="s1">constraint</span><span class="s4">, </span><span class="s1">index_elements</span><span class="s4">, </span><span class="s1">index_where</span><span class="s4">, </span><span class="s1">set_</span><span class="s4">, </span><span class="s1">where</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@_generative</span>
    <span class="s1">@_on_conflict_exclusive</span>
    <span class="s2">def </span><span class="s1">on_conflict_do_nothing(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">constraint: _OnConflictConstraintT = </span><span class="s2">None</span><span class="s4">,</span>
        <span class="s1">index_elements: _OnConflictIndexElementsT = </span><span class="s2">None</span><span class="s4">,</span>
        <span class="s1">index_where: _OnConflictIndexWhereT = </span><span class="s2">None</span><span class="s4">,</span>
    <span class="s1">) -&gt; Self:</span>
        <span class="s5">&quot;&quot;&quot; 
        Specifies a DO NOTHING action for ON CONFLICT clause. 
 
        The ``constraint`` and ``index_elements`` arguments 
        are optional, but only one of these can be specified. 
 
        :param constraint: 
         The name of a unique or exclusion constraint on the table, 
         or the constraint object itself if it has a .name attribute. 
 
        :param index_elements: 
         A sequence consisting of string column names, :class:`_schema.Column` 
         objects, or other column expression objects that will be used 
         to infer a target index. 
 
        :param index_where: 
         Additional WHERE criterion that can be used to infer a 
         conditional target index. 
 
        .. seealso:: 
 
            :ref:`postgresql_insert_on_conflict` 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._post_values_clause = OnConflictDoNothing(</span>
            <span class="s1">constraint</span><span class="s4">, </span><span class="s1">index_elements</span><span class="s4">, </span><span class="s1">index_where</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self</span>


<span class="s2">class </span><span class="s1">OnConflictClause(ClauseElement):</span>
    <span class="s1">stringify_dialect = </span><span class="s3">&quot;postgresql&quot;</span>

    <span class="s1">constraint_target: Optional[str]</span>
    <span class="s1">inferred_target_elements: _OnConflictIndexElementsT</span>
    <span class="s1">inferred_target_whereclause: _OnConflictIndexWhereT</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">constraint: _OnConflictConstraintT = </span><span class="s2">None</span><span class="s4">,</span>
        <span class="s1">index_elements: _OnConflictIndexElementsT = </span><span class="s2">None</span><span class="s4">,</span>
        <span class="s1">index_where: _OnConflictIndexWhereT = </span><span class="s2">None</span><span class="s4">,</span>
    <span class="s1">):</span>
        <span class="s2">if </span><span class="s1">constraint </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">isinstance(constraint</span><span class="s4">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">isinstance(</span>
                <span class="s1">constraint</span><span class="s4">,</span>
                <span class="s1">(schema.Constraint</span><span class="s4">, </span><span class="s1">ext.ExcludeConstraint)</span><span class="s4">,</span>
            <span class="s1">):</span>
                <span class="s1">constraint = getattr(constraint</span><span class="s4">, </span><span class="s3">&quot;name&quot;</span><span class="s1">) </span><span class="s2">or </span><span class="s1">constraint</span>

        <span class="s2">if </span><span class="s1">constraint </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">index_elements </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;'constraint' and 'index_elements' are mutually exclusive&quot;</span>
                <span class="s1">)</span>

            <span class="s2">if </span><span class="s1">isinstance(constraint</span><span class="s4">, </span><span class="s1">str):</span>
                <span class="s1">self.constraint_target = constraint</span>
                <span class="s1">self.inferred_target_elements = </span><span class="s2">None</span>
                <span class="s1">self.inferred_target_whereclause = </span><span class="s2">None</span>
            <span class="s2">elif </span><span class="s1">isinstance(constraint</span><span class="s4">, </span><span class="s1">schema.Index):</span>
                <span class="s1">index_elements = constraint.expressions</span>
                <span class="s1">index_where = constraint.dialect_options[</span><span class="s3">&quot;postgresql&quot;</span><span class="s1">].get(</span>
                    <span class="s3">&quot;where&quot;</span>
                <span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">isinstance(constraint</span><span class="s4">, </span><span class="s1">ext.ExcludeConstraint):</span>
                <span class="s1">index_elements = constraint.columns</span>
                <span class="s1">index_where = constraint.where</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">index_elements = constraint.columns</span>
                <span class="s1">index_where = constraint.dialect_options[</span><span class="s3">&quot;postgresql&quot;</span><span class="s1">].get(</span>
                    <span class="s3">&quot;where&quot;</span>
                <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">index_elements </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.constraint_target = </span><span class="s2">None</span>
            <span class="s1">self.inferred_target_elements = index_elements</span>
            <span class="s1">self.inferred_target_whereclause = index_where</span>
        <span class="s2">elif </span><span class="s1">constraint </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.constraint_target = self.inferred_target_elements = (</span>
                <span class="s1">self.inferred_target_whereclause</span>
            <span class="s1">) = </span><span class="s2">None</span>


<span class="s2">class </span><span class="s1">OnConflictDoNothing(OnConflictClause):</span>
    <span class="s1">__visit_name__ = </span><span class="s3">&quot;on_conflict_do_nothing&quot;</span>


<span class="s2">class </span><span class="s1">OnConflictDoUpdate(OnConflictClause):</span>
    <span class="s1">__visit_name__ = </span><span class="s3">&quot;on_conflict_do_update&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">constraint: _OnConflictConstraintT = </span><span class="s2">None</span><span class="s4">,</span>
        <span class="s1">index_elements: _OnConflictIndexElementsT = </span><span class="s2">None</span><span class="s4">,</span>
        <span class="s1">index_where: _OnConflictIndexWhereT = </span><span class="s2">None</span><span class="s4">,</span>
        <span class="s1">set_: _OnConflictSetT = </span><span class="s2">None</span><span class="s4">,</span>
        <span class="s1">where: _OnConflictWhereT = </span><span class="s2">None</span><span class="s4">,</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">constraint=constraint</span><span class="s4">,</span>
            <span class="s1">index_elements=index_elements</span><span class="s4">,</span>
            <span class="s1">index_where=index_where</span><span class="s4">,</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">self.inferred_target_elements </span><span class="s2">is None</span>
            <span class="s2">and </span><span class="s1">self.constraint_target </span><span class="s2">is None</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;Either constraint or index_elements, &quot;</span>
                <span class="s3">&quot;but not both, must be specified unless DO NOTHING&quot;</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">isinstance(set_</span><span class="s4">, </span><span class="s1">dict):</span>
            <span class="s2">if not </span><span class="s1">set_:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;set parameter dictionary must not be empty&quot;</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">isinstance(set_</span><span class="s4">, </span><span class="s1">ColumnCollection):</span>
            <span class="s1">set_ = dict(set_)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;set parameter must be a non-empty dictionary &quot;</span>
                <span class="s3">&quot;or a ColumnCollection such as the `.c.` collection &quot;</span>
                <span class="s3">&quot;of a Table object&quot;</span>
            <span class="s1">)</span>
        <span class="s1">self.update_values_to_set = [</span>
            <span class="s1">(coercions.expect(roles.DMLColumnRole</span><span class="s4">, </span><span class="s1">key)</span><span class="s4">, </span><span class="s1">value)</span>
            <span class="s2">for </span><span class="s1">key</span><span class="s4">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">set_.items()</span>
        <span class="s1">]</span>
        <span class="s1">self.update_whereclause = where</span>
</pre>
</body>
</html>