<html>
<head>
<title>result.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5d69bb;}
.s1 { color: #d8d8d8;}
.s2 { color: #717ed3; font-style: italic;}
.s3 { color: #cc8b60;}
.s4 { color: #cc7832;}
.s5 { color: #96bf7d;}
.s6 { color: #bbb55b;}
</style>
</head>
<body bgcolor="#1a1a25">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
result.py</font>
</center></td></tr></table>
<pre><span class="s0"># engine/result.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>

<span class="s2">&quot;&quot;&quot;Define generic result set constructs.&quot;&quot;&quot;</span>

<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">annotations</span>

<span class="s3">from </span><span class="s1">enum </span><span class="s3">import </span><span class="s1">Enum</span>
<span class="s3">import </span><span class="s1">functools</span>
<span class="s3">import </span><span class="s1">itertools</span>
<span class="s3">import </span><span class="s1">operator</span>
<span class="s3">import </span><span class="s1">typing</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Callable</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">cast</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Dict</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Generic</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Iterable</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Iterator</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">List</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Mapping</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">NoReturn</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Optional</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">overload</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Sequence</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Set</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Tuple</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TypeVar</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Union</span>

<span class="s3">from </span><span class="s1">.row </span><span class="s3">import </span><span class="s1">Row</span>
<span class="s3">from </span><span class="s1">.row </span><span class="s3">import </span><span class="s1">RowMapping</span>
<span class="s3">from </span><span class="s1">.. </span><span class="s3">import </span><span class="s1">exc</span>
<span class="s3">from </span><span class="s1">.. </span><span class="s3">import </span><span class="s1">util</span>
<span class="s3">from </span><span class="s1">..sql.base </span><span class="s3">import </span><span class="s1">_generative</span>
<span class="s3">from </span><span class="s1">..sql.base </span><span class="s3">import </span><span class="s1">HasMemoized</span>
<span class="s3">from </span><span class="s1">..sql.base </span><span class="s3">import </span><span class="s1">InPlaceGenerative</span>
<span class="s3">from </span><span class="s1">..util </span><span class="s3">import </span><span class="s1">HasMemoized_ro_memoized_attribute</span>
<span class="s3">from </span><span class="s1">..util </span><span class="s3">import </span><span class="s1">NONE_SET</span>
<span class="s3">from </span><span class="s1">..util._has_cy </span><span class="s3">import </span><span class="s1">HAS_CYEXTENSION</span>
<span class="s3">from </span><span class="s1">..util.typing </span><span class="s3">import </span><span class="s1">Literal</span>
<span class="s3">from </span><span class="s1">..util.typing </span><span class="s3">import </span><span class="s1">Self</span>

<span class="s3">if </span><span class="s1">typing.TYPE_CHECKING </span><span class="s3">or not </span><span class="s1">HAS_CYEXTENSION:</span>
    <span class="s3">from </span><span class="s1">._py_row </span><span class="s3">import </span><span class="s1">tuplegetter </span><span class="s3">as </span><span class="s1">tuplegetter</span>
<span class="s3">else</span><span class="s1">:</span>
    <span class="s3">from </span><span class="s1">sqlalchemy.cyextension.resultproxy </span><span class="s3">import </span><span class="s1">tuplegetter </span><span class="s3">as </span><span class="s1">tuplegetter</span>

<span class="s3">if </span><span class="s1">typing.TYPE_CHECKING:</span>
    <span class="s3">from </span><span class="s1">..sql.schema </span><span class="s3">import </span><span class="s1">Column</span>
    <span class="s3">from </span><span class="s1">..sql.type_api </span><span class="s3">import </span><span class="s1">_ResultProcessorType</span>

<span class="s1">_KeyType = Union[str</span><span class="s4">, </span><span class="s5">&quot;Column[Any]&quot;</span><span class="s1">]</span>
<span class="s1">_KeyIndexType = Union[str</span><span class="s4">, </span><span class="s5">&quot;Column[Any]&quot;</span><span class="s4">, </span><span class="s1">int]</span>

<span class="s0"># is overridden in cursor using _CursorKeyMapRecType</span>
<span class="s1">_KeyMapRecType = Any</span>

<span class="s1">_KeyMapType = Mapping[_KeyType</span><span class="s4">, </span><span class="s1">_KeyMapRecType]</span>


<span class="s1">_RowData = Union[Row[Any]</span><span class="s4">, </span><span class="s1">RowMapping</span><span class="s4">, </span><span class="s1">Any]</span>
<span class="s5">&quot;&quot;&quot;A generic form of &quot;row&quot; that accommodates for the different kinds of 
&quot;rows&quot; that different result objects return, including row, row mapping, and 
scalar values&quot;&quot;&quot;</span>

<span class="s1">_RawRowType = Tuple[Any</span><span class="s4">, </span><span class="s1">...]</span>
<span class="s5">&quot;&quot;&quot;represents the kind of row we get from a DBAPI cursor&quot;&quot;&quot;</span>

<span class="s1">_R = TypeVar(</span><span class="s5">&quot;_R&quot;</span><span class="s4">, </span><span class="s1">bound=_RowData)</span>
<span class="s1">_T = TypeVar(</span><span class="s5">&quot;_T&quot;</span><span class="s4">, </span><span class="s1">bound=Any)</span>
<span class="s1">_TP = TypeVar(</span><span class="s5">&quot;_TP&quot;</span><span class="s4">, </span><span class="s1">bound=Tuple[Any</span><span class="s4">, </span><span class="s1">...])</span>

<span class="s1">_InterimRowType = Union[_R</span><span class="s4">, </span><span class="s1">_RawRowType]</span>
<span class="s5">&quot;&quot;&quot;a catchall &quot;anything&quot; kind of return type that can be applied 
across all the result types 
 
&quot;&quot;&quot;</span>

<span class="s1">_InterimSupportsScalarsRowType = Union[Row[Any]</span><span class="s4">, </span><span class="s1">Any]</span>

<span class="s1">_ProcessorsType = Sequence[Optional[</span><span class="s5">&quot;_ResultProcessorType[Any]&quot;</span><span class="s1">]]</span>
<span class="s1">_TupleGetterType = Callable[[Sequence[Any]]</span><span class="s4">, </span><span class="s1">Sequence[Any]]</span>
<span class="s1">_UniqueFilterType = Callable[[Any]</span><span class="s4">, </span><span class="s1">Any]</span>
<span class="s1">_UniqueFilterStateType = Tuple[Set[Any]</span><span class="s4">, </span><span class="s1">Optional[_UniqueFilterType]]</span>


<span class="s3">class </span><span class="s1">ResultMetaData:</span>
    <span class="s2">&quot;&quot;&quot;Base for metadata about result rows.&quot;&quot;&quot;</span>

    <span class="s1">__slots__ = ()</span>

    <span class="s1">_tuplefilter: Optional[_TupleGetterType] = </span><span class="s3">None</span>
    <span class="s1">_translated_indexes: Optional[Sequence[int]] = </span><span class="s3">None</span>
    <span class="s1">_unique_filters: Optional[Sequence[Callable[[Any]</span><span class="s4">, </span><span class="s1">Any]]] = </span><span class="s3">None</span>
    <span class="s1">_keymap: _KeyMapType</span>
    <span class="s1">_keys: Sequence[str]</span>
    <span class="s1">_processors: Optional[_ProcessorsType]</span>
    <span class="s1">_key_to_index: Mapping[_KeyType</span><span class="s4">, </span><span class="s1">int]</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">keys(self) -&gt; RMKeyView:</span>
        <span class="s3">return </span><span class="s1">RMKeyView(self)</span>

    <span class="s3">def </span><span class="s1">_has_key(self</span><span class="s4">, </span><span class="s1">key: object) -&gt; bool:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s3">def </span><span class="s1">_for_freeze(self) -&gt; ResultMetaData:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s1">@overload</span>
    <span class="s3">def </span><span class="s1">_key_fallback(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">key: Any</span><span class="s4">, </span><span class="s1">err: Optional[Exception]</span><span class="s4">, </span><span class="s1">raiseerr: Literal[</span><span class="s3">True</span><span class="s1">] = ...</span>
    <span class="s1">) -&gt; NoReturn: ...</span>

    <span class="s1">@overload</span>
    <span class="s3">def </span><span class="s1">_key_fallback(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">key: Any</span><span class="s4">,</span>
        <span class="s1">err: Optional[Exception]</span><span class="s4">,</span>
        <span class="s1">raiseerr: Literal[</span><span class="s3">False</span><span class="s1">] = ...</span><span class="s4">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">: ...</span>

    <span class="s1">@overload</span>
    <span class="s3">def </span><span class="s1">_key_fallback(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">key: Any</span><span class="s4">, </span><span class="s1">err: Optional[Exception]</span><span class="s4">, </span><span class="s1">raiseerr: bool = ...</span>
    <span class="s1">) -&gt; Optional[NoReturn]: ...</span>

    <span class="s3">def </span><span class="s1">_key_fallback(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">key: Any</span><span class="s4">, </span><span class="s1">err: Optional[Exception]</span><span class="s4">, </span><span class="s1">raiseerr: bool = </span><span class="s3">True</span>
    <span class="s1">) -&gt; Optional[NoReturn]:</span>
        <span class="s3">assert </span><span class="s1">raiseerr</span>
        <span class="s3">raise </span><span class="s1">KeyError(key) </span><span class="s3">from </span><span class="s1">err</span>

    <span class="s3">def </span><span class="s1">_raise_for_ambiguous_column_name(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">rec: _KeyMapRecType</span>
    <span class="s1">) -&gt; NoReturn:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span>
            <span class="s5">&quot;ambiguous column name logic is implemented for &quot;</span>
            <span class="s5">&quot;CursorResultMetaData&quot;</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_index_for_key(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">key: _KeyIndexType</span><span class="s4">, </span><span class="s1">raiseerr: bool</span>
    <span class="s1">) -&gt; Optional[int]:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s3">def </span><span class="s1">_indexes_for_keys(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">keys: Sequence[_KeyIndexType]</span>
    <span class="s1">) -&gt; Sequence[int]:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s3">def </span><span class="s1">_metadata_for_keys(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">keys: Sequence[_KeyIndexType]</span>
    <span class="s1">) -&gt; Iterator[_KeyMapRecType]:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s3">def </span><span class="s1">_reduce(self</span><span class="s4">, </span><span class="s1">keys: Sequence[_KeyIndexType]) -&gt; ResultMetaData:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s3">def </span><span class="s1">_getter(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">key: Any</span><span class="s4">, </span><span class="s1">raiseerr: bool = </span><span class="s3">True</span>
    <span class="s1">) -&gt; Optional[Callable[[Row[Any]]</span><span class="s4">, </span><span class="s1">Any]]:</span>
        <span class="s1">index = self._index_for_key(key</span><span class="s4">, </span><span class="s1">raiseerr)</span>

        <span class="s3">if </span><span class="s1">index </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">operator.itemgetter(index)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">_row_as_tuple_getter(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">keys: Sequence[_KeyIndexType]</span>
    <span class="s1">) -&gt; _TupleGetterType:</span>
        <span class="s1">indexes = self._indexes_for_keys(keys)</span>
        <span class="s3">return </span><span class="s1">tuplegetter(*indexes)</span>

    <span class="s3">def </span><span class="s1">_make_key_to_index(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">keymap: Mapping[_KeyType</span><span class="s4">, </span><span class="s1">Sequence[Any]]</span><span class="s4">, </span><span class="s1">index: int</span>
    <span class="s1">) -&gt; Mapping[_KeyType</span><span class="s4">, </span><span class="s1">int]:</span>
        <span class="s3">return </span><span class="s1">{</span>
            <span class="s1">key: rec[index]</span>
            <span class="s3">for </span><span class="s1">key</span><span class="s4">, </span><span class="s1">rec </span><span class="s3">in </span><span class="s1">keymap.items()</span>
            <span class="s3">if </span><span class="s1">rec[index] </span><span class="s3">is not None</span>
        <span class="s1">}</span>

    <span class="s3">def </span><span class="s1">_key_not_found(self</span><span class="s4">, </span><span class="s1">key: Any</span><span class="s4">, </span><span class="s1">attr_error: bool) -&gt; NoReturn:</span>
        <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self._keymap:</span>
            <span class="s0"># the index must be none in this case</span>
            <span class="s1">self._raise_for_ambiguous_column_name(self._keymap[key])</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># unknown key</span>
            <span class="s3">if </span><span class="s1">attr_error:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">self._key_fallback(key</span><span class="s4">, </span><span class="s3">None</span><span class="s1">)</span>
                <span class="s3">except </span><span class="s1">KeyError </span><span class="s3">as </span><span class="s1">ke:</span>
                    <span class="s3">raise </span><span class="s1">AttributeError(ke.args[</span><span class="s6">0</span><span class="s1">]) </span><span class="s3">from </span><span class="s1">ke</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self._key_fallback(key</span><span class="s4">, </span><span class="s3">None</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">_effective_processors(self) -&gt; Optional[_ProcessorsType]:</span>
        <span class="s3">if not </span><span class="s1">self._processors </span><span class="s3">or </span><span class="s1">NONE_SET.issuperset(self._processors):</span>
            <span class="s3">return None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self._processors</span>


<span class="s3">class </span><span class="s1">RMKeyView(typing.KeysView[Any]):</span>
    <span class="s1">__slots__ = (</span><span class="s5">&quot;_parent&quot;</span><span class="s4">, </span><span class="s5">&quot;_keys&quot;</span><span class="s1">)</span>

    <span class="s1">_parent: ResultMetaData</span>
    <span class="s1">_keys: Sequence[str]</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">parent: ResultMetaData):</span>
        <span class="s1">self._parent = parent</span>
        <span class="s1">self._keys = [k </span><span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">parent._keys </span><span class="s3">if </span><span class="s1">k </span><span class="s3">is not None</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">__len__(self) -&gt; int:</span>
        <span class="s3">return </span><span class="s1">len(self._keys)</span>

    <span class="s3">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s3">return </span><span class="s5">&quot;{0.__class__.__name__}({0._keys!r})&quot;</span><span class="s1">.format(self)</span>

    <span class="s3">def </span><span class="s1">__iter__(self) -&gt; Iterator[str]:</span>
        <span class="s3">return </span><span class="s1">iter(self._keys)</span>

    <span class="s3">def </span><span class="s1">__contains__(self</span><span class="s4">, </span><span class="s1">item: Any) -&gt; bool:</span>
        <span class="s3">if </span><span class="s1">isinstance(item</span><span class="s4">, </span><span class="s1">int):</span>
            <span class="s3">return False</span>

        <span class="s0"># note this also includes special key fallback behaviors</span>
        <span class="s0"># which also don't seem to be tested in test_resultset right now</span>
        <span class="s3">return </span><span class="s1">self._parent._has_key(item)</span>

    <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s4">, </span><span class="s1">other: Any) -&gt; bool:</span>
        <span class="s3">return </span><span class="s1">list(other) == list(self)</span>

    <span class="s3">def </span><span class="s1">__ne__(self</span><span class="s4">, </span><span class="s1">other: Any) -&gt; bool:</span>
        <span class="s3">return </span><span class="s1">list(other) != list(self)</span>


<span class="s3">class </span><span class="s1">SimpleResultMetaData(ResultMetaData):</span>
    <span class="s2">&quot;&quot;&quot;result metadata for in-memory collections.&quot;&quot;&quot;</span>

    <span class="s1">__slots__ = (</span>
        <span class="s5">&quot;_keys&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;_keymap&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;_processors&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;_tuplefilter&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;_translated_indexes&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;_unique_filters&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;_key_to_index&quot;</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">_keys: Sequence[str]</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">keys: Sequence[str]</span><span class="s4">,</span>
        <span class="s1">extra: Optional[Sequence[Any]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_processors: Optional[_ProcessorsType] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_tuplefilter: Optional[_TupleGetterType] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_translated_indexes: Optional[Sequence[int]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_unique_filters: Optional[Sequence[Callable[[Any]</span><span class="s4">, </span><span class="s1">Any]]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">):</span>
        <span class="s1">self._keys = list(keys)</span>
        <span class="s1">self._tuplefilter = _tuplefilter</span>
        <span class="s1">self._translated_indexes = _translated_indexes</span>
        <span class="s1">self._unique_filters = _unique_filters</span>
        <span class="s3">if </span><span class="s1">extra:</span>
            <span class="s1">recs_names = [</span>
                <span class="s1">(</span>
                    <span class="s1">(name</span><span class="s4">,</span><span class="s1">) + (extras </span><span class="s3">if </span><span class="s1">extras </span><span class="s3">else </span><span class="s1">())</span><span class="s4">,</span>
                    <span class="s1">(index</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">extras)</span><span class="s4">,</span>
                <span class="s1">)</span>
                <span class="s3">for </span><span class="s1">index</span><span class="s4">, </span><span class="s1">(name</span><span class="s4">, </span><span class="s1">extras) </span><span class="s3">in </span><span class="s1">enumerate(zip(self._keys</span><span class="s4">, </span><span class="s1">extra))</span>
            <span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">recs_names = [</span>
                <span class="s1">((name</span><span class="s4">,</span><span class="s1">)</span><span class="s4">, </span><span class="s1">(index</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">()))</span>
                <span class="s3">for </span><span class="s1">index</span><span class="s4">, </span><span class="s1">name </span><span class="s3">in </span><span class="s1">enumerate(self._keys)</span>
            <span class="s1">]</span>

        <span class="s1">self._keymap = {key: rec </span><span class="s3">for </span><span class="s1">keys</span><span class="s4">, </span><span class="s1">rec </span><span class="s3">in </span><span class="s1">recs_names </span><span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">keys}</span>

        <span class="s1">self._processors = _processors</span>

        <span class="s1">self._key_to_index = self._make_key_to_index(self._keymap</span><span class="s4">, </span><span class="s6">0</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_has_key(self</span><span class="s4">, </span><span class="s1">key: object) -&gt; bool:</span>
        <span class="s3">return </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self._keymap</span>

    <span class="s3">def </span><span class="s1">_for_freeze(self) -&gt; ResultMetaData:</span>
        <span class="s1">unique_filters = self._unique_filters</span>
        <span class="s3">if </span><span class="s1">unique_filters </span><span class="s3">and </span><span class="s1">self._tuplefilter:</span>
            <span class="s1">unique_filters = self._tuplefilter(unique_filters)</span>

        <span class="s0"># TODO: are we freezing the result with or without uniqueness</span>
        <span class="s0"># applied?</span>
        <span class="s3">return </span><span class="s1">SimpleResultMetaData(</span>
            <span class="s1">self._keys</span><span class="s4">,</span>
            <span class="s1">extra=[self._keymap[key][</span><span class="s6">2</span><span class="s1">] </span><span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self._keys]</span><span class="s4">,</span>
            <span class="s1">_unique_filters=unique_filters</span><span class="s4">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__getstate__(self) -&gt; Dict[str</span><span class="s4">, </span><span class="s1">Any]:</span>
        <span class="s3">return </span><span class="s1">{</span>
            <span class="s5">&quot;_keys&quot;</span><span class="s1">: self._keys</span><span class="s4">,</span>
            <span class="s5">&quot;_translated_indexes&quot;</span><span class="s1">: self._translated_indexes</span><span class="s4">,</span>
        <span class="s1">}</span>

    <span class="s3">def </span><span class="s1">__setstate__(self</span><span class="s4">, </span><span class="s1">state: Dict[str</span><span class="s4">, </span><span class="s1">Any]) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">state[</span><span class="s5">&quot;_translated_indexes&quot;</span><span class="s1">]:</span>
            <span class="s1">_translated_indexes = state[</span><span class="s5">&quot;_translated_indexes&quot;</span><span class="s1">]</span>
            <span class="s1">_tuplefilter = tuplegetter(*_translated_indexes)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">_translated_indexes = _tuplefilter = </span><span class="s3">None</span>
        <span class="s1">self.__init__(  </span><span class="s0"># type: ignore</span>
            <span class="s1">state[</span><span class="s5">&quot;_keys&quot;</span><span class="s1">]</span><span class="s4">,</span>
            <span class="s1">_translated_indexes=_translated_indexes</span><span class="s4">,</span>
            <span class="s1">_tuplefilter=_tuplefilter</span><span class="s4">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_index_for_key(self</span><span class="s4">, </span><span class="s1">key: Any</span><span class="s4">, </span><span class="s1">raiseerr: bool = </span><span class="s3">True</span><span class="s1">) -&gt; int:</span>
        <span class="s3">if </span><span class="s1">int </span><span class="s3">in </span><span class="s1">key.__class__.__mro__:</span>
            <span class="s1">key = self._keys[key]</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">rec = self._keymap[key]</span>
        <span class="s3">except </span><span class="s1">KeyError </span><span class="s3">as </span><span class="s1">ke:</span>
            <span class="s1">rec = self._key_fallback(key</span><span class="s4">, </span><span class="s1">ke</span><span class="s4">, </span><span class="s1">raiseerr)</span>

        <span class="s3">return </span><span class="s1">rec[</span><span class="s6">0</span><span class="s1">]  </span><span class="s0"># type: ignore[no-any-return]</span>

    <span class="s3">def </span><span class="s1">_indexes_for_keys(self</span><span class="s4">, </span><span class="s1">keys: Sequence[Any]) -&gt; Sequence[int]:</span>
        <span class="s3">return </span><span class="s1">[self._keymap[key][</span><span class="s6">0</span><span class="s1">] </span><span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">keys]</span>

    <span class="s3">def </span><span class="s1">_metadata_for_keys(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">keys: Sequence[Any]</span>
    <span class="s1">) -&gt; Iterator[_KeyMapRecType]:</span>
        <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">keys:</span>
            <span class="s3">if </span><span class="s1">int </span><span class="s3">in </span><span class="s1">key.__class__.__mro__:</span>
                <span class="s1">key = self._keys[key]</span>

            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">rec = self._keymap[key]</span>
            <span class="s3">except </span><span class="s1">KeyError </span><span class="s3">as </span><span class="s1">ke:</span>
                <span class="s1">rec = self._key_fallback(key</span><span class="s4">, </span><span class="s1">ke</span><span class="s4">, </span><span class="s3">True</span><span class="s1">)</span>

            <span class="s3">yield </span><span class="s1">rec</span>

    <span class="s3">def </span><span class="s1">_reduce(self</span><span class="s4">, </span><span class="s1">keys: Sequence[Any]) -&gt; ResultMetaData:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">metadata_for_keys = [</span>
                <span class="s1">self._keymap[</span>
                    <span class="s1">self._keys[key] </span><span class="s3">if </span><span class="s1">int </span><span class="s3">in </span><span class="s1">key.__class__.__mro__ </span><span class="s3">else </span><span class="s1">key</span>
                <span class="s1">]</span>
                <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">keys</span>
            <span class="s1">]</span>
        <span class="s3">except </span><span class="s1">KeyError </span><span class="s3">as </span><span class="s1">ke:</span>
            <span class="s1">self._key_fallback(ke.args[</span><span class="s6">0</span><span class="s1">]</span><span class="s4">, </span><span class="s1">ke</span><span class="s4">, </span><span class="s3">True</span><span class="s1">)</span>

        <span class="s1">indexes: Sequence[int]</span>
        <span class="s1">new_keys: Sequence[str]</span>
        <span class="s1">extra: Sequence[Any]</span>
        <span class="s1">indexes</span><span class="s4">, </span><span class="s1">new_keys</span><span class="s4">, </span><span class="s1">extra = zip(*metadata_for_keys)</span>

        <span class="s3">if </span><span class="s1">self._translated_indexes:</span>
            <span class="s1">indexes = [self._translated_indexes[idx] </span><span class="s3">for </span><span class="s1">idx </span><span class="s3">in </span><span class="s1">indexes]</span>

        <span class="s1">tup = tuplegetter(*indexes)</span>

        <span class="s1">new_metadata = SimpleResultMetaData(</span>
            <span class="s1">new_keys</span><span class="s4">,</span>
            <span class="s1">extra=extra</span><span class="s4">,</span>
            <span class="s1">_tuplefilter=tup</span><span class="s4">,</span>
            <span class="s1">_translated_indexes=indexes</span><span class="s4">,</span>
            <span class="s1">_processors=self._processors</span><span class="s4">,</span>
            <span class="s1">_unique_filters=self._unique_filters</span><span class="s4">,</span>
        <span class="s1">)</span>

        <span class="s3">return </span><span class="s1">new_metadata</span>


<span class="s3">def </span><span class="s1">result_tuple(</span>
    <span class="s1">fields: Sequence[str]</span><span class="s4">, </span><span class="s1">extra: Optional[Any] = </span><span class="s3">None</span>
<span class="s1">) -&gt; Callable[[Iterable[Any]]</span><span class="s4">, </span><span class="s1">Row[Any]]:</span>
    <span class="s1">parent = SimpleResultMetaData(fields</span><span class="s4">, </span><span class="s1">extra)</span>
    <span class="s3">return </span><span class="s1">functools.partial(</span>
        <span class="s1">Row</span><span class="s4">, </span><span class="s1">parent</span><span class="s4">, </span><span class="s1">parent._effective_processors</span><span class="s4">, </span><span class="s1">parent._key_to_index</span>
    <span class="s1">)</span>


<span class="s0"># a symbol that indicates to internal Result methods that</span>
<span class="s0"># &quot;no row is returned&quot;.  We can't use None for those cases where a scalar</span>
<span class="s0"># filter is applied to rows.</span>
<span class="s3">class </span><span class="s1">_NoRow(Enum):</span>
    <span class="s1">_NO_ROW = </span><span class="s6">0</span>


<span class="s1">_NO_ROW = _NoRow._NO_ROW</span>


<span class="s3">class </span><span class="s1">ResultInternal(InPlaceGenerative</span><span class="s4">, </span><span class="s1">Generic[_R]):</span>
    <span class="s1">__slots__ = ()</span>

    <span class="s1">_real_result: Optional[Result[Any]] = </span><span class="s3">None</span>
    <span class="s1">_generate_rows: bool = </span><span class="s3">True</span>
    <span class="s1">_row_logging_fn: Optional[Callable[[Any]</span><span class="s4">, </span><span class="s1">Any]]</span>

    <span class="s1">_unique_filter_state: Optional[_UniqueFilterStateType] = </span><span class="s3">None</span>
    <span class="s1">_post_creational_filter: Optional[Callable[[Any]</span><span class="s4">, </span><span class="s1">Any]] = </span><span class="s3">None</span>
    <span class="s1">_is_cursor = </span><span class="s3">False</span>

    <span class="s1">_metadata: ResultMetaData</span>

    <span class="s1">_source_supports_scalars: bool</span>

    <span class="s3">def </span><span class="s1">_fetchiter_impl(self) -&gt; Iterator[_InterimRowType[Row[Any]]]:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s3">def </span><span class="s1">_fetchone_impl(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">hard_close: bool = </span><span class="s3">False</span>
    <span class="s1">) -&gt; Optional[_InterimRowType[Row[Any]]]:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s3">def </span><span class="s1">_fetchmany_impl(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">size: Optional[int] = </span><span class="s3">None</span>
    <span class="s1">) -&gt; List[_InterimRowType[Row[Any]]]:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s3">def </span><span class="s1">_fetchall_impl(self) -&gt; List[_InterimRowType[Row[Any]]]:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s3">def </span><span class="s1">_soft_close(self</span><span class="s4">, </span><span class="s1">hard: bool = </span><span class="s3">False</span><span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s1">@HasMemoized_ro_memoized_attribute</span>
    <span class="s3">def </span><span class="s1">_row_getter(self) -&gt; Optional[Callable[...</span><span class="s4">, </span><span class="s1">_R]]:</span>
        <span class="s1">real_result: Result[Any] = (</span>
            <span class="s1">self._real_result</span>
            <span class="s3">if </span><span class="s1">self._real_result</span>
            <span class="s3">else </span><span class="s1">cast(</span><span class="s5">&quot;Result[Any]&quot;</span><span class="s4">, </span><span class="s1">self)</span>
        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">real_result._source_supports_scalars:</span>
            <span class="s3">if not </span><span class="s1">self._generate_rows:</span>
                <span class="s3">return None</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">_proc = Row</span>

                <span class="s3">def </span><span class="s1">process_row(</span>
                    <span class="s1">metadata: ResultMetaData</span><span class="s4">,</span>
                    <span class="s1">processors: Optional[_ProcessorsType]</span><span class="s4">,</span>
                    <span class="s1">key_to_index: Mapping[_KeyType</span><span class="s4">, </span><span class="s1">int]</span><span class="s4">,</span>
                    <span class="s1">scalar_obj: Any</span><span class="s4">,</span>
                <span class="s1">) -&gt; Row[Any]:</span>
                    <span class="s3">return </span><span class="s1">_proc(</span>
                        <span class="s1">metadata</span><span class="s4">, </span><span class="s1">processors</span><span class="s4">, </span><span class="s1">key_to_index</span><span class="s4">, </span><span class="s1">(scalar_obj</span><span class="s4">,</span><span class="s1">)</span>
                    <span class="s1">)</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">process_row = Row  </span><span class="s0"># type: ignore</span>

        <span class="s1">metadata = self._metadata</span>

        <span class="s1">key_to_index = metadata._key_to_index</span>
        <span class="s1">processors = metadata._effective_processors</span>
        <span class="s1">tf = metadata._tuplefilter</span>

        <span class="s3">if </span><span class="s1">tf </span><span class="s3">and not </span><span class="s1">real_result._source_supports_scalars:</span>
            <span class="s3">if </span><span class="s1">processors:</span>
                <span class="s1">processors = tf(processors)</span>

            <span class="s1">_make_row_orig: Callable[...</span><span class="s4">, </span><span class="s1">_R] = functools.partial(  </span><span class="s0"># type: ignore  # noqa E501</span>
                <span class="s1">process_row</span><span class="s4">, </span><span class="s1">metadata</span><span class="s4">, </span><span class="s1">processors</span><span class="s4">, </span><span class="s1">key_to_index</span>
            <span class="s1">)</span>

            <span class="s1">fixed_tf = tf</span>

            <span class="s3">def </span><span class="s1">make_row(row: _InterimRowType[Row[Any]]) -&gt; _R:</span>
                <span class="s3">return </span><span class="s1">_make_row_orig(fixed_tf(row))</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">make_row = functools.partial(  </span><span class="s0"># type: ignore</span>
                <span class="s1">process_row</span><span class="s4">, </span><span class="s1">metadata</span><span class="s4">, </span><span class="s1">processors</span><span class="s4">, </span><span class="s1">key_to_index</span>
            <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">real_result._row_logging_fn:</span>
            <span class="s1">_log_row = real_result._row_logging_fn</span>
            <span class="s1">_make_row = make_row</span>

            <span class="s3">def </span><span class="s1">make_row(row: _InterimRowType[Row[Any]]) -&gt; _R:</span>
                <span class="s3">return </span><span class="s1">_log_row(_make_row(row))  </span><span class="s0"># type: ignore</span>

        <span class="s3">return </span><span class="s1">make_row</span>

    <span class="s1">@HasMemoized_ro_memoized_attribute</span>
    <span class="s3">def </span><span class="s1">_iterator_getter(self) -&gt; Callable[...</span><span class="s4">, </span><span class="s1">Iterator[_R]]:</span>
        <span class="s1">make_row = self._row_getter</span>

        <span class="s1">post_creational_filter = self._post_creational_filter</span>

        <span class="s3">if </span><span class="s1">self._unique_filter_state:</span>
            <span class="s1">uniques</span><span class="s4">, </span><span class="s1">strategy = self._unique_strategy</span>

            <span class="s3">def </span><span class="s1">iterrows(self: Result[Any]) -&gt; Iterator[_R]:</span>
                <span class="s3">for </span><span class="s1">raw_row </span><span class="s3">in </span><span class="s1">self._fetchiter_impl():</span>
                    <span class="s1">obj: _InterimRowType[Any] = (</span>
                        <span class="s1">make_row(raw_row) </span><span class="s3">if </span><span class="s1">make_row </span><span class="s3">else </span><span class="s1">raw_row</span>
                    <span class="s1">)</span>
                    <span class="s1">hashed = strategy(obj) </span><span class="s3">if </span><span class="s1">strategy </span><span class="s3">else </span><span class="s1">obj</span>
                    <span class="s3">if </span><span class="s1">hashed </span><span class="s3">in </span><span class="s1">uniques:</span>
                        <span class="s3">continue</span>
                    <span class="s1">uniques.add(hashed)</span>
                    <span class="s3">if </span><span class="s1">post_creational_filter:</span>
                        <span class="s1">obj = post_creational_filter(obj)</span>
                    <span class="s3">yield </span><span class="s1">obj  </span><span class="s0"># type: ignore</span>

        <span class="s3">else</span><span class="s1">:</span>

            <span class="s3">def </span><span class="s1">iterrows(self: Result[Any]) -&gt; Iterator[_R]:</span>
                <span class="s3">for </span><span class="s1">raw_row </span><span class="s3">in </span><span class="s1">self._fetchiter_impl():</span>
                    <span class="s1">row: _InterimRowType[Any] = (</span>
                        <span class="s1">make_row(raw_row) </span><span class="s3">if </span><span class="s1">make_row </span><span class="s3">else </span><span class="s1">raw_row</span>
                    <span class="s1">)</span>
                    <span class="s3">if </span><span class="s1">post_creational_filter:</span>
                        <span class="s1">row = post_creational_filter(row)</span>
                    <span class="s3">yield </span><span class="s1">row  </span><span class="s0"># type: ignore</span>

        <span class="s3">return </span><span class="s1">iterrows</span>

    <span class="s3">def </span><span class="s1">_raw_all_rows(self) -&gt; List[_R]:</span>
        <span class="s1">make_row = self._row_getter</span>
        <span class="s3">assert </span><span class="s1">make_row </span><span class="s3">is not None</span>
        <span class="s1">rows = self._fetchall_impl()</span>
        <span class="s3">return </span><span class="s1">[make_row(row) </span><span class="s3">for </span><span class="s1">row </span><span class="s3">in </span><span class="s1">rows]</span>

    <span class="s3">def </span><span class="s1">_allrows(self) -&gt; List[_R]:</span>
        <span class="s1">post_creational_filter = self._post_creational_filter</span>

        <span class="s1">make_row = self._row_getter</span>

        <span class="s1">rows = self._fetchall_impl()</span>
        <span class="s1">made_rows: List[_InterimRowType[_R]]</span>
        <span class="s3">if </span><span class="s1">make_row:</span>
            <span class="s1">made_rows = [make_row(row) </span><span class="s3">for </span><span class="s1">row </span><span class="s3">in </span><span class="s1">rows]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">made_rows = rows  </span><span class="s0"># type: ignore</span>

        <span class="s1">interim_rows: List[_R]</span>

        <span class="s3">if </span><span class="s1">self._unique_filter_state:</span>
            <span class="s1">uniques</span><span class="s4">, </span><span class="s1">strategy = self._unique_strategy</span>

            <span class="s1">interim_rows = [</span>
                <span class="s1">made_row  </span><span class="s0"># type: ignore</span>
                <span class="s3">for </span><span class="s1">made_row</span><span class="s4">, </span><span class="s1">sig_row </span><span class="s3">in </span><span class="s1">[</span>
                    <span class="s1">(</span>
                        <span class="s1">made_row</span><span class="s4">,</span>
                        <span class="s1">strategy(made_row) </span><span class="s3">if </span><span class="s1">strategy </span><span class="s3">else </span><span class="s1">made_row</span><span class="s4">,</span>
                    <span class="s1">)</span>
                    <span class="s3">for </span><span class="s1">made_row </span><span class="s3">in </span><span class="s1">made_rows</span>
                <span class="s1">]</span>
                <span class="s3">if </span><span class="s1">sig_row </span><span class="s3">not in </span><span class="s1">uniques </span><span class="s3">and not </span><span class="s1">uniques.add(sig_row)  </span><span class="s0"># type: ignore # noqa: E501</span>
            <span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">interim_rows = made_rows  </span><span class="s0"># type: ignore</span>

        <span class="s3">if </span><span class="s1">post_creational_filter:</span>
            <span class="s1">interim_rows = [</span>
                <span class="s1">post_creational_filter(row) </span><span class="s3">for </span><span class="s1">row </span><span class="s3">in </span><span class="s1">interim_rows</span>
            <span class="s1">]</span>
        <span class="s3">return </span><span class="s1">interim_rows</span>

    <span class="s1">@HasMemoized_ro_memoized_attribute</span>
    <span class="s3">def </span><span class="s1">_onerow_getter(</span>
        <span class="s1">self</span><span class="s4">,</span>
    <span class="s1">) -&gt; Callable[...</span><span class="s4">, </span><span class="s1">Union[Literal[_NoRow._NO_ROW]</span><span class="s4">, </span><span class="s1">_R]]:</span>
        <span class="s1">make_row = self._row_getter</span>

        <span class="s1">post_creational_filter = self._post_creational_filter</span>

        <span class="s3">if </span><span class="s1">self._unique_filter_state:</span>
            <span class="s1">uniques</span><span class="s4">, </span><span class="s1">strategy = self._unique_strategy</span>

            <span class="s3">def </span><span class="s1">onerow(self: Result[Any]) -&gt; Union[_NoRow</span><span class="s4">, </span><span class="s1">_R]:</span>
                <span class="s1">_onerow = self._fetchone_impl</span>
                <span class="s3">while True</span><span class="s1">:</span>
                    <span class="s1">row = _onerow()</span>
                    <span class="s3">if </span><span class="s1">row </span><span class="s3">is None</span><span class="s1">:</span>
                        <span class="s3">return </span><span class="s1">_NO_ROW</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">obj: _InterimRowType[Any] = (</span>
                            <span class="s1">make_row(row) </span><span class="s3">if </span><span class="s1">make_row </span><span class="s3">else </span><span class="s1">row</span>
                        <span class="s1">)</span>
                        <span class="s1">hashed = strategy(obj) </span><span class="s3">if </span><span class="s1">strategy </span><span class="s3">else </span><span class="s1">obj</span>
                        <span class="s3">if </span><span class="s1">hashed </span><span class="s3">in </span><span class="s1">uniques:</span>
                            <span class="s3">continue</span>
                        <span class="s3">else</span><span class="s1">:</span>
                            <span class="s1">uniques.add(hashed)</span>
                        <span class="s3">if </span><span class="s1">post_creational_filter:</span>
                            <span class="s1">obj = post_creational_filter(obj)</span>
                        <span class="s3">return </span><span class="s1">obj  </span><span class="s0"># type: ignore</span>

        <span class="s3">else</span><span class="s1">:</span>

            <span class="s3">def </span><span class="s1">onerow(self: Result[Any]) -&gt; Union[_NoRow</span><span class="s4">, </span><span class="s1">_R]:</span>
                <span class="s1">row = self._fetchone_impl()</span>
                <span class="s3">if </span><span class="s1">row </span><span class="s3">is None</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s1">_NO_ROW</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">interim_row: _InterimRowType[Any] = (</span>
                        <span class="s1">make_row(row) </span><span class="s3">if </span><span class="s1">make_row </span><span class="s3">else </span><span class="s1">row</span>
                    <span class="s1">)</span>
                    <span class="s3">if </span><span class="s1">post_creational_filter:</span>
                        <span class="s1">interim_row = post_creational_filter(interim_row)</span>
                    <span class="s3">return </span><span class="s1">interim_row  </span><span class="s0"># type: ignore</span>

        <span class="s3">return </span><span class="s1">onerow</span>

    <span class="s1">@HasMemoized_ro_memoized_attribute</span>
    <span class="s3">def </span><span class="s1">_manyrow_getter(self) -&gt; Callable[...</span><span class="s4">, </span><span class="s1">List[_R]]:</span>
        <span class="s1">make_row = self._row_getter</span>

        <span class="s1">post_creational_filter = self._post_creational_filter</span>

        <span class="s3">if </span><span class="s1">self._unique_filter_state:</span>
            <span class="s1">uniques</span><span class="s4">, </span><span class="s1">strategy = self._unique_strategy</span>

            <span class="s3">def </span><span class="s1">filterrows(</span>
                <span class="s1">make_row: Optional[Callable[...</span><span class="s4">, </span><span class="s1">_R]]</span><span class="s4">,</span>
                <span class="s1">rows: List[Any]</span><span class="s4">,</span>
                <span class="s1">strategy: Optional[Callable[[List[Any]]</span><span class="s4">, </span><span class="s1">Any]]</span><span class="s4">,</span>
                <span class="s1">uniques: Set[Any]</span><span class="s4">,</span>
            <span class="s1">) -&gt; List[_R]:</span>
                <span class="s3">if </span><span class="s1">make_row:</span>
                    <span class="s1">rows = [make_row(row) </span><span class="s3">for </span><span class="s1">row </span><span class="s3">in </span><span class="s1">rows]</span>

                <span class="s3">if </span><span class="s1">strategy:</span>
                    <span class="s1">made_rows = (</span>
                        <span class="s1">(made_row</span><span class="s4">, </span><span class="s1">strategy(made_row)) </span><span class="s3">for </span><span class="s1">made_row </span><span class="s3">in </span><span class="s1">rows</span>
                    <span class="s1">)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">made_rows = ((made_row</span><span class="s4">, </span><span class="s1">made_row) </span><span class="s3">for </span><span class="s1">made_row </span><span class="s3">in </span><span class="s1">rows)</span>
                <span class="s3">return </span><span class="s1">[</span>
                    <span class="s1">made_row</span>
                    <span class="s3">for </span><span class="s1">made_row</span><span class="s4">, </span><span class="s1">sig_row </span><span class="s3">in </span><span class="s1">made_rows</span>
                    <span class="s3">if </span><span class="s1">sig_row </span><span class="s3">not in </span><span class="s1">uniques </span><span class="s3">and not </span><span class="s1">uniques.add(sig_row)  </span><span class="s0"># type: ignore  # noqa: E501</span>
                <span class="s1">]</span>

            <span class="s3">def </span><span class="s1">manyrows(</span>
                <span class="s1">self: ResultInternal[_R]</span><span class="s4">, </span><span class="s1">num: Optional[int]</span>
            <span class="s1">) -&gt; List[_R]:</span>
                <span class="s1">collect: List[_R] = []</span>

                <span class="s1">_manyrows = self._fetchmany_impl</span>

                <span class="s3">if </span><span class="s1">num </span><span class="s3">is None</span><span class="s1">:</span>
                    <span class="s0"># if None is passed, we don't know the default</span>
                    <span class="s0"># manyrows number, DBAPI has this as cursor.arraysize</span>
                    <span class="s0"># different DBAPIs / fetch strategies may be different.</span>
                    <span class="s0"># do a fetch to find what the number is.  if there are</span>
                    <span class="s0"># only fewer rows left, then it doesn't matter.</span>
                    <span class="s1">real_result = (</span>
                        <span class="s1">self._real_result</span>
                        <span class="s3">if </span><span class="s1">self._real_result</span>
                        <span class="s3">else </span><span class="s1">cast(</span><span class="s5">&quot;Result[Any]&quot;</span><span class="s4">, </span><span class="s1">self)</span>
                    <span class="s1">)</span>
                    <span class="s3">if </span><span class="s1">real_result._yield_per:</span>
                        <span class="s1">num_required = num = real_result._yield_per</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">rows = _manyrows(num)</span>
                        <span class="s1">num = len(rows)</span>
                        <span class="s3">assert </span><span class="s1">make_row </span><span class="s3">is not None</span>
                        <span class="s1">collect.extend(</span>
                            <span class="s1">filterrows(make_row</span><span class="s4">, </span><span class="s1">rows</span><span class="s4">, </span><span class="s1">strategy</span><span class="s4">, </span><span class="s1">uniques)</span>
                        <span class="s1">)</span>
                        <span class="s1">num_required = num - len(collect)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">num_required = num</span>

                <span class="s3">assert </span><span class="s1">num </span><span class="s3">is not None</span>

                <span class="s3">while </span><span class="s1">num_required:</span>
                    <span class="s1">rows = _manyrows(num_required)</span>
                    <span class="s3">if not </span><span class="s1">rows:</span>
                        <span class="s3">break</span>

                    <span class="s1">collect.extend(</span>
                        <span class="s1">filterrows(make_row</span><span class="s4">, </span><span class="s1">rows</span><span class="s4">, </span><span class="s1">strategy</span><span class="s4">, </span><span class="s1">uniques)</span>
                    <span class="s1">)</span>
                    <span class="s1">num_required = num - len(collect)</span>

                <span class="s3">if </span><span class="s1">post_creational_filter:</span>
                    <span class="s1">collect = [post_creational_filter(row) </span><span class="s3">for </span><span class="s1">row </span><span class="s3">in </span><span class="s1">collect]</span>
                <span class="s3">return </span><span class="s1">collect</span>

        <span class="s3">else</span><span class="s1">:</span>

            <span class="s3">def </span><span class="s1">manyrows(</span>
                <span class="s1">self: ResultInternal[_R]</span><span class="s4">, </span><span class="s1">num: Optional[int]</span>
            <span class="s1">) -&gt; List[_R]:</span>
                <span class="s3">if </span><span class="s1">num </span><span class="s3">is None</span><span class="s1">:</span>
                    <span class="s1">real_result = (</span>
                        <span class="s1">self._real_result</span>
                        <span class="s3">if </span><span class="s1">self._real_result</span>
                        <span class="s3">else </span><span class="s1">cast(</span><span class="s5">&quot;Result[Any]&quot;</span><span class="s4">, </span><span class="s1">self)</span>
                    <span class="s1">)</span>
                    <span class="s1">num = real_result._yield_per</span>

                <span class="s1">rows: List[_InterimRowType[Any]] = self._fetchmany_impl(num)</span>
                <span class="s3">if </span><span class="s1">make_row:</span>
                    <span class="s1">rows = [make_row(row) </span><span class="s3">for </span><span class="s1">row </span><span class="s3">in </span><span class="s1">rows]</span>
                <span class="s3">if </span><span class="s1">post_creational_filter:</span>
                    <span class="s1">rows = [post_creational_filter(row) </span><span class="s3">for </span><span class="s1">row </span><span class="s3">in </span><span class="s1">rows]</span>
                <span class="s3">return </span><span class="s1">rows  </span><span class="s0"># type: ignore</span>

        <span class="s3">return </span><span class="s1">manyrows</span>

    <span class="s1">@overload</span>
    <span class="s3">def </span><span class="s1">_only_one_row(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">raise_for_second_row: bool</span><span class="s4">,</span>
        <span class="s1">raise_for_none: Literal[</span><span class="s3">True</span><span class="s1">]</span><span class="s4">,</span>
        <span class="s1">scalar: bool</span><span class="s4">,</span>
    <span class="s1">) -&gt; _R: ...</span>

    <span class="s1">@overload</span>
    <span class="s3">def </span><span class="s1">_only_one_row(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">raise_for_second_row: bool</span><span class="s4">,</span>
        <span class="s1">raise_for_none: bool</span><span class="s4">,</span>
        <span class="s1">scalar: bool</span><span class="s4">,</span>
    <span class="s1">) -&gt; Optional[_R]: ...</span>

    <span class="s3">def </span><span class="s1">_only_one_row(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">raise_for_second_row: bool</span><span class="s4">,</span>
        <span class="s1">raise_for_none: bool</span><span class="s4">,</span>
        <span class="s1">scalar: bool</span><span class="s4">,</span>
    <span class="s1">) -&gt; Optional[_R]:</span>
        <span class="s1">onerow = self._fetchone_impl</span>

        <span class="s1">row: Optional[_InterimRowType[Any]] = onerow(hard_close=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">row </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">raise_for_none:</span>
                <span class="s3">raise </span><span class="s1">exc.NoResultFound(</span>
                    <span class="s5">&quot;No row was found when one was required&quot;</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return None</span>

        <span class="s3">if </span><span class="s1">scalar </span><span class="s3">and </span><span class="s1">self._source_supports_scalars:</span>
            <span class="s1">self._generate_rows = </span><span class="s3">False</span>
            <span class="s1">make_row = </span><span class="s3">None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">make_row = self._row_getter</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">row = make_row(row) </span><span class="s3">if </span><span class="s1">make_row </span><span class="s3">else </span><span class="s1">row</span>
        <span class="s3">except</span><span class="s1">:</span>
            <span class="s1">self._soft_close(hard=</span><span class="s3">True</span><span class="s1">)</span>
            <span class="s3">raise</span>

        <span class="s3">if </span><span class="s1">raise_for_second_row:</span>
            <span class="s3">if </span><span class="s1">self._unique_filter_state:</span>
                <span class="s0"># for no second row but uniqueness, need to essentially</span>
                <span class="s0"># consume the entire result :(</span>
                <span class="s1">uniques</span><span class="s4">, </span><span class="s1">strategy = self._unique_strategy</span>

                <span class="s1">existing_row_hash = strategy(row) </span><span class="s3">if </span><span class="s1">strategy </span><span class="s3">else </span><span class="s1">row</span>

                <span class="s3">while True</span><span class="s1">:</span>
                    <span class="s1">next_row: Any = onerow(hard_close=</span><span class="s3">True</span><span class="s1">)</span>
                    <span class="s3">if </span><span class="s1">next_row </span><span class="s3">is None</span><span class="s1">:</span>
                        <span class="s1">next_row = _NO_ROW</span>
                        <span class="s3">break</span>

                    <span class="s3">try</span><span class="s1">:</span>
                        <span class="s1">next_row = make_row(next_row) </span><span class="s3">if </span><span class="s1">make_row </span><span class="s3">else </span><span class="s1">next_row</span>

                        <span class="s3">if </span><span class="s1">strategy:</span>
                            <span class="s3">assert </span><span class="s1">next_row </span><span class="s3">is not </span><span class="s1">_NO_ROW</span>
                            <span class="s3">if </span><span class="s1">existing_row_hash == strategy(next_row):</span>
                                <span class="s3">continue</span>
                        <span class="s3">elif </span><span class="s1">row == next_row:</span>
                            <span class="s3">continue</span>
                        <span class="s0"># here, we have a row and it's different</span>
                        <span class="s3">break</span>
                    <span class="s3">except</span><span class="s1">:</span>
                        <span class="s1">self._soft_close(hard=</span><span class="s3">True</span><span class="s1">)</span>
                        <span class="s3">raise</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">next_row = onerow(hard_close=</span><span class="s3">True</span><span class="s1">)</span>
                <span class="s3">if </span><span class="s1">next_row </span><span class="s3">is None</span><span class="s1">:</span>
                    <span class="s1">next_row = _NO_ROW</span>

            <span class="s3">if </span><span class="s1">next_row </span><span class="s3">is not </span><span class="s1">_NO_ROW:</span>
                <span class="s1">self._soft_close(hard=</span><span class="s3">True</span><span class="s1">)</span>
                <span class="s3">raise </span><span class="s1">exc.MultipleResultsFound(</span>
                    <span class="s5">&quot;Multiple rows were found when exactly one was required&quot;</span>
                    <span class="s3">if </span><span class="s1">raise_for_none</span>
                    <span class="s3">else </span><span class="s5">&quot;Multiple rows were found when one or none &quot;</span>
                    <span class="s5">&quot;was required&quot;</span>
                <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">next_row = _NO_ROW</span>
            <span class="s0"># if we checked for second row then that would have</span>
            <span class="s0"># closed us :)</span>
            <span class="s1">self._soft_close(hard=</span><span class="s3">True</span><span class="s1">)</span>

        <span class="s3">if not </span><span class="s1">scalar:</span>
            <span class="s1">post_creational_filter = self._post_creational_filter</span>
            <span class="s3">if </span><span class="s1">post_creational_filter:</span>
                <span class="s1">row = post_creational_filter(row)</span>

        <span class="s3">if </span><span class="s1">scalar </span><span class="s3">and </span><span class="s1">make_row:</span>
            <span class="s3">return </span><span class="s1">row[</span><span class="s6">0</span><span class="s1">]  </span><span class="s0"># type: ignore</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">row  </span><span class="s0"># type: ignore</span>

    <span class="s3">def </span><span class="s1">_iter_impl(self) -&gt; Iterator[_R]:</span>
        <span class="s3">return </span><span class="s1">self._iterator_getter(self)</span>

    <span class="s3">def </span><span class="s1">_next_impl(self) -&gt; _R:</span>
        <span class="s1">row = self._onerow_getter(self)</span>
        <span class="s3">if </span><span class="s1">row </span><span class="s3">is </span><span class="s1">_NO_ROW:</span>
            <span class="s3">raise </span><span class="s1">StopIteration()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">row</span>

    <span class="s1">@_generative</span>
    <span class="s3">def </span><span class="s1">_column_slices(self</span><span class="s4">, </span><span class="s1">indexes: Sequence[_KeyIndexType]) -&gt; Self:</span>
        <span class="s1">real_result = (</span>
            <span class="s1">self._real_result</span>
            <span class="s3">if </span><span class="s1">self._real_result</span>
            <span class="s3">else </span><span class="s1">cast(</span><span class="s5">&quot;Result[Any]&quot;</span><span class="s4">, </span><span class="s1">self)</span>
        <span class="s1">)</span>

        <span class="s3">if not </span><span class="s1">real_result._source_supports_scalars </span><span class="s3">or </span><span class="s1">len(indexes) != </span><span class="s6">1</span><span class="s1">:</span>
            <span class="s1">self._metadata = self._metadata._reduce(indexes)</span>

        <span class="s3">assert </span><span class="s1">self._generate_rows</span>

        <span class="s3">return </span><span class="s1">self</span>

    <span class="s1">@HasMemoized.memoized_attribute</span>
    <span class="s3">def </span><span class="s1">_unique_strategy(self) -&gt; _UniqueFilterStateType:</span>
        <span class="s3">assert </span><span class="s1">self._unique_filter_state </span><span class="s3">is not None</span>
        <span class="s1">uniques</span><span class="s4">, </span><span class="s1">strategy = self._unique_filter_state</span>

        <span class="s1">real_result = (</span>
            <span class="s1">self._real_result</span>
            <span class="s3">if </span><span class="s1">self._real_result </span><span class="s3">is not None</span>
            <span class="s3">else </span><span class="s1">cast(</span><span class="s5">&quot;Result[Any]&quot;</span><span class="s4">, </span><span class="s1">self)</span>
        <span class="s1">)</span>

        <span class="s3">if not </span><span class="s1">strategy </span><span class="s3">and </span><span class="s1">self._metadata._unique_filters:</span>
            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">real_result._source_supports_scalars</span>
                <span class="s3">and not </span><span class="s1">self._generate_rows</span>
            <span class="s1">):</span>
                <span class="s1">strategy = self._metadata._unique_filters[</span><span class="s6">0</span><span class="s1">]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">filters = self._metadata._unique_filters</span>
                <span class="s3">if </span><span class="s1">self._metadata._tuplefilter:</span>
                    <span class="s1">filters = self._metadata._tuplefilter(filters)</span>

                <span class="s1">strategy = operator.methodcaller(</span><span class="s5">&quot;_filter_on_values&quot;</span><span class="s4">, </span><span class="s1">filters)</span>
        <span class="s3">return </span><span class="s1">uniques</span><span class="s4">, </span><span class="s1">strategy</span>


<span class="s3">class </span><span class="s1">_WithKeys:</span>
    <span class="s1">__slots__ = ()</span>

    <span class="s1">_metadata: ResultMetaData</span>

    <span class="s0"># used mainly to share documentation on the keys method.</span>
    <span class="s3">def </span><span class="s1">keys(self) -&gt; RMKeyView:</span>
        <span class="s2">&quot;&quot;&quot;Return an iterable view which yields the string keys that would 
        be represented by each :class:`_engine.Row`. 
 
        The keys can represent the labels of the columns returned by a core 
        statement or the names of the orm classes returned by an orm 
        execution. 
 
        The view also can be tested for key containment using the Python 
        ``in`` operator, which will test both for the string keys represented 
        in the view, as well as for alternate keys such as column objects. 
 
        .. versionchanged:: 1.4 a key view object is returned rather than a 
           plain list. 
 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._metadata.keys</span>


<span class="s3">class </span><span class="s1">Result(_WithKeys</span><span class="s4">, </span><span class="s1">ResultInternal[Row[_TP]]):</span>
    <span class="s2">&quot;&quot;&quot;Represent a set of database results. 
 
    .. versionadded:: 1.4  The :class:`_engine.Result` object provides a 
       completely updated usage model and calling facade for SQLAlchemy 
       Core and SQLAlchemy ORM.   In Core, it forms the basis of the 
       :class:`_engine.CursorResult` object which replaces the previous 
       :class:`_engine.ResultProxy` interface.   When using the ORM, a 
       higher level object called :class:`_engine.ChunkedIteratorResult` 
       is normally used. 
 
    .. note:: In SQLAlchemy 1.4 and above, this object is 
       used for ORM results returned by :meth:`_orm.Session.execute`, which can 
       yield instances of ORM mapped objects either individually or within 
       tuple-like rows. Note that the :class:`_engine.Result` object does not 
       deduplicate instances or rows automatically as is the case with the 
       legacy :class:`_orm.Query` object. For in-Python de-duplication of 
       instances or rows, use the :meth:`_engine.Result.unique` modifier 
       method. 
 
    .. seealso:: 
 
        :ref:`tutorial_fetching_rows` - in the :doc:`/tutorial/index` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = (</span><span class="s5">&quot;_metadata&quot;</span><span class="s4">, </span><span class="s5">&quot;__dict__&quot;</span><span class="s1">)</span>

    <span class="s1">_row_logging_fn: Optional[Callable[[Row[Any]]</span><span class="s4">, </span><span class="s1">Row[Any]]] = </span><span class="s3">None</span>

    <span class="s1">_source_supports_scalars: bool = </span><span class="s3">False</span>

    <span class="s1">_yield_per: Optional[int] = </span><span class="s3">None</span>

    <span class="s1">_attributes: util.immutabledict[Any</span><span class="s4">, </span><span class="s1">Any] = util.immutabledict()</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">cursor_metadata: ResultMetaData):</span>
        <span class="s1">self._metadata = cursor_metadata</span>

    <span class="s3">def </span><span class="s1">__enter__(self) -&gt; Self:</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">__exit__(self</span><span class="s4">, </span><span class="s1">type_: Any</span><span class="s4">, </span><span class="s1">value: Any</span><span class="s4">, </span><span class="s1">traceback: Any) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">self.close()</span>

    <span class="s3">def </span><span class="s1">close(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;close this :class:`_engine.Result`. 
 
        The behavior of this method is implementation specific, and is 
        not implemented by default.    The method should generally end 
        the resources in use by the result object and also cause any 
        subsequent iteration or row fetching to raise 
        :class:`.ResourceClosedError`. 
 
        .. versionadded:: 1.4.27 - ``.close()`` was previously not generally 
           available for all :class:`_engine.Result` classes, instead only 
           being available on the :class:`_engine.CursorResult` returned for 
           Core statement executions. As most other result objects, namely the 
           ones used by the ORM, are proxying a :class:`_engine.CursorResult` 
           in any case, this allows the underlying cursor result to be closed 
           from the outside facade for the case when the ORM query is using 
           the ``yield_per`` execution option where it does not immediately 
           exhaust and autoclose the database cursor. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._soft_close(hard=</span><span class="s3">True</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">_soft_closed(self) -&gt; bool:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">closed(self) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot;return ``True`` if this :class:`_engine.Result` reports .closed 
 
        .. versionadded:: 1.4.43 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s1">@_generative</span>
    <span class="s3">def </span><span class="s1">yield_per(self</span><span class="s4">, </span><span class="s1">num: int) -&gt; Self:</span>
        <span class="s2">&quot;&quot;&quot;Configure the row-fetching strategy to fetch ``num`` rows at a time. 
 
        This impacts the underlying behavior of the result when iterating over 
        the result object, or otherwise making use of  methods such as 
        :meth:`_engine.Result.fetchone` that return one row at a time.   Data 
        from the underlying cursor or other data source will be buffered up to 
        this many rows in memory, and the buffered collection will then be 
        yielded out one row at a time or as many rows are requested. Each time 
        the buffer clears, it will be refreshed to this many rows or as many 
        rows remain if fewer remain. 
 
        The :meth:`_engine.Result.yield_per` method is generally used in 
        conjunction with the 
        :paramref:`_engine.Connection.execution_options.stream_results` 
        execution option, which will allow the database dialect in use to make 
        use of a server side cursor, if the DBAPI supports a specific &quot;server 
        side cursor&quot; mode separate from its default mode of operation. 
 
        .. tip:: 
 
            Consider using the 
            :paramref:`_engine.Connection.execution_options.yield_per` 
            execution option, which will simultaneously set 
            :paramref:`_engine.Connection.execution_options.stream_results` 
            to ensure the use of server side cursors, as well as automatically 
            invoke the :meth:`_engine.Result.yield_per` method to establish 
            a fixed row buffer size at once. 
 
            The :paramref:`_engine.Connection.execution_options.yield_per` 
            execution option is available for ORM operations, with 
            :class:`_orm.Session`-oriented use described at 
            :ref:`orm_queryguide_yield_per`. The Core-only version which works 
            with :class:`_engine.Connection` is new as of SQLAlchemy 1.4.40. 
 
        .. versionadded:: 1.4 
 
        :param num: number of rows to fetch each time the buffer is refilled. 
         If set to a value below 1, fetches all rows for the next buffer. 
 
        .. seealso:: 
 
            :ref:`engine_stream_results` - describes Core behavior for 
            :meth:`_engine.Result.yield_per` 
 
            :ref:`orm_queryguide_yield_per` - in the :ref:`queryguide_toplevel` 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._yield_per = num</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s1">@_generative</span>
    <span class="s3">def </span><span class="s1">unique(self</span><span class="s4">, </span><span class="s1">strategy: Optional[_UniqueFilterType] = </span><span class="s3">None</span><span class="s1">) -&gt; Self:</span>
        <span class="s2">&quot;&quot;&quot;Apply unique filtering to the objects returned by this 
        :class:`_engine.Result`. 
 
        When this filter is applied with no arguments, the rows or objects 
        returned will filtered such that each row is returned uniquely. The 
        algorithm used to determine this uniqueness is by default the Python 
        hashing identity of the whole tuple.   In some cases a specialized 
        per-entity hashing scheme may be used, such as when using the ORM, a 
        scheme is applied which  works against the primary key identity of 
        returned objects. 
 
        The unique filter is applied **after all other filters**, which means 
        if the columns returned have been refined using a method such as the 
        :meth:`_engine.Result.columns` or :meth:`_engine.Result.scalars` 
        method, the uniquing is applied to **only the column or columns 
        returned**.   This occurs regardless of the order in which these 
        methods have been called upon the :class:`_engine.Result` object. 
 
        The unique filter also changes the calculus used for methods like 
        :meth:`_engine.Result.fetchmany` and :meth:`_engine.Result.partitions`. 
        When using :meth:`_engine.Result.unique`, these methods will continue 
        to yield the number of rows or objects requested, after uniquing 
        has been applied.  However, this necessarily impacts the buffering 
        behavior of the underlying cursor or datasource, such that multiple 
        underlying calls to ``cursor.fetchmany()`` may be necessary in order 
        to accumulate enough objects in order to provide a unique collection 
        of the requested size. 
 
        :param strategy: a callable that will be applied to rows or objects 
         being iterated, which should return an object that represents the 
         unique value of the row.   A Python ``set()`` is used to store 
         these identities.   If not passed, a default uniqueness strategy 
         is used which may have been assembled by the source of this 
         :class:`_engine.Result` object. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._unique_filter_state = (set()</span><span class="s4">, </span><span class="s1">strategy)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">columns(self</span><span class="s4">, </span><span class="s1">*col_expressions: _KeyIndexType) -&gt; Self:</span>
        <span class="s2">r&quot;&quot;&quot;Establish the columns that should be returned in each row. 
 
        This method may be used to limit the columns returned as well 
        as to reorder them.   The given list of expressions are normally 
        a series of integers or string key names.   They may also be 
        appropriate :class:`.ColumnElement` objects which correspond to 
        a given statement construct. 
 
        .. versionchanged:: 2.0  Due to a bug in 1.4, the 
           :meth:`_engine.Result.columns` method had an incorrect behavior 
           where calling upon the method with just one index would cause the 
           :class:`_engine.Result` object to yield scalar values rather than 
           :class:`_engine.Row` objects.   In version 2.0, this behavior 
           has been corrected such that calling upon 
           :meth:`_engine.Result.columns` with a single index will 
           produce a :class:`_engine.Result` object that continues 
           to yield :class:`_engine.Row` objects, which include 
           only a single column. 
 
        E.g.:: 
 
            statement = select(table.c.x, table.c.y, table.c.z) 
            result = connection.execute(statement) 
 
            for z, y in result.columns('z', 'y'): 
                # ... 
 
 
        Example of using the column objects from the statement itself:: 
 
            for z, y in result.columns( 
                    statement.selected_columns.c.z, 
                    statement.selected_columns.c.y 
            ): 
                # ... 
 
        .. versionadded:: 1.4 
 
        :param \*col_expressions: indicates columns to be returned.  Elements 
         may be integer row indexes, string column names, or appropriate 
         :class:`.ColumnElement` objects corresponding to a select construct. 
 
        :return: this :class:`_engine.Result` object with the modifications 
         given. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._column_slices(col_expressions)</span>

    <span class="s1">@overload</span>
    <span class="s3">def </span><span class="s1">scalars(self: Result[Tuple[_T]]) -&gt; ScalarResult[_T]: ...</span>

    <span class="s1">@overload</span>
    <span class="s3">def </span><span class="s1">scalars(</span>
        <span class="s1">self: Result[Tuple[_T]]</span><span class="s4">, </span><span class="s1">index: Literal[</span><span class="s6">0</span><span class="s1">]</span>
    <span class="s1">) -&gt; ScalarResult[_T]: ...</span>

    <span class="s1">@overload</span>
    <span class="s3">def </span><span class="s1">scalars(self</span><span class="s4">, </span><span class="s1">index: _KeyIndexType = </span><span class="s6">0</span><span class="s1">) -&gt; ScalarResult[Any]: ...</span>

    <span class="s3">def </span><span class="s1">scalars(self</span><span class="s4">, </span><span class="s1">index: _KeyIndexType = </span><span class="s6">0</span><span class="s1">) -&gt; ScalarResult[Any]:</span>
        <span class="s2">&quot;&quot;&quot;Return a :class:`_engine.ScalarResult` filtering object which 
        will return single elements rather than :class:`_row.Row` objects. 
 
        E.g.:: 
 
            &gt;&gt;&gt; result = conn.execute(text(&quot;select int_id from table&quot;)) 
            &gt;&gt;&gt; result.scalars().all() 
            [1, 2, 3] 
 
        When results are fetched from the :class:`_engine.ScalarResult` 
        filtering object, the single column-row that would be returned by the 
        :class:`_engine.Result` is instead returned as the column's value. 
 
        .. versionadded:: 1.4 
 
        :param index: integer or row key indicating the column to be fetched 
         from each row, defaults to ``0`` indicating the first column. 
 
        :return: a new :class:`_engine.ScalarResult` filtering object referring 
         to this :class:`_engine.Result` object. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">ScalarResult(self</span><span class="s4">, </span><span class="s1">index)</span>

    <span class="s3">def </span><span class="s1">_getter(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">key: _KeyIndexType</span><span class="s4">, </span><span class="s1">raiseerr: bool = </span><span class="s3">True</span>
    <span class="s1">) -&gt; Optional[Callable[[Row[Any]]</span><span class="s4">, </span><span class="s1">Any]]:</span>
        <span class="s2">&quot;&quot;&quot;return a callable that will retrieve the given key from a 
        :class:`_engine.Row`. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self._source_supports_scalars:</span>
            <span class="s3">raise </span><span class="s1">NotImplementedError(</span>
                <span class="s5">&quot;can't use this function in 'only scalars' mode&quot;</span>
            <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self._metadata._getter(key</span><span class="s4">, </span><span class="s1">raiseerr)</span>

    <span class="s3">def </span><span class="s1">_tuple_getter(self</span><span class="s4">, </span><span class="s1">keys: Sequence[_KeyIndexType]) -&gt; _TupleGetterType:</span>
        <span class="s2">&quot;&quot;&quot;return a callable that will retrieve the given keys from a 
        :class:`_engine.Row`. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self._source_supports_scalars:</span>
            <span class="s3">raise </span><span class="s1">NotImplementedError(</span>
                <span class="s5">&quot;can't use this function in 'only scalars' mode&quot;</span>
            <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self._metadata._row_as_tuple_getter(keys)</span>

    <span class="s3">def </span><span class="s1">mappings(self) -&gt; MappingResult:</span>
        <span class="s2">&quot;&quot;&quot;Apply a mappings filter to returned rows, returning an instance of 
        :class:`_engine.MappingResult`. 
 
        When this filter is applied, fetching rows will return 
        :class:`_engine.RowMapping` objects instead of :class:`_engine.Row` 
        objects. 
 
        .. versionadded:: 1.4 
 
        :return: a new :class:`_engine.MappingResult` filtering object 
         referring to this :class:`_engine.Result` object. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">MappingResult(self)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">t(self) -&gt; TupleResult[_TP]:</span>
        <span class="s2">&quot;&quot;&quot;Apply a &quot;typed tuple&quot; typing filter to returned rows. 
 
        The :attr:`_engine.Result.t` attribute is a synonym for 
        calling the :meth:`_engine.Result.tuples` method. 
 
        .. versionadded:: 2.0 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self  </span><span class="s0"># type: ignore</span>

    <span class="s3">def </span><span class="s1">tuples(self) -&gt; TupleResult[_TP]:</span>
        <span class="s2">&quot;&quot;&quot;Apply a &quot;typed tuple&quot; typing filter to returned rows. 
 
        This method returns the same :class:`_engine.Result` object 
        at runtime, 
        however annotates as returning a :class:`_engine.TupleResult` object 
        that will indicate to :pep:`484` typing tools that plain typed 
        ``Tuple`` instances are returned rather than rows.  This allows 
        tuple unpacking and ``__getitem__`` access of :class:`_engine.Row` 
        objects to by typed, for those cases where the statement invoked 
        itself included typing information. 
 
        .. versionadded:: 2.0 
 
        :return: the :class:`_engine.TupleResult` type at typing time. 
 
        .. seealso:: 
 
            :attr:`_engine.Result.t` - shorter synonym 
 
            :attr:`_engine.Row._t` - :class:`_engine.Row` version 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">self  </span><span class="s0"># type: ignore</span>

    <span class="s3">def </span><span class="s1">_raw_row_iterator(self) -&gt; Iterator[_RowData]:</span>
        <span class="s2">&quot;&quot;&quot;Return a safe iterator that yields raw row data. 
 
        This is used by the :meth:`_engine.Result.merge` method 
        to merge multiple compatible results together. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s3">def </span><span class="s1">__iter__(self) -&gt; Iterator[Row[_TP]]:</span>
        <span class="s3">return </span><span class="s1">self._iter_impl()</span>

    <span class="s3">def </span><span class="s1">__next__(self) -&gt; Row[_TP]:</span>
        <span class="s3">return </span><span class="s1">self._next_impl()</span>

    <span class="s3">def </span><span class="s1">partitions(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">size: Optional[int] = </span><span class="s3">None</span>
    <span class="s1">) -&gt; Iterator[Sequence[Row[_TP]]]:</span>
        <span class="s2">&quot;&quot;&quot;Iterate through sub-lists of rows of the size given. 
 
        Each list will be of the size given, excluding the last list to 
        be yielded, which may have a small number of rows.  No empty 
        lists will be yielded. 
 
        The result object is automatically closed when the iterator 
        is fully consumed. 
 
        Note that the backend driver will usually buffer the entire result 
        ahead of time unless the 
        :paramref:`.Connection.execution_options.stream_results` execution 
        option is used indicating that the driver should not pre-buffer 
        results, if possible.   Not all drivers support this option and 
        the option is silently ignored for those who do not. 
 
        When using the ORM, the :meth:`_engine.Result.partitions` method 
        is typically more effective from a memory perspective when it is 
        combined with use of the 
        :ref:`yield_per execution option &lt;orm_queryguide_yield_per&gt;`, 
        which instructs both the DBAPI driver to use server side cursors, 
        if available, as well as instructs the ORM loading internals to only 
        build a certain amount of ORM objects from a result at a time before 
        yielding them out. 
 
        .. versionadded:: 1.4 
 
        :param size: indicate the maximum number of rows to be present 
         in each list yielded.  If None, makes use of the value set by 
         the :meth:`_engine.Result.yield_per`, method, if it were called, 
         or the :paramref:`_engine.Connection.execution_options.yield_per` 
         execution option, which is equivalent in this regard.  If 
         yield_per weren't set, it makes use of the 
         :meth:`_engine.Result.fetchmany` default, which may be backend 
         specific and not well defined. 
 
        :return: iterator of lists 
 
        .. seealso:: 
 
            :ref:`engine_stream_results` 
 
            :ref:`orm_queryguide_yield_per` - in the :ref:`queryguide_toplevel` 
 
        &quot;&quot;&quot;</span>

        <span class="s1">getter = self._manyrow_getter</span>

        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s1">partition = getter(self</span><span class="s4">, </span><span class="s1">size)</span>
            <span class="s3">if </span><span class="s1">partition:</span>
                <span class="s3">yield </span><span class="s1">partition</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">break</span>

    <span class="s3">def </span><span class="s1">fetchall(self) -&gt; Sequence[Row[_TP]]:</span>
        <span class="s2">&quot;&quot;&quot;A synonym for the :meth:`_engine.Result.all` method.&quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">self._allrows()</span>

    <span class="s3">def </span><span class="s1">fetchone(self) -&gt; Optional[Row[_TP]]:</span>
        <span class="s2">&quot;&quot;&quot;Fetch one row. 
 
        When all rows are exhausted, returns None. 
 
        This method is provided for backwards compatibility with 
        SQLAlchemy 1.x.x. 
 
        To fetch the first row of a result only, use the 
        :meth:`_engine.Result.first` method.  To iterate through all 
        rows, iterate the :class:`_engine.Result` object directly. 
 
        :return: a :class:`_engine.Row` object if no filters are applied, 
         or ``None`` if no rows remain. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">row = self._onerow_getter(self)</span>
        <span class="s3">if </span><span class="s1">row </span><span class="s3">is </span><span class="s1">_NO_ROW:</span>
            <span class="s3">return None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">row</span>

    <span class="s3">def </span><span class="s1">fetchmany(self</span><span class="s4">, </span><span class="s1">size: Optional[int] = </span><span class="s3">None</span><span class="s1">) -&gt; Sequence[Row[_TP]]:</span>
        <span class="s2">&quot;&quot;&quot;Fetch many rows. 
 
        When all rows are exhausted, returns an empty sequence. 
 
        This method is provided for backwards compatibility with 
        SQLAlchemy 1.x.x. 
 
        To fetch rows in groups, use the :meth:`_engine.Result.partitions` 
        method. 
 
        :return: a sequence of :class:`_engine.Row` objects. 
 
        .. seealso:: 
 
            :meth:`_engine.Result.partitions` 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">self._manyrow_getter(self</span><span class="s4">, </span><span class="s1">size)</span>

    <span class="s3">def </span><span class="s1">all(self) -&gt; Sequence[Row[_TP]]:</span>
        <span class="s2">&quot;&quot;&quot;Return all rows in a sequence. 
 
        Closes the result set after invocation.   Subsequent invocations 
        will return an empty sequence. 
 
        .. versionadded:: 1.4 
 
        :return: a sequence of :class:`_engine.Row` objects. 
 
        .. seealso:: 
 
            :ref:`engine_stream_results` - How to stream a large result set 
            without loading it completely in python. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">self._allrows()</span>

    <span class="s3">def </span><span class="s1">first(self) -&gt; Optional[Row[_TP]]:</span>
        <span class="s2">&quot;&quot;&quot;Fetch the first row or ``None`` if no row is present. 
 
        Closes the result set and discards remaining rows. 
 
        .. note::  This method returns one **row**, e.g. tuple, by default. 
           To return exactly one single scalar value, that is, the first 
           column of the first row, use the 
           :meth:`_engine.Result.scalar` method, 
           or combine :meth:`_engine.Result.scalars` and 
           :meth:`_engine.Result.first`. 
 
           Additionally, in contrast to the behavior of the legacy  ORM 
           :meth:`_orm.Query.first` method, **no limit is applied** to the 
           SQL query which was invoked to produce this 
           :class:`_engine.Result`; 
           for a DBAPI driver that buffers results in memory before yielding 
           rows, all rows will be sent to the Python process and all but 
           the first row will be discarded. 
 
           .. seealso:: 
 
                :ref:`migration_20_unify_select` 
 
        :return: a :class:`_engine.Row` object, or None 
         if no rows remain. 
 
        .. seealso:: 
 
            :meth:`_engine.Result.scalar` 
 
            :meth:`_engine.Result.one` 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">self._only_one_row(</span>
            <span class="s1">raise_for_second_row=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">raise_for_none=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">scalar=</span><span class="s3">False</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">one_or_none(self) -&gt; Optional[Row[_TP]]:</span>
        <span class="s2">&quot;&quot;&quot;Return at most one result or raise an exception. 
 
        Returns ``None`` if the result has no rows. 
        Raises :class:`.MultipleResultsFound` 
        if multiple rows are returned. 
 
        .. versionadded:: 1.4 
 
        :return: The first :class:`_engine.Row` or ``None`` if no row 
         is available. 
 
        :raises: :class:`.MultipleResultsFound` 
 
        .. seealso:: 
 
            :meth:`_engine.Result.first` 
 
            :meth:`_engine.Result.one` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._only_one_row(</span>
            <span class="s1">raise_for_second_row=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">raise_for_none=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">scalar=</span><span class="s3">False</span>
        <span class="s1">)</span>

    <span class="s1">@overload</span>
    <span class="s3">def </span><span class="s1">scalar_one(self: Result[Tuple[_T]]) -&gt; _T: ...</span>

    <span class="s1">@overload</span>
    <span class="s3">def </span><span class="s1">scalar_one(self) -&gt; Any: ...</span>

    <span class="s3">def </span><span class="s1">scalar_one(self) -&gt; Any:</span>
        <span class="s2">&quot;&quot;&quot;Return exactly one scalar result or raise an exception. 
 
        This is equivalent to calling :meth:`_engine.Result.scalars` and 
        then :meth:`_engine.ScalarResult.one`. 
 
        .. seealso:: 
 
            :meth:`_engine.ScalarResult.one` 
 
            :meth:`_engine.Result.scalars` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._only_one_row(</span>
            <span class="s1">raise_for_second_row=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">raise_for_none=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">scalar=</span><span class="s3">True</span>
        <span class="s1">)</span>

    <span class="s1">@overload</span>
    <span class="s3">def </span><span class="s1">scalar_one_or_none(self: Result[Tuple[_T]]) -&gt; Optional[_T]: ...</span>

    <span class="s1">@overload</span>
    <span class="s3">def </span><span class="s1">scalar_one_or_none(self) -&gt; Optional[Any]: ...</span>

    <span class="s3">def </span><span class="s1">scalar_one_or_none(self) -&gt; Optional[Any]:</span>
        <span class="s2">&quot;&quot;&quot;Return exactly one scalar result or ``None``. 
 
        This is equivalent to calling :meth:`_engine.Result.scalars` and 
        then :meth:`_engine.ScalarResult.one_or_none`. 
 
        .. seealso:: 
 
            :meth:`_engine.ScalarResult.one_or_none` 
 
            :meth:`_engine.Result.scalars` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._only_one_row(</span>
            <span class="s1">raise_for_second_row=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">raise_for_none=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">scalar=</span><span class="s3">True</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">one(self) -&gt; Row[_TP]:</span>
        <span class="s2">&quot;&quot;&quot;Return exactly one row or raise an exception. 
 
        Raises :class:`.NoResultFound` if the result returns no 
        rows, or :class:`.MultipleResultsFound` if multiple rows 
        would be returned. 
 
        .. note::  This method returns one **row**, e.g. tuple, by default. 
           To return exactly one single scalar value, that is, the first 
           column of the first row, use the 
           :meth:`_engine.Result.scalar_one` method, or combine 
           :meth:`_engine.Result.scalars` and 
           :meth:`_engine.Result.one`. 
 
        .. versionadded:: 1.4 
 
        :return: The first :class:`_engine.Row`. 
 
        :raises: :class:`.MultipleResultsFound`, :class:`.NoResultFound` 
 
        .. seealso:: 
 
            :meth:`_engine.Result.first` 
 
            :meth:`_engine.Result.one_or_none` 
 
            :meth:`_engine.Result.scalar_one` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._only_one_row(</span>
            <span class="s1">raise_for_second_row=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">raise_for_none=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">scalar=</span><span class="s3">False</span>
        <span class="s1">)</span>

    <span class="s1">@overload</span>
    <span class="s3">def </span><span class="s1">scalar(self: Result[Tuple[_T]]) -&gt; Optional[_T]: ...</span>

    <span class="s1">@overload</span>
    <span class="s3">def </span><span class="s1">scalar(self) -&gt; Any: ...</span>

    <span class="s3">def </span><span class="s1">scalar(self) -&gt; Any:</span>
        <span class="s2">&quot;&quot;&quot;Fetch the first column of the first row, and close the result set. 
 
        Returns ``None`` if there are no rows to fetch. 
 
        No validation is performed to test if additional rows remain. 
 
        After calling this method, the object is fully closed, 
        e.g. the :meth:`_engine.CursorResult.close` 
        method will have been called. 
 
        :return: a Python scalar value, or ``None`` if no rows remain. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._only_one_row(</span>
            <span class="s1">raise_for_second_row=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">raise_for_none=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">scalar=</span><span class="s3">True</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">freeze(self) -&gt; FrozenResult[_TP]:</span>
        <span class="s2">&quot;&quot;&quot;Return a callable object that will produce copies of this 
        :class:`_engine.Result` when invoked. 
 
        The callable object returned is an instance of 
        :class:`_engine.FrozenResult`. 
 
        This is used for result set caching.  The method must be called 
        on the result when it has been unconsumed, and calling the method 
        will consume the result fully.   When the :class:`_engine.FrozenResult` 
        is retrieved from a cache, it can be called any number of times where 
        it will produce a new :class:`_engine.Result` object each time 
        against its stored set of rows. 
 
        .. seealso:: 
 
            :ref:`do_orm_execute_re_executing` - example usage within the 
            ORM to implement a result-set cache. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">FrozenResult(self)</span>

    <span class="s3">def </span><span class="s1">merge(self</span><span class="s4">, </span><span class="s1">*others: Result[Any]) -&gt; MergedResult[_TP]:</span>
        <span class="s2">&quot;&quot;&quot;Merge this :class:`_engine.Result` with other compatible result 
        objects. 
 
        The object returned is an instance of :class:`_engine.MergedResult`, 
        which will be composed of iterators from the given result 
        objects. 
 
        The new result will use the metadata from this result object. 
        The subsequent result objects must be against an identical 
        set of result / cursor metadata, otherwise the behavior is 
        undefined. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">MergedResult(self._metadata</span><span class="s4">, </span><span class="s1">(self</span><span class="s4">,</span><span class="s1">) + others)</span>


<span class="s3">class </span><span class="s1">FilterResult(ResultInternal[_R]):</span>
    <span class="s2">&quot;&quot;&quot;A wrapper for a :class:`_engine.Result` that returns objects other than 
    :class:`_engine.Row` objects, such as dictionaries or scalar objects. 
 
    :class:`_engine.FilterResult` is the common base for additional result 
    APIs including :class:`_engine.MappingResult`, 
    :class:`_engine.ScalarResult` and :class:`_engine.AsyncResult`. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = (</span>
        <span class="s5">&quot;_real_result&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;_post_creational_filter&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;_metadata&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;_unique_filter_state&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;__dict__&quot;</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">_post_creational_filter: Optional[Callable[[Any]</span><span class="s4">, </span><span class="s1">Any]]</span>

    <span class="s1">_real_result: Result[Any]</span>

    <span class="s3">def </span><span class="s1">__enter__(self) -&gt; Self:</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">__exit__(self</span><span class="s4">, </span><span class="s1">type_: Any</span><span class="s4">, </span><span class="s1">value: Any</span><span class="s4">, </span><span class="s1">traceback: Any) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">self._real_result.__exit__(type_</span><span class="s4">, </span><span class="s1">value</span><span class="s4">, </span><span class="s1">traceback)</span>

    <span class="s1">@_generative</span>
    <span class="s3">def </span><span class="s1">yield_per(self</span><span class="s4">, </span><span class="s1">num: int) -&gt; Self:</span>
        <span class="s2">&quot;&quot;&quot;Configure the row-fetching strategy to fetch ``num`` rows at a time. 
 
        The :meth:`_engine.FilterResult.yield_per` method is a pass through 
        to the :meth:`_engine.Result.yield_per` method.  See that method's 
        documentation for usage notes. 
 
        .. versionadded:: 1.4.40 - added :meth:`_engine.FilterResult.yield_per` 
           so that the method is available on all result set implementations 
 
        .. seealso:: 
 
            :ref:`engine_stream_results` - describes Core behavior for 
            :meth:`_engine.Result.yield_per` 
 
            :ref:`orm_queryguide_yield_per` - in the :ref:`queryguide_toplevel` 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._real_result = self._real_result.yield_per(num)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_soft_close(self</span><span class="s4">, </span><span class="s1">hard: bool = </span><span class="s3">False</span><span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">self._real_result._soft_close(hard=hard)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">_soft_closed(self) -&gt; bool:</span>
        <span class="s3">return </span><span class="s1">self._real_result._soft_closed</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">closed(self) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot;Return ``True`` if the underlying :class:`_engine.Result` reports 
        closed 
 
        .. versionadded:: 1.4.43 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._real_result.closed</span>

    <span class="s3">def </span><span class="s1">close(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Close this :class:`_engine.FilterResult`. 
 
        .. versionadded:: 1.4.43 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._real_result.close()</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">_attributes(self) -&gt; Dict[Any</span><span class="s4">, </span><span class="s1">Any]:</span>
        <span class="s3">return </span><span class="s1">self._real_result._attributes</span>

    <span class="s3">def </span><span class="s1">_fetchiter_impl(self) -&gt; Iterator[_InterimRowType[Row[Any]]]:</span>
        <span class="s3">return </span><span class="s1">self._real_result._fetchiter_impl()</span>

    <span class="s3">def </span><span class="s1">_fetchone_impl(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">hard_close: bool = </span><span class="s3">False</span>
    <span class="s1">) -&gt; Optional[_InterimRowType[Row[Any]]]:</span>
        <span class="s3">return </span><span class="s1">self._real_result._fetchone_impl(hard_close=hard_close)</span>

    <span class="s3">def </span><span class="s1">_fetchall_impl(self) -&gt; List[_InterimRowType[Row[Any]]]:</span>
        <span class="s3">return </span><span class="s1">self._real_result._fetchall_impl()</span>

    <span class="s3">def </span><span class="s1">_fetchmany_impl(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">size: Optional[int] = </span><span class="s3">None</span>
    <span class="s1">) -&gt; List[_InterimRowType[Row[Any]]]:</span>
        <span class="s3">return </span><span class="s1">self._real_result._fetchmany_impl(size=size)</span>


<span class="s3">class </span><span class="s1">ScalarResult(FilterResult[_R]):</span>
    <span class="s2">&quot;&quot;&quot;A wrapper for a :class:`_engine.Result` that returns scalar values 
    rather than :class:`_row.Row` values. 
 
    The :class:`_engine.ScalarResult` object is acquired by calling the 
    :meth:`_engine.Result.scalars` method. 
 
    A special limitation of :class:`_engine.ScalarResult` is that it has 
    no ``fetchone()`` method; since the semantics of ``fetchone()`` are that 
    the ``None`` value indicates no more results, this is not compatible 
    with :class:`_engine.ScalarResult` since there is no way to distinguish 
    between ``None`` as a row value versus ``None`` as an indicator.  Use 
    ``next(result)`` to receive values individually. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = ()</span>

    <span class="s1">_generate_rows = </span><span class="s3">False</span>

    <span class="s1">_post_creational_filter: Optional[Callable[[Any]</span><span class="s4">, </span><span class="s1">Any]]</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">real_result: Result[Any]</span><span class="s4">, </span><span class="s1">index: _KeyIndexType):</span>
        <span class="s1">self._real_result = real_result</span>

        <span class="s3">if </span><span class="s1">real_result._source_supports_scalars:</span>
            <span class="s1">self._metadata = real_result._metadata</span>
            <span class="s1">self._post_creational_filter = </span><span class="s3">None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self._metadata = real_result._metadata._reduce([index])</span>
            <span class="s1">self._post_creational_filter = operator.itemgetter(</span><span class="s6">0</span><span class="s1">)</span>

        <span class="s1">self._unique_filter_state = real_result._unique_filter_state</span>

    <span class="s3">def </span><span class="s1">unique(self</span><span class="s4">, </span><span class="s1">strategy: Optional[_UniqueFilterType] = </span><span class="s3">None</span><span class="s1">) -&gt; Self:</span>
        <span class="s2">&quot;&quot;&quot;Apply unique filtering to the objects returned by this 
        :class:`_engine.ScalarResult`. 
 
        See :meth:`_engine.Result.unique` for usage details. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._unique_filter_state = (set()</span><span class="s4">, </span><span class="s1">strategy)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">partitions(self</span><span class="s4">, </span><span class="s1">size: Optional[int] = </span><span class="s3">None</span><span class="s1">) -&gt; Iterator[Sequence[_R]]:</span>
        <span class="s2">&quot;&quot;&quot;Iterate through sub-lists of elements of the size given. 
 
        Equivalent to :meth:`_engine.Result.partitions` except that 
        scalar values, rather than :class:`_engine.Row` objects, 
        are returned. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">getter = self._manyrow_getter</span>

        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s1">partition = getter(self</span><span class="s4">, </span><span class="s1">size)</span>
            <span class="s3">if </span><span class="s1">partition:</span>
                <span class="s3">yield </span><span class="s1">partition</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">break</span>

    <span class="s3">def </span><span class="s1">fetchall(self) -&gt; Sequence[_R]:</span>
        <span class="s2">&quot;&quot;&quot;A synonym for the :meth:`_engine.ScalarResult.all` method.&quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">self._allrows()</span>

    <span class="s3">def </span><span class="s1">fetchmany(self</span><span class="s4">, </span><span class="s1">size: Optional[int] = </span><span class="s3">None</span><span class="s1">) -&gt; Sequence[_R]:</span>
        <span class="s2">&quot;&quot;&quot;Fetch many objects. 
 
        Equivalent to :meth:`_engine.Result.fetchmany` except that 
        scalar values, rather than :class:`_engine.Row` objects, 
        are returned. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._manyrow_getter(self</span><span class="s4">, </span><span class="s1">size)</span>

    <span class="s3">def </span><span class="s1">all(self) -&gt; Sequence[_R]:</span>
        <span class="s2">&quot;&quot;&quot;Return all scalar values in a sequence. 
 
        Equivalent to :meth:`_engine.Result.all` except that 
        scalar values, rather than :class:`_engine.Row` objects, 
        are returned. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._allrows()</span>

    <span class="s3">def </span><span class="s1">__iter__(self) -&gt; Iterator[_R]:</span>
        <span class="s3">return </span><span class="s1">self._iter_impl()</span>

    <span class="s3">def </span><span class="s1">__next__(self) -&gt; _R:</span>
        <span class="s3">return </span><span class="s1">self._next_impl()</span>

    <span class="s3">def </span><span class="s1">first(self) -&gt; Optional[_R]:</span>
        <span class="s2">&quot;&quot;&quot;Fetch the first object or ``None`` if no object is present. 
 
        Equivalent to :meth:`_engine.Result.first` except that 
        scalar values, rather than :class:`_engine.Row` objects, 
        are returned. 
 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._only_one_row(</span>
            <span class="s1">raise_for_second_row=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">raise_for_none=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">scalar=</span><span class="s3">False</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">one_or_none(self) -&gt; Optional[_R]:</span>
        <span class="s2">&quot;&quot;&quot;Return at most one object or raise an exception. 
 
        Equivalent to :meth:`_engine.Result.one_or_none` except that 
        scalar values, rather than :class:`_engine.Row` objects, 
        are returned. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._only_one_row(</span>
            <span class="s1">raise_for_second_row=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">raise_for_none=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">scalar=</span><span class="s3">False</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">one(self) -&gt; _R:</span>
        <span class="s2">&quot;&quot;&quot;Return exactly one object or raise an exception. 
 
        Equivalent to :meth:`_engine.Result.one` except that 
        scalar values, rather than :class:`_engine.Row` objects, 
        are returned. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._only_one_row(</span>
            <span class="s1">raise_for_second_row=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">raise_for_none=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">scalar=</span><span class="s3">False</span>
        <span class="s1">)</span>


<span class="s3">class </span><span class="s1">TupleResult(FilterResult[_R]</span><span class="s4">, </span><span class="s1">util.TypingOnly):</span>
    <span class="s2">&quot;&quot;&quot;A :class:`_engine.Result` that's typed as returning plain 
    Python tuples instead of rows. 
 
    Since :class:`_engine.Row` acts like a tuple in every way already, 
    this class is a typing only class, regular :class:`_engine.Result` is 
    still used at runtime. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = ()</span>

    <span class="s3">if </span><span class="s1">TYPE_CHECKING:</span>

        <span class="s3">def </span><span class="s1">partitions(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">size: Optional[int] = </span><span class="s3">None</span>
        <span class="s1">) -&gt; Iterator[Sequence[_R]]:</span>
            <span class="s2">&quot;&quot;&quot;Iterate through sub-lists of elements of the size given. 
 
            Equivalent to :meth:`_engine.Result.partitions` except that 
            tuple values, rather than :class:`_engine.Row` objects, 
            are returned. 
 
            &quot;&quot;&quot;</span>
            <span class="s1">...</span>

        <span class="s3">def </span><span class="s1">fetchone(self) -&gt; Optional[_R]:</span>
            <span class="s2">&quot;&quot;&quot;Fetch one tuple. 
 
            Equivalent to :meth:`_engine.Result.fetchone` except that 
            tuple values, rather than :class:`_engine.Row` 
            objects, are returned. 
 
            &quot;&quot;&quot;</span>
            <span class="s1">...</span>

        <span class="s3">def </span><span class="s1">fetchall(self) -&gt; Sequence[_R]:</span>
            <span class="s2">&quot;&quot;&quot;A synonym for the :meth:`_engine.ScalarResult.all` method.&quot;&quot;&quot;</span>
            <span class="s1">...</span>

        <span class="s3">def </span><span class="s1">fetchmany(self</span><span class="s4">, </span><span class="s1">size: Optional[int] = </span><span class="s3">None</span><span class="s1">) -&gt; Sequence[_R]:</span>
            <span class="s2">&quot;&quot;&quot;Fetch many objects. 
 
            Equivalent to :meth:`_engine.Result.fetchmany` except that 
            tuple values, rather than :class:`_engine.Row` objects, 
            are returned. 
 
            &quot;&quot;&quot;</span>
            <span class="s1">...</span>

        <span class="s3">def </span><span class="s1">all(self) -&gt; Sequence[_R]:  </span><span class="s0"># noqa: A001</span>
            <span class="s2">&quot;&quot;&quot;Return all scalar values in a sequence. 
 
            Equivalent to :meth:`_engine.Result.all` except that 
            tuple values, rather than :class:`_engine.Row` objects, 
            are returned. 
 
            &quot;&quot;&quot;</span>
            <span class="s1">...</span>

        <span class="s3">def </span><span class="s1">__iter__(self) -&gt; Iterator[_R]: ...</span>

        <span class="s3">def </span><span class="s1">__next__(self) -&gt; _R: ...</span>

        <span class="s3">def </span><span class="s1">first(self) -&gt; Optional[_R]:</span>
            <span class="s2">&quot;&quot;&quot;Fetch the first object or ``None`` if no object is present. 
 
            Equivalent to :meth:`_engine.Result.first` except that 
            tuple values, rather than :class:`_engine.Row` objects, 
            are returned. 
 
 
            &quot;&quot;&quot;</span>
            <span class="s1">...</span>

        <span class="s3">def </span><span class="s1">one_or_none(self) -&gt; Optional[_R]:</span>
            <span class="s2">&quot;&quot;&quot;Return at most one object or raise an exception. 
 
            Equivalent to :meth:`_engine.Result.one_or_none` except that 
            tuple values, rather than :class:`_engine.Row` objects, 
            are returned. 
 
            &quot;&quot;&quot;</span>
            <span class="s1">...</span>

        <span class="s3">def </span><span class="s1">one(self) -&gt; _R:</span>
            <span class="s2">&quot;&quot;&quot;Return exactly one object or raise an exception. 
 
            Equivalent to :meth:`_engine.Result.one` except that 
            tuple values, rather than :class:`_engine.Row` objects, 
            are returned. 
 
            &quot;&quot;&quot;</span>
            <span class="s1">...</span>

        <span class="s1">@overload</span>
        <span class="s3">def </span><span class="s1">scalar_one(self: TupleResult[Tuple[_T]]) -&gt; _T: ...</span>

        <span class="s1">@overload</span>
        <span class="s3">def </span><span class="s1">scalar_one(self) -&gt; Any: ...</span>

        <span class="s3">def </span><span class="s1">scalar_one(self) -&gt; Any:</span>
            <span class="s2">&quot;&quot;&quot;Return exactly one scalar result or raise an exception. 
 
            This is equivalent to calling :meth:`_engine.Result.scalars` 
            and then :meth:`_engine.ScalarResult.one`. 
 
            .. seealso:: 
 
                :meth:`_engine.ScalarResult.one` 
 
                :meth:`_engine.Result.scalars` 
 
            &quot;&quot;&quot;</span>
            <span class="s1">...</span>

        <span class="s1">@overload</span>
        <span class="s3">def </span><span class="s1">scalar_one_or_none(</span>
            <span class="s1">self: TupleResult[Tuple[_T]]</span><span class="s4">,</span>
        <span class="s1">) -&gt; Optional[_T]: ...</span>

        <span class="s1">@overload</span>
        <span class="s3">def </span><span class="s1">scalar_one_or_none(self) -&gt; Optional[Any]: ...</span>

        <span class="s3">def </span><span class="s1">scalar_one_or_none(self) -&gt; Optional[Any]:</span>
            <span class="s2">&quot;&quot;&quot;Return exactly one or no scalar result. 
 
            This is equivalent to calling :meth:`_engine.Result.scalars` 
            and then :meth:`_engine.ScalarResult.one_or_none`. 
 
            .. seealso:: 
 
                :meth:`_engine.ScalarResult.one_or_none` 
 
                :meth:`_engine.Result.scalars` 
 
            &quot;&quot;&quot;</span>
            <span class="s1">...</span>

        <span class="s1">@overload</span>
        <span class="s3">def </span><span class="s1">scalar(self: TupleResult[Tuple[_T]]) -&gt; Optional[_T]: ...</span>

        <span class="s1">@overload</span>
        <span class="s3">def </span><span class="s1">scalar(self) -&gt; Any: ...</span>

        <span class="s3">def </span><span class="s1">scalar(self) -&gt; Any:</span>
            <span class="s2">&quot;&quot;&quot;Fetch the first column of the first row, and close the result 
            set. 
 
            Returns ``None`` if there are no rows to fetch. 
 
            No validation is performed to test if additional rows remain. 
 
            After calling this method, the object is fully closed, 
            e.g. the :meth:`_engine.CursorResult.close` 
            method will have been called. 
 
            :return: a Python scalar value , or ``None`` if no rows remain. 
 
            &quot;&quot;&quot;</span>
            <span class="s1">...</span>


<span class="s3">class </span><span class="s1">MappingResult(_WithKeys</span><span class="s4">, </span><span class="s1">FilterResult[RowMapping]):</span>
    <span class="s2">&quot;&quot;&quot;A wrapper for a :class:`_engine.Result` that returns dictionary values 
    rather than :class:`_engine.Row` values. 
 
    The :class:`_engine.MappingResult` object is acquired by calling the 
    :meth:`_engine.Result.mappings` method. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = ()</span>

    <span class="s1">_generate_rows = </span><span class="s3">True</span>

    <span class="s1">_post_creational_filter = operator.attrgetter(</span><span class="s5">&quot;_mapping&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">result: Result[Any]):</span>
        <span class="s1">self._real_result = result</span>
        <span class="s1">self._unique_filter_state = result._unique_filter_state</span>
        <span class="s1">self._metadata = result._metadata</span>
        <span class="s3">if </span><span class="s1">result._source_supports_scalars:</span>
            <span class="s1">self._metadata = self._metadata._reduce([</span><span class="s6">0</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">unique(self</span><span class="s4">, </span><span class="s1">strategy: Optional[_UniqueFilterType] = </span><span class="s3">None</span><span class="s1">) -&gt; Self:</span>
        <span class="s2">&quot;&quot;&quot;Apply unique filtering to the objects returned by this 
        :class:`_engine.MappingResult`. 
 
        See :meth:`_engine.Result.unique` for usage details. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._unique_filter_state = (set()</span><span class="s4">, </span><span class="s1">strategy)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">columns(self</span><span class="s4">, </span><span class="s1">*col_expressions: _KeyIndexType) -&gt; Self:</span>
        <span class="s2">r&quot;&quot;&quot;Establish the columns that should be returned in each row.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._column_slices(col_expressions)</span>

    <span class="s3">def </span><span class="s1">partitions(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">size: Optional[int] = </span><span class="s3">None</span>
    <span class="s1">) -&gt; Iterator[Sequence[RowMapping]]:</span>
        <span class="s2">&quot;&quot;&quot;Iterate through sub-lists of elements of the size given. 
 
        Equivalent to :meth:`_engine.Result.partitions` except that 
        :class:`_engine.RowMapping` values, rather than :class:`_engine.Row` 
        objects, are returned. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">getter = self._manyrow_getter</span>

        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s1">partition = getter(self</span><span class="s4">, </span><span class="s1">size)</span>
            <span class="s3">if </span><span class="s1">partition:</span>
                <span class="s3">yield </span><span class="s1">partition</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">break</span>

    <span class="s3">def </span><span class="s1">fetchall(self) -&gt; Sequence[RowMapping]:</span>
        <span class="s2">&quot;&quot;&quot;A synonym for the :meth:`_engine.MappingResult.all` method.&quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">self._allrows()</span>

    <span class="s3">def </span><span class="s1">fetchone(self) -&gt; Optional[RowMapping]:</span>
        <span class="s2">&quot;&quot;&quot;Fetch one object. 
 
        Equivalent to :meth:`_engine.Result.fetchone` except that 
        :class:`_engine.RowMapping` values, rather than :class:`_engine.Row` 
        objects, are returned. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">row = self._onerow_getter(self)</span>
        <span class="s3">if </span><span class="s1">row </span><span class="s3">is </span><span class="s1">_NO_ROW:</span>
            <span class="s3">return None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">row</span>

    <span class="s3">def </span><span class="s1">fetchmany(self</span><span class="s4">, </span><span class="s1">size: Optional[int] = </span><span class="s3">None</span><span class="s1">) -&gt; Sequence[RowMapping]:</span>
        <span class="s2">&quot;&quot;&quot;Fetch many objects. 
 
        Equivalent to :meth:`_engine.Result.fetchmany` except that 
        :class:`_engine.RowMapping` values, rather than :class:`_engine.Row` 
        objects, are returned. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">self._manyrow_getter(self</span><span class="s4">, </span><span class="s1">size)</span>

    <span class="s3">def </span><span class="s1">all(self) -&gt; Sequence[RowMapping]:</span>
        <span class="s2">&quot;&quot;&quot;Return all scalar values in a sequence. 
 
        Equivalent to :meth:`_engine.Result.all` except that 
        :class:`_engine.RowMapping` values, rather than :class:`_engine.Row` 
        objects, are returned. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">self._allrows()</span>

    <span class="s3">def </span><span class="s1">__iter__(self) -&gt; Iterator[RowMapping]:</span>
        <span class="s3">return </span><span class="s1">self._iter_impl()</span>

    <span class="s3">def </span><span class="s1">__next__(self) -&gt; RowMapping:</span>
        <span class="s3">return </span><span class="s1">self._next_impl()</span>

    <span class="s3">def </span><span class="s1">first(self) -&gt; Optional[RowMapping]:</span>
        <span class="s2">&quot;&quot;&quot;Fetch the first object or ``None`` if no object is present. 
 
        Equivalent to :meth:`_engine.Result.first` except that 
        :class:`_engine.RowMapping` values, rather than :class:`_engine.Row` 
        objects, are returned. 
 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._only_one_row(</span>
            <span class="s1">raise_for_second_row=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">raise_for_none=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">scalar=</span><span class="s3">False</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">one_or_none(self) -&gt; Optional[RowMapping]:</span>
        <span class="s2">&quot;&quot;&quot;Return at most one object or raise an exception. 
 
        Equivalent to :meth:`_engine.Result.one_or_none` except that 
        :class:`_engine.RowMapping` values, rather than :class:`_engine.Row` 
        objects, are returned. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._only_one_row(</span>
            <span class="s1">raise_for_second_row=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">raise_for_none=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">scalar=</span><span class="s3">False</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">one(self) -&gt; RowMapping:</span>
        <span class="s2">&quot;&quot;&quot;Return exactly one object or raise an exception. 
 
        Equivalent to :meth:`_engine.Result.one` except that 
        :class:`_engine.RowMapping` values, rather than :class:`_engine.Row` 
        objects, are returned. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._only_one_row(</span>
            <span class="s1">raise_for_second_row=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">raise_for_none=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">scalar=</span><span class="s3">False</span>
        <span class="s1">)</span>


<span class="s3">class </span><span class="s1">FrozenResult(Generic[_TP]):</span>
    <span class="s2">&quot;&quot;&quot;Represents a :class:`_engine.Result` object in a &quot;frozen&quot; state suitable 
    for caching. 
 
    The :class:`_engine.FrozenResult` object is returned from the 
    :meth:`_engine.Result.freeze` method of any :class:`_engine.Result` 
    object. 
 
    A new iterable :class:`_engine.Result` object is generated from a fixed 
    set of data each time the :class:`_engine.FrozenResult` is invoked as 
    a callable:: 
 
 
        result = connection.execute(query) 
 
        frozen = result.freeze() 
 
        unfrozen_result_one = frozen() 
 
        for row in unfrozen_result_one: 
            print(row) 
 
        unfrozen_result_two = frozen() 
        rows = unfrozen_result_two.all() 
 
        # ... etc 
 
    .. versionadded:: 1.4 
 
    .. seealso:: 
 
        :ref:`do_orm_execute_re_executing` - example usage within the 
        ORM to implement a result-set cache. 
 
        :func:`_orm.loading.merge_frozen_result` - ORM function to merge 
        a frozen result back into a :class:`_orm.Session`. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">data: Sequence[Any]</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">result: Result[_TP]):</span>
        <span class="s1">self.metadata = result._metadata._for_freeze()</span>
        <span class="s1">self._source_supports_scalars = result._source_supports_scalars</span>
        <span class="s1">self._attributes = result._attributes</span>

        <span class="s3">if </span><span class="s1">self._source_supports_scalars:</span>
            <span class="s1">self.data = list(result._raw_row_iterator())</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.data = result.fetchall()</span>

    <span class="s3">def </span><span class="s1">rewrite_rows(self) -&gt; Sequence[Sequence[Any]]:</span>
        <span class="s3">if </span><span class="s1">self._source_supports_scalars:</span>
            <span class="s3">return </span><span class="s1">[[elem] </span><span class="s3">for </span><span class="s1">elem </span><span class="s3">in </span><span class="s1">self.data]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">[list(row) </span><span class="s3">for </span><span class="s1">row </span><span class="s3">in </span><span class="s1">self.data]</span>

    <span class="s3">def </span><span class="s1">with_new_rows(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">tuple_data: Sequence[Row[_TP]]</span>
    <span class="s1">) -&gt; FrozenResult[_TP]:</span>
        <span class="s1">fr = FrozenResult.__new__(FrozenResult)</span>
        <span class="s1">fr.metadata = self.metadata</span>
        <span class="s1">fr._attributes = self._attributes</span>
        <span class="s1">fr._source_supports_scalars = self._source_supports_scalars</span>

        <span class="s3">if </span><span class="s1">self._source_supports_scalars:</span>
            <span class="s1">fr.data = [d[</span><span class="s6">0</span><span class="s1">] </span><span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">tuple_data]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">fr.data = tuple_data</span>
        <span class="s3">return </span><span class="s1">fr</span>

    <span class="s3">def </span><span class="s1">__call__(self) -&gt; Result[_TP]:</span>
        <span class="s1">result: IteratorResult[_TP] = IteratorResult(</span>
            <span class="s1">self.metadata</span><span class="s4">, </span><span class="s1">iter(self.data)</span>
        <span class="s1">)</span>
        <span class="s1">result._attributes = self._attributes</span>
        <span class="s1">result._source_supports_scalars = self._source_supports_scalars</span>
        <span class="s3">return </span><span class="s1">result</span>


<span class="s3">class </span><span class="s1">IteratorResult(Result[_TP]):</span>
    <span class="s2">&quot;&quot;&quot;A :class:`_engine.Result` that gets data from a Python iterator of 
    :class:`_engine.Row` objects or similar row-like data. 
 
    .. versionadded:: 1.4 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_hard_closed = </span><span class="s3">False</span>
    <span class="s1">_soft_closed = </span><span class="s3">False</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">cursor_metadata: ResultMetaData</span><span class="s4">,</span>
        <span class="s1">iterator: Iterator[_InterimSupportsScalarsRowType]</span><span class="s4">,</span>
        <span class="s1">raw: Optional[Result[Any]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_source_supports_scalars: bool = </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s1">):</span>
        <span class="s1">self._metadata = cursor_metadata</span>
        <span class="s1">self.iterator = iterator</span>
        <span class="s1">self.raw = raw</span>
        <span class="s1">self._source_supports_scalars = _source_supports_scalars</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">closed(self) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot;Return ``True`` if this :class:`_engine.IteratorResult` has 
        been closed 
 
        .. versionadded:: 1.4.43 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._hard_closed</span>

    <span class="s3">def </span><span class="s1">_soft_close(self</span><span class="s4">, </span><span class="s1">hard: bool = </span><span class="s3">False</span><span class="s4">, </span><span class="s1">**kw: Any) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">hard:</span>
            <span class="s1">self._hard_closed = </span><span class="s3">True</span>
        <span class="s3">if </span><span class="s1">self.raw </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.raw._soft_close(hard=hard</span><span class="s4">, </span><span class="s1">**kw)</span>
        <span class="s1">self.iterator = iter([])</span>
        <span class="s1">self._reset_memoizations()</span>
        <span class="s1">self._soft_closed = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">_raise_hard_closed(self) -&gt; NoReturn:</span>
        <span class="s3">raise </span><span class="s1">exc.ResourceClosedError(</span><span class="s5">&quot;This result object is closed.&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_raw_row_iterator(self) -&gt; Iterator[_RowData]:</span>
        <span class="s3">return </span><span class="s1">self.iterator</span>

    <span class="s3">def </span><span class="s1">_fetchiter_impl(self) -&gt; Iterator[_InterimSupportsScalarsRowType]:</span>
        <span class="s3">if </span><span class="s1">self._hard_closed:</span>
            <span class="s1">self._raise_hard_closed()</span>
        <span class="s3">return </span><span class="s1">self.iterator</span>

    <span class="s3">def </span><span class="s1">_fetchone_impl(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">hard_close: bool = </span><span class="s3">False</span>
    <span class="s1">) -&gt; Optional[_InterimRowType[Row[Any]]]:</span>
        <span class="s3">if </span><span class="s1">self._hard_closed:</span>
            <span class="s1">self._raise_hard_closed()</span>

        <span class="s1">row = next(self.iterator</span><span class="s4">, </span><span class="s1">_NO_ROW)</span>
        <span class="s3">if </span><span class="s1">row </span><span class="s3">is </span><span class="s1">_NO_ROW:</span>
            <span class="s1">self._soft_close(hard=hard_close)</span>
            <span class="s3">return None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">row</span>

    <span class="s3">def </span><span class="s1">_fetchall_impl(self) -&gt; List[_InterimRowType[Row[Any]]]:</span>
        <span class="s3">if </span><span class="s1">self._hard_closed:</span>
            <span class="s1">self._raise_hard_closed()</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">list(self.iterator)</span>
        <span class="s3">finally</span><span class="s1">:</span>
            <span class="s1">self._soft_close()</span>

    <span class="s3">def </span><span class="s1">_fetchmany_impl(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">size: Optional[int] = </span><span class="s3">None</span>
    <span class="s1">) -&gt; List[_InterimRowType[Row[Any]]]:</span>
        <span class="s3">if </span><span class="s1">self._hard_closed:</span>
            <span class="s1">self._raise_hard_closed()</span>

        <span class="s3">return </span><span class="s1">list(itertools.islice(self.iterator</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s1">size))</span>


<span class="s3">def </span><span class="s1">null_result() -&gt; IteratorResult[Any]:</span>
    <span class="s3">return </span><span class="s1">IteratorResult(SimpleResultMetaData([])</span><span class="s4">, </span><span class="s1">iter([]))</span>


<span class="s3">class </span><span class="s1">ChunkedIteratorResult(IteratorResult[_TP]):</span>
    <span class="s2">&quot;&quot;&quot;An :class:`_engine.IteratorResult` that works from an 
    iterator-producing callable. 
 
    The given ``chunks`` argument is a function that is given a number of rows 
    to return in each chunk, or ``None`` for all rows.  The function should 
    then return an un-consumed iterator of lists, each list of the requested 
    size. 
 
    The function can be called at any time again, in which case it should 
    continue from the same result set but adjust the chunk size as given. 
 
    .. versionadded:: 1.4 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">cursor_metadata: ResultMetaData</span><span class="s4">,</span>
        <span class="s1">chunks: Callable[</span>
            <span class="s1">[Optional[int]]</span><span class="s4">, </span><span class="s1">Iterator[Sequence[_InterimRowType[_R]]]</span>
        <span class="s1">]</span><span class="s4">,</span>
        <span class="s1">source_supports_scalars: bool = </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">raw: Optional[Result[Any]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">dynamic_yield_per: bool = </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s1">):</span>
        <span class="s1">self._metadata = cursor_metadata</span>
        <span class="s1">self.chunks = chunks</span>
        <span class="s1">self._source_supports_scalars = source_supports_scalars</span>
        <span class="s1">self.raw = raw</span>
        <span class="s1">self.iterator = itertools.chain.from_iterable(self.chunks(</span><span class="s3">None</span><span class="s1">))</span>
        <span class="s1">self.dynamic_yield_per = dynamic_yield_per</span>

    <span class="s1">@_generative</span>
    <span class="s3">def </span><span class="s1">yield_per(self</span><span class="s4">, </span><span class="s1">num: int) -&gt; Self:</span>
        <span class="s0"># TODO: this throws away the iterator which may be holding</span>
        <span class="s0"># onto a chunk.   the yield_per cannot be changed once any</span>
        <span class="s0"># rows have been fetched.   either find a way to enforce this,</span>
        <span class="s0"># or we can't use itertools.chain and will instead have to</span>
        <span class="s0"># keep track.</span>

        <span class="s1">self._yield_per = num</span>
        <span class="s1">self.iterator = itertools.chain.from_iterable(self.chunks(num))</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_soft_close(self</span><span class="s4">, </span><span class="s1">hard: bool = </span><span class="s3">False</span><span class="s4">, </span><span class="s1">**kw: Any) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">super()._soft_close(hard=hard</span><span class="s4">, </span><span class="s1">**kw)</span>
        <span class="s1">self.chunks = </span><span class="s3">lambda </span><span class="s1">size: []  </span><span class="s0"># type: ignore</span>

    <span class="s3">def </span><span class="s1">_fetchmany_impl(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">size: Optional[int] = </span><span class="s3">None</span>
    <span class="s1">) -&gt; List[_InterimRowType[Row[Any]]]:</span>
        <span class="s3">if </span><span class="s1">self.dynamic_yield_per:</span>
            <span class="s1">self.iterator = itertools.chain.from_iterable(self.chunks(size))</span>
        <span class="s3">return </span><span class="s1">super()._fetchmany_impl(size=size)</span>


<span class="s3">class </span><span class="s1">MergedResult(IteratorResult[_TP]):</span>
    <span class="s2">&quot;&quot;&quot;A :class:`_engine.Result` that is merged from any number of 
    :class:`_engine.Result` objects. 
 
    Returned by the :meth:`_engine.Result.merge` method. 
 
    .. versionadded:: 1.4 
 
    &quot;&quot;&quot;</span>

    <span class="s1">closed = </span><span class="s3">False</span>
    <span class="s1">rowcount: Optional[int]</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">cursor_metadata: ResultMetaData</span><span class="s4">, </span><span class="s1">results: Sequence[Result[_TP]]</span>
    <span class="s1">):</span>
        <span class="s1">self._results = results</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">cursor_metadata</span><span class="s4">,</span>
            <span class="s1">itertools.chain.from_iterable(</span>
                <span class="s1">r._raw_row_iterator() </span><span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">results</span>
            <span class="s1">)</span><span class="s4">,</span>
        <span class="s1">)</span>

        <span class="s1">self._unique_filter_state = results[</span><span class="s6">0</span><span class="s1">]._unique_filter_state</span>
        <span class="s1">self._yield_per = results[</span><span class="s6">0</span><span class="s1">]._yield_per</span>

        <span class="s0"># going to try something w/ this in next rev</span>
        <span class="s1">self._source_supports_scalars = results[</span><span class="s6">0</span><span class="s1">]._source_supports_scalars</span>

        <span class="s1">self._attributes = self._attributes.merge_with(</span>
            <span class="s1">*[r._attributes </span><span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">results]</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_soft_close(self</span><span class="s4">, </span><span class="s1">hard: bool = </span><span class="s3">False</span><span class="s4">, </span><span class="s1">**kw: Any) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">self._results:</span>
            <span class="s1">r._soft_close(hard=hard</span><span class="s4">, </span><span class="s1">**kw)</span>
        <span class="s3">if </span><span class="s1">hard:</span>
            <span class="s1">self.closed = </span><span class="s3">True</span>
</pre>
</body>
</html>