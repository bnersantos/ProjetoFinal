<html>
<head>
<title>ranges.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5d69bb;}
.s1 { color: #d8d8d8;}
.s2 { color: #cc8b60;}
.s3 { color: #96bf7d;}
.s4 { color: #cc7832;}
.s5 { color: #717ed3; font-style: italic;}
.s6 { color: #bbb55b;}
.s7 { color: #d7539b; font-weight: bold;}
</style>
</head>
<body bgcolor="#1a1a25">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ranges.py</font>
</center></td></tr></table>
<pre><span class="s0"># dialects/postgresql/ranges.py</span>
<span class="s0"># Copyright (C) 2013-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">import </span><span class="s1">dataclasses</span>
<span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">date</span>
<span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">datetime</span>
<span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">timedelta</span>
<span class="s2">from </span><span class="s1">decimal </span><span class="s2">import </span><span class="s1">Decimal</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Any</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">cast</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Generic</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">List</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Optional</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">overload</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Sequence</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Tuple</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Type</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TypeVar</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Union</span>

<span class="s2">from </span><span class="s1">.operators </span><span class="s2">import </span><span class="s1">ADJACENT_TO</span>
<span class="s2">from </span><span class="s1">.operators </span><span class="s2">import </span><span class="s1">CONTAINED_BY</span>
<span class="s2">from </span><span class="s1">.operators </span><span class="s2">import </span><span class="s1">CONTAINS</span>
<span class="s2">from </span><span class="s1">.operators </span><span class="s2">import </span><span class="s1">NOT_EXTEND_LEFT_OF</span>
<span class="s2">from </span><span class="s1">.operators </span><span class="s2">import </span><span class="s1">NOT_EXTEND_RIGHT_OF</span>
<span class="s2">from </span><span class="s1">.operators </span><span class="s2">import </span><span class="s1">OVERLAP</span>
<span class="s2">from </span><span class="s1">.operators </span><span class="s2">import </span><span class="s1">STRICTLY_LEFT_OF</span>
<span class="s2">from </span><span class="s1">.operators </span><span class="s2">import </span><span class="s1">STRICTLY_RIGHT_OF</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">types </span><span class="s2">as </span><span class="s1">sqltypes</span>
<span class="s2">from </span><span class="s1">...sql </span><span class="s2">import </span><span class="s1">operators</span>
<span class="s2">from </span><span class="s1">...sql.type_api </span><span class="s2">import </span><span class="s1">TypeEngine</span>
<span class="s2">from </span><span class="s1">...util </span><span class="s2">import </span><span class="s1">py310</span>
<span class="s2">from </span><span class="s1">...util.typing </span><span class="s2">import </span><span class="s1">Literal</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s2">from </span><span class="s1">...sql.elements </span><span class="s2">import </span><span class="s1">ColumnElement</span>
    <span class="s2">from </span><span class="s1">...sql.type_api </span><span class="s2">import </span><span class="s1">_TE</span>
    <span class="s2">from </span><span class="s1">...sql.type_api </span><span class="s2">import </span><span class="s1">TypeEngineMixin</span>

<span class="s1">_T = TypeVar(</span><span class="s3">&quot;_T&quot;</span><span class="s4">, </span><span class="s1">bound=Any)</span>

<span class="s1">_BoundsType = Literal[</span><span class="s3">&quot;()&quot;</span><span class="s4">, </span><span class="s3">&quot;[)&quot;</span><span class="s4">, </span><span class="s3">&quot;(]&quot;</span><span class="s4">, </span><span class="s3">&quot;[]&quot;</span><span class="s1">]</span>

<span class="s2">if </span><span class="s1">py310:</span>
    <span class="s1">dc_slots = {</span><span class="s3">&quot;slots&quot;</span><span class="s1">: </span><span class="s2">True</span><span class="s1">}</span>
    <span class="s1">dc_kwonly = {</span><span class="s3">&quot;kw_only&quot;</span><span class="s1">: </span><span class="s2">True</span><span class="s1">}</span>
<span class="s2">else</span><span class="s1">:</span>
    <span class="s1">dc_slots = {}</span>
    <span class="s1">dc_kwonly = {}</span>


<span class="s1">@dataclasses.dataclass(frozen=</span><span class="s2">True</span><span class="s4">, </span><span class="s1">**dc_slots)</span>
<span class="s2">class </span><span class="s1">Range(Generic[_T]):</span>
    <span class="s5">&quot;&quot;&quot;Represent a PostgreSQL range. 
 
    E.g.:: 
 
        r = Range(10, 50, bounds=&quot;()&quot;) 
 
    The calling style is similar to that of psycopg and psycopg2, in part 
    to allow easier migration from previous SQLAlchemy versions that used 
    these objects directly. 
 
    :param lower: Lower bound value, or None 
    :param upper: Upper bound value, or None 
    :param bounds: keyword-only, optional string value that is one of 
     ``&quot;()&quot;``, ``&quot;[)&quot;``, ``&quot;(]&quot;``, ``&quot;[]&quot;``.  Defaults to ``&quot;[)&quot;``. 
    :param empty: keyword-only, optional bool indicating this is an &quot;empty&quot; 
     range 
 
    .. versionadded:: 2.0 
 
    &quot;&quot;&quot;</span>

    <span class="s1">lower: Optional[_T] = </span><span class="s2">None</span>
    <span class="s3">&quot;&quot;&quot;the lower bound&quot;&quot;&quot;</span>

    <span class="s1">upper: Optional[_T] = </span><span class="s2">None</span>
    <span class="s3">&quot;&quot;&quot;the upper bound&quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
        <span class="s1">bounds: _BoundsType = dataclasses.field(default=</span><span class="s3">&quot;[)&quot;</span><span class="s1">)</span>
        <span class="s1">empty: bool = dataclasses.field(default=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">bounds: _BoundsType = dataclasses.field(default=</span><span class="s3">&quot;[)&quot;</span><span class="s4">, </span><span class="s1">**dc_kwonly)</span>
        <span class="s1">empty: bool = dataclasses.field(default=</span><span class="s2">False</span><span class="s4">, </span><span class="s1">**dc_kwonly)</span>

    <span class="s2">if not </span><span class="s1">py310:</span>

        <span class="s2">def </span><span class="s1">__init__(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">lower: Optional[_T] = </span><span class="s2">None</span><span class="s4">,</span>
            <span class="s1">upper: Optional[_T] = </span><span class="s2">None</span><span class="s4">,</span>
            <span class="s1">*</span><span class="s4">,</span>
            <span class="s1">bounds: _BoundsType = </span><span class="s3">&quot;[)&quot;</span><span class="s4">,</span>
            <span class="s1">empty: bool = </span><span class="s2">False</span><span class="s4">,</span>
        <span class="s1">):</span>
            <span class="s0"># no __slots__ either so we can update dict</span>
            <span class="s1">self.__dict__.update(</span>
                <span class="s1">{</span>
                    <span class="s3">&quot;lower&quot;</span><span class="s1">: lower</span><span class="s4">,</span>
                    <span class="s3">&quot;upper&quot;</span><span class="s1">: upper</span><span class="s4">,</span>
                    <span class="s3">&quot;bounds&quot;</span><span class="s1">: bounds</span><span class="s4">,</span>
                    <span class="s3">&quot;empty&quot;</span><span class="s1">: empty</span><span class="s4">,</span>
                <span class="s1">}</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__bool__(self) -&gt; bool:</span>
        <span class="s2">return not </span><span class="s1">self.empty</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">isempty(self) -&gt; bool:</span>
        <span class="s5">&quot;A synonym for the 'empty' attribute.&quot;</span>

        <span class="s2">return </span><span class="s1">self.empty</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">is_empty(self) -&gt; bool:</span>
        <span class="s5">&quot;A synonym for the 'empty' attribute.&quot;</span>

        <span class="s2">return </span><span class="s1">self.empty</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">lower_inc(self) -&gt; bool:</span>
        <span class="s5">&quot;&quot;&quot;Return True if the lower bound is inclusive.&quot;&quot;&quot;</span>

        <span class="s2">return </span><span class="s1">self.bounds[</span><span class="s6">0</span><span class="s1">] == </span><span class="s3">&quot;[&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">lower_inf(self) -&gt; bool:</span>
        <span class="s5">&quot;&quot;&quot;Return True if this range is non-empty and lower bound is 
        infinite.&quot;&quot;&quot;</span>

        <span class="s2">return not </span><span class="s1">self.empty </span><span class="s2">and </span><span class="s1">self.lower </span><span class="s2">is None</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">upper_inc(self) -&gt; bool:</span>
        <span class="s5">&quot;&quot;&quot;Return True if the upper bound is inclusive.&quot;&quot;&quot;</span>

        <span class="s2">return </span><span class="s1">self.bounds[</span><span class="s6">1</span><span class="s1">] == </span><span class="s3">&quot;]&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">upper_inf(self) -&gt; bool:</span>
        <span class="s5">&quot;&quot;&quot;Return True if this range is non-empty and the upper bound is 
        infinite.&quot;&quot;&quot;</span>

        <span class="s2">return not </span><span class="s1">self.empty </span><span class="s2">and </span><span class="s1">self.upper </span><span class="s2">is None</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">__sa_type_engine__(self) -&gt; AbstractSingleRange[_T]:</span>
        <span class="s2">return </span><span class="s1">AbstractSingleRange()</span>

    <span class="s2">def </span><span class="s1">_contains_value(self</span><span class="s4">, </span><span class="s1">value: _T) -&gt; bool:</span>
        <span class="s5">&quot;&quot;&quot;Return True if this range contains the given value.&quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">self.empty:</span>
            <span class="s2">return False</span>

        <span class="s2">if </span><span class="s1">self.lower </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.upper </span><span class="s2">is None or </span><span class="s1">(</span>
                <span class="s1">value &lt; self.upper</span>
                <span class="s2">if </span><span class="s1">self.bounds[</span><span class="s6">1</span><span class="s1">] == </span><span class="s3">&quot;)&quot;</span>
                <span class="s2">else </span><span class="s1">value &lt;= self.upper</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.upper </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">(  </span><span class="s0"># type: ignore</span>
                <span class="s1">value &gt; self.lower</span>
                <span class="s2">if </span><span class="s1">self.bounds[</span><span class="s6">0</span><span class="s1">] == </span><span class="s3">&quot;(&quot;</span>
                <span class="s2">else </span><span class="s1">value &gt;= self.lower</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">(  </span><span class="s0"># type: ignore</span>
            <span class="s1">value &gt; self.lower</span>
            <span class="s2">if </span><span class="s1">self.bounds[</span><span class="s6">0</span><span class="s1">] == </span><span class="s3">&quot;(&quot;</span>
            <span class="s2">else </span><span class="s1">value &gt;= self.lower</span>
        <span class="s1">) </span><span class="s2">and </span><span class="s1">(</span>
            <span class="s1">value &lt; self.upper</span>
            <span class="s2">if </span><span class="s1">self.bounds[</span><span class="s6">1</span><span class="s1">] == </span><span class="s3">&quot;)&quot;</span>
            <span class="s2">else </span><span class="s1">value &lt;= self.upper</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_get_discrete_step(self) -&gt; Any:</span>
        <span class="s5">&quot;Determine the “step” for this range, if it is a discrete one.&quot;</span>

        <span class="s0"># See</span>
        <span class="s0"># https://www.postgresql.org/docs/current/rangetypes.html#RANGETYPES-DISCRETE</span>
        <span class="s0"># for the rationale</span>

        <span class="s2">if </span><span class="s1">isinstance(self.lower</span><span class="s4">, </span><span class="s1">int) </span><span class="s2">or </span><span class="s1">isinstance(self.upper</span><span class="s4">, </span><span class="s1">int):</span>
            <span class="s2">return </span><span class="s6">1</span>
        <span class="s2">elif </span><span class="s1">isinstance(self.lower</span><span class="s4">, </span><span class="s1">datetime) </span><span class="s2">or </span><span class="s1">isinstance(</span>
            <span class="s1">self.upper</span><span class="s4">, </span><span class="s1">datetime</span>
        <span class="s1">):</span>
            <span class="s0"># This is required, because a `isinstance(datetime.now(), date)`</span>
            <span class="s0"># is True</span>
            <span class="s2">return None</span>
        <span class="s2">elif </span><span class="s1">isinstance(self.lower</span><span class="s4">, </span><span class="s1">date) </span><span class="s2">or </span><span class="s1">isinstance(self.upper</span><span class="s4">, </span><span class="s1">date):</span>
            <span class="s2">return </span><span class="s1">timedelta(days=</span><span class="s6">1</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">_compare_edges(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">value1: Optional[_T]</span><span class="s4">,</span>
        <span class="s1">bound1: str</span><span class="s4">,</span>
        <span class="s1">value2: Optional[_T]</span><span class="s4">,</span>
        <span class="s1">bound2: str</span><span class="s4">,</span>
        <span class="s1">only_values: bool = </span><span class="s2">False</span><span class="s4">,</span>
    <span class="s1">) -&gt; int:</span>
        <span class="s5">&quot;&quot;&quot;Compare two range bounds. 
 
        Return -1, 0 or 1 respectively when `value1` is less than, 
        equal to or greater than `value2`. 
 
        When `only_value` is ``True``, do not consider the *inclusivity* 
        of the edges, just their values. 
        &quot;&quot;&quot;</span>

        <span class="s1">value1_is_lower_bound = bound1 </span><span class="s2">in </span><span class="s1">{</span><span class="s3">&quot;[&quot;</span><span class="s4">, </span><span class="s3">&quot;(&quot;</span><span class="s1">}</span>
        <span class="s1">value2_is_lower_bound = bound2 </span><span class="s2">in </span><span class="s1">{</span><span class="s3">&quot;[&quot;</span><span class="s4">, </span><span class="s3">&quot;(&quot;</span><span class="s1">}</span>

        <span class="s0"># Infinite edges are equal when they are on the same side,</span>
        <span class="s0"># otherwise a lower edge is considered less than the upper end</span>
        <span class="s2">if </span><span class="s1">value1 </span><span class="s2">is </span><span class="s1">value2 </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">value1_is_lower_bound == value2_is_lower_bound:</span>
                <span class="s2">return </span><span class="s6">0</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">-</span><span class="s6">1 </span><span class="s2">if </span><span class="s1">value1_is_lower_bound </span><span class="s2">else </span><span class="s6">1</span>
        <span class="s2">elif </span><span class="s1">value1 </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">-</span><span class="s6">1 </span><span class="s2">if </span><span class="s1">value1_is_lower_bound </span><span class="s2">else </span><span class="s6">1</span>
        <span class="s2">elif </span><span class="s1">value2 </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s6">1 </span><span class="s2">if </span><span class="s1">value2_is_lower_bound </span><span class="s2">else </span><span class="s1">-</span><span class="s6">1</span>

        <span class="s0"># Short path for trivial case</span>
        <span class="s2">if </span><span class="s1">bound1 == bound2 </span><span class="s2">and </span><span class="s1">value1 == value2:</span>
            <span class="s2">return </span><span class="s6">0</span>

        <span class="s1">value1_inc = bound1 </span><span class="s2">in </span><span class="s1">{</span><span class="s3">&quot;[&quot;</span><span class="s4">, </span><span class="s3">&quot;]&quot;</span><span class="s1">}</span>
        <span class="s1">value2_inc = bound2 </span><span class="s2">in </span><span class="s1">{</span><span class="s3">&quot;[&quot;</span><span class="s4">, </span><span class="s3">&quot;]&quot;</span><span class="s1">}</span>
        <span class="s1">step = self._get_discrete_step()</span>

        <span class="s2">if </span><span class="s1">step </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s0"># &quot;Normalize&quot; the two edges as '[)', to simplify successive</span>
            <span class="s0"># logic when the range is discrete: otherwise we would need</span>
            <span class="s0"># to handle the comparison between ``(0`` and ``[1`` that</span>
            <span class="s0"># are equal when dealing with integers while for floats the</span>
            <span class="s0"># former is lesser than the latter</span>

            <span class="s2">if </span><span class="s1">value1_is_lower_bound:</span>
                <span class="s2">if not </span><span class="s1">value1_inc:</span>
                    <span class="s1">value1 += step</span>
                    <span class="s1">value1_inc = </span><span class="s2">True</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">value1_inc:</span>
                    <span class="s1">value1 += step</span>
                    <span class="s1">value1_inc = </span><span class="s2">False</span>
            <span class="s2">if </span><span class="s1">value2_is_lower_bound:</span>
                <span class="s2">if not </span><span class="s1">value2_inc:</span>
                    <span class="s1">value2 += step</span>
                    <span class="s1">value2_inc = </span><span class="s2">True</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">value2_inc:</span>
                    <span class="s1">value2 += step</span>
                    <span class="s1">value2_inc = </span><span class="s2">False</span>

        <span class="s2">if </span><span class="s1">value1 &lt; value2:  </span><span class="s0"># type: ignore</span>
            <span class="s2">return </span><span class="s1">-</span><span class="s6">1</span>
        <span class="s2">elif </span><span class="s1">value1 &gt; value2:  </span><span class="s0"># type: ignore</span>
            <span class="s2">return </span><span class="s6">1</span>
        <span class="s2">elif </span><span class="s1">only_values:</span>
            <span class="s2">return </span><span class="s6">0</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># Neither one is infinite but are equal, so we</span>
            <span class="s0"># need to consider the respective inclusive/exclusive</span>
            <span class="s0"># flag</span>

            <span class="s2">if </span><span class="s1">value1_inc </span><span class="s2">and </span><span class="s1">value2_inc:</span>
                <span class="s2">return </span><span class="s6">0</span>
            <span class="s2">elif not </span><span class="s1">value1_inc </span><span class="s2">and not </span><span class="s1">value2_inc:</span>
                <span class="s2">if </span><span class="s1">value1_is_lower_bound == value2_is_lower_bound:</span>
                    <span class="s2">return </span><span class="s6">0</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s6">1 </span><span class="s2">if </span><span class="s1">value1_is_lower_bound </span><span class="s2">else </span><span class="s1">-</span><span class="s6">1</span>
            <span class="s2">elif not </span><span class="s1">value1_inc:</span>
                <span class="s2">return </span><span class="s6">1 </span><span class="s2">if </span><span class="s1">value1_is_lower_bound </span><span class="s2">else </span><span class="s1">-</span><span class="s6">1</span>
            <span class="s2">elif not </span><span class="s1">value2_inc:</span>
                <span class="s2">return </span><span class="s1">-</span><span class="s6">1 </span><span class="s2">if </span><span class="s1">value2_is_lower_bound </span><span class="s2">else </span><span class="s6">1</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s6">0</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s4">, </span><span class="s1">other: Any) -&gt; bool:</span>
        <span class="s5">&quot;&quot;&quot;Compare this range to the `other` taking into account 
        bounds inclusivity, returning ``True`` if they are equal. 
        &quot;&quot;&quot;</span>

        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s4">, </span><span class="s1">Range):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">if </span><span class="s1">self.empty </span><span class="s2">and </span><span class="s1">other.empty:</span>
            <span class="s2">return True</span>
        <span class="s2">elif </span><span class="s1">self.empty != other.empty:</span>
            <span class="s2">return False</span>

        <span class="s1">slower = self.lower</span>
        <span class="s1">slower_b = self.bounds[</span><span class="s6">0</span><span class="s1">]</span>
        <span class="s1">olower = other.lower</span>
        <span class="s1">olower_b = other.bounds[</span><span class="s6">0</span><span class="s1">]</span>
        <span class="s1">supper = self.upper</span>
        <span class="s1">supper_b = self.bounds[</span><span class="s6">1</span><span class="s1">]</span>
        <span class="s1">oupper = other.upper</span>
        <span class="s1">oupper_b = other.bounds[</span><span class="s6">1</span><span class="s1">]</span>

        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">self._compare_edges(slower</span><span class="s4">, </span><span class="s1">slower_b</span><span class="s4">, </span><span class="s1">olower</span><span class="s4">, </span><span class="s1">olower_b) == </span><span class="s6">0</span>
            <span class="s2">and </span><span class="s1">self._compare_edges(supper</span><span class="s4">, </span><span class="s1">supper_b</span><span class="s4">, </span><span class="s1">oupper</span><span class="s4">, </span><span class="s1">oupper_b) == </span><span class="s6">0</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">contained_by(self</span><span class="s4">, </span><span class="s1">other: Range[_T]) -&gt; bool:</span>
        <span class="s5">&quot;Determine whether this range is a contained by `other`.&quot;</span>

        <span class="s0"># Any range contains the empty one</span>
        <span class="s2">if </span><span class="s1">self.empty:</span>
            <span class="s2">return True</span>

        <span class="s0"># An empty range does not contain any range except the empty one</span>
        <span class="s2">if </span><span class="s1">other.empty:</span>
            <span class="s2">return False</span>

        <span class="s1">slower = self.lower</span>
        <span class="s1">slower_b = self.bounds[</span><span class="s6">0</span><span class="s1">]</span>
        <span class="s1">olower = other.lower</span>
        <span class="s1">olower_b = other.bounds[</span><span class="s6">0</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">self._compare_edges(slower</span><span class="s4">, </span><span class="s1">slower_b</span><span class="s4">, </span><span class="s1">olower</span><span class="s4">, </span><span class="s1">olower_b) &lt; </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s2">return False</span>

        <span class="s1">supper = self.upper</span>
        <span class="s1">supper_b = self.bounds[</span><span class="s6">1</span><span class="s1">]</span>
        <span class="s1">oupper = other.upper</span>
        <span class="s1">oupper_b = other.bounds[</span><span class="s6">1</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">self._compare_edges(supper</span><span class="s4">, </span><span class="s1">supper_b</span><span class="s4">, </span><span class="s1">oupper</span><span class="s4">, </span><span class="s1">oupper_b) &gt; </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s2">return False</span>

        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">contains(self</span><span class="s4">, </span><span class="s1">value: Union[_T</span><span class="s4">, </span><span class="s1">Range[_T]]) -&gt; bool:</span>
        <span class="s5">&quot;Determine whether this range contains `value`.&quot;</span>

        <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s4">, </span><span class="s1">Range):</span>
            <span class="s2">return </span><span class="s1">value.contained_by(self)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._contains_value(value)</span>

    <span class="s2">def </span><span class="s1">overlaps(self</span><span class="s4">, </span><span class="s1">other: Range[_T]) -&gt; bool:</span>
        <span class="s5">&quot;Determine whether this range overlaps with `other`.&quot;</span>

        <span class="s0"># Empty ranges never overlap with any other range</span>
        <span class="s2">if </span><span class="s1">self.empty </span><span class="s2">or </span><span class="s1">other.empty:</span>
            <span class="s2">return False</span>

        <span class="s1">slower = self.lower</span>
        <span class="s1">slower_b = self.bounds[</span><span class="s6">0</span><span class="s1">]</span>
        <span class="s1">supper = self.upper</span>
        <span class="s1">supper_b = self.bounds[</span><span class="s6">1</span><span class="s1">]</span>
        <span class="s1">olower = other.lower</span>
        <span class="s1">olower_b = other.bounds[</span><span class="s6">0</span><span class="s1">]</span>
        <span class="s1">oupper = other.upper</span>
        <span class="s1">oupper_b = other.bounds[</span><span class="s6">1</span><span class="s1">]</span>

        <span class="s0"># Check whether this lower bound is contained in the other range</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">self._compare_edges(slower</span><span class="s4">, </span><span class="s1">slower_b</span><span class="s4">, </span><span class="s1">olower</span><span class="s4">, </span><span class="s1">olower_b) &gt;= </span><span class="s6">0</span>
            <span class="s2">and </span><span class="s1">self._compare_edges(slower</span><span class="s4">, </span><span class="s1">slower_b</span><span class="s4">, </span><span class="s1">oupper</span><span class="s4">, </span><span class="s1">oupper_b) &lt;= </span><span class="s6">0</span>
        <span class="s1">):</span>
            <span class="s2">return True</span>

        <span class="s0"># Check whether other lower bound is contained in this range</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">self._compare_edges(olower</span><span class="s4">, </span><span class="s1">olower_b</span><span class="s4">, </span><span class="s1">slower</span><span class="s4">, </span><span class="s1">slower_b) &gt;= </span><span class="s6">0</span>
            <span class="s2">and </span><span class="s1">self._compare_edges(olower</span><span class="s4">, </span><span class="s1">olower_b</span><span class="s4">, </span><span class="s1">supper</span><span class="s4">, </span><span class="s1">supper_b) &lt;= </span><span class="s6">0</span>
        <span class="s1">):</span>
            <span class="s2">return True</span>

        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">strictly_left_of(self</span><span class="s4">, </span><span class="s1">other: Range[_T]) -&gt; bool:</span>
        <span class="s5">&quot;Determine whether this range is completely to the left of `other`.&quot;</span>

        <span class="s0"># Empty ranges are neither to left nor to the right of any other range</span>
        <span class="s2">if </span><span class="s1">self.empty </span><span class="s2">or </span><span class="s1">other.empty:</span>
            <span class="s2">return False</span>

        <span class="s1">supper = self.upper</span>
        <span class="s1">supper_b = self.bounds[</span><span class="s6">1</span><span class="s1">]</span>
        <span class="s1">olower = other.lower</span>
        <span class="s1">olower_b = other.bounds[</span><span class="s6">0</span><span class="s1">]</span>

        <span class="s0"># Check whether this upper edge is less than other's lower end</span>
        <span class="s2">return </span><span class="s1">self._compare_edges(supper</span><span class="s4">, </span><span class="s1">supper_b</span><span class="s4">, </span><span class="s1">olower</span><span class="s4">, </span><span class="s1">olower_b) &lt; </span><span class="s6">0</span>

    <span class="s1">__lshift__ = strictly_left_of</span>

    <span class="s2">def </span><span class="s1">strictly_right_of(self</span><span class="s4">, </span><span class="s1">other: Range[_T]) -&gt; bool:</span>
        <span class="s5">&quot;Determine whether this range is completely to the right of `other`.&quot;</span>

        <span class="s0"># Empty ranges are neither to left nor to the right of any other range</span>
        <span class="s2">if </span><span class="s1">self.empty </span><span class="s2">or </span><span class="s1">other.empty:</span>
            <span class="s2">return False</span>

        <span class="s1">slower = self.lower</span>
        <span class="s1">slower_b = self.bounds[</span><span class="s6">0</span><span class="s1">]</span>
        <span class="s1">oupper = other.upper</span>
        <span class="s1">oupper_b = other.bounds[</span><span class="s6">1</span><span class="s1">]</span>

        <span class="s0"># Check whether this lower edge is greater than other's upper end</span>
        <span class="s2">return </span><span class="s1">self._compare_edges(slower</span><span class="s4">, </span><span class="s1">slower_b</span><span class="s4">, </span><span class="s1">oupper</span><span class="s4">, </span><span class="s1">oupper_b) &gt; </span><span class="s6">0</span>

    <span class="s1">__rshift__ = strictly_right_of</span>

    <span class="s2">def </span><span class="s1">not_extend_left_of(self</span><span class="s4">, </span><span class="s1">other: Range[_T]) -&gt; bool:</span>
        <span class="s5">&quot;Determine whether this does not extend to the left of `other`.&quot;</span>

        <span class="s0"># Empty ranges are neither to left nor to the right of any other range</span>
        <span class="s2">if </span><span class="s1">self.empty </span><span class="s2">or </span><span class="s1">other.empty:</span>
            <span class="s2">return False</span>

        <span class="s1">slower = self.lower</span>
        <span class="s1">slower_b = self.bounds[</span><span class="s6">0</span><span class="s1">]</span>
        <span class="s1">olower = other.lower</span>
        <span class="s1">olower_b = other.bounds[</span><span class="s6">0</span><span class="s1">]</span>

        <span class="s0"># Check whether this lower edge is not less than other's lower end</span>
        <span class="s2">return </span><span class="s1">self._compare_edges(slower</span><span class="s4">, </span><span class="s1">slower_b</span><span class="s4">, </span><span class="s1">olower</span><span class="s4">, </span><span class="s1">olower_b) &gt;= </span><span class="s6">0</span>

    <span class="s2">def </span><span class="s1">not_extend_right_of(self</span><span class="s4">, </span><span class="s1">other: Range[_T]) -&gt; bool:</span>
        <span class="s5">&quot;Determine whether this does not extend to the right of `other`.&quot;</span>

        <span class="s0"># Empty ranges are neither to left nor to the right of any other range</span>
        <span class="s2">if </span><span class="s1">self.empty </span><span class="s2">or </span><span class="s1">other.empty:</span>
            <span class="s2">return False</span>

        <span class="s1">supper = self.upper</span>
        <span class="s1">supper_b = self.bounds[</span><span class="s6">1</span><span class="s1">]</span>
        <span class="s1">oupper = other.upper</span>
        <span class="s1">oupper_b = other.bounds[</span><span class="s6">1</span><span class="s1">]</span>

        <span class="s0"># Check whether this upper edge is not greater than other's upper end</span>
        <span class="s2">return </span><span class="s1">self._compare_edges(supper</span><span class="s4">, </span><span class="s1">supper_b</span><span class="s4">, </span><span class="s1">oupper</span><span class="s4">, </span><span class="s1">oupper_b) &lt;= </span><span class="s6">0</span>

    <span class="s2">def </span><span class="s1">_upper_edge_adjacent_to_lower(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">value1: Optional[_T]</span><span class="s4">,</span>
        <span class="s1">bound1: str</span><span class="s4">,</span>
        <span class="s1">value2: Optional[_T]</span><span class="s4">,</span>
        <span class="s1">bound2: str</span><span class="s4">,</span>
    <span class="s1">) -&gt; bool:</span>
        <span class="s5">&quot;&quot;&quot;Determine whether an upper bound is immediately successive to a 
        lower bound.&quot;&quot;&quot;</span>

        <span class="s0"># Since we need a peculiar way to handle the bounds inclusivity,</span>
        <span class="s0"># just do a comparison by value here</span>
        <span class="s1">res = self._compare_edges(value1</span><span class="s4">, </span><span class="s1">bound1</span><span class="s4">, </span><span class="s1">value2</span><span class="s4">, </span><span class="s1">bound2</span><span class="s4">, </span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">res == -</span><span class="s6">1</span><span class="s1">:</span>
            <span class="s1">step = self._get_discrete_step()</span>
            <span class="s2">if </span><span class="s1">step </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">return False</span>
            <span class="s2">if </span><span class="s1">bound1 == </span><span class="s3">&quot;]&quot;</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">bound2 == </span><span class="s3">&quot;[&quot;</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">value1 == value2 - step  </span><span class="s0"># type: ignore</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">value1 == value2</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">bound2 == </span><span class="s3">&quot;[&quot;</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">value1 == value2</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">value1 == value2 - step  </span><span class="s0"># type: ignore</span>
        <span class="s2">elif </span><span class="s1">res == </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s0"># Cover cases like [0,0] -|- [1,] and [0,2) -|- (1,3]</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">bound1 == </span><span class="s3">&quot;]&quot;</span>
                <span class="s2">and </span><span class="s1">bound2 == </span><span class="s3">&quot;[&quot;</span>
                <span class="s2">or </span><span class="s1">bound1 == </span><span class="s3">&quot;)&quot;</span>
                <span class="s2">and </span><span class="s1">bound2 == </span><span class="s3">&quot;(&quot;</span>
            <span class="s1">):</span>
                <span class="s1">step = self._get_discrete_step()</span>
                <span class="s2">if </span><span class="s1">step </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s2">return True</span>
            <span class="s2">return </span><span class="s1">(</span>
                <span class="s1">bound1 == </span><span class="s3">&quot;)&quot;</span>
                <span class="s2">and </span><span class="s1">bound2 == </span><span class="s3">&quot;[&quot;</span>
                <span class="s2">or </span><span class="s1">bound1 == </span><span class="s3">&quot;]&quot;</span>
                <span class="s2">and </span><span class="s1">bound2 == </span><span class="s3">&quot;(&quot;</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">adjacent_to(self</span><span class="s4">, </span><span class="s1">other: Range[_T]) -&gt; bool:</span>
        <span class="s5">&quot;Determine whether this range is adjacent to the `other`.&quot;</span>

        <span class="s0"># Empty ranges are not adjacent to any other range</span>
        <span class="s2">if </span><span class="s1">self.empty </span><span class="s2">or </span><span class="s1">other.empty:</span>
            <span class="s2">return False</span>

        <span class="s1">slower = self.lower</span>
        <span class="s1">slower_b = self.bounds[</span><span class="s6">0</span><span class="s1">]</span>
        <span class="s1">supper = self.upper</span>
        <span class="s1">supper_b = self.bounds[</span><span class="s6">1</span><span class="s1">]</span>
        <span class="s1">olower = other.lower</span>
        <span class="s1">olower_b = other.bounds[</span><span class="s6">0</span><span class="s1">]</span>
        <span class="s1">oupper = other.upper</span>
        <span class="s1">oupper_b = other.bounds[</span><span class="s6">1</span><span class="s1">]</span>

        <span class="s2">return </span><span class="s1">self._upper_edge_adjacent_to_lower(</span>
            <span class="s1">supper</span><span class="s4">, </span><span class="s1">supper_b</span><span class="s4">, </span><span class="s1">olower</span><span class="s4">, </span><span class="s1">olower_b</span>
        <span class="s1">) </span><span class="s2">or </span><span class="s1">self._upper_edge_adjacent_to_lower(</span>
            <span class="s1">oupper</span><span class="s4">, </span><span class="s1">oupper_b</span><span class="s4">, </span><span class="s1">slower</span><span class="s4">, </span><span class="s1">slower_b</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">union(self</span><span class="s4">, </span><span class="s1">other: Range[_T]) -&gt; Range[_T]:</span>
        <span class="s5">&quot;&quot;&quot;Compute the union of this range with the `other`. 
 
        This raises a ``ValueError`` exception if the two ranges are 
        &quot;disjunct&quot;, that is neither adjacent nor overlapping. 
        &quot;&quot;&quot;</span>

        <span class="s0"># Empty ranges are &quot;additive identities&quot;</span>
        <span class="s2">if </span><span class="s1">self.empty:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s2">if </span><span class="s1">other.empty:</span>
            <span class="s2">return </span><span class="s1">self</span>

        <span class="s2">if not </span><span class="s1">self.overlaps(other) </span><span class="s2">and not </span><span class="s1">self.adjacent_to(other):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;Adding non-overlapping and non-adjacent&quot;</span>
                <span class="s3">&quot; ranges is not implemented&quot;</span>
            <span class="s1">)</span>

        <span class="s1">slower = self.lower</span>
        <span class="s1">slower_b = self.bounds[</span><span class="s6">0</span><span class="s1">]</span>
        <span class="s1">supper = self.upper</span>
        <span class="s1">supper_b = self.bounds[</span><span class="s6">1</span><span class="s1">]</span>
        <span class="s1">olower = other.lower</span>
        <span class="s1">olower_b = other.bounds[</span><span class="s6">0</span><span class="s1">]</span>
        <span class="s1">oupper = other.upper</span>
        <span class="s1">oupper_b = other.bounds[</span><span class="s6">1</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">self._compare_edges(slower</span><span class="s4">, </span><span class="s1">slower_b</span><span class="s4">, </span><span class="s1">olower</span><span class="s4">, </span><span class="s1">olower_b) &lt; </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s1">rlower = slower</span>
            <span class="s1">rlower_b = slower_b</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">rlower = olower</span>
            <span class="s1">rlower_b = olower_b</span>

        <span class="s2">if </span><span class="s1">self._compare_edges(supper</span><span class="s4">, </span><span class="s1">supper_b</span><span class="s4">, </span><span class="s1">oupper</span><span class="s4">, </span><span class="s1">oupper_b) &gt; </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s1">rupper = supper</span>
            <span class="s1">rupper_b = supper_b</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">rupper = oupper</span>
            <span class="s1">rupper_b = oupper_b</span>

        <span class="s2">return </span><span class="s1">Range(</span>
            <span class="s1">rlower</span><span class="s4">, </span><span class="s1">rupper</span><span class="s4">, </span><span class="s1">bounds=cast(_BoundsType</span><span class="s4">, </span><span class="s1">rlower_b + rupper_b)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__add__(self</span><span class="s4">, </span><span class="s1">other: Range[_T]) -&gt; Range[_T]:</span>
        <span class="s2">return </span><span class="s1">self.union(other)</span>

    <span class="s2">def </span><span class="s1">difference(self</span><span class="s4">, </span><span class="s1">other: Range[_T]) -&gt; Range[_T]:</span>
        <span class="s5">&quot;&quot;&quot;Compute the difference between this range and the `other`. 
 
        This raises a ``ValueError`` exception if the two ranges are 
        &quot;disjunct&quot;, that is neither adjacent nor overlapping. 
        &quot;&quot;&quot;</span>

        <span class="s0"># Subtracting an empty range is a no-op</span>
        <span class="s2">if </span><span class="s1">self.empty </span><span class="s2">or </span><span class="s1">other.empty:</span>
            <span class="s2">return </span><span class="s1">self</span>

        <span class="s1">slower = self.lower</span>
        <span class="s1">slower_b = self.bounds[</span><span class="s6">0</span><span class="s1">]</span>
        <span class="s1">supper = self.upper</span>
        <span class="s1">supper_b = self.bounds[</span><span class="s6">1</span><span class="s1">]</span>
        <span class="s1">olower = other.lower</span>
        <span class="s1">olower_b = other.bounds[</span><span class="s6">0</span><span class="s1">]</span>
        <span class="s1">oupper = other.upper</span>
        <span class="s1">oupper_b = other.bounds[</span><span class="s6">1</span><span class="s1">]</span>

        <span class="s1">sl_vs_ol = self._compare_edges(slower</span><span class="s4">, </span><span class="s1">slower_b</span><span class="s4">, </span><span class="s1">olower</span><span class="s4">, </span><span class="s1">olower_b)</span>
        <span class="s1">su_vs_ou = self._compare_edges(supper</span><span class="s4">, </span><span class="s1">supper_b</span><span class="s4">, </span><span class="s1">oupper</span><span class="s4">, </span><span class="s1">oupper_b)</span>
        <span class="s2">if </span><span class="s1">sl_vs_ol &lt; </span><span class="s6">0 </span><span class="s2">and </span><span class="s1">su_vs_ou &gt; </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;Subtracting a strictly inner range is not implemented&quot;</span>
            <span class="s1">)</span>

        <span class="s1">sl_vs_ou = self._compare_edges(slower</span><span class="s4">, </span><span class="s1">slower_b</span><span class="s4">, </span><span class="s1">oupper</span><span class="s4">, </span><span class="s1">oupper_b)</span>
        <span class="s1">su_vs_ol = self._compare_edges(supper</span><span class="s4">, </span><span class="s1">supper_b</span><span class="s4">, </span><span class="s1">olower</span><span class="s4">, </span><span class="s1">olower_b)</span>

        <span class="s0"># If the ranges do not overlap, result is simply the first</span>
        <span class="s2">if </span><span class="s1">sl_vs_ou &gt; </span><span class="s6">0 </span><span class="s2">or </span><span class="s1">su_vs_ol &lt; </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self</span>

        <span class="s0"># If this range is completely contained by the other, result is empty</span>
        <span class="s2">if </span><span class="s1">sl_vs_ol &gt;= </span><span class="s6">0 </span><span class="s2">and </span><span class="s1">su_vs_ou &lt;= </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">Range(</span><span class="s2">None</span><span class="s4">, </span><span class="s2">None</span><span class="s4">, </span><span class="s1">empty=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s0"># If this range extends to the left of the other and ends in its</span>
        <span class="s0"># middle</span>
        <span class="s2">if </span><span class="s1">sl_vs_ol &lt;= </span><span class="s6">0 </span><span class="s2">and </span><span class="s1">su_vs_ol &gt;= </span><span class="s6">0 </span><span class="s2">and </span><span class="s1">su_vs_ou &lt;= </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s1">rupper_b = </span><span class="s3">&quot;)&quot; </span><span class="s2">if </span><span class="s1">olower_b == </span><span class="s3">&quot;[&quot; </span><span class="s2">else </span><span class="s3">&quot;]&quot;</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">slower_b != </span><span class="s3">&quot;[&quot;</span>
                <span class="s2">and </span><span class="s1">rupper_b != </span><span class="s3">&quot;]&quot;</span>
                <span class="s2">and </span><span class="s1">self._compare_edges(slower</span><span class="s4">, </span><span class="s1">slower_b</span><span class="s4">, </span><span class="s1">olower</span><span class="s4">, </span><span class="s1">rupper_b)</span>
                <span class="s1">== </span><span class="s6">0</span>
            <span class="s1">):</span>
                <span class="s2">return </span><span class="s1">Range(</span><span class="s2">None</span><span class="s4">, </span><span class="s2">None</span><span class="s4">, </span><span class="s1">empty=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">Range(</span>
                    <span class="s1">slower</span><span class="s4">,</span>
                    <span class="s1">olower</span><span class="s4">,</span>
                    <span class="s1">bounds=cast(_BoundsType</span><span class="s4">, </span><span class="s1">slower_b + rupper_b)</span><span class="s4">,</span>
                <span class="s1">)</span>

        <span class="s0"># If this range starts in the middle of the other and extends to its</span>
        <span class="s0"># right</span>
        <span class="s2">if </span><span class="s1">sl_vs_ol &gt;= </span><span class="s6">0 </span><span class="s2">and </span><span class="s1">su_vs_ou &gt;= </span><span class="s6">0 </span><span class="s2">and </span><span class="s1">sl_vs_ou &lt;= </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s1">rlower_b = </span><span class="s3">&quot;(&quot; </span><span class="s2">if </span><span class="s1">oupper_b == </span><span class="s3">&quot;]&quot; </span><span class="s2">else </span><span class="s3">&quot;[&quot;</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">rlower_b != </span><span class="s3">&quot;[&quot;</span>
                <span class="s2">and </span><span class="s1">supper_b != </span><span class="s3">&quot;]&quot;</span>
                <span class="s2">and </span><span class="s1">self._compare_edges(oupper</span><span class="s4">, </span><span class="s1">rlower_b</span><span class="s4">, </span><span class="s1">supper</span><span class="s4">, </span><span class="s1">supper_b)</span>
                <span class="s1">== </span><span class="s6">0</span>
            <span class="s1">):</span>
                <span class="s2">return </span><span class="s1">Range(</span><span class="s2">None</span><span class="s4">, </span><span class="s2">None</span><span class="s4">, </span><span class="s1">empty=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">Range(</span>
                    <span class="s1">oupper</span><span class="s4">,</span>
                    <span class="s1">supper</span><span class="s4">,</span>
                    <span class="s1">bounds=cast(_BoundsType</span><span class="s4">, </span><span class="s1">rlower_b + supper_b)</span><span class="s4">,</span>
                <span class="s1">)</span>

        <span class="s2">assert False</span><span class="s4">, </span><span class="s3">f&quot;Unhandled case computing </span><span class="s7">{</span><span class="s1">self</span><span class="s7">} </span><span class="s3">- </span><span class="s7">{</span><span class="s1">other</span><span class="s7">}</span><span class="s3">&quot;</span>

    <span class="s2">def </span><span class="s1">__sub__(self</span><span class="s4">, </span><span class="s1">other: Range[_T]) -&gt; Range[_T]:</span>
        <span class="s2">return </span><span class="s1">self.difference(other)</span>

    <span class="s2">def </span><span class="s1">intersection(self</span><span class="s4">, </span><span class="s1">other: Range[_T]) -&gt; Range[_T]:</span>
        <span class="s5">&quot;&quot;&quot;Compute the intersection of this range with the `other`. 
 
        .. versionadded:: 2.0.10 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.empty </span><span class="s2">or </span><span class="s1">other.empty </span><span class="s2">or not </span><span class="s1">self.overlaps(other):</span>
            <span class="s2">return </span><span class="s1">Range(</span><span class="s2">None</span><span class="s4">, </span><span class="s2">None</span><span class="s4">, </span><span class="s1">empty=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">slower = self.lower</span>
        <span class="s1">slower_b = self.bounds[</span><span class="s6">0</span><span class="s1">]</span>
        <span class="s1">supper = self.upper</span>
        <span class="s1">supper_b = self.bounds[</span><span class="s6">1</span><span class="s1">]</span>
        <span class="s1">olower = other.lower</span>
        <span class="s1">olower_b = other.bounds[</span><span class="s6">0</span><span class="s1">]</span>
        <span class="s1">oupper = other.upper</span>
        <span class="s1">oupper_b = other.bounds[</span><span class="s6">1</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">self._compare_edges(slower</span><span class="s4">, </span><span class="s1">slower_b</span><span class="s4">, </span><span class="s1">olower</span><span class="s4">, </span><span class="s1">olower_b) &lt; </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s1">rlower = olower</span>
            <span class="s1">rlower_b = olower_b</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">rlower = slower</span>
            <span class="s1">rlower_b = slower_b</span>

        <span class="s2">if </span><span class="s1">self._compare_edges(supper</span><span class="s4">, </span><span class="s1">supper_b</span><span class="s4">, </span><span class="s1">oupper</span><span class="s4">, </span><span class="s1">oupper_b) &gt; </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s1">rupper = oupper</span>
            <span class="s1">rupper_b = oupper_b</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">rupper = supper</span>
            <span class="s1">rupper_b = supper_b</span>

        <span class="s2">return </span><span class="s1">Range(</span>
            <span class="s1">rlower</span><span class="s4">,</span>
            <span class="s1">rupper</span><span class="s4">,</span>
            <span class="s1">bounds=cast(_BoundsType</span><span class="s4">, </span><span class="s1">rlower_b + rupper_b)</span><span class="s4">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__mul__(self</span><span class="s4">, </span><span class="s1">other: Range[_T]) -&gt; Range[_T]:</span>
        <span class="s2">return </span><span class="s1">self.intersection(other)</span>

    <span class="s2">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">self._stringify()</span>

    <span class="s2">def </span><span class="s1">_stringify(self) -&gt; str:</span>
        <span class="s2">if </span><span class="s1">self.empty:</span>
            <span class="s2">return </span><span class="s3">&quot;empty&quot;</span>

        <span class="s1">l</span><span class="s4">, </span><span class="s1">r = self.lower</span><span class="s4">, </span><span class="s1">self.upper</span>
        <span class="s1">l = </span><span class="s3">&quot;&quot; </span><span class="s2">if </span><span class="s1">l </span><span class="s2">is None else </span><span class="s1">l  </span><span class="s0"># type: ignore</span>
        <span class="s1">r = </span><span class="s3">&quot;&quot; </span><span class="s2">if </span><span class="s1">r </span><span class="s2">is None else </span><span class="s1">r  </span><span class="s0"># type: ignore</span>

        <span class="s1">b0</span><span class="s4">, </span><span class="s1">b1 = cast(</span><span class="s3">&quot;Tuple[str, str]&quot;</span><span class="s4">, </span><span class="s1">self.bounds)</span>

        <span class="s2">return </span><span class="s3">f&quot;</span><span class="s7">{</span><span class="s1">b0</span><span class="s7">}{</span><span class="s1">l</span><span class="s7">}</span><span class="s3">,</span><span class="s7">{</span><span class="s1">r</span><span class="s7">}{</span><span class="s1">b1</span><span class="s7">}</span><span class="s3">&quot;</span>


<span class="s2">class </span><span class="s1">MultiRange(List[Range[_T]]):</span>
    <span class="s5">&quot;&quot;&quot;Represents a multirange sequence. 
 
    This list subclass is an utility to allow automatic type inference of 
    the proper multi-range SQL type depending on the single range values. 
    This is useful when operating on literal multi-ranges:: 
 
        import sqlalchemy as sa 
        from sqlalchemy.dialects.postgresql import MultiRange, Range 
 
        value = literal(MultiRange([Range(2, 4)])) 
 
        select(tbl).where(tbl.c.value.op(&quot;@&quot;)(MultiRange([Range(-3, 7)]))) 
 
    .. versionadded:: 2.0.26 
 
    .. seealso:: 
 
        - :ref:`postgresql_multirange_list_use`. 
    &quot;&quot;&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">__sa_type_engine__(self) -&gt; AbstractMultiRange[_T]:</span>
        <span class="s2">return </span><span class="s1">AbstractMultiRange()</span>


<span class="s2">class </span><span class="s1">AbstractRange(sqltypes.TypeEngine[_T]):</span>
    <span class="s5">&quot;&quot;&quot;Base class for single and multi Range SQL types.&quot;&quot;&quot;</span>

    <span class="s1">render_bind_cast = </span><span class="s2">True</span>

    <span class="s1">__abstract__ = </span><span class="s2">True</span>

    <span class="s1">@overload</span>
    <span class="s2">def </span><span class="s1">adapt(self</span><span class="s4">, </span><span class="s1">cls: Type[_TE]</span><span class="s4">, </span><span class="s1">**kw: Any) -&gt; _TE: ...</span>

    <span class="s1">@overload</span>
    <span class="s2">def </span><span class="s1">adapt(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">cls: Type[TypeEngineMixin]</span><span class="s4">, </span><span class="s1">**kw: Any</span>
    <span class="s1">) -&gt; TypeEngine[Any]: ...</span>

    <span class="s2">def </span><span class="s1">adapt(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">cls: Type[Union[TypeEngine[Any]</span><span class="s4">, </span><span class="s1">TypeEngineMixin]]</span><span class="s4">,</span>
        <span class="s1">**kw: Any</span><span class="s4">,</span>
    <span class="s1">) -&gt; TypeEngine[Any]:</span>
        <span class="s5">&quot;&quot;&quot;Dynamically adapt a range type to an abstract impl. 
 
        For example ``INT4RANGE().adapt(_Psycopg2NumericRange)`` should 
        produce a type that will have ``_Psycopg2NumericRange`` behaviors 
        and also render as ``INT4RANGE`` in SQL and DDL. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">issubclass(cls</span><span class="s4">, </span><span class="s1">(AbstractSingleRangeImpl</span><span class="s4">, </span><span class="s1">AbstractMultiRangeImpl))</span>
            <span class="s2">and </span><span class="s1">cls </span><span class="s2">is not </span><span class="s1">self.__class__</span>
        <span class="s1">):</span>
            <span class="s0"># two ways to do this are:  1. create a new type on the fly</span>
            <span class="s0"># or 2. have AbstractRangeImpl(visit_name) constructor and a</span>
            <span class="s0"># visit_abstract_range_impl() method in the PG compiler.</span>
            <span class="s0"># I'm choosing #1 as the resulting type object</span>
            <span class="s0"># will then make use of the same mechanics</span>
            <span class="s0"># as if we had made all these sub-types explicitly, and will</span>
            <span class="s0"># also look more obvious under pdb etc.</span>
            <span class="s0"># The adapt() operation here is cached per type-class-per-dialect,</span>
            <span class="s0"># so is not much of a performance concern</span>
            <span class="s1">visit_name = self.__visit_name__</span>
            <span class="s2">return </span><span class="s1">type(  </span><span class="s0"># type: ignore</span>
                <span class="s3">f&quot;</span><span class="s7">{</span><span class="s1">visit_name</span><span class="s7">}</span><span class="s3">RangeImpl&quot;</span><span class="s4">,</span>
                <span class="s1">(cls</span><span class="s4">, </span><span class="s1">self.__class__)</span><span class="s4">,</span>
                <span class="s1">{</span><span class="s3">&quot;__visit_name__&quot;</span><span class="s1">: visit_name}</span><span class="s4">,</span>
            <span class="s1">)()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">super().adapt(cls)</span>

    <span class="s2">class </span><span class="s1">comparator_factory(TypeEngine.Comparator[Range[Any]]):</span>
        <span class="s5">&quot;&quot;&quot;Define comparison operations for range types.&quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">contains(self</span><span class="s4">, </span><span class="s1">other: Any</span><span class="s4">, </span><span class="s1">**kw: Any) -&gt; ColumnElement[bool]:</span>
            <span class="s5">&quot;&quot;&quot;Boolean expression. Returns true if the right hand operand, 
            which can be an element or a range, is contained within the 
            column. 
 
            kwargs may be ignored by this operator but are required for API 
            conformance. 
            &quot;&quot;&quot;</span>
            <span class="s2">return </span><span class="s1">self.expr.operate(CONTAINS</span><span class="s4">, </span><span class="s1">other)</span>

        <span class="s2">def </span><span class="s1">contained_by(self</span><span class="s4">, </span><span class="s1">other: Any) -&gt; ColumnElement[bool]:</span>
            <span class="s5">&quot;&quot;&quot;Boolean expression. Returns true if the column is contained 
            within the right hand operand. 
            &quot;&quot;&quot;</span>
            <span class="s2">return </span><span class="s1">self.expr.operate(CONTAINED_BY</span><span class="s4">, </span><span class="s1">other)</span>

        <span class="s2">def </span><span class="s1">overlaps(self</span><span class="s4">, </span><span class="s1">other: Any) -&gt; ColumnElement[bool]:</span>
            <span class="s5">&quot;&quot;&quot;Boolean expression. Returns true if the column overlaps 
            (has points in common with) the right hand operand. 
            &quot;&quot;&quot;</span>
            <span class="s2">return </span><span class="s1">self.expr.operate(OVERLAP</span><span class="s4">, </span><span class="s1">other)</span>

        <span class="s2">def </span><span class="s1">strictly_left_of(self</span><span class="s4">, </span><span class="s1">other: Any) -&gt; ColumnElement[bool]:</span>
            <span class="s5">&quot;&quot;&quot;Boolean expression. Returns true if the column is strictly 
            left of the right hand operand. 
            &quot;&quot;&quot;</span>
            <span class="s2">return </span><span class="s1">self.expr.operate(STRICTLY_LEFT_OF</span><span class="s4">, </span><span class="s1">other)</span>

        <span class="s1">__lshift__ = strictly_left_of</span>

        <span class="s2">def </span><span class="s1">strictly_right_of(self</span><span class="s4">, </span><span class="s1">other: Any) -&gt; ColumnElement[bool]:</span>
            <span class="s5">&quot;&quot;&quot;Boolean expression. Returns true if the column is strictly 
            right of the right hand operand. 
            &quot;&quot;&quot;</span>
            <span class="s2">return </span><span class="s1">self.expr.operate(STRICTLY_RIGHT_OF</span><span class="s4">, </span><span class="s1">other)</span>

        <span class="s1">__rshift__ = strictly_right_of</span>

        <span class="s2">def </span><span class="s1">not_extend_right_of(self</span><span class="s4">, </span><span class="s1">other: Any) -&gt; ColumnElement[bool]:</span>
            <span class="s5">&quot;&quot;&quot;Boolean expression. Returns true if the range in the column 
            does not extend right of the range in the operand. 
            &quot;&quot;&quot;</span>
            <span class="s2">return </span><span class="s1">self.expr.operate(NOT_EXTEND_RIGHT_OF</span><span class="s4">, </span><span class="s1">other)</span>

        <span class="s2">def </span><span class="s1">not_extend_left_of(self</span><span class="s4">, </span><span class="s1">other: Any) -&gt; ColumnElement[bool]:</span>
            <span class="s5">&quot;&quot;&quot;Boolean expression. Returns true if the range in the column 
            does not extend left of the range in the operand. 
            &quot;&quot;&quot;</span>
            <span class="s2">return </span><span class="s1">self.expr.operate(NOT_EXTEND_LEFT_OF</span><span class="s4">, </span><span class="s1">other)</span>

        <span class="s2">def </span><span class="s1">adjacent_to(self</span><span class="s4">, </span><span class="s1">other: Any) -&gt; ColumnElement[bool]:</span>
            <span class="s5">&quot;&quot;&quot;Boolean expression. Returns true if the range in the column 
            is adjacent to the range in the operand. 
            &quot;&quot;&quot;</span>
            <span class="s2">return </span><span class="s1">self.expr.operate(ADJACENT_TO</span><span class="s4">, </span><span class="s1">other)</span>

        <span class="s2">def </span><span class="s1">union(self</span><span class="s4">, </span><span class="s1">other: Any) -&gt; ColumnElement[bool]:</span>
            <span class="s5">&quot;&quot;&quot;Range expression. Returns the union of the two ranges. 
            Will raise an exception if the resulting range is not 
            contiguous. 
            &quot;&quot;&quot;</span>
            <span class="s2">return </span><span class="s1">self.expr.operate(operators.add</span><span class="s4">, </span><span class="s1">other)</span>

        <span class="s2">def </span><span class="s1">difference(self</span><span class="s4">, </span><span class="s1">other: Any) -&gt; ColumnElement[bool]:</span>
            <span class="s5">&quot;&quot;&quot;Range expression. Returns the union of the two ranges. 
            Will raise an exception if the resulting range is not 
            contiguous. 
            &quot;&quot;&quot;</span>
            <span class="s2">return </span><span class="s1">self.expr.operate(operators.sub</span><span class="s4">, </span><span class="s1">other)</span>

        <span class="s2">def </span><span class="s1">intersection(self</span><span class="s4">, </span><span class="s1">other: Any) -&gt; ColumnElement[Range[_T]]:</span>
            <span class="s5">&quot;&quot;&quot;Range expression. Returns the intersection of the two ranges. 
            Will raise an exception if the resulting range is not 
            contiguous. 
            &quot;&quot;&quot;</span>
            <span class="s2">return </span><span class="s1">self.expr.operate(operators.mul</span><span class="s4">, </span><span class="s1">other)</span>


<span class="s2">class </span><span class="s1">AbstractSingleRange(AbstractRange[Range[_T]]):</span>
    <span class="s3">&quot;&quot;&quot;Base for PostgreSQL RANGE types. 
 
    These are types that return a single :class:`_postgresql.Range` object. 
 
    .. seealso:: 
 
        `PostgreSQL range functions &lt;https://www.postgresql.org/docs/current/static/functions-range.html&gt;`_ 
 
    &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

    <span class="s1">__abstract__ = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">_resolve_for_literal(self</span><span class="s4">, </span><span class="s1">value: Range[Any]) -&gt; Any:</span>
        <span class="s1">spec = value.lower </span><span class="s2">if </span><span class="s1">value.lower </span><span class="s2">is not None else </span><span class="s1">value.upper</span>

        <span class="s2">if </span><span class="s1">isinstance(spec</span><span class="s4">, </span><span class="s1">int):</span>
            <span class="s0"># pg is unreasonably picky here: the query</span>
            <span class="s0"># &quot;select 1::INTEGER &lt;@ '[1, 4)'::INT8RANGE&quot; raises</span>
            <span class="s0"># &quot;operator does not exist: integer &lt;@ int8range&quot; as of pg 16</span>
            <span class="s2">if </span><span class="s1">_is_int32(value):</span>
                <span class="s2">return </span><span class="s1">INT4RANGE()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">INT8RANGE()</span>
        <span class="s2">elif </span><span class="s1">isinstance(spec</span><span class="s4">, </span><span class="s1">(Decimal</span><span class="s4">, </span><span class="s1">float)):</span>
            <span class="s2">return </span><span class="s1">NUMRANGE()</span>
        <span class="s2">elif </span><span class="s1">isinstance(spec</span><span class="s4">, </span><span class="s1">datetime):</span>
            <span class="s2">return </span><span class="s1">TSRANGE() </span><span class="s2">if not </span><span class="s1">spec.tzinfo </span><span class="s2">else </span><span class="s1">TSTZRANGE()</span>
        <span class="s2">elif </span><span class="s1">isinstance(spec</span><span class="s4">, </span><span class="s1">date):</span>
            <span class="s2">return </span><span class="s1">DATERANGE()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># empty Range, SQL datatype can't be determined here</span>
            <span class="s2">return </span><span class="s1">sqltypes.NULLTYPE</span>


<span class="s2">class </span><span class="s1">AbstractSingleRangeImpl(AbstractSingleRange[_T]):</span>
    <span class="s5">&quot;&quot;&quot;Marker for AbstractSingleRange that will apply a subclass-specific 
    adaptation&quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">AbstractMultiRange(AbstractRange[Sequence[Range[_T]]]):</span>
    <span class="s5">&quot;&quot;&quot;Base for PostgreSQL MULTIRANGE types. 
 
    these are types that return a sequence of :class:`_postgresql.Range` 
    objects. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__abstract__ = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">_resolve_for_literal(self</span><span class="s4">, </span><span class="s1">value: Sequence[Range[Any]]) -&gt; Any:</span>
        <span class="s2">if not </span><span class="s1">value:</span>
            <span class="s0"># empty MultiRange, SQL datatype can't be determined here</span>
            <span class="s2">return </span><span class="s1">sqltypes.NULLTYPE</span>
        <span class="s1">first = value[</span><span class="s6">0</span><span class="s1">]</span>
        <span class="s1">spec = first.lower </span><span class="s2">if </span><span class="s1">first.lower </span><span class="s2">is not None else </span><span class="s1">first.upper</span>

        <span class="s2">if </span><span class="s1">isinstance(spec</span><span class="s4">, </span><span class="s1">int):</span>
            <span class="s0"># pg is unreasonably picky here: the query</span>
            <span class="s0"># &quot;select 1::INTEGER &lt;@ '{[1, 4),[6,19)}'::INT8MULTIRANGE&quot; raises</span>
            <span class="s0"># &quot;operator does not exist: integer &lt;@ int8multirange&quot; as of pg 16</span>
            <span class="s2">if </span><span class="s1">all(_is_int32(r) </span><span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">value):</span>
                <span class="s2">return </span><span class="s1">INT4MULTIRANGE()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">INT8MULTIRANGE()</span>
        <span class="s2">elif </span><span class="s1">isinstance(spec</span><span class="s4">, </span><span class="s1">(Decimal</span><span class="s4">, </span><span class="s1">float)):</span>
            <span class="s2">return </span><span class="s1">NUMMULTIRANGE()</span>
        <span class="s2">elif </span><span class="s1">isinstance(spec</span><span class="s4">, </span><span class="s1">datetime):</span>
            <span class="s2">return </span><span class="s1">TSMULTIRANGE() </span><span class="s2">if not </span><span class="s1">spec.tzinfo </span><span class="s2">else </span><span class="s1">TSTZMULTIRANGE()</span>
        <span class="s2">elif </span><span class="s1">isinstance(spec</span><span class="s4">, </span><span class="s1">date):</span>
            <span class="s2">return </span><span class="s1">DATEMULTIRANGE()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># empty Range, SQL datatype can't be determined here</span>
            <span class="s2">return </span><span class="s1">sqltypes.NULLTYPE</span>


<span class="s2">class </span><span class="s1">AbstractMultiRangeImpl(AbstractMultiRange[_T]):</span>
    <span class="s5">&quot;&quot;&quot;Marker for AbstractMultiRange that will apply a subclass-specific 
    adaptation&quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">INT4RANGE(AbstractSingleRange[int]):</span>
    <span class="s5">&quot;&quot;&quot;Represent the PostgreSQL INT4RANGE type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ = </span><span class="s3">&quot;INT4RANGE&quot;</span>


<span class="s2">class </span><span class="s1">INT8RANGE(AbstractSingleRange[int]):</span>
    <span class="s5">&quot;&quot;&quot;Represent the PostgreSQL INT8RANGE type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ = </span><span class="s3">&quot;INT8RANGE&quot;</span>


<span class="s2">class </span><span class="s1">NUMRANGE(AbstractSingleRange[Decimal]):</span>
    <span class="s5">&quot;&quot;&quot;Represent the PostgreSQL NUMRANGE type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ = </span><span class="s3">&quot;NUMRANGE&quot;</span>


<span class="s2">class </span><span class="s1">DATERANGE(AbstractSingleRange[date]):</span>
    <span class="s5">&quot;&quot;&quot;Represent the PostgreSQL DATERANGE type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ = </span><span class="s3">&quot;DATERANGE&quot;</span>


<span class="s2">class </span><span class="s1">TSRANGE(AbstractSingleRange[datetime]):</span>
    <span class="s5">&quot;&quot;&quot;Represent the PostgreSQL TSRANGE type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ = </span><span class="s3">&quot;TSRANGE&quot;</span>


<span class="s2">class </span><span class="s1">TSTZRANGE(AbstractSingleRange[datetime]):</span>
    <span class="s5">&quot;&quot;&quot;Represent the PostgreSQL TSTZRANGE type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ = </span><span class="s3">&quot;TSTZRANGE&quot;</span>


<span class="s2">class </span><span class="s1">INT4MULTIRANGE(AbstractMultiRange[int]):</span>
    <span class="s5">&quot;&quot;&quot;Represent the PostgreSQL INT4MULTIRANGE type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ = </span><span class="s3">&quot;INT4MULTIRANGE&quot;</span>


<span class="s2">class </span><span class="s1">INT8MULTIRANGE(AbstractMultiRange[int]):</span>
    <span class="s5">&quot;&quot;&quot;Represent the PostgreSQL INT8MULTIRANGE type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ = </span><span class="s3">&quot;INT8MULTIRANGE&quot;</span>


<span class="s2">class </span><span class="s1">NUMMULTIRANGE(AbstractMultiRange[Decimal]):</span>
    <span class="s5">&quot;&quot;&quot;Represent the PostgreSQL NUMMULTIRANGE type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ = </span><span class="s3">&quot;NUMMULTIRANGE&quot;</span>


<span class="s2">class </span><span class="s1">DATEMULTIRANGE(AbstractMultiRange[date]):</span>
    <span class="s5">&quot;&quot;&quot;Represent the PostgreSQL DATEMULTIRANGE type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ = </span><span class="s3">&quot;DATEMULTIRANGE&quot;</span>


<span class="s2">class </span><span class="s1">TSMULTIRANGE(AbstractMultiRange[datetime]):</span>
    <span class="s5">&quot;&quot;&quot;Represent the PostgreSQL TSRANGE type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ = </span><span class="s3">&quot;TSMULTIRANGE&quot;</span>


<span class="s2">class </span><span class="s1">TSTZMULTIRANGE(AbstractMultiRange[datetime]):</span>
    <span class="s5">&quot;&quot;&quot;Represent the PostgreSQL TSTZRANGE type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ = </span><span class="s3">&quot;TSTZMULTIRANGE&quot;</span>


<span class="s1">_max_int_32 = </span><span class="s6">2</span><span class="s1">**</span><span class="s6">31 </span><span class="s1">- </span><span class="s6">1</span>
<span class="s1">_min_int_32 = -(</span><span class="s6">2</span><span class="s1">**</span><span class="s6">31</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_is_int32(r: Range[int]) -&gt; bool:</span>
    <span class="s2">return </span><span class="s1">(r.lower </span><span class="s2">is None or </span><span class="s1">_min_int_32 &lt;= r.lower &lt;= _max_int_32) </span><span class="s2">and </span><span class="s1">(</span>
        <span class="s1">r.upper </span><span class="s2">is None or </span><span class="s1">_min_int_32 &lt;= r.upper &lt;= _max_int_32</span>
    <span class="s1">)</span>
</pre>
</body>
</html>