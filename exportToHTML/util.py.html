<html>
<head>
<title>util.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5d69bb;}
.s1 { color: #d8d8d8;}
.s2 { color: #cc8b60;}
.s3 { color: #bbb55b;}
.s4 { color: #cc7832;}
.s5 { color: #96bf7d;}
.s6 { color: #717ed3; font-style: italic;}
.s7 { color: #d7539b; font-weight: bold;}
</style>
</head>
<body bgcolor="#1a1a25">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
util.py</font>
</center></td></tr></table>
<pre><span class="s0"># testing/util.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>
<span class="s0"># mypy: ignore-errors</span>


<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">deque</span>
<span class="s2">import </span><span class="s1">contextlib</span>
<span class="s2">import </span><span class="s1">decimal</span>
<span class="s2">import </span><span class="s1">gc</span>
<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">chain</span>
<span class="s2">import </span><span class="s1">random</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">from </span><span class="s1">sys </span><span class="s2">import </span><span class="s1">getsizeof</span>
<span class="s2">import </span><span class="s1">time</span>
<span class="s2">import </span><span class="s1">types</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Any</span>

<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">config</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">mock</span>
<span class="s2">from </span><span class="s1">.. </span><span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">from </span><span class="s1">..engine </span><span class="s2">import </span><span class="s1">Connection</span>
<span class="s2">from </span><span class="s1">..schema </span><span class="s2">import </span><span class="s1">Column</span>
<span class="s2">from </span><span class="s1">..schema </span><span class="s2">import </span><span class="s1">DropConstraint</span>
<span class="s2">from </span><span class="s1">..schema </span><span class="s2">import </span><span class="s1">DropTable</span>
<span class="s2">from </span><span class="s1">..schema </span><span class="s2">import </span><span class="s1">ForeignKeyConstraint</span>
<span class="s2">from </span><span class="s1">..schema </span><span class="s2">import </span><span class="s1">MetaData</span>
<span class="s2">from </span><span class="s1">..schema </span><span class="s2">import </span><span class="s1">Table</span>
<span class="s2">from </span><span class="s1">..sql </span><span class="s2">import </span><span class="s1">schema</span>
<span class="s2">from </span><span class="s1">..sql.sqltypes </span><span class="s2">import </span><span class="s1">Integer</span>
<span class="s2">from </span><span class="s1">..util </span><span class="s2">import </span><span class="s1">decorator</span>
<span class="s2">from </span><span class="s1">..util </span><span class="s2">import </span><span class="s1">defaultdict</span>
<span class="s2">from </span><span class="s1">..util </span><span class="s2">import </span><span class="s1">has_refcount_gc</span>
<span class="s2">from </span><span class="s1">..util </span><span class="s2">import </span><span class="s1">inspect_getfullargspec</span>


<span class="s2">if not </span><span class="s1">has_refcount_gc:</span>

    <span class="s2">def </span><span class="s1">non_refcount_gc_collect(*args):</span>
        <span class="s1">gc.collect()</span>
        <span class="s1">gc.collect()</span>

    <span class="s1">gc_collect = lazy_gc = non_refcount_gc_collect</span>
<span class="s2">else</span><span class="s1">:</span>
    <span class="s0"># assume CPython - straight gc.collect, lazy_gc() is a pass</span>
    <span class="s1">gc_collect = gc.collect</span>

    <span class="s2">def </span><span class="s1">lazy_gc():</span>
        <span class="s2">pass</span>


<span class="s2">def </span><span class="s1">picklers():</span>
    <span class="s1">picklers = set()</span>
    <span class="s2">import </span><span class="s1">pickle</span>

    <span class="s1">picklers.add(pickle)</span>

    <span class="s0"># yes, this thing needs this much testing</span>
    <span class="s2">for </span><span class="s1">pickle_ </span><span class="s2">in </span><span class="s1">picklers:</span>
        <span class="s2">for </span><span class="s1">protocol </span><span class="s2">in </span><span class="s1">range(-</span><span class="s3">2</span><span class="s4">, </span><span class="s1">pickle.HIGHEST_PROTOCOL + </span><span class="s3">1</span><span class="s1">):</span>
            <span class="s2">yield </span><span class="s1">pickle_.loads</span><span class="s4">, </span><span class="s2">lambda </span><span class="s1">d: pickle_.dumps(d</span><span class="s4">, </span><span class="s1">protocol)</span>


<span class="s2">def </span><span class="s1">random_choices(population</span><span class="s4">, </span><span class="s1">k=</span><span class="s3">1</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">random.choices(population</span><span class="s4">, </span><span class="s1">k=k)</span>


<span class="s2">def </span><span class="s1">round_decimal(value</span><span class="s4">, </span><span class="s1">prec):</span>
    <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s4">, </span><span class="s1">float):</span>
        <span class="s2">return </span><span class="s1">round(value</span><span class="s4">, </span><span class="s1">prec)</span>

    <span class="s0"># can also use shift() here but that is 2.6 only</span>
    <span class="s2">return </span><span class="s1">(value * decimal.Decimal(</span><span class="s5">&quot;1&quot; </span><span class="s1">+ </span><span class="s5">&quot;0&quot; </span><span class="s1">* prec)).to_integral(</span>
        <span class="s1">decimal.ROUND_FLOOR</span>
    <span class="s1">) / pow(</span><span class="s3">10</span><span class="s4">, </span><span class="s1">prec)</span>


<span class="s2">class </span><span class="s1">RandomSet(set):</span>
    <span class="s2">def </span><span class="s1">__iter__(self):</span>
        <span class="s1">l = list(set.__iter__(self))</span>
        <span class="s1">random.shuffle(l)</span>
        <span class="s2">return </span><span class="s1">iter(l)</span>

    <span class="s2">def </span><span class="s1">pop(self):</span>
        <span class="s1">index = random.randint(</span><span class="s3">0</span><span class="s4">, </span><span class="s1">len(self) - </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">item = list(set.__iter__(self))[index]</span>
        <span class="s1">self.remove(item)</span>
        <span class="s2">return </span><span class="s1">item</span>

    <span class="s2">def </span><span class="s1">union(self</span><span class="s4">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">RandomSet(set.union(self</span><span class="s4">, </span><span class="s1">other))</span>

    <span class="s2">def </span><span class="s1">difference(self</span><span class="s4">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">RandomSet(set.difference(self</span><span class="s4">, </span><span class="s1">other))</span>

    <span class="s2">def </span><span class="s1">intersection(self</span><span class="s4">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">RandomSet(set.intersection(self</span><span class="s4">, </span><span class="s1">other))</span>

    <span class="s2">def </span><span class="s1">copy(self):</span>
        <span class="s2">return </span><span class="s1">RandomSet(self)</span>


<span class="s2">def </span><span class="s1">conforms_partial_ordering(tuples</span><span class="s4">, </span><span class="s1">sorted_elements):</span>
    <span class="s6">&quot;&quot;&quot;True if the given sorting conforms to the given partial ordering.&quot;&quot;&quot;</span>

    <span class="s1">deps = defaultdict(set)</span>
    <span class="s2">for </span><span class="s1">parent</span><span class="s4">, </span><span class="s1">child </span><span class="s2">in </span><span class="s1">tuples:</span>
        <span class="s1">deps[parent].add(child)</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">node </span><span class="s2">in </span><span class="s1">enumerate(sorted_elements):</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">sorted_elements[i:]:</span>
            <span class="s2">if </span><span class="s1">node </span><span class="s2">in </span><span class="s1">deps[n]:</span>
                <span class="s2">return False</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return True</span>


<span class="s2">def </span><span class="s1">all_partial_orderings(tuples</span><span class="s4">, </span><span class="s1">elements):</span>
    <span class="s1">edges = defaultdict(set)</span>
    <span class="s2">for </span><span class="s1">parent</span><span class="s4">, </span><span class="s1">child </span><span class="s2">in </span><span class="s1">tuples:</span>
        <span class="s1">edges[child].add(parent)</span>

    <span class="s2">def </span><span class="s1">_all_orderings(elements):</span>
        <span class="s2">if </span><span class="s1">len(elements) == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">list(elements)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">elem </span><span class="s2">in </span><span class="s1">elements:</span>
                <span class="s1">subset = set(elements).difference([elem])</span>
                <span class="s2">if not </span><span class="s1">subset.intersection(edges[elem]):</span>
                    <span class="s2">for </span><span class="s1">sub_ordering </span><span class="s2">in </span><span class="s1">_all_orderings(subset):</span>
                        <span class="s2">yield </span><span class="s1">[elem] + sub_ordering</span>

    <span class="s2">return </span><span class="s1">iter(_all_orderings(elements))</span>


<span class="s2">def </span><span class="s1">function_named(fn</span><span class="s4">, </span><span class="s1">name):</span>
    <span class="s6">&quot;&quot;&quot;Return a function with a given __name__. 
 
    Will assign to __name__ and return the original function if possible on 
    the Python implementation, otherwise a new function will be constructed. 
 
    This function should be phased out as much as possible 
    in favor of @decorator.   Tests that &quot;generate&quot; many named tests 
    should be modernized. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">fn.__name__ = name</span>
    <span class="s2">except </span><span class="s1">TypeError:</span>
        <span class="s1">fn = types.FunctionType(</span>
            <span class="s1">fn.__code__</span><span class="s4">, </span><span class="s1">fn.__globals__</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">fn.__defaults__</span><span class="s4">, </span><span class="s1">fn.__closure__</span>
        <span class="s1">)</span>
    <span class="s2">return </span><span class="s1">fn</span>


<span class="s2">def </span><span class="s1">run_as_contextmanager(ctx</span><span class="s4">, </span><span class="s1">fn</span><span class="s4">, </span><span class="s1">*arg</span><span class="s4">, </span><span class="s1">**kw):</span>
    <span class="s6">&quot;&quot;&quot;Run the given function under the given contextmanager, 
    simulating the behavior of 'with' to support older 
    Python versions. 
 
    This is not necessary anymore as we have placed 2.6 
    as minimum Python version, however some tests are still using 
    this structure. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">obj = ctx.__enter__()</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">result = fn(obj</span><span class="s4">, </span><span class="s1">*arg</span><span class="s4">, </span><span class="s1">**kw)</span>
        <span class="s1">ctx.__exit__(</span><span class="s2">None</span><span class="s4">, </span><span class="s2">None</span><span class="s4">, </span><span class="s2">None</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">result</span>
    <span class="s2">except</span><span class="s1">:</span>
        <span class="s1">exc_info = sys.exc_info()</span>
        <span class="s1">raise_ = ctx.__exit__(*exc_info)</span>
        <span class="s2">if not </span><span class="s1">raise_:</span>
            <span class="s2">raise</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">raise_</span>


<span class="s2">def </span><span class="s1">rowset(results):</span>
    <span class="s6">&quot;&quot;&quot;Converts the results of sql execution into a plain set of column tuples. 
 
    Useful for asserting the results of an unordered query. 
    &quot;&quot;&quot;</span>

    <span class="s2">return </span><span class="s1">{tuple(row) </span><span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">results}</span>


<span class="s2">def </span><span class="s1">fail(msg):</span>
    <span class="s2">assert False</span><span class="s4">, </span><span class="s1">msg</span>


<span class="s1">@decorator</span>
<span class="s2">def </span><span class="s1">provide_metadata(fn</span><span class="s4">, </span><span class="s1">*args</span><span class="s4">, </span><span class="s1">**kw):</span>
    <span class="s6">&quot;&quot;&quot;Provide bound MetaData for a single test, dropping afterwards. 
 
    Legacy; use the &quot;metadata&quot; pytest fixture. 
 
    &quot;&quot;&quot;</span>

    <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">fixtures</span>

    <span class="s1">metadata = schema.MetaData()</span>
    <span class="s1">self = args[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">prev_meta = getattr(self</span><span class="s4">, </span><span class="s5">&quot;metadata&quot;</span><span class="s4">, </span><span class="s2">None</span><span class="s1">)</span>
    <span class="s1">self.metadata = metadata</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">fn(*args</span><span class="s4">, </span><span class="s1">**kw)</span>
    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s0"># close out some things that get in the way of dropping tables.</span>
        <span class="s0"># when using the &quot;metadata&quot; fixture, there is a set ordering</span>
        <span class="s0"># of things that makes sure things are cleaned up in order, however</span>
        <span class="s0"># the simple &quot;decorator&quot; nature of this legacy function means</span>
        <span class="s0"># we have to hardcode some of that cleanup ahead of time.</span>

        <span class="s0"># close ORM sessions</span>
        <span class="s1">fixtures.close_all_sessions()</span>

        <span class="s0"># integrate with the &quot;connection&quot; fixture as there are many</span>
        <span class="s0"># tests where it is used along with provide_metadata</span>
        <span class="s1">cfc = fixtures.base._connection_fixture_connection</span>
        <span class="s2">if </span><span class="s1">cfc:</span>
            <span class="s0"># TODO: this warning can be used to find all the places</span>
            <span class="s0"># this is used with connection fixture</span>
            <span class="s0"># warn(&quot;mixing legacy provide metadata with connection fixture&quot;)</span>
            <span class="s1">drop_all_tables_from_metadata(metadata</span><span class="s4">, </span><span class="s1">cfc)</span>
            <span class="s0"># as the provide_metadata fixture is often used with &quot;testing.db&quot;,</span>
            <span class="s0"># when we do the drop we have to commit the transaction so that</span>
            <span class="s0"># the DB is actually updated as the CREATE would have been</span>
            <span class="s0"># committed</span>
            <span class="s1">cfc.get_transaction().commit()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">drop_all_tables_from_metadata(metadata</span><span class="s4">, </span><span class="s1">config.db)</span>
        <span class="s1">self.metadata = prev_meta</span>


<span class="s2">def </span><span class="s1">flag_combinations(*combinations):</span>
    <span class="s6">&quot;&quot;&quot;A facade around @testing.combinations() oriented towards boolean 
    keyword-based arguments. 
 
    Basically generates a nice looking identifier based on the keywords 
    and also sets up the argument names. 
 
    E.g.:: 
 
        @testing.flag_combinations( 
            dict(lazy=False, passive=False), 
            dict(lazy=True, passive=False), 
            dict(lazy=False, passive=True), 
            dict(lazy=False, passive=True, raiseload=True), 
        ) 
 
 
    would result in:: 
 
        @testing.combinations( 
            ('', False, False, False), 
            ('lazy', True, False, False), 
            ('lazy_passive', True, True, False), 
            ('lazy_passive', True, True, True), 
            id_='iaaa', 
            argnames='lazy,passive,raiseload' 
        ) 
 
    &quot;&quot;&quot;</span>

    <span class="s1">keys = set()</span>

    <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">combinations:</span>
        <span class="s1">keys.update(d)</span>

    <span class="s1">keys = sorted(keys)</span>

    <span class="s2">return </span><span class="s1">config.combinations(</span>
        <span class="s1">*[</span>
            <span class="s1">(</span><span class="s5">&quot;_&quot;</span><span class="s1">.join(k </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">keys </span><span class="s2">if </span><span class="s1">d.get(k</span><span class="s4">, </span><span class="s2">False</span><span class="s1">))</span><span class="s4">,</span><span class="s1">)</span>
            <span class="s1">+ tuple(d.get(k</span><span class="s4">, </span><span class="s2">False</span><span class="s1">) </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">keys)</span>
            <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">combinations</span>
        <span class="s1">]</span><span class="s4">,</span>
        <span class="s1">id_=</span><span class="s5">&quot;i&quot; </span><span class="s1">+ (</span><span class="s5">&quot;a&quot; </span><span class="s1">* len(keys))</span><span class="s4">,</span>
        <span class="s1">argnames=</span><span class="s5">&quot;,&quot;</span><span class="s1">.join(keys)</span><span class="s4">,</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">lambda_combinations(lambda_arg_sets</span><span class="s4">, </span><span class="s1">**kw):</span>
    <span class="s1">args = inspect_getfullargspec(lambda_arg_sets)</span>

    <span class="s1">arg_sets = lambda_arg_sets(*[mock.Mock() </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args[</span><span class="s3">0</span><span class="s1">]])</span>

    <span class="s2">def </span><span class="s1">create_fixture(pos):</span>
        <span class="s2">def </span><span class="s1">fixture(**kw):</span>
            <span class="s2">return </span><span class="s1">lambda_arg_sets(**kw)[pos]</span>

        <span class="s1">fixture.__name__ = </span><span class="s5">&quot;fixture_%3.3d&quot; </span><span class="s1">% pos</span>
        <span class="s2">return </span><span class="s1">fixture</span>

    <span class="s2">return </span><span class="s1">config.combinations(</span>
        <span class="s1">*[(create_fixture(i)</span><span class="s4">,</span><span class="s1">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(arg_sets))]</span><span class="s4">, </span><span class="s1">**kw</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">resolve_lambda(__fn</span><span class="s4">, </span><span class="s1">**kw):</span>
    <span class="s6">&quot;&quot;&quot;Given a no-arg lambda and a namespace, return a new lambda that 
    has all the values filled in. 
 
    This is used so that we can have module-level fixtures that 
    refer to instance-level variables using lambdas. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">pos_args = inspect_getfullargspec(__fn)[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">pass_pos_args = {arg: kw.pop(arg) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">pos_args}</span>
    <span class="s1">glb = dict(__fn.__globals__)</span>
    <span class="s1">glb.update(kw)</span>
    <span class="s1">new_fn = types.FunctionType(__fn.__code__</span><span class="s4">, </span><span class="s1">glb)</span>
    <span class="s2">return </span><span class="s1">new_fn(**pass_pos_args)</span>


<span class="s2">def </span><span class="s1">metadata_fixture(ddl=</span><span class="s5">&quot;function&quot;</span><span class="s1">):</span>
    <span class="s6">&quot;&quot;&quot;Provide MetaData for a pytest fixture.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">decorate(fn):</span>
        <span class="s2">def </span><span class="s1">run_ddl(self):</span>
            <span class="s1">metadata = self.metadata = schema.MetaData()</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">result = fn(self</span><span class="s4">, </span><span class="s1">metadata)</span>
                <span class="s1">metadata.create_all(config.db)</span>
                <span class="s0"># TODO:</span>
                <span class="s0"># somehow get a per-function dml erase fixture here</span>
                <span class="s2">yield </span><span class="s1">result</span>
            <span class="s2">finally</span><span class="s1">:</span>
                <span class="s1">metadata.drop_all(config.db)</span>

        <span class="s2">return </span><span class="s1">config.fixture(scope=ddl)(run_ddl)</span>

    <span class="s2">return </span><span class="s1">decorate</span>


<span class="s2">def </span><span class="s1">force_drop_names(*names):</span>
    <span class="s6">&quot;&quot;&quot;Force the given table names to be dropped after test complete, 
    isolating for foreign key cycles 
 
    &quot;&quot;&quot;</span>

    <span class="s1">@decorator</span>
    <span class="s2">def </span><span class="s1">go(fn</span><span class="s4">, </span><span class="s1">*args</span><span class="s4">, </span><span class="s1">**kw):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">fn(*args</span><span class="s4">, </span><span class="s1">**kw)</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">drop_all_tables(config.db</span><span class="s4">, </span><span class="s1">inspect(config.db)</span><span class="s4">, </span><span class="s1">include_names=names)</span>

    <span class="s2">return </span><span class="s1">go</span>


<span class="s2">class </span><span class="s1">adict(dict):</span>
    <span class="s6">&quot;&quot;&quot;Dict keys available as attributes.  Shadows.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__getattribute__(self</span><span class="s4">, </span><span class="s1">key):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self[key]</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s2">return </span><span class="s1">dict.__getattribute__(self</span><span class="s4">, </span><span class="s1">key)</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s4">, </span><span class="s1">*keys):</span>
        <span class="s2">return </span><span class="s1">tuple([self[key] </span><span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">keys])</span>

    <span class="s1">get_all = __call__</span>


<span class="s2">def </span><span class="s1">drop_all_tables_from_metadata(metadata</span><span class="s4">, </span><span class="s1">engine_or_connection):</span>
    <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">engines</span>

    <span class="s2">def </span><span class="s1">go(connection):</span>
        <span class="s1">engines.testing_reaper.prepare_for_drop_tables(connection)</span>

        <span class="s2">if not </span><span class="s1">connection.dialect.supports_alter:</span>
            <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">assertions</span>

            <span class="s2">with </span><span class="s1">assertions.expect_warnings(</span>
                <span class="s5">&quot;Can't sort tables&quot;</span><span class="s4">, </span><span class="s1">assert_=</span><span class="s2">False</span>
            <span class="s1">):</span>
                <span class="s1">metadata.drop_all(connection)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">metadata.drop_all(connection)</span>

    <span class="s2">if not </span><span class="s1">isinstance(engine_or_connection</span><span class="s4">, </span><span class="s1">Connection):</span>
        <span class="s2">with </span><span class="s1">engine_or_connection.begin() </span><span class="s2">as </span><span class="s1">connection:</span>
            <span class="s1">go(connection)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">go(engine_or_connection)</span>


<span class="s2">def </span><span class="s1">drop_all_tables(</span>
    <span class="s1">engine</span><span class="s4">,</span>
    <span class="s1">inspector</span><span class="s4">,</span>
    <span class="s1">schema=</span><span class="s2">None</span><span class="s4">,</span>
    <span class="s1">consider_schemas=(</span><span class="s2">None</span><span class="s4">,</span><span class="s1">)</span><span class="s4">,</span>
    <span class="s1">include_names=</span><span class="s2">None</span><span class="s4">,</span>
<span class="s1">):</span>
    <span class="s2">if </span><span class="s1">include_names </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">include_names = set(include_names)</span>

    <span class="s2">if </span><span class="s1">schema </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">assert </span><span class="s1">consider_schemas == (</span>
            <span class="s2">None</span><span class="s4">,</span>
        <span class="s1">)</span><span class="s4">, </span><span class="s5">&quot;consider_schemas and schema are mutually exclusive&quot;</span>
        <span class="s1">consider_schemas = (schema</span><span class="s4">,</span><span class="s1">)</span>

    <span class="s2">with </span><span class="s1">engine.begin() </span><span class="s2">as </span><span class="s1">conn:</span>
        <span class="s2">for </span><span class="s1">table_key</span><span class="s4">, </span><span class="s1">fkcs </span><span class="s2">in </span><span class="s1">reversed(</span>
            <span class="s1">inspector.sort_tables_on_foreign_key_dependency(</span>
                <span class="s1">consider_schemas=consider_schemas</span>
            <span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s2">if </span><span class="s1">table_key:</span>
                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s1">include_names </span><span class="s2">is not None</span>
                    <span class="s2">and </span><span class="s1">table_key[</span><span class="s3">1</span><span class="s1">] </span><span class="s2">not in </span><span class="s1">include_names</span>
                <span class="s1">):</span>
                    <span class="s2">continue</span>
                <span class="s1">conn.execute(</span>
                    <span class="s1">DropTable(</span>
                        <span class="s1">Table(table_key[</span><span class="s3">1</span><span class="s1">]</span><span class="s4">, </span><span class="s1">MetaData()</span><span class="s4">, </span><span class="s1">schema=table_key[</span><span class="s3">0</span><span class="s1">])</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">fkcs:</span>
                <span class="s2">if not </span><span class="s1">engine.dialect.supports_alter:</span>
                    <span class="s2">continue</span>
                <span class="s2">for </span><span class="s1">t_key</span><span class="s4">, </span><span class="s1">fkc </span><span class="s2">in </span><span class="s1">fkcs:</span>
                    <span class="s2">if </span><span class="s1">(</span>
                        <span class="s1">include_names </span><span class="s2">is not None</span>
                        <span class="s2">and </span><span class="s1">t_key[</span><span class="s3">1</span><span class="s1">] </span><span class="s2">not in </span><span class="s1">include_names</span>
                    <span class="s1">):</span>
                        <span class="s2">continue</span>
                    <span class="s1">tb = Table(</span>
                        <span class="s1">t_key[</span><span class="s3">1</span><span class="s1">]</span><span class="s4">,</span>
                        <span class="s1">MetaData()</span><span class="s4">,</span>
                        <span class="s1">Column(</span><span class="s5">&quot;x&quot;</span><span class="s4">, </span><span class="s1">Integer)</span><span class="s4">,</span>
                        <span class="s1">Column(</span><span class="s5">&quot;y&quot;</span><span class="s4">, </span><span class="s1">Integer)</span><span class="s4">,</span>
                        <span class="s1">schema=t_key[</span><span class="s3">0</span><span class="s1">]</span><span class="s4">,</span>
                    <span class="s1">)</span>
                    <span class="s1">conn.execute(</span>
                        <span class="s1">DropConstraint(</span>
                            <span class="s1">ForeignKeyConstraint([tb.c.x]</span><span class="s4">, </span><span class="s1">[tb.c.y]</span><span class="s4">, </span><span class="s1">name=fkc)</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">teardown_events(event_cls):</span>
    <span class="s1">@decorator</span>
    <span class="s2">def </span><span class="s1">decorate(fn</span><span class="s4">, </span><span class="s1">*arg</span><span class="s4">, </span><span class="s1">**kw):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">fn(*arg</span><span class="s4">, </span><span class="s1">**kw)</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">event_cls._clear()</span>

    <span class="s2">return </span><span class="s1">decorate</span>


<span class="s2">def </span><span class="s1">total_size(o):</span>
    <span class="s6">&quot;&quot;&quot;Returns the approximate memory footprint an object and all of its 
    contents. 
 
    source: https://code.activestate.com/recipes/577504/ 
 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">dict_handler(d):</span>
        <span class="s2">return </span><span class="s1">chain.from_iterable(d.items())</span>

    <span class="s1">all_handlers = {</span>
        <span class="s1">tuple: iter</span><span class="s4">,</span>
        <span class="s1">list: iter</span><span class="s4">,</span>
        <span class="s1">deque: iter</span><span class="s4">,</span>
        <span class="s1">dict: dict_handler</span><span class="s4">,</span>
        <span class="s1">set: iter</span><span class="s4">,</span>
        <span class="s1">frozenset: iter</span><span class="s4">,</span>
    <span class="s1">}</span>
    <span class="s1">seen = set()  </span><span class="s0"># track which object id's have already been seen</span>
    <span class="s1">default_size = getsizeof(</span><span class="s3">0</span><span class="s1">)  </span><span class="s0"># estimate sizeof object without __sizeof__</span>

    <span class="s2">def </span><span class="s1">sizeof(o):</span>
        <span class="s2">if </span><span class="s1">id(o) </span><span class="s2">in </span><span class="s1">seen:  </span><span class="s0"># do not double count the same object</span>
            <span class="s2">return </span><span class="s3">0</span>
        <span class="s1">seen.add(id(o))</span>
        <span class="s1">s = getsizeof(o</span><span class="s4">, </span><span class="s1">default_size)</span>

        <span class="s2">for </span><span class="s1">typ</span><span class="s4">, </span><span class="s1">handler </span><span class="s2">in </span><span class="s1">all_handlers.items():</span>
            <span class="s2">if </span><span class="s1">isinstance(o</span><span class="s4">, </span><span class="s1">typ):</span>
                <span class="s1">s += sum(map(sizeof</span><span class="s4">, </span><span class="s1">handler(o)))</span>
                <span class="s2">break</span>
        <span class="s2">return </span><span class="s1">s</span>

    <span class="s2">return </span><span class="s1">sizeof(o)</span>


<span class="s2">def </span><span class="s1">count_cache_key_tuples(tup):</span>
    <span class="s6">&quot;&quot;&quot;given a cache key tuple, counts how many instances of actual 
    tuples are found. 
 
    used to alert large jumps in cache key complexity. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">stack = [tup]</span>

    <span class="s1">sentinel = object()</span>
    <span class="s1">num_elements = </span><span class="s3">0</span>

    <span class="s2">while </span><span class="s1">stack:</span>
        <span class="s1">elem = stack.pop(</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">elem </span><span class="s2">is </span><span class="s1">sentinel:</span>
            <span class="s1">num_elements += </span><span class="s3">1</span>
        <span class="s2">elif </span><span class="s1">isinstance(elem</span><span class="s4">, </span><span class="s1">tuple):</span>
            <span class="s2">if </span><span class="s1">elem:</span>
                <span class="s1">stack = list(elem) + [sentinel] + stack</span>
    <span class="s2">return </span><span class="s1">num_elements</span>


<span class="s1">@contextlib.contextmanager</span>
<span class="s2">def </span><span class="s1">skip_if_timeout(seconds: float</span><span class="s4">, </span><span class="s1">cleanup: Any = </span><span class="s2">None</span><span class="s1">):</span>

    <span class="s1">now = time.time()</span>
    <span class="s2">yield</span>
    <span class="s1">sec = time.time() - now</span>
    <span class="s2">if </span><span class="s1">sec &gt; seconds:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">cleanup()</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">config.skip_test(</span>
                <span class="s5">f&quot;test took too long (</span><span class="s7">{</span><span class="s1">sec</span><span class="s7">:</span><span class="s5">.4f</span><span class="s7">} </span><span class="s5">seconds &gt; </span><span class="s7">{</span><span class="s1">seconds</span><span class="s7">}</span><span class="s5">)&quot;</span>
            <span class="s1">)</span>
</pre>
</body>
</html>