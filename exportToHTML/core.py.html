<html>
<head>
<title>core.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc8b60;}
.s1 { color: #d8d8d8;}
.s2 { color: #96bf7d;}
.s3 { color: #cc7832;}
.s4 { color: #717ed3; font-style: italic;}
.s5 { color: #d7539b; font-weight: bold;}
.s6 { color: #5d69bb;}
.s7 { color: #bbb55b;}
</style>
</head>
<body bgcolor="#1a1a25">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
core.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">enum</span>
<span class="s0">import </span><span class="s1">errno</span>
<span class="s0">import </span><span class="s1">inspect</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">typing </span><span class="s0">as </span><span class="s1">t</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">abc</span>
<span class="s0">from </span><span class="s1">contextlib </span><span class="s0">import </span><span class="s1">contextmanager</span>
<span class="s0">from </span><span class="s1">contextlib </span><span class="s0">import </span><span class="s1">ExitStack</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">update_wrapper</span>
<span class="s0">from </span><span class="s1">gettext </span><span class="s0">import </span><span class="s1">gettext </span><span class="s0">as </span><span class="s1">_</span>
<span class="s0">from </span><span class="s1">gettext </span><span class="s0">import </span><span class="s1">ngettext</span>
<span class="s0">from </span><span class="s1">itertools </span><span class="s0">import </span><span class="s1">repeat</span>
<span class="s0">from </span><span class="s1">types </span><span class="s0">import </span><span class="s1">TracebackType</span>

<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">types</span>
<span class="s0">from </span><span class="s1">.exceptions </span><span class="s0">import </span><span class="s1">Abort</span>
<span class="s0">from </span><span class="s1">.exceptions </span><span class="s0">import </span><span class="s1">BadParameter</span>
<span class="s0">from </span><span class="s1">.exceptions </span><span class="s0">import </span><span class="s1">ClickException</span>
<span class="s0">from </span><span class="s1">.exceptions </span><span class="s0">import </span><span class="s1">Exit</span>
<span class="s0">from </span><span class="s1">.exceptions </span><span class="s0">import </span><span class="s1">MissingParameter</span>
<span class="s0">from </span><span class="s1">.exceptions </span><span class="s0">import </span><span class="s1">UsageError</span>
<span class="s0">from </span><span class="s1">.formatting </span><span class="s0">import </span><span class="s1">HelpFormatter</span>
<span class="s0">from </span><span class="s1">.formatting </span><span class="s0">import </span><span class="s1">join_options</span>
<span class="s0">from </span><span class="s1">.globals </span><span class="s0">import </span><span class="s1">pop_context</span>
<span class="s0">from </span><span class="s1">.globals </span><span class="s0">import </span><span class="s1">push_context</span>
<span class="s0">from </span><span class="s1">.parser </span><span class="s0">import </span><span class="s1">_flag_needs_value</span>
<span class="s0">from </span><span class="s1">.parser </span><span class="s0">import </span><span class="s1">OptionParser</span>
<span class="s0">from </span><span class="s1">.parser </span><span class="s0">import </span><span class="s1">split_opt</span>
<span class="s0">from </span><span class="s1">.termui </span><span class="s0">import </span><span class="s1">confirm</span>
<span class="s0">from </span><span class="s1">.termui </span><span class="s0">import </span><span class="s1">prompt</span>
<span class="s0">from </span><span class="s1">.termui </span><span class="s0">import </span><span class="s1">style</span>
<span class="s0">from </span><span class="s1">.utils </span><span class="s0">import </span><span class="s1">_detect_program_name</span>
<span class="s0">from </span><span class="s1">.utils </span><span class="s0">import </span><span class="s1">_expand_args</span>
<span class="s0">from </span><span class="s1">.utils </span><span class="s0">import </span><span class="s1">echo</span>
<span class="s0">from </span><span class="s1">.utils </span><span class="s0">import </span><span class="s1">make_default_short_help</span>
<span class="s0">from </span><span class="s1">.utils </span><span class="s0">import </span><span class="s1">make_str</span>
<span class="s0">from </span><span class="s1">.utils </span><span class="s0">import </span><span class="s1">PacifyFlushWrapper</span>

<span class="s0">if </span><span class="s1">t.TYPE_CHECKING:</span>
    <span class="s0">import </span><span class="s1">typing_extensions </span><span class="s0">as </span><span class="s1">te</span>
    <span class="s0">from </span><span class="s1">.shell_completion </span><span class="s0">import </span><span class="s1">CompletionItem</span>

<span class="s1">F = t.TypeVar(</span><span class="s2">&quot;F&quot;</span><span class="s3">, </span><span class="s1">bound=t.Callable[...</span><span class="s3">, </span><span class="s1">t.Any])</span>
<span class="s1">V = t.TypeVar(</span><span class="s2">&quot;V&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_complete_visible_commands(</span>
    <span class="s1">ctx: </span><span class="s2">&quot;Context&quot;</span><span class="s3">, </span><span class="s1">incomplete: str</span>
<span class="s1">) -&gt; t.Iterator[t.Tuple[str</span><span class="s3">, </span><span class="s2">&quot;Command&quot;</span><span class="s1">]]:</span>
    <span class="s4">&quot;&quot;&quot;List all the subcommands of a group that start with the 
    incomplete value and aren't hidden. 
 
    :param ctx: Invocation context for the group. 
    :param incomplete: Value being completed. May be empty. 
    &quot;&quot;&quot;</span>
    <span class="s1">multi = t.cast(MultiCommand</span><span class="s3">, </span><span class="s1">ctx.command)</span>

    <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">multi.list_commands(ctx):</span>
        <span class="s0">if </span><span class="s1">name.startswith(incomplete):</span>
            <span class="s1">command = multi.get_command(ctx</span><span class="s3">, </span><span class="s1">name)</span>

            <span class="s0">if </span><span class="s1">command </span><span class="s0">is not None and not </span><span class="s1">command.hidden:</span>
                <span class="s0">yield </span><span class="s1">name</span><span class="s3">, </span><span class="s1">command</span>


<span class="s0">def </span><span class="s1">_check_multicommand(</span>
    <span class="s1">base_command: </span><span class="s2">&quot;MultiCommand&quot;</span><span class="s3">, </span><span class="s1">cmd_name: str</span><span class="s3">, </span><span class="s1">cmd: </span><span class="s2">&quot;Command&quot;</span><span class="s3">, </span><span class="s1">register: bool = </span><span class="s0">False</span>
<span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
    <span class="s0">if not </span><span class="s1">base_command.chain </span><span class="s0">or not </span><span class="s1">isinstance(cmd</span><span class="s3">, </span><span class="s1">MultiCommand):</span>
        <span class="s0">return</span>
    <span class="s0">if </span><span class="s1">register:</span>
        <span class="s1">hint = (</span>
            <span class="s2">&quot;It is not possible to add multi commands as children to&quot;</span>
            <span class="s2">&quot; another multi command that is in chain mode.&quot;</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">hint = (</span>
            <span class="s2">&quot;Found a multi command as subcommand to a multi command&quot;</span>
            <span class="s2">&quot; that is in chain mode. This is not supported.&quot;</span>
        <span class="s1">)</span>
    <span class="s0">raise </span><span class="s1">RuntimeError(</span>
        <span class="s2">f&quot;</span><span class="s5">{</span><span class="s1">hint</span><span class="s5">}</span><span class="s2">. Command </span><span class="s5">{</span><span class="s1">base_command.name</span><span class="s5">!r} </span><span class="s2">is set to chain and&quot;</span>
        <span class="s2">f&quot; </span><span class="s5">{</span><span class="s1">cmd_name</span><span class="s5">!r} </span><span class="s2">was added as a subcommand but it in itself is a&quot;</span>
        <span class="s2">f&quot; multi command. (</span><span class="s5">{</span><span class="s1">cmd_name</span><span class="s5">!r} </span><span class="s2">is a </span><span class="s5">{</span><span class="s1">type(cmd).__name__</span><span class="s5">}</span><span class="s2">&quot;</span>
        <span class="s2">f&quot; within a chained </span><span class="s5">{</span><span class="s1">type(base_command).__name__</span><span class="s5">} </span><span class="s2">named&quot;</span>
        <span class="s2">f&quot; </span><span class="s5">{</span><span class="s1">base_command.name</span><span class="s5">!r}</span><span class="s2">).&quot;</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">batch(iterable: t.Iterable[V]</span><span class="s3">, </span><span class="s1">batch_size: int) -&gt; t.List[t.Tuple[V</span><span class="s3">, </span><span class="s1">...]]:</span>
    <span class="s0">return </span><span class="s1">list(zip(*repeat(iter(iterable)</span><span class="s3">, </span><span class="s1">batch_size)))</span>


<span class="s1">@contextmanager</span>
<span class="s0">def </span><span class="s1">augment_usage_errors(</span>
    <span class="s1">ctx: </span><span class="s2">&quot;Context&quot;</span><span class="s3">, </span><span class="s1">param: t.Optional[</span><span class="s2">&quot;Parameter&quot;</span><span class="s1">] = </span><span class="s0">None</span>
<span class="s1">) -&gt; t.Iterator[</span><span class="s0">None</span><span class="s1">]:</span>
    <span class="s4">&quot;&quot;&quot;Context manager that attaches extra information to exceptions.&quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">yield</span>
    <span class="s0">except </span><span class="s1">BadParameter </span><span class="s0">as </span><span class="s1">e:</span>
        <span class="s0">if </span><span class="s1">e.ctx </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">e.ctx = ctx</span>
        <span class="s0">if </span><span class="s1">param </span><span class="s0">is not None and </span><span class="s1">e.param </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">e.param = param</span>
        <span class="s0">raise</span>
    <span class="s0">except </span><span class="s1">UsageError </span><span class="s0">as </span><span class="s1">e:</span>
        <span class="s0">if </span><span class="s1">e.ctx </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">e.ctx = ctx</span>
        <span class="s0">raise</span>


<span class="s0">def </span><span class="s1">iter_params_for_processing(</span>
    <span class="s1">invocation_order: t.Sequence[</span><span class="s2">&quot;Parameter&quot;</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s1">declaration_order: t.Sequence[</span><span class="s2">&quot;Parameter&quot;</span><span class="s1">]</span><span class="s3">,</span>
<span class="s1">) -&gt; t.List[</span><span class="s2">&quot;Parameter&quot;</span><span class="s1">]:</span>
    <span class="s4">&quot;&quot;&quot;Given a sequence of parameters in the order as should be considered 
    for processing and an iterable of parameters that exist, this returns 
    a list in the correct order as they should be processed. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">sort_key(item: </span><span class="s2">&quot;Parameter&quot;</span><span class="s1">) -&gt; t.Tuple[bool</span><span class="s3">, </span><span class="s1">float]:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">idx: float = invocation_order.index(item)</span>
        <span class="s0">except </span><span class="s1">ValueError:</span>
            <span class="s1">idx = float(</span><span class="s2">&quot;inf&quot;</span><span class="s1">)</span>

        <span class="s0">return not </span><span class="s1">item.is_eager</span><span class="s3">, </span><span class="s1">idx</span>

    <span class="s0">return </span><span class="s1">sorted(declaration_order</span><span class="s3">, </span><span class="s1">key=sort_key)</span>


<span class="s0">class </span><span class="s1">ParameterSource(enum.Enum):</span>
    <span class="s4">&quot;&quot;&quot;This is an :class:`~enum.Enum` that indicates the source of a 
    parameter's value. 
 
    Use :meth:`click.Context.get_parameter_source` to get the 
    source for a parameter by name. 
 
    .. versionchanged:: 8.0 
        Use :class:`~enum.Enum` and drop the ``validate`` method. 
 
    .. versionchanged:: 8.0 
        Added the ``PROMPT`` value. 
    &quot;&quot;&quot;</span>

    <span class="s1">COMMANDLINE = enum.auto()</span>
    <span class="s2">&quot;&quot;&quot;The value was provided by the command line args.&quot;&quot;&quot;</span>
    <span class="s1">ENVIRONMENT = enum.auto()</span>
    <span class="s2">&quot;&quot;&quot;The value was provided with an environment variable.&quot;&quot;&quot;</span>
    <span class="s1">DEFAULT = enum.auto()</span>
    <span class="s2">&quot;&quot;&quot;Used the default specified by the parameter.&quot;&quot;&quot;</span>
    <span class="s1">DEFAULT_MAP = enum.auto()</span>
    <span class="s2">&quot;&quot;&quot;Used a default provided by :attr:`Context.default_map`.&quot;&quot;&quot;</span>
    <span class="s1">PROMPT = enum.auto()</span>
    <span class="s2">&quot;&quot;&quot;Used a prompt to confirm a default or provide a value.&quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">Context:</span>
    <span class="s4">&quot;&quot;&quot;The context is a special internal object that holds state relevant 
    for the script execution at every single level.  It's normally invisible 
    to commands unless they opt-in to getting access to it. 
 
    The context is useful as it can pass internal objects around and can 
    control special execution features such as reading data from 
    environment variables. 
 
    A context can be used as context manager in which case it will call 
    :meth:`close` on teardown. 
 
    :param command: the command class for this context. 
    :param parent: the parent context. 
    :param info_name: the info name for this invocation.  Generally this 
                      is the most descriptive name for the script or 
                      command.  For the toplevel script it is usually 
                      the name of the script, for commands below it it's 
                      the name of the script. 
    :param obj: an arbitrary object of user data. 
    :param auto_envvar_prefix: the prefix to use for automatic environment 
                               variables.  If this is `None` then reading 
                               from environment variables is disabled.  This 
                               does not affect manually set environment 
                               variables which are always read. 
    :param default_map: a dictionary (like object) with default values 
                        for parameters. 
    :param terminal_width: the width of the terminal.  The default is 
                           inherit from parent context.  If no context 
                           defines the terminal width then auto 
                           detection will be applied. 
    :param max_content_width: the maximum width for content rendered by 
                              Click (this currently only affects help 
                              pages).  This defaults to 80 characters if 
                              not overridden.  In other words: even if the 
                              terminal is larger than that, Click will not 
                              format things wider than 80 characters by 
                              default.  In addition to that, formatters might 
                              add some safety mapping on the right. 
    :param resilient_parsing: if this flag is enabled then Click will 
                              parse without any interactivity or callback 
                              invocation.  Default values will also be 
                              ignored.  This is useful for implementing 
                              things such as completion support. 
    :param allow_extra_args: if this is set to `True` then extra arguments 
                             at the end will not raise an error and will be 
                             kept on the context.  The default is to inherit 
                             from the command. 
    :param allow_interspersed_args: if this is set to `False` then options 
                                    and arguments cannot be mixed.  The 
                                    default is to inherit from the command. 
    :param ignore_unknown_options: instructs click to ignore options it does 
                                   not know and keeps them for later 
                                   processing. 
    :param help_option_names: optionally a list of strings that define how 
                              the default help parameter is named.  The 
                              default is ``['--help']``. 
    :param token_normalize_func: an optional function that is used to 
                                 normalize tokens (options, choices, 
                                 etc.).  This for instance can be used to 
                                 implement case insensitive behavior. 
    :param color: controls if the terminal supports ANSI colors or not.  The 
                  default is autodetection.  This is only needed if ANSI 
                  codes are used in texts that Click prints which is by 
                  default not the case.  This for instance would affect 
                  help output. 
    :param show_default: Show the default value for commands. If this 
        value is not set, it defaults to the value from the parent 
        context. ``Command.show_default`` overrides this default for the 
        specific command. 
 
    .. versionchanged:: 8.1 
        The ``show_default`` parameter is overridden by 
        ``Command.show_default``, instead of the other way around. 
 
    .. versionchanged:: 8.0 
        The ``show_default`` parameter defaults to the value from the 
        parent context. 
 
    .. versionchanged:: 7.1 
       Added the ``show_default`` parameter. 
 
    .. versionchanged:: 4.0 
        Added the ``color``, ``ignore_unknown_options``, and 
        ``max_content_width`` parameters. 
 
    .. versionchanged:: 3.0 
        Added the ``allow_extra_args`` and ``allow_interspersed_args`` 
        parameters. 
 
    .. versionchanged:: 2.0 
        Added the ``resilient_parsing``, ``help_option_names``, and 
        ``token_normalize_func`` parameters. 
    &quot;&quot;&quot;</span>

    <span class="s6">#: The formatter class to create with :meth:`make_formatter`.</span>
    <span class="s6">#:</span>
    <span class="s6">#: .. versionadded:: 8.0</span>
    <span class="s1">formatter_class: t.Type[</span><span class="s2">&quot;HelpFormatter&quot;</span><span class="s1">] = HelpFormatter</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">command: </span><span class="s2">&quot;Command&quot;</span><span class="s3">,</span>
        <span class="s1">parent: t.Optional[</span><span class="s2">&quot;Context&quot;</span><span class="s1">] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">info_name: t.Optional[str] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">obj: t.Optional[t.Any] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">auto_envvar_prefix: t.Optional[str] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">default_map: t.Optional[t.MutableMapping[str</span><span class="s3">, </span><span class="s1">t.Any]] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">terminal_width: t.Optional[int] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">max_content_width: t.Optional[int] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">resilient_parsing: bool = </span><span class="s0">False</span><span class="s3">,</span>
        <span class="s1">allow_extra_args: t.Optional[bool] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">allow_interspersed_args: t.Optional[bool] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">ignore_unknown_options: t.Optional[bool] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">help_option_names: t.Optional[t.List[str]] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">token_normalize_func: t.Optional[t.Callable[[str]</span><span class="s3">, </span><span class="s1">str]] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">color: t.Optional[bool] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">show_default: t.Optional[bool] = </span><span class="s0">None</span><span class="s3">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s6">#: the parent context or `None` if none exists.</span>
        <span class="s1">self.parent = parent</span>
        <span class="s6">#: the :class:`Command` for this context.</span>
        <span class="s1">self.command = command</span>
        <span class="s6">#: the descriptive information name</span>
        <span class="s1">self.info_name = info_name</span>
        <span class="s6">#: Map of parameter names to their parsed values. Parameters</span>
        <span class="s6">#: with ``expose_value=False`` are not stored.</span>
        <span class="s1">self.params: t.Dict[str</span><span class="s3">, </span><span class="s1">t.Any] = {}</span>
        <span class="s6">#: the leftover arguments.</span>
        <span class="s1">self.args: t.List[str] = []</span>
        <span class="s6">#: protected arguments.  These are arguments that are prepended</span>
        <span class="s6">#: to `args` when certain parsing scenarios are encountered but</span>
        <span class="s6">#: must be never propagated to another arguments.  This is used</span>
        <span class="s6">#: to implement nested parsing.</span>
        <span class="s1">self.protected_args: t.List[str] = []</span>
        <span class="s6">#: the collected prefixes of the command's options.</span>
        <span class="s1">self._opt_prefixes: t.Set[str] = set(parent._opt_prefixes) </span><span class="s0">if </span><span class="s1">parent </span><span class="s0">else </span><span class="s1">set()</span>

        <span class="s0">if </span><span class="s1">obj </span><span class="s0">is None and </span><span class="s1">parent </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">obj = parent.obj</span>

        <span class="s6">#: the user object stored.</span>
        <span class="s1">self.obj: t.Any = obj</span>
        <span class="s1">self._meta: t.Dict[str</span><span class="s3">, </span><span class="s1">t.Any] = getattr(parent</span><span class="s3">, </span><span class="s2">&quot;meta&quot;</span><span class="s3">, </span><span class="s1">{})</span>

        <span class="s6">#: A dictionary (-like object) with defaults for parameters.</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">default_map </span><span class="s0">is None</span>
            <span class="s0">and </span><span class="s1">info_name </span><span class="s0">is not None</span>
            <span class="s0">and </span><span class="s1">parent </span><span class="s0">is not None</span>
            <span class="s0">and </span><span class="s1">parent.default_map </span><span class="s0">is not None</span>
        <span class="s1">):</span>
            <span class="s1">default_map = parent.default_map.get(info_name)</span>

        <span class="s1">self.default_map: t.Optional[t.MutableMapping[str</span><span class="s3">, </span><span class="s1">t.Any]] = default_map</span>

        <span class="s6">#: This flag indicates if a subcommand is going to be executed. A</span>
        <span class="s6">#: group callback can use this information to figure out if it's</span>
        <span class="s6">#: being executed directly or because the execution flow passes</span>
        <span class="s6">#: onwards to a subcommand. By default it's None, but it can be</span>
        <span class="s6">#: the name of the subcommand to execute.</span>
        <span class="s6">#:</span>
        <span class="s6">#: If chaining is enabled this will be set to ``'*'`` in case</span>
        <span class="s6">#: any commands are executed.  It is however not possible to</span>
        <span class="s6">#: figure out which ones.  If you require this knowledge you</span>
        <span class="s6">#: should use a :func:`result_callback`.</span>
        <span class="s1">self.invoked_subcommand: t.Optional[str] = </span><span class="s0">None</span>

        <span class="s0">if </span><span class="s1">terminal_width </span><span class="s0">is None and </span><span class="s1">parent </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">terminal_width = parent.terminal_width</span>

        <span class="s6">#: The width of the terminal (None is autodetection).</span>
        <span class="s1">self.terminal_width: t.Optional[int] = terminal_width</span>

        <span class="s0">if </span><span class="s1">max_content_width </span><span class="s0">is None and </span><span class="s1">parent </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">max_content_width = parent.max_content_width</span>

        <span class="s6">#: The maximum width of formatted content (None implies a sensible</span>
        <span class="s6">#: default which is 80 for most things).</span>
        <span class="s1">self.max_content_width: t.Optional[int] = max_content_width</span>

        <span class="s0">if </span><span class="s1">allow_extra_args </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">allow_extra_args = command.allow_extra_args</span>

        <span class="s6">#: Indicates if the context allows extra args or if it should</span>
        <span class="s6">#: fail on parsing.</span>
        <span class="s6">#:</span>
        <span class="s6">#: .. versionadded:: 3.0</span>
        <span class="s1">self.allow_extra_args = allow_extra_args</span>

        <span class="s0">if </span><span class="s1">allow_interspersed_args </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">allow_interspersed_args = command.allow_interspersed_args</span>

        <span class="s6">#: Indicates if the context allows mixing of arguments and</span>
        <span class="s6">#: options or not.</span>
        <span class="s6">#:</span>
        <span class="s6">#: .. versionadded:: 3.0</span>
        <span class="s1">self.allow_interspersed_args: bool = allow_interspersed_args</span>

        <span class="s0">if </span><span class="s1">ignore_unknown_options </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">ignore_unknown_options = command.ignore_unknown_options</span>

        <span class="s6">#: Instructs click to ignore options that a command does not</span>
        <span class="s6">#: understand and will store it on the context for later</span>
        <span class="s6">#: processing.  This is primarily useful for situations where you</span>
        <span class="s6">#: want to call into external programs.  Generally this pattern is</span>
        <span class="s6">#: strongly discouraged because it's not possibly to losslessly</span>
        <span class="s6">#: forward all arguments.</span>
        <span class="s6">#:</span>
        <span class="s6">#: .. versionadded:: 4.0</span>
        <span class="s1">self.ignore_unknown_options: bool = ignore_unknown_options</span>

        <span class="s0">if </span><span class="s1">help_option_names </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">parent </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">help_option_names = parent.help_option_names</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">help_option_names = [</span><span class="s2">&quot;--help&quot;</span><span class="s1">]</span>

        <span class="s6">#: The names for the help options.</span>
        <span class="s1">self.help_option_names: t.List[str] = help_option_names</span>

        <span class="s0">if </span><span class="s1">token_normalize_func </span><span class="s0">is None and </span><span class="s1">parent </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">token_normalize_func = parent.token_normalize_func</span>

        <span class="s6">#: An optional normalization function for tokens.  This is</span>
        <span class="s6">#: options, choices, commands etc.</span>
        <span class="s1">self.token_normalize_func: t.Optional[</span>
            <span class="s1">t.Callable[[str]</span><span class="s3">, </span><span class="s1">str]</span>
        <span class="s1">] = token_normalize_func</span>

        <span class="s6">#: Indicates if resilient parsing is enabled.  In that case Click</span>
        <span class="s6">#: will do its best to not cause any failures and default values</span>
        <span class="s6">#: will be ignored. Useful for completion.</span>
        <span class="s1">self.resilient_parsing: bool = resilient_parsing</span>

        <span class="s6"># If there is no envvar prefix yet, but the parent has one and</span>
        <span class="s6"># the command on this level has a name, we can expand the envvar</span>
        <span class="s6"># prefix automatically.</span>
        <span class="s0">if </span><span class="s1">auto_envvar_prefix </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">(</span>
                <span class="s1">parent </span><span class="s0">is not None</span>
                <span class="s0">and </span><span class="s1">parent.auto_envvar_prefix </span><span class="s0">is not None</span>
                <span class="s0">and </span><span class="s1">self.info_name </span><span class="s0">is not None</span>
            <span class="s1">):</span>
                <span class="s1">auto_envvar_prefix = (</span>
                    <span class="s2">f&quot;</span><span class="s5">{</span><span class="s1">parent.auto_envvar_prefix</span><span class="s5">}</span><span class="s2">_</span><span class="s5">{</span><span class="s1">self.info_name.upper()</span><span class="s5">}</span><span class="s2">&quot;</span>
                <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">auto_envvar_prefix = auto_envvar_prefix.upper()</span>

        <span class="s0">if </span><span class="s1">auto_envvar_prefix </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">auto_envvar_prefix = auto_envvar_prefix.replace(</span><span class="s2">&quot;-&quot;</span><span class="s3">, </span><span class="s2">&quot;_&quot;</span><span class="s1">)</span>

        <span class="s1">self.auto_envvar_prefix: t.Optional[str] = auto_envvar_prefix</span>

        <span class="s0">if </span><span class="s1">color </span><span class="s0">is None and </span><span class="s1">parent </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">color = parent.color</span>

        <span class="s6">#: Controls if styling output is wanted or not.</span>
        <span class="s1">self.color: t.Optional[bool] = color</span>

        <span class="s0">if </span><span class="s1">show_default </span><span class="s0">is None and </span><span class="s1">parent </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">show_default = parent.show_default</span>

        <span class="s6">#: Show option default values when formatting help text.</span>
        <span class="s1">self.show_default: t.Optional[bool] = show_default</span>

        <span class="s1">self._close_callbacks: t.List[t.Callable[[]</span><span class="s3">, </span><span class="s1">t.Any]] = []</span>
        <span class="s1">self._depth = </span><span class="s7">0</span>
        <span class="s1">self._parameter_source: t.Dict[str</span><span class="s3">, </span><span class="s1">ParameterSource] = {}</span>
        <span class="s1">self._exit_stack = ExitStack()</span>

    <span class="s0">def </span><span class="s1">to_info_dict(self) -&gt; t.Dict[str</span><span class="s3">, </span><span class="s1">t.Any]:</span>
        <span class="s4">&quot;&quot;&quot;Gather information that could be useful for a tool generating 
        user-facing documentation. This traverses the entire CLI 
        structure. 
 
        .. code-block:: python 
 
            with Context(cli) as ctx: 
                info = ctx.to_info_dict() 
 
        .. versionadded:: 8.0 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">{</span>
            <span class="s2">&quot;command&quot;</span><span class="s1">: self.command.to_info_dict(self)</span><span class="s3">,</span>
            <span class="s2">&quot;info_name&quot;</span><span class="s1">: self.info_name</span><span class="s3">,</span>
            <span class="s2">&quot;allow_extra_args&quot;</span><span class="s1">: self.allow_extra_args</span><span class="s3">,</span>
            <span class="s2">&quot;allow_interspersed_args&quot;</span><span class="s1">: self.allow_interspersed_args</span><span class="s3">,</span>
            <span class="s2">&quot;ignore_unknown_options&quot;</span><span class="s1">: self.ignore_unknown_options</span><span class="s3">,</span>
            <span class="s2">&quot;auto_envvar_prefix&quot;</span><span class="s1">: self.auto_envvar_prefix</span><span class="s3">,</span>
        <span class="s1">}</span>

    <span class="s0">def </span><span class="s1">__enter__(self) -&gt; </span><span class="s2">&quot;Context&quot;</span><span class="s1">:</span>
        <span class="s1">self._depth += </span><span class="s7">1</span>
        <span class="s1">push_context(self)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">__exit__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">exc_type: t.Optional[t.Type[BaseException]]</span><span class="s3">,</span>
        <span class="s1">exc_value: t.Optional[BaseException]</span><span class="s3">,</span>
        <span class="s1">tb: t.Optional[TracebackType]</span><span class="s3">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self._depth -= </span><span class="s7">1</span>
        <span class="s0">if </span><span class="s1">self._depth == </span><span class="s7">0</span><span class="s1">:</span>
            <span class="s1">self.close()</span>
        <span class="s1">pop_context()</span>

    <span class="s1">@contextmanager</span>
    <span class="s0">def </span><span class="s1">scope(self</span><span class="s3">, </span><span class="s1">cleanup: bool = </span><span class="s0">True</span><span class="s1">) -&gt; t.Iterator[</span><span class="s2">&quot;Context&quot;</span><span class="s1">]:</span>
        <span class="s4">&quot;&quot;&quot;This helper method can be used with the context object to promote 
        it to the current thread local (see :func:`get_current_context`). 
        The default behavior of this is to invoke the cleanup functions which 
        can be disabled by setting `cleanup` to `False`.  The cleanup 
        functions are typically used for things such as closing file handles. 
 
        If the cleanup is intended the context object can also be directly 
        used as a context manager. 
 
        Example usage:: 
 
            with ctx.scope(): 
                assert get_current_context() is ctx 
 
        This is equivalent:: 
 
            with ctx: 
                assert get_current_context() is ctx 
 
        .. versionadded:: 5.0 
 
        :param cleanup: controls if the cleanup functions should be run or 
                        not.  The default is to run these functions.  In 
                        some situations the context only wants to be 
                        temporarily pushed in which case this can be disabled. 
                        Nested pushes automatically defer the cleanup. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">cleanup:</span>
            <span class="s1">self._depth += </span><span class="s7">1</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">with </span><span class="s1">self </span><span class="s0">as </span><span class="s1">rv:</span>
                <span class="s0">yield </span><span class="s1">rv</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">cleanup:</span>
                <span class="s1">self._depth -= </span><span class="s7">1</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">meta(self) -&gt; t.Dict[str</span><span class="s3">, </span><span class="s1">t.Any]:</span>
        <span class="s4">&quot;&quot;&quot;This is a dictionary which is shared with all the contexts 
        that are nested.  It exists so that click utilities can store some 
        state here if they need to.  It is however the responsibility of 
        that code to manage this dictionary well. 
 
        The keys are supposed to be unique dotted strings.  For instance 
        module paths are a good choice for it.  What is stored in there is 
        irrelevant for the operation of click.  However what is important is 
        that code that places data here adheres to the general semantics of 
        the system. 
 
        Example usage:: 
 
            LANG_KEY = f'{__name__}.lang' 
 
            def set_language(value): 
                ctx = get_current_context() 
                ctx.meta[LANG_KEY] = value 
 
            def get_language(): 
                return get_current_context().meta.get(LANG_KEY, 'en_US') 
 
        .. versionadded:: 5.0 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._meta</span>

    <span class="s0">def </span><span class="s1">make_formatter(self) -&gt; HelpFormatter:</span>
        <span class="s4">&quot;&quot;&quot;Creates the :class:`~click.HelpFormatter` for the help and 
        usage output. 
 
        To quickly customize the formatter class used without overriding 
        this method, set the :attr:`formatter_class` attribute. 
 
        .. versionchanged:: 8.0 
            Added the :attr:`formatter_class` attribute. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.formatter_class(</span>
            <span class="s1">width=self.terminal_width</span><span class="s3">, </span><span class="s1">max_width=self.max_content_width</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">with_resource(self</span><span class="s3">, </span><span class="s1">context_manager: t.ContextManager[V]) -&gt; V:</span>
        <span class="s4">&quot;&quot;&quot;Register a resource as if it were used in a ``with`` 
        statement. The resource will be cleaned up when the context is 
        popped. 
 
        Uses :meth:`contextlib.ExitStack.enter_context`. It calls the 
        resource's ``__enter__()`` method and returns the result. When 
        the context is popped, it closes the stack, which calls the 
        resource's ``__exit__()`` method. 
 
        To register a cleanup function for something that isn't a 
        context manager, use :meth:`call_on_close`. Or use something 
        from :mod:`contextlib` to turn it into a context manager first. 
 
        .. code-block:: python 
 
            @click.group() 
            @click.option(&quot;--name&quot;) 
            @click.pass_context 
            def cli(ctx): 
                ctx.obj = ctx.with_resource(connect_db(name)) 
 
        :param context_manager: The context manager to enter. 
        :return: Whatever ``context_manager.__enter__()`` returns. 
 
        .. versionadded:: 8.0 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._exit_stack.enter_context(context_manager)</span>

    <span class="s0">def </span><span class="s1">call_on_close(self</span><span class="s3">, </span><span class="s1">f: t.Callable[...</span><span class="s3">, </span><span class="s1">t.Any]) -&gt; t.Callable[...</span><span class="s3">, </span><span class="s1">t.Any]:</span>
        <span class="s4">&quot;&quot;&quot;Register a function to be called when the context tears down. 
 
        This can be used to close resources opened during the script 
        execution. Resources that support Python's context manager 
        protocol which would be used in a ``with`` statement should be 
        registered with :meth:`with_resource` instead. 
 
        :param f: The function to execute on teardown. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._exit_stack.callback(f)</span>

    <span class="s0">def </span><span class="s1">close(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Invoke all close callbacks registered with 
        :meth:`call_on_close`, and exit all context managers entered 
        with :meth:`with_resource`. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._exit_stack.close()</span>
        <span class="s6"># In case the context is reused, create a new exit stack.</span>
        <span class="s1">self._exit_stack = ExitStack()</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">command_path(self) -&gt; str:</span>
        <span class="s4">&quot;&quot;&quot;The computed command path.  This is used for the ``usage`` 
        information on the help page.  It's automatically created by 
        combining the info names of the chain of contexts to the root. 
        &quot;&quot;&quot;</span>
        <span class="s1">rv = </span><span class="s2">&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.info_name </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">rv = self.info_name</span>
        <span class="s0">if </span><span class="s1">self.parent </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">parent_command_path = [self.parent.command_path]</span>

            <span class="s0">if </span><span class="s1">isinstance(self.parent.command</span><span class="s3">, </span><span class="s1">Command):</span>
                <span class="s0">for </span><span class="s1">param </span><span class="s0">in </span><span class="s1">self.parent.command.get_params(self):</span>
                    <span class="s1">parent_command_path.extend(param.get_usage_pieces(self))</span>

            <span class="s1">rv = </span><span class="s2">f&quot;</span><span class="s5">{</span><span class="s2">' '</span><span class="s1">.join(parent_command_path)</span><span class="s5">} {</span><span class="s1">rv</span><span class="s5">}</span><span class="s2">&quot;</span>
        <span class="s0">return </span><span class="s1">rv.lstrip()</span>

    <span class="s0">def </span><span class="s1">find_root(self) -&gt; </span><span class="s2">&quot;Context&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Finds the outermost context.&quot;&quot;&quot;</span>
        <span class="s1">node = self</span>
        <span class="s0">while </span><span class="s1">node.parent </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">node = node.parent</span>
        <span class="s0">return </span><span class="s1">node</span>

    <span class="s0">def </span><span class="s1">find_object(self</span><span class="s3">, </span><span class="s1">object_type: t.Type[V]) -&gt; t.Optional[V]:</span>
        <span class="s4">&quot;&quot;&quot;Finds the closest object of a given type.&quot;&quot;&quot;</span>
        <span class="s1">node: t.Optional[</span><span class="s2">&quot;Context&quot;</span><span class="s1">] = self</span>

        <span class="s0">while </span><span class="s1">node </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(node.obj</span><span class="s3">, </span><span class="s1">object_type):</span>
                <span class="s0">return </span><span class="s1">node.obj</span>

            <span class="s1">node = node.parent</span>

        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">ensure_object(self</span><span class="s3">, </span><span class="s1">object_type: t.Type[V]) -&gt; V:</span>
        <span class="s4">&quot;&quot;&quot;Like :meth:`find_object` but sets the innermost object to a 
        new instance of `object_type` if it does not exist. 
        &quot;&quot;&quot;</span>
        <span class="s1">rv = self.find_object(object_type)</span>
        <span class="s0">if </span><span class="s1">rv </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self.obj = rv = object_type()</span>
        <span class="s0">return </span><span class="s1">rv</span>

    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">lookup_default(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">name: str</span><span class="s3">, </span><span class="s1">call: </span><span class="s2">&quot;te.Literal[True]&quot; </span><span class="s1">= </span><span class="s0">True</span>
    <span class="s1">) -&gt; t.Optional[t.Any]:</span>
        <span class="s1">...</span>

    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">lookup_default(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">name: str</span><span class="s3">, </span><span class="s1">call: </span><span class="s2">&quot;te.Literal[False]&quot; </span><span class="s1">= ...</span>
    <span class="s1">) -&gt; t.Optional[t.Union[t.Any</span><span class="s3">, </span><span class="s1">t.Callable[[]</span><span class="s3">, </span><span class="s1">t.Any]]]:</span>
        <span class="s1">...</span>

    <span class="s0">def </span><span class="s1">lookup_default(self</span><span class="s3">, </span><span class="s1">name: str</span><span class="s3">, </span><span class="s1">call: bool = </span><span class="s0">True</span><span class="s1">) -&gt; t.Optional[t.Any]:</span>
        <span class="s4">&quot;&quot;&quot;Get the default for a parameter from :attr:`default_map`. 
 
        :param name: Name of the parameter. 
        :param call: If the default is a callable, call it. Disable to 
            return the callable instead. 
 
        .. versionchanged:: 8.0 
            Added the ``call`` parameter. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.default_map </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">value = self.default_map.get(name)</span>

            <span class="s0">if </span><span class="s1">call </span><span class="s0">and </span><span class="s1">callable(value):</span>
                <span class="s0">return </span><span class="s1">value()</span>

            <span class="s0">return </span><span class="s1">value</span>

        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">fail(self</span><span class="s3">, </span><span class="s1">message: str) -&gt; </span><span class="s2">&quot;te.NoReturn&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Aborts the execution of the program with a specific error 
        message. 
 
        :param message: the error message to fail with. 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">UsageError(message</span><span class="s3">, </span><span class="s1">self)</span>

    <span class="s0">def </span><span class="s1">abort(self) -&gt; </span><span class="s2">&quot;te.NoReturn&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Aborts the script.&quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">Abort()</span>

    <span class="s0">def </span><span class="s1">exit(self</span><span class="s3">, </span><span class="s1">code: int = </span><span class="s7">0</span><span class="s1">) -&gt; </span><span class="s2">&quot;te.NoReturn&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Exits the application with a given exit code.&quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">Exit(code)</span>

    <span class="s0">def </span><span class="s1">get_usage(self) -&gt; str:</span>
        <span class="s4">&quot;&quot;&quot;Helper method to get formatted usage string for the current 
        context and command. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.command.get_usage(self)</span>

    <span class="s0">def </span><span class="s1">get_help(self) -&gt; str:</span>
        <span class="s4">&quot;&quot;&quot;Helper method to get formatted help page for the current 
        context and command. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.command.get_help(self)</span>

    <span class="s0">def </span><span class="s1">_make_sub_context(self</span><span class="s3">, </span><span class="s1">command: </span><span class="s2">&quot;Command&quot;</span><span class="s1">) -&gt; </span><span class="s2">&quot;Context&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Create a new context of the same type as this context, but 
        for a new command. 
 
        :meta private: 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">type(self)(command</span><span class="s3">, </span><span class="s1">info_name=command.name</span><span class="s3">, </span><span class="s1">parent=self)</span>

    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">invoke(</span>
        <span class="s1">__self</span><span class="s3">,  </span><span class="s6"># noqa: B902</span>
        <span class="s1">__callback: </span><span class="s2">&quot;t.Callable[..., V]&quot;</span><span class="s3">,</span>
        <span class="s1">*args: t.Any</span><span class="s3">,</span>
        <span class="s1">**kwargs: t.Any</span><span class="s3">,</span>
    <span class="s1">) -&gt; V:</span>
        <span class="s1">...</span>

    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">invoke(</span>
        <span class="s1">__self</span><span class="s3">,  </span><span class="s6"># noqa: B902</span>
        <span class="s1">__callback: </span><span class="s2">&quot;Command&quot;</span><span class="s3">,</span>
        <span class="s1">*args: t.Any</span><span class="s3">,</span>
        <span class="s1">**kwargs: t.Any</span><span class="s3">,</span>
    <span class="s1">) -&gt; t.Any:</span>
        <span class="s1">...</span>

    <span class="s0">def </span><span class="s1">invoke(</span>
        <span class="s1">__self</span><span class="s3">,  </span><span class="s6"># noqa: B902</span>
        <span class="s1">__callback: t.Union[</span><span class="s2">&quot;Command&quot;</span><span class="s3">, </span><span class="s2">&quot;t.Callable[..., V]&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s1">*args: t.Any</span><span class="s3">,</span>
        <span class="s1">**kwargs: t.Any</span><span class="s3">,</span>
    <span class="s1">) -&gt; t.Union[t.Any</span><span class="s3">, </span><span class="s1">V]:</span>
        <span class="s4">&quot;&quot;&quot;Invokes a command callback in exactly the way it expects.  There 
        are two ways to invoke this method: 
 
        1.  the first argument can be a callback and all other arguments and 
            keyword arguments are forwarded directly to the function. 
        2.  the first argument is a click command object.  In that case all 
            arguments are forwarded as well but proper click parameters 
            (options and click arguments) must be keyword arguments and Click 
            will fill in defaults. 
 
        Note that before Click 3.2 keyword arguments were not properly filled 
        in against the intention of this code and no context was created.  For 
        more information about this change and why it was done in a bugfix 
        release see :ref:`upgrade-to-3.2`. 
 
        .. versionchanged:: 8.0 
            All ``kwargs`` are tracked in :attr:`params` so they will be 
            passed if :meth:`forward` is called at multiple levels. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(__callback</span><span class="s3">, </span><span class="s1">Command):</span>
            <span class="s1">other_cmd = __callback</span>

            <span class="s0">if </span><span class="s1">other_cmd.callback </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span>
                    <span class="s2">&quot;The given command does not have a callback that can be invoked.&quot;</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">__callback = t.cast(</span><span class="s2">&quot;t.Callable[..., V]&quot;</span><span class="s3">, </span><span class="s1">other_cmd.callback)</span>

            <span class="s1">ctx = __self._make_sub_context(other_cmd)</span>

            <span class="s0">for </span><span class="s1">param </span><span class="s0">in </span><span class="s1">other_cmd.params:</span>
                <span class="s0">if </span><span class="s1">param.name </span><span class="s0">not in </span><span class="s1">kwargs </span><span class="s0">and </span><span class="s1">param.expose_value:</span>
                    <span class="s1">kwargs[param.name] = param.type_cast_value(  </span><span class="s6"># type: ignore</span>
                        <span class="s1">ctx</span><span class="s3">, </span><span class="s1">param.get_default(ctx)</span>
                    <span class="s1">)</span>

            <span class="s6"># Track all kwargs as params, so that forward() will pass</span>
            <span class="s6"># them on in subsequent calls.</span>
            <span class="s1">ctx.params.update(kwargs)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">ctx = __self</span>

        <span class="s0">with </span><span class="s1">augment_usage_errors(__self):</span>
            <span class="s0">with </span><span class="s1">ctx:</span>
                <span class="s0">return </span><span class="s1">__callback(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">forward(</span>
        <span class="s1">__self</span><span class="s3">, </span><span class="s1">__cmd: </span><span class="s2">&quot;Command&quot;</span><span class="s3">, </span><span class="s1">*args: t.Any</span><span class="s3">, </span><span class="s1">**kwargs: t.Any  </span><span class="s6"># noqa: B902</span>
    <span class="s1">) -&gt; t.Any:</span>
        <span class="s4">&quot;&quot;&quot;Similar to :meth:`invoke` but fills in default keyword 
        arguments from the current context if the other command expects 
        it.  This cannot invoke callbacks directly, only other commands. 
 
        .. versionchanged:: 8.0 
            All ``kwargs`` are tracked in :attr:`params` so they will be 
            passed if ``forward`` is called at multiple levels. 
        &quot;&quot;&quot;</span>
        <span class="s6"># Can only forward to other commands, not direct callbacks.</span>
        <span class="s0">if not </span><span class="s1">isinstance(__cmd</span><span class="s3">, </span><span class="s1">Command):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Callback is not a command.&quot;</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">param </span><span class="s0">in </span><span class="s1">__self.params:</span>
            <span class="s0">if </span><span class="s1">param </span><span class="s0">not in </span><span class="s1">kwargs:</span>
                <span class="s1">kwargs[param] = __self.params[param]</span>

        <span class="s0">return </span><span class="s1">__self.invoke(__cmd</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">set_parameter_source(self</span><span class="s3">, </span><span class="s1">name: str</span><span class="s3">, </span><span class="s1">source: ParameterSource) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Set the source of a parameter. This indicates the location 
        from which the value of the parameter was obtained. 
 
        :param name: The name of the parameter. 
        :param source: A member of :class:`~click.core.ParameterSource`. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._parameter_source[name] = source</span>

    <span class="s0">def </span><span class="s1">get_parameter_source(self</span><span class="s3">, </span><span class="s1">name: str) -&gt; t.Optional[ParameterSource]:</span>
        <span class="s4">&quot;&quot;&quot;Get the source of a parameter. This indicates the location 
        from which the value of the parameter was obtained. 
 
        This can be useful for determining when a user specified a value 
        on the command line that is the same as the default value. It 
        will be :attr:`~click.core.ParameterSource.DEFAULT` only if the 
        value was actually taken from the default. 
 
        :param name: The name of the parameter. 
        :rtype: ParameterSource 
 
        .. versionchanged:: 8.0 
            Returns ``None`` if the parameter was not provided from any 
            source. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._parameter_source.get(name)</span>


<span class="s0">class </span><span class="s1">BaseCommand:</span>
    <span class="s4">&quot;&quot;&quot;The base command implements the minimal API contract of commands. 
    Most code will never use this as it does not implement a lot of useful 
    functionality but it can act as the direct subclass of alternative 
    parsing methods that do not depend on the Click parser. 
 
    For instance, this can be used to bridge Click and other systems like 
    argparse or docopt. 
 
    Because base commands do not implement a lot of the API that other 
    parts of Click take for granted, they are not supported for all 
    operations.  For instance, they cannot be used with the decorators 
    usually and they have no built-in callback system. 
 
    .. versionchanged:: 2.0 
       Added the `context_settings` parameter. 
 
    :param name: the name of the command to use unless a group overrides it. 
    :param context_settings: an optional dictionary with defaults that are 
                             passed to the context object. 
    &quot;&quot;&quot;</span>

    <span class="s6">#: The context class to create with :meth:`make_context`.</span>
    <span class="s6">#:</span>
    <span class="s6">#: .. versionadded:: 8.0</span>
    <span class="s1">context_class: t.Type[Context] = Context</span>
    <span class="s6">#: the default for the :attr:`Context.allow_extra_args` flag.</span>
    <span class="s1">allow_extra_args = </span><span class="s0">False</span>
    <span class="s6">#: the default for the :attr:`Context.allow_interspersed_args` flag.</span>
    <span class="s1">allow_interspersed_args = </span><span class="s0">True</span>
    <span class="s6">#: the default for the :attr:`Context.ignore_unknown_options` flag.</span>
    <span class="s1">ignore_unknown_options = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">name: t.Optional[str]</span><span class="s3">,</span>
        <span class="s1">context_settings: t.Optional[t.MutableMapping[str</span><span class="s3">, </span><span class="s1">t.Any]] = </span><span class="s0">None</span><span class="s3">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s6">#: the name the command thinks it has.  Upon registering a command</span>
        <span class="s6">#: on a :class:`Group` the group will default the command name</span>
        <span class="s6">#: with this information.  You should instead use the</span>
        <span class="s6">#: :class:`Context`\'s :attr:`~Context.info_name` attribute.</span>
        <span class="s1">self.name = name</span>

        <span class="s0">if </span><span class="s1">context_settings </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">context_settings = {}</span>

        <span class="s6">#: an optional dictionary with defaults passed to the context.</span>
        <span class="s1">self.context_settings: t.MutableMapping[str</span><span class="s3">, </span><span class="s1">t.Any] = context_settings</span>

    <span class="s0">def </span><span class="s1">to_info_dict(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; t.Dict[str</span><span class="s3">, </span><span class="s1">t.Any]:</span>
        <span class="s4">&quot;&quot;&quot;Gather information that could be useful for a tool generating 
        user-facing documentation. This traverses the entire structure 
        below this command. 
 
        Use :meth:`click.Context.to_info_dict` to traverse the entire 
        CLI structure. 
 
        :param ctx: A :class:`Context` representing this command. 
 
        .. versionadded:: 8.0 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">{</span><span class="s2">&quot;name&quot;</span><span class="s1">: self.name}</span>

    <span class="s0">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s2">f&quot;&lt;</span><span class="s5">{</span><span class="s1">self.__class__.__name__</span><span class="s5">} {</span><span class="s1">self.name</span><span class="s5">}</span><span class="s2">&gt;&quot;</span>

    <span class="s0">def </span><span class="s1">get_usage(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; str:</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s2">&quot;Base commands cannot get usage&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_help(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; str:</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s2">&quot;Base commands cannot get help&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">make_context(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">info_name: t.Optional[str]</span><span class="s3">,</span>
        <span class="s1">args: t.List[str]</span><span class="s3">,</span>
        <span class="s1">parent: t.Optional[Context] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">**extra: t.Any</span><span class="s3">,</span>
    <span class="s1">) -&gt; Context:</span>
        <span class="s4">&quot;&quot;&quot;This function when given an info name and arguments will kick 
        off the parsing and create a new :class:`Context`.  It does not 
        invoke the actual command callback though. 
 
        To quickly customize the context class used without overriding 
        this method, set the :attr:`context_class` attribute. 
 
        :param info_name: the info name for this invocation.  Generally this 
                          is the most descriptive name for the script or 
                          command.  For the toplevel script it's usually 
                          the name of the script, for commands below it's 
                          the name of the command. 
        :param args: the arguments to parse as list of strings. 
        :param parent: the parent context if available. 
        :param extra: extra keyword arguments forwarded to the context 
                      constructor. 
 
        .. versionchanged:: 8.0 
            Added the :attr:`context_class` attribute. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">self.context_settings.items():</span>
            <span class="s0">if </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">extra:</span>
                <span class="s1">extra[key] = value</span>

        <span class="s1">ctx = self.context_class(</span>
            <span class="s1">self</span><span class="s3">, </span><span class="s1">info_name=info_name</span><span class="s3">, </span><span class="s1">parent=parent</span><span class="s3">, </span><span class="s1">**extra  </span><span class="s6"># type: ignore</span>
        <span class="s1">)</span>

        <span class="s0">with </span><span class="s1">ctx.scope(cleanup=</span><span class="s0">False</span><span class="s1">):</span>
            <span class="s1">self.parse_args(ctx</span><span class="s3">, </span><span class="s1">args)</span>
        <span class="s0">return </span><span class="s1">ctx</span>

    <span class="s0">def </span><span class="s1">parse_args(self</span><span class="s3">, </span><span class="s1">ctx: Context</span><span class="s3">, </span><span class="s1">args: t.List[str]) -&gt; t.List[str]:</span>
        <span class="s4">&quot;&quot;&quot;Given a context and a list of arguments this creates the parser 
        and parses the arguments, then modifies the context as necessary. 
        This is automatically invoked by :meth:`make_context`. 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s2">&quot;Base commands do not know how to parse arguments.&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">invoke(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; t.Any:</span>
        <span class="s4">&quot;&quot;&quot;Given a context, this invokes the command.  The default 
        implementation is raising a not implemented error. 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s2">&quot;Base commands are not invocable by default&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">shell_complete(self</span><span class="s3">, </span><span class="s1">ctx: Context</span><span class="s3">, </span><span class="s1">incomplete: str) -&gt; t.List[</span><span class="s2">&quot;CompletionItem&quot;</span><span class="s1">]:</span>
        <span class="s4">&quot;&quot;&quot;Return a list of completions for the incomplete value. Looks 
        at the names of chained multi-commands. 
 
        Any command could be part of a chained multi-command, so sibling 
        commands are valid at any point during command completion. Other 
        command classes will return more completions. 
 
        :param ctx: Invocation context for this command. 
        :param incomplete: Value being completed. May be empty. 
 
        .. versionadded:: 8.0 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">click.shell_completion </span><span class="s0">import </span><span class="s1">CompletionItem</span>

        <span class="s1">results: t.List[</span><span class="s2">&quot;CompletionItem&quot;</span><span class="s1">] = []</span>

        <span class="s0">while </span><span class="s1">ctx.parent </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">ctx = ctx.parent</span>

            <span class="s0">if </span><span class="s1">isinstance(ctx.command</span><span class="s3">, </span><span class="s1">MultiCommand) </span><span class="s0">and </span><span class="s1">ctx.command.chain:</span>
                <span class="s1">results.extend(</span>
                    <span class="s1">CompletionItem(name</span><span class="s3">, </span><span class="s1">help=command.get_short_help_str())</span>
                    <span class="s0">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">command </span><span class="s0">in </span><span class="s1">_complete_visible_commands(ctx</span><span class="s3">, </span><span class="s1">incomplete)</span>
                    <span class="s0">if </span><span class="s1">name </span><span class="s0">not in </span><span class="s1">ctx.protected_args</span>
                <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">results</span>

    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">main(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">args: t.Optional[t.Sequence[str]] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">prog_name: t.Optional[str] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">complete_var: t.Optional[str] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">standalone_mode: </span><span class="s2">&quot;te.Literal[True]&quot; </span><span class="s1">= </span><span class="s0">True</span><span class="s3">,</span>
        <span class="s1">**extra: t.Any</span><span class="s3">,</span>
    <span class="s1">) -&gt; </span><span class="s2">&quot;te.NoReturn&quot;</span><span class="s1">:</span>
        <span class="s1">...</span>

    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">main(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">args: t.Optional[t.Sequence[str]] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">prog_name: t.Optional[str] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">complete_var: t.Optional[str] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">standalone_mode: bool = ...</span><span class="s3">,</span>
        <span class="s1">**extra: t.Any</span><span class="s3">,</span>
    <span class="s1">) -&gt; t.Any:</span>
        <span class="s1">...</span>

    <span class="s0">def </span><span class="s1">main(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">args: t.Optional[t.Sequence[str]] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">prog_name: t.Optional[str] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">complete_var: t.Optional[str] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">standalone_mode: bool = </span><span class="s0">True</span><span class="s3">,</span>
        <span class="s1">windows_expand_args: bool = </span><span class="s0">True</span><span class="s3">,</span>
        <span class="s1">**extra: t.Any</span><span class="s3">,</span>
    <span class="s1">) -&gt; t.Any:</span>
        <span class="s4">&quot;&quot;&quot;This is the way to invoke a script with all the bells and 
        whistles as a command line application.  This will always terminate 
        the application after a call.  If this is not wanted, ``SystemExit`` 
        needs to be caught. 
 
        This method is also available by directly calling the instance of 
        a :class:`Command`. 
 
        :param args: the arguments that should be used for parsing.  If not 
                     provided, ``sys.argv[1:]`` is used. 
        :param prog_name: the program name that should be used.  By default 
                          the program name is constructed by taking the file 
                          name from ``sys.argv[0]``. 
        :param complete_var: the environment variable that controls the 
                             bash completion support.  The default is 
                             ``&quot;_&lt;prog_name&gt;_COMPLETE&quot;`` with prog_name in 
                             uppercase. 
        :param standalone_mode: the default behavior is to invoke the script 
                                in standalone mode.  Click will then 
                                handle exceptions and convert them into 
                                error messages and the function will never 
                                return but shut down the interpreter.  If 
                                this is set to `False` they will be 
                                propagated to the caller and the return 
                                value of this function is the return value 
                                of :meth:`invoke`. 
        :param windows_expand_args: Expand glob patterns, user dir, and 
            env vars in command line args on Windows. 
        :param extra: extra keyword arguments are forwarded to the context 
                      constructor.  See :class:`Context` for more information. 
 
        .. versionchanged:: 8.0.1 
            Added the ``windows_expand_args`` parameter to allow 
            disabling command line arg expansion on Windows. 
 
        .. versionchanged:: 8.0 
            When taking arguments from ``sys.argv`` on Windows, glob 
            patterns, user dir, and env vars are expanded. 
 
        .. versionchanged:: 3.0 
           Added the ``standalone_mode`` parameter. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">args </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">args = sys.argv[</span><span class="s7">1</span><span class="s1">:]</span>

            <span class="s0">if </span><span class="s1">os.name == </span><span class="s2">&quot;nt&quot; </span><span class="s0">and </span><span class="s1">windows_expand_args:</span>
                <span class="s1">args = _expand_args(args)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">args = list(args)</span>

        <span class="s0">if </span><span class="s1">prog_name </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">prog_name = _detect_program_name()</span>

        <span class="s6"># Process shell completion requests and exit early.</span>
        <span class="s1">self._main_shell_completion(extra</span><span class="s3">, </span><span class="s1">prog_name</span><span class="s3">, </span><span class="s1">complete_var)</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">with </span><span class="s1">self.make_context(prog_name</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">**extra) </span><span class="s0">as </span><span class="s1">ctx:</span>
                    <span class="s1">rv = self.invoke(ctx)</span>
                    <span class="s0">if not </span><span class="s1">standalone_mode:</span>
                        <span class="s0">return </span><span class="s1">rv</span>
                    <span class="s6"># it's not safe to `ctx.exit(rv)` here!</span>
                    <span class="s6"># note that `rv` may actually contain data like &quot;1&quot; which</span>
                    <span class="s6"># has obvious effects</span>
                    <span class="s6"># more subtle case: `rv=[None, None]` can come out of</span>
                    <span class="s6"># chained commands which all returned `None` -- so it's not</span>
                    <span class="s6"># even always obvious that `rv` indicates success/failure</span>
                    <span class="s6"># by its truthiness/falsiness</span>
                    <span class="s1">ctx.exit()</span>
            <span class="s0">except </span><span class="s1">(EOFError</span><span class="s3">, </span><span class="s1">KeyboardInterrupt) </span><span class="s0">as </span><span class="s1">e:</span>
                <span class="s1">echo(file=sys.stderr)</span>
                <span class="s0">raise </span><span class="s1">Abort() </span><span class="s0">from </span><span class="s1">e</span>
            <span class="s0">except </span><span class="s1">ClickException </span><span class="s0">as </span><span class="s1">e:</span>
                <span class="s0">if not </span><span class="s1">standalone_mode:</span>
                    <span class="s0">raise</span>
                <span class="s1">e.show()</span>
                <span class="s1">sys.exit(e.exit_code)</span>
            <span class="s0">except </span><span class="s1">OSError </span><span class="s0">as </span><span class="s1">e:</span>
                <span class="s0">if </span><span class="s1">e.errno == errno.EPIPE:</span>
                    <span class="s1">sys.stdout = t.cast(t.TextIO</span><span class="s3">, </span><span class="s1">PacifyFlushWrapper(sys.stdout))</span>
                    <span class="s1">sys.stderr = t.cast(t.TextIO</span><span class="s3">, </span><span class="s1">PacifyFlushWrapper(sys.stderr))</span>
                    <span class="s1">sys.exit(</span><span class="s7">1</span><span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">raise</span>
        <span class="s0">except </span><span class="s1">Exit </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s0">if </span><span class="s1">standalone_mode:</span>
                <span class="s1">sys.exit(e.exit_code)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s6"># in non-standalone mode, return the exit code</span>
                <span class="s6"># note that this is only reached if `self.invoke` above raises</span>
                <span class="s6"># an Exit explicitly -- thus bypassing the check there which</span>
                <span class="s6"># would return its result</span>
                <span class="s6"># the results of non-standalone execution may therefore be</span>
                <span class="s6"># somewhat ambiguous: if there are codepaths which lead to</span>
                <span class="s6"># `ctx.exit(1)` and to `return 1`, the caller won't be able to</span>
                <span class="s6"># tell the difference between the two</span>
                <span class="s0">return </span><span class="s1">e.exit_code</span>
        <span class="s0">except </span><span class="s1">Abort:</span>
            <span class="s0">if not </span><span class="s1">standalone_mode:</span>
                <span class="s0">raise</span>
            <span class="s1">echo(_(</span><span class="s2">&quot;Aborted!&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">file=sys.stderr)</span>
            <span class="s1">sys.exit(</span><span class="s7">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_main_shell_completion(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">ctx_args: t.MutableMapping[str</span><span class="s3">, </span><span class="s1">t.Any]</span><span class="s3">,</span>
        <span class="s1">prog_name: str</span><span class="s3">,</span>
        <span class="s1">complete_var: t.Optional[str] = </span><span class="s0">None</span><span class="s3">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Check if the shell is asking for tab completion, process 
        that, then exit early. Called from :meth:`main` before the 
        program is invoked. 
 
        :param prog_name: Name of the executable in the shell. 
        :param complete_var: Name of the environment variable that holds 
            the completion instruction. Defaults to 
            ``_{PROG_NAME}_COMPLETE``. 
 
        .. versionchanged:: 8.2.0 
            Dots (``.``) in ``prog_name`` are replaced with underscores (``_``). 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">complete_var </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">complete_name = prog_name.replace(</span><span class="s2">&quot;-&quot;</span><span class="s3">, </span><span class="s2">&quot;_&quot;</span><span class="s1">).replace(</span><span class="s2">&quot;.&quot;</span><span class="s3">, </span><span class="s2">&quot;_&quot;</span><span class="s1">)</span>
            <span class="s1">complete_var = </span><span class="s2">f&quot;_</span><span class="s5">{</span><span class="s1">complete_name</span><span class="s5">}</span><span class="s2">_COMPLETE&quot;</span><span class="s1">.upper()</span>

        <span class="s1">instruction = os.environ.get(complete_var)</span>

        <span class="s0">if not </span><span class="s1">instruction:</span>
            <span class="s0">return</span>

        <span class="s0">from </span><span class="s1">.shell_completion </span><span class="s0">import </span><span class="s1">shell_complete</span>

        <span class="s1">rv = shell_complete(self</span><span class="s3">, </span><span class="s1">ctx_args</span><span class="s3">, </span><span class="s1">prog_name</span><span class="s3">, </span><span class="s1">complete_var</span><span class="s3">, </span><span class="s1">instruction)</span>
        <span class="s1">sys.exit(rv)</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">*args: t.Any</span><span class="s3">, </span><span class="s1">**kwargs: t.Any) -&gt; t.Any:</span>
        <span class="s4">&quot;&quot;&quot;Alias for :meth:`main`.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.main(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0">class </span><span class="s1">Command(BaseCommand):</span>
    <span class="s4">&quot;&quot;&quot;Commands are the basic building block of command line interfaces in 
    Click.  A basic command handles command line parsing and might dispatch 
    more parsing to commands nested below it. 
 
    :param name: the name of the command to use unless a group overrides it. 
    :param context_settings: an optional dictionary with defaults that are 
                             passed to the context object. 
    :param callback: the callback to invoke.  This is optional. 
    :param params: the parameters to register with this command.  This can 
                   be either :class:`Option` or :class:`Argument` objects. 
    :param help: the help string to use for this command. 
    :param epilog: like the help string but it's printed at the end of the 
                   help page after everything else. 
    :param short_help: the short help to use for this command.  This is 
                       shown on the command listing of the parent command. 
    :param add_help_option: by default each command registers a ``--help`` 
                            option.  This can be disabled by this parameter. 
    :param no_args_is_help: this controls what happens if no arguments are 
                            provided.  This option is disabled by default. 
                            If enabled this will add ``--help`` as argument 
                            if no arguments are passed 
    :param hidden: hide this command from help outputs. 
 
    :param deprecated: issues a message indicating that 
                             the command is deprecated. 
 
    .. versionchanged:: 8.1 
        ``help``, ``epilog``, and ``short_help`` are stored unprocessed, 
        all formatting is done when outputting help text, not at init, 
        and is done even if not using the ``@command`` decorator. 
 
    .. versionchanged:: 8.0 
        Added a ``repr`` showing the command name. 
 
    .. versionchanged:: 7.1 
        Added the ``no_args_is_help`` parameter. 
 
    .. versionchanged:: 2.0 
        Added the ``context_settings`` parameter. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">name: t.Optional[str]</span><span class="s3">,</span>
        <span class="s1">context_settings: t.Optional[t.MutableMapping[str</span><span class="s3">, </span><span class="s1">t.Any]] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">callback: t.Optional[t.Callable[...</span><span class="s3">, </span><span class="s1">t.Any]] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">params: t.Optional[t.List[</span><span class="s2">&quot;Parameter&quot;</span><span class="s1">]] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">help: t.Optional[str] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">epilog: t.Optional[str] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">short_help: t.Optional[str] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">options_metavar: t.Optional[str] = </span><span class="s2">&quot;[OPTIONS]&quot;</span><span class="s3">,</span>
        <span class="s1">add_help_option: bool = </span><span class="s0">True</span><span class="s3">,</span>
        <span class="s1">no_args_is_help: bool = </span><span class="s0">False</span><span class="s3">,</span>
        <span class="s1">hidden: bool = </span><span class="s0">False</span><span class="s3">,</span>
        <span class="s1">deprecated: bool = </span><span class="s0">False</span><span class="s3">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">super().__init__(name</span><span class="s3">, </span><span class="s1">context_settings)</span>
        <span class="s6">#: the callback to execute when the command fires.  This might be</span>
        <span class="s6">#: `None` in which case nothing happens.</span>
        <span class="s1">self.callback = callback</span>
        <span class="s6">#: the list of parameters for this command in the order they</span>
        <span class="s6">#: should show up in the help page and execute.  Eager parameters</span>
        <span class="s6">#: will automatically be handled before non eager ones.</span>
        <span class="s1">self.params: t.List[</span><span class="s2">&quot;Parameter&quot;</span><span class="s1">] = params </span><span class="s0">or </span><span class="s1">[]</span>
        <span class="s1">self.help = help</span>
        <span class="s1">self.epilog = epilog</span>
        <span class="s1">self.options_metavar = options_metavar</span>
        <span class="s1">self.short_help = short_help</span>
        <span class="s1">self.add_help_option = add_help_option</span>
        <span class="s1">self.no_args_is_help = no_args_is_help</span>
        <span class="s1">self.hidden = hidden</span>
        <span class="s1">self.deprecated = deprecated</span>

    <span class="s0">def </span><span class="s1">to_info_dict(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; t.Dict[str</span><span class="s3">, </span><span class="s1">t.Any]:</span>
        <span class="s1">info_dict = super().to_info_dict(ctx)</span>
        <span class="s1">info_dict.update(</span>
            <span class="s1">params=[param.to_info_dict() </span><span class="s0">for </span><span class="s1">param </span><span class="s0">in </span><span class="s1">self.get_params(ctx)]</span><span class="s3">,</span>
            <span class="s1">help=self.help</span><span class="s3">,</span>
            <span class="s1">epilog=self.epilog</span><span class="s3">,</span>
            <span class="s1">short_help=self.short_help</span><span class="s3">,</span>
            <span class="s1">hidden=self.hidden</span><span class="s3">,</span>
            <span class="s1">deprecated=self.deprecated</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">info_dict</span>

    <span class="s0">def </span><span class="s1">get_usage(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; str:</span>
        <span class="s4">&quot;&quot;&quot;Formats the usage line into a string and returns it. 
 
        Calls :meth:`format_usage` internally. 
        &quot;&quot;&quot;</span>
        <span class="s1">formatter = ctx.make_formatter()</span>
        <span class="s1">self.format_usage(ctx</span><span class="s3">, </span><span class="s1">formatter)</span>
        <span class="s0">return </span><span class="s1">formatter.getvalue().rstrip(</span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_params(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; t.List[</span><span class="s2">&quot;Parameter&quot;</span><span class="s1">]:</span>
        <span class="s1">rv = self.params</span>
        <span class="s1">help_option = self.get_help_option(ctx)</span>

        <span class="s0">if </span><span class="s1">help_option </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">rv = [*rv</span><span class="s3">, </span><span class="s1">help_option]</span>

        <span class="s0">return </span><span class="s1">rv</span>

    <span class="s0">def </span><span class="s1">format_usage(self</span><span class="s3">, </span><span class="s1">ctx: Context</span><span class="s3">, </span><span class="s1">formatter: HelpFormatter) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Writes the usage line into the formatter. 
 
        This is a low-level method called by :meth:`get_usage`. 
        &quot;&quot;&quot;</span>
        <span class="s1">pieces = self.collect_usage_pieces(ctx)</span>
        <span class="s1">formatter.write_usage(ctx.command_path</span><span class="s3">, </span><span class="s2">&quot; &quot;</span><span class="s1">.join(pieces))</span>

    <span class="s0">def </span><span class="s1">collect_usage_pieces(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; t.List[str]:</span>
        <span class="s4">&quot;&quot;&quot;Returns all the pieces that go into the usage line and returns 
        it as a list of strings. 
        &quot;&quot;&quot;</span>
        <span class="s1">rv = [self.options_metavar] </span><span class="s0">if </span><span class="s1">self.options_metavar </span><span class="s0">else </span><span class="s1">[]</span>

        <span class="s0">for </span><span class="s1">param </span><span class="s0">in </span><span class="s1">self.get_params(ctx):</span>
            <span class="s1">rv.extend(param.get_usage_pieces(ctx))</span>

        <span class="s0">return </span><span class="s1">rv</span>

    <span class="s0">def </span><span class="s1">get_help_option_names(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; t.List[str]:</span>
        <span class="s4">&quot;&quot;&quot;Returns the names for the help option.&quot;&quot;&quot;</span>
        <span class="s1">all_names = set(ctx.help_option_names)</span>
        <span class="s0">for </span><span class="s1">param </span><span class="s0">in </span><span class="s1">self.params:</span>
            <span class="s1">all_names.difference_update(param.opts)</span>
            <span class="s1">all_names.difference_update(param.secondary_opts)</span>
        <span class="s0">return </span><span class="s1">list(all_names)</span>

    <span class="s0">def </span><span class="s1">get_help_option(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; t.Optional[</span><span class="s2">&quot;Option&quot;</span><span class="s1">]:</span>
        <span class="s4">&quot;&quot;&quot;Returns the help option object.&quot;&quot;&quot;</span>
        <span class="s1">help_options = self.get_help_option_names(ctx)</span>

        <span class="s0">if not </span><span class="s1">help_options </span><span class="s0">or not </span><span class="s1">self.add_help_option:</span>
            <span class="s0">return None</span>

        <span class="s0">def </span><span class="s1">show_help(ctx: Context</span><span class="s3">, </span><span class="s1">param: </span><span class="s2">&quot;Parameter&quot;</span><span class="s3">, </span><span class="s1">value: str) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">value </span><span class="s0">and not </span><span class="s1">ctx.resilient_parsing:</span>
                <span class="s1">echo(ctx.get_help()</span><span class="s3">, </span><span class="s1">color=ctx.color)</span>
                <span class="s1">ctx.exit()</span>

        <span class="s0">return </span><span class="s1">Option(</span>
            <span class="s1">help_options</span><span class="s3">,</span>
            <span class="s1">is_flag=</span><span class="s0">True</span><span class="s3">,</span>
            <span class="s1">is_eager=</span><span class="s0">True</span><span class="s3">,</span>
            <span class="s1">expose_value=</span><span class="s0">False</span><span class="s3">,</span>
            <span class="s1">callback=show_help</span><span class="s3">,</span>
            <span class="s1">help=_(</span><span class="s2">&quot;Show this message and exit.&quot;</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">make_parser(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; OptionParser:</span>
        <span class="s4">&quot;&quot;&quot;Creates the underlying option parser for this command.&quot;&quot;&quot;</span>
        <span class="s1">parser = OptionParser(ctx)</span>
        <span class="s0">for </span><span class="s1">param </span><span class="s0">in </span><span class="s1">self.get_params(ctx):</span>
            <span class="s1">param.add_to_parser(parser</span><span class="s3">, </span><span class="s1">ctx)</span>
        <span class="s0">return </span><span class="s1">parser</span>

    <span class="s0">def </span><span class="s1">get_help(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; str:</span>
        <span class="s4">&quot;&quot;&quot;Formats the help into a string and returns it. 
 
        Calls :meth:`format_help` internally. 
        &quot;&quot;&quot;</span>
        <span class="s1">formatter = ctx.make_formatter()</span>
        <span class="s1">self.format_help(ctx</span><span class="s3">, </span><span class="s1">formatter)</span>
        <span class="s0">return </span><span class="s1">formatter.getvalue().rstrip(</span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_short_help_str(self</span><span class="s3">, </span><span class="s1">limit: int = </span><span class="s7">45</span><span class="s1">) -&gt; str:</span>
        <span class="s4">&quot;&quot;&quot;Gets short help for the command or makes it by shortening the 
        long help string. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.short_help:</span>
            <span class="s1">text = inspect.cleandoc(self.short_help)</span>
        <span class="s0">elif </span><span class="s1">self.help:</span>
            <span class="s1">text = make_default_short_help(self.help</span><span class="s3">, </span><span class="s1">limit)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">text = </span><span class="s2">&quot;&quot;</span>

        <span class="s0">if </span><span class="s1">self.deprecated:</span>
            <span class="s1">text = _(</span><span class="s2">&quot;(Deprecated) {text}&quot;</span><span class="s1">).format(text=text)</span>

        <span class="s0">return </span><span class="s1">text.strip()</span>

    <span class="s0">def </span><span class="s1">format_help(self</span><span class="s3">, </span><span class="s1">ctx: Context</span><span class="s3">, </span><span class="s1">formatter: HelpFormatter) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Writes the help into the formatter if it exists. 
 
        This is a low-level method called by :meth:`get_help`. 
 
        This calls the following methods: 
 
        -   :meth:`format_usage` 
        -   :meth:`format_help_text` 
        -   :meth:`format_options` 
        -   :meth:`format_epilog` 
        &quot;&quot;&quot;</span>
        <span class="s1">self.format_usage(ctx</span><span class="s3">, </span><span class="s1">formatter)</span>
        <span class="s1">self.format_help_text(ctx</span><span class="s3">, </span><span class="s1">formatter)</span>
        <span class="s1">self.format_options(ctx</span><span class="s3">, </span><span class="s1">formatter)</span>
        <span class="s1">self.format_epilog(ctx</span><span class="s3">, </span><span class="s1">formatter)</span>

    <span class="s0">def </span><span class="s1">format_help_text(self</span><span class="s3">, </span><span class="s1">ctx: Context</span><span class="s3">, </span><span class="s1">formatter: HelpFormatter) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Writes the help text to the formatter if it exists.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.help </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s6"># truncate the help text to the first form feed</span>
            <span class="s1">text = inspect.cleandoc(self.help).partition(</span><span class="s2">&quot;</span><span class="s5">\f</span><span class="s2">&quot;</span><span class="s1">)[</span><span class="s7">0</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">text = </span><span class="s2">&quot;&quot;</span>

        <span class="s0">if </span><span class="s1">self.deprecated:</span>
            <span class="s1">text = _(</span><span class="s2">&quot;(Deprecated) {text}&quot;</span><span class="s1">).format(text=text)</span>

        <span class="s0">if </span><span class="s1">text:</span>
            <span class="s1">formatter.write_paragraph()</span>

            <span class="s0">with </span><span class="s1">formatter.indentation():</span>
                <span class="s1">formatter.write_text(text)</span>

    <span class="s0">def </span><span class="s1">format_options(self</span><span class="s3">, </span><span class="s1">ctx: Context</span><span class="s3">, </span><span class="s1">formatter: HelpFormatter) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Writes all the options into the formatter if they exist.&quot;&quot;&quot;</span>
        <span class="s1">opts = []</span>
        <span class="s0">for </span><span class="s1">param </span><span class="s0">in </span><span class="s1">self.get_params(ctx):</span>
            <span class="s1">rv = param.get_help_record(ctx)</span>
            <span class="s0">if </span><span class="s1">rv </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">opts.append(rv)</span>

        <span class="s0">if </span><span class="s1">opts:</span>
            <span class="s0">with </span><span class="s1">formatter.section(_(</span><span class="s2">&quot;Options&quot;</span><span class="s1">)):</span>
                <span class="s1">formatter.write_dl(opts)</span>

    <span class="s0">def </span><span class="s1">format_epilog(self</span><span class="s3">, </span><span class="s1">ctx: Context</span><span class="s3">, </span><span class="s1">formatter: HelpFormatter) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Writes the epilog into the formatter if it exists.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.epilog:</span>
            <span class="s1">epilog = inspect.cleandoc(self.epilog)</span>
            <span class="s1">formatter.write_paragraph()</span>

            <span class="s0">with </span><span class="s1">formatter.indentation():</span>
                <span class="s1">formatter.write_text(epilog)</span>

    <span class="s0">def </span><span class="s1">parse_args(self</span><span class="s3">, </span><span class="s1">ctx: Context</span><span class="s3">, </span><span class="s1">args: t.List[str]) -&gt; t.List[str]:</span>
        <span class="s0">if not </span><span class="s1">args </span><span class="s0">and </span><span class="s1">self.no_args_is_help </span><span class="s0">and not </span><span class="s1">ctx.resilient_parsing:</span>
            <span class="s1">echo(ctx.get_help()</span><span class="s3">, </span><span class="s1">color=ctx.color)</span>
            <span class="s1">ctx.exit()</span>

        <span class="s1">parser = self.make_parser(ctx)</span>
        <span class="s1">opts</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">param_order = parser.parse_args(args=args)</span>

        <span class="s0">for </span><span class="s1">param </span><span class="s0">in </span><span class="s1">iter_params_for_processing(param_order</span><span class="s3">, </span><span class="s1">self.get_params(ctx)):</span>
            <span class="s1">value</span><span class="s3">, </span><span class="s1">args = param.handle_parse_result(ctx</span><span class="s3">, </span><span class="s1">opts</span><span class="s3">, </span><span class="s1">args)</span>

        <span class="s0">if </span><span class="s1">args </span><span class="s0">and not </span><span class="s1">ctx.allow_extra_args </span><span class="s0">and not </span><span class="s1">ctx.resilient_parsing:</span>
            <span class="s1">ctx.fail(</span>
                <span class="s1">ngettext(</span>
                    <span class="s2">&quot;Got unexpected extra argument ({args})&quot;</span><span class="s3">,</span>
                    <span class="s2">&quot;Got unexpected extra arguments ({args})&quot;</span><span class="s3">,</span>
                    <span class="s1">len(args)</span><span class="s3">,</span>
                <span class="s1">).format(args=</span><span class="s2">&quot; &quot;</span><span class="s1">.join(map(str</span><span class="s3">, </span><span class="s1">args)))</span>
            <span class="s1">)</span>

        <span class="s1">ctx.args = args</span>
        <span class="s1">ctx._opt_prefixes.update(parser._opt_prefixes)</span>
        <span class="s0">return </span><span class="s1">args</span>

    <span class="s0">def </span><span class="s1">invoke(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; t.Any:</span>
        <span class="s4">&quot;&quot;&quot;Given a context, this invokes the attached callback (if it exists) 
        in the right way. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.deprecated:</span>
            <span class="s1">message = _(</span>
                <span class="s2">&quot;DeprecationWarning: The command {name!r} is deprecated.&quot;</span>
            <span class="s1">).format(name=self.name)</span>
            <span class="s1">echo(style(message</span><span class="s3">, </span><span class="s1">fg=</span><span class="s2">&quot;red&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">err=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">self.callback </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">ctx.invoke(self.callback</span><span class="s3">, </span><span class="s1">**ctx.params)</span>

    <span class="s0">def </span><span class="s1">shell_complete(self</span><span class="s3">, </span><span class="s1">ctx: Context</span><span class="s3">, </span><span class="s1">incomplete: str) -&gt; t.List[</span><span class="s2">&quot;CompletionItem&quot;</span><span class="s1">]:</span>
        <span class="s4">&quot;&quot;&quot;Return a list of completions for the incomplete value. Looks 
        at the names of options and chained multi-commands. 
 
        :param ctx: Invocation context for this command. 
        :param incomplete: Value being completed. May be empty. 
 
        .. versionadded:: 8.0 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">click.shell_completion </span><span class="s0">import </span><span class="s1">CompletionItem</span>

        <span class="s1">results: t.List[</span><span class="s2">&quot;CompletionItem&quot;</span><span class="s1">] = []</span>

        <span class="s0">if </span><span class="s1">incomplete </span><span class="s0">and not </span><span class="s1">incomplete[</span><span class="s7">0</span><span class="s1">].isalnum():</span>
            <span class="s0">for </span><span class="s1">param </span><span class="s0">in </span><span class="s1">self.get_params(ctx):</span>
                <span class="s0">if </span><span class="s1">(</span>
                    <span class="s0">not </span><span class="s1">isinstance(param</span><span class="s3">, </span><span class="s1">Option)</span>
                    <span class="s0">or </span><span class="s1">param.hidden</span>
                    <span class="s0">or </span><span class="s1">(</span>
                        <span class="s0">not </span><span class="s1">param.multiple</span>
                        <span class="s0">and </span><span class="s1">ctx.get_parameter_source(param.name)  </span><span class="s6"># type: ignore</span>
                        <span class="s0">is </span><span class="s1">ParameterSource.COMMANDLINE</span>
                    <span class="s1">)</span>
                <span class="s1">):</span>
                    <span class="s0">continue</span>

                <span class="s1">results.extend(</span>
                    <span class="s1">CompletionItem(name</span><span class="s3">, </span><span class="s1">help=param.help)</span>
                    <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">[*param.opts</span><span class="s3">, </span><span class="s1">*param.secondary_opts]</span>
                    <span class="s0">if </span><span class="s1">name.startswith(incomplete)</span>
                <span class="s1">)</span>

        <span class="s1">results.extend(super().shell_complete(ctx</span><span class="s3">, </span><span class="s1">incomplete))</span>
        <span class="s0">return </span><span class="s1">results</span>


<span class="s0">class </span><span class="s1">MultiCommand(Command):</span>
    <span class="s4">&quot;&quot;&quot;A multi command is the basic implementation of a command that 
    dispatches to subcommands.  The most common version is the 
    :class:`Group`. 
 
    :param invoke_without_command: this controls how the multi command itself 
                                   is invoked.  By default it's only invoked 
                                   if a subcommand is provided. 
    :param no_args_is_help: this controls what happens if no arguments are 
                            provided.  This option is enabled by default if 
                            `invoke_without_command` is disabled or disabled 
                            if it's enabled.  If enabled this will add 
                            ``--help`` as argument if no arguments are 
                            passed. 
    :param subcommand_metavar: the string that is used in the documentation 
                               to indicate the subcommand place. 
    :param chain: if this is set to `True` chaining of multiple subcommands 
                  is enabled.  This restricts the form of commands in that 
                  they cannot have optional arguments but it allows 
                  multiple commands to be chained together. 
    :param result_callback: The result callback to attach to this multi 
        command. This can be set or changed later with the 
        :meth:`result_callback` decorator. 
    :param attrs: Other command arguments described in :class:`Command`. 
    &quot;&quot;&quot;</span>

    <span class="s1">allow_extra_args = </span><span class="s0">True</span>
    <span class="s1">allow_interspersed_args = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">name: t.Optional[str] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">invoke_without_command: bool = </span><span class="s0">False</span><span class="s3">,</span>
        <span class="s1">no_args_is_help: t.Optional[bool] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">subcommand_metavar: t.Optional[str] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">chain: bool = </span><span class="s0">False</span><span class="s3">,</span>
        <span class="s1">result_callback: t.Optional[t.Callable[...</span><span class="s3">, </span><span class="s1">t.Any]] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">**attrs: t.Any</span><span class="s3">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">super().__init__(name</span><span class="s3">, </span><span class="s1">**attrs)</span>

        <span class="s0">if </span><span class="s1">no_args_is_help </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">no_args_is_help = </span><span class="s0">not </span><span class="s1">invoke_without_command</span>

        <span class="s1">self.no_args_is_help = no_args_is_help</span>
        <span class="s1">self.invoke_without_command = invoke_without_command</span>

        <span class="s0">if </span><span class="s1">subcommand_metavar </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">chain:</span>
                <span class="s1">subcommand_metavar = </span><span class="s2">&quot;COMMAND1 [ARGS]... [COMMAND2 [ARGS]...]...&quot;</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">subcommand_metavar = </span><span class="s2">&quot;COMMAND [ARGS]...&quot;</span>

        <span class="s1">self.subcommand_metavar = subcommand_metavar</span>
        <span class="s1">self.chain = chain</span>
        <span class="s6"># The result callback that is stored. This can be set or</span>
        <span class="s6"># overridden with the :func:`result_callback` decorator.</span>
        <span class="s1">self._result_callback = result_callback</span>

        <span class="s0">if </span><span class="s1">self.chain:</span>
            <span class="s0">for </span><span class="s1">param </span><span class="s0">in </span><span class="s1">self.params:</span>
                <span class="s0">if </span><span class="s1">isinstance(param</span><span class="s3">, </span><span class="s1">Argument) </span><span class="s0">and not </span><span class="s1">param.required:</span>
                    <span class="s0">raise </span><span class="s1">RuntimeError(</span>
                        <span class="s2">&quot;Multi commands in chain mode cannot have&quot;</span>
                        <span class="s2">&quot; optional arguments.&quot;</span>
                    <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">to_info_dict(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; t.Dict[str</span><span class="s3">, </span><span class="s1">t.Any]:</span>
        <span class="s1">info_dict = super().to_info_dict(ctx)</span>
        <span class="s1">commands = {}</span>

        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self.list_commands(ctx):</span>
            <span class="s1">command = self.get_command(ctx</span><span class="s3">, </span><span class="s1">name)</span>

            <span class="s0">if </span><span class="s1">command </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">continue</span>

            <span class="s1">sub_ctx = ctx._make_sub_context(command)</span>

            <span class="s0">with </span><span class="s1">sub_ctx.scope(cleanup=</span><span class="s0">False</span><span class="s1">):</span>
                <span class="s1">commands[name] = command.to_info_dict(sub_ctx)</span>

        <span class="s1">info_dict.update(commands=commands</span><span class="s3">, </span><span class="s1">chain=self.chain)</span>
        <span class="s0">return </span><span class="s1">info_dict</span>

    <span class="s0">def </span><span class="s1">collect_usage_pieces(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; t.List[str]:</span>
        <span class="s1">rv = super().collect_usage_pieces(ctx)</span>
        <span class="s1">rv.append(self.subcommand_metavar)</span>
        <span class="s0">return </span><span class="s1">rv</span>

    <span class="s0">def </span><span class="s1">format_options(self</span><span class="s3">, </span><span class="s1">ctx: Context</span><span class="s3">, </span><span class="s1">formatter: HelpFormatter) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">super().format_options(ctx</span><span class="s3">, </span><span class="s1">formatter)</span>
        <span class="s1">self.format_commands(ctx</span><span class="s3">, </span><span class="s1">formatter)</span>

    <span class="s0">def </span><span class="s1">result_callback(self</span><span class="s3">, </span><span class="s1">replace: bool = </span><span class="s0">False</span><span class="s1">) -&gt; t.Callable[[F]</span><span class="s3">, </span><span class="s1">F]:</span>
        <span class="s4">&quot;&quot;&quot;Adds a result callback to the command.  By default if a 
        result callback is already registered this will chain them but 
        this can be disabled with the `replace` parameter.  The result 
        callback is invoked with the return value of the subcommand 
        (or the list of return values from all subcommands if chaining 
        is enabled) as well as the parameters as they would be passed 
        to the main callback. 
 
        Example:: 
 
            @click.group() 
            @click.option('-i', '--input', default=23) 
            def cli(input): 
                return 42 
 
            @cli.result_callback() 
            def process_result(result, input): 
                return result + input 
 
        :param replace: if set to `True` an already existing result 
                        callback will be removed. 
 
        .. versionchanged:: 8.0 
            Renamed from ``resultcallback``. 
 
        .. versionadded:: 3.0 
        &quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">decorator(f: F) -&gt; F:</span>
            <span class="s1">old_callback = self._result_callback</span>

            <span class="s0">if </span><span class="s1">old_callback </span><span class="s0">is None or </span><span class="s1">replace:</span>
                <span class="s1">self._result_callback = f</span>
                <span class="s0">return </span><span class="s1">f</span>

            <span class="s0">def </span><span class="s1">function(__value</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):  </span><span class="s6"># type: ignore</span>
                <span class="s1">inner = old_callback(__value</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
                <span class="s0">return </span><span class="s1">f(inner</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>

            <span class="s1">self._result_callback = rv = update_wrapper(t.cast(F</span><span class="s3">, </span><span class="s1">function)</span><span class="s3">, </span><span class="s1">f)</span>
            <span class="s0">return </span><span class="s1">rv</span>

        <span class="s0">return </span><span class="s1">decorator</span>

    <span class="s0">def </span><span class="s1">format_commands(self</span><span class="s3">, </span><span class="s1">ctx: Context</span><span class="s3">, </span><span class="s1">formatter: HelpFormatter) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Extra format methods for multi methods that adds all the commands 
        after the options. 
        &quot;&quot;&quot;</span>
        <span class="s1">commands = []</span>
        <span class="s0">for </span><span class="s1">subcommand </span><span class="s0">in </span><span class="s1">self.list_commands(ctx):</span>
            <span class="s1">cmd = self.get_command(ctx</span><span class="s3">, </span><span class="s1">subcommand)</span>
            <span class="s6"># What is this, the tool lied about a command.  Ignore it</span>
            <span class="s0">if </span><span class="s1">cmd </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s1">cmd.hidden:</span>
                <span class="s0">continue</span>

            <span class="s1">commands.append((subcommand</span><span class="s3">, </span><span class="s1">cmd))</span>

        <span class="s6"># allow for 3 times the default spacing</span>
        <span class="s0">if </span><span class="s1">len(commands):</span>
            <span class="s1">limit = formatter.width - </span><span class="s7">6 </span><span class="s1">- max(len(cmd[</span><span class="s7">0</span><span class="s1">]) </span><span class="s0">for </span><span class="s1">cmd </span><span class="s0">in </span><span class="s1">commands)</span>

            <span class="s1">rows = []</span>
            <span class="s0">for </span><span class="s1">subcommand</span><span class="s3">, </span><span class="s1">cmd </span><span class="s0">in </span><span class="s1">commands:</span>
                <span class="s1">help = cmd.get_short_help_str(limit)</span>
                <span class="s1">rows.append((subcommand</span><span class="s3">, </span><span class="s1">help))</span>

            <span class="s0">if </span><span class="s1">rows:</span>
                <span class="s0">with </span><span class="s1">formatter.section(_(</span><span class="s2">&quot;Commands&quot;</span><span class="s1">)):</span>
                    <span class="s1">formatter.write_dl(rows)</span>

    <span class="s0">def </span><span class="s1">parse_args(self</span><span class="s3">, </span><span class="s1">ctx: Context</span><span class="s3">, </span><span class="s1">args: t.List[str]) -&gt; t.List[str]:</span>
        <span class="s0">if not </span><span class="s1">args </span><span class="s0">and </span><span class="s1">self.no_args_is_help </span><span class="s0">and not </span><span class="s1">ctx.resilient_parsing:</span>
            <span class="s1">echo(ctx.get_help()</span><span class="s3">, </span><span class="s1">color=ctx.color)</span>
            <span class="s1">ctx.exit()</span>

        <span class="s1">rest = super().parse_args(ctx</span><span class="s3">, </span><span class="s1">args)</span>

        <span class="s0">if </span><span class="s1">self.chain:</span>
            <span class="s1">ctx.protected_args = rest</span>
            <span class="s1">ctx.args = []</span>
        <span class="s0">elif </span><span class="s1">rest:</span>
            <span class="s1">ctx.protected_args</span><span class="s3">, </span><span class="s1">ctx.args = rest[:</span><span class="s7">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">rest[</span><span class="s7">1</span><span class="s1">:]</span>

        <span class="s0">return </span><span class="s1">ctx.args</span>

    <span class="s0">def </span><span class="s1">invoke(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; t.Any:</span>
        <span class="s0">def </span><span class="s1">_process_result(value: t.Any) -&gt; t.Any:</span>
            <span class="s0">if </span><span class="s1">self._result_callback </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">value = ctx.invoke(self._result_callback</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">**ctx.params)</span>
            <span class="s0">return </span><span class="s1">value</span>

        <span class="s0">if not </span><span class="s1">ctx.protected_args:</span>
            <span class="s0">if </span><span class="s1">self.invoke_without_command:</span>
                <span class="s6"># No subcommand was invoked, so the result callback is</span>
                <span class="s6"># invoked with the group return value for regular</span>
                <span class="s6"># groups, or an empty list for chained groups.</span>
                <span class="s0">with </span><span class="s1">ctx:</span>
                    <span class="s1">rv = super().invoke(ctx)</span>
                    <span class="s0">return </span><span class="s1">_process_result([] </span><span class="s0">if </span><span class="s1">self.chain </span><span class="s0">else </span><span class="s1">rv)</span>
            <span class="s1">ctx.fail(_(</span><span class="s2">&quot;Missing command.&quot;</span><span class="s1">))</span>

        <span class="s6"># Fetch args back out</span>
        <span class="s1">args = [*ctx.protected_args</span><span class="s3">, </span><span class="s1">*ctx.args]</span>
        <span class="s1">ctx.args = []</span>
        <span class="s1">ctx.protected_args = []</span>

        <span class="s6"># If we're not in chain mode, we only allow the invocation of a</span>
        <span class="s6"># single command but we also inform the current context about the</span>
        <span class="s6"># name of the command to invoke.</span>
        <span class="s0">if not </span><span class="s1">self.chain:</span>
            <span class="s6"># Make sure the context is entered so we do not clean up</span>
            <span class="s6"># resources until the result processor has worked.</span>
            <span class="s0">with </span><span class="s1">ctx:</span>
                <span class="s1">cmd_name</span><span class="s3">, </span><span class="s1">cmd</span><span class="s3">, </span><span class="s1">args = self.resolve_command(ctx</span><span class="s3">, </span><span class="s1">args)</span>
                <span class="s0">assert </span><span class="s1">cmd </span><span class="s0">is not None</span>
                <span class="s1">ctx.invoked_subcommand = cmd_name</span>
                <span class="s1">super().invoke(ctx)</span>
                <span class="s1">sub_ctx = cmd.make_context(cmd_name</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">parent=ctx)</span>
                <span class="s0">with </span><span class="s1">sub_ctx:</span>
                    <span class="s0">return </span><span class="s1">_process_result(sub_ctx.command.invoke(sub_ctx))</span>

        <span class="s6"># In chain mode we create the contexts step by step, but after the</span>
        <span class="s6"># base command has been invoked.  Because at that point we do not</span>
        <span class="s6"># know the subcommands yet, the invoked subcommand attribute is</span>
        <span class="s6"># set to ``*`` to inform the command that subcommands are executed</span>
        <span class="s6"># but nothing else.</span>
        <span class="s0">with </span><span class="s1">ctx:</span>
            <span class="s1">ctx.invoked_subcommand = </span><span class="s2">&quot;*&quot; </span><span class="s0">if </span><span class="s1">args </span><span class="s0">else None</span>
            <span class="s1">super().invoke(ctx)</span>

            <span class="s6"># Otherwise we make every single context and invoke them in a</span>
            <span class="s6"># chain.  In that case the return value to the result processor</span>
            <span class="s6"># is the list of all invoked subcommand's results.</span>
            <span class="s1">contexts = []</span>
            <span class="s0">while </span><span class="s1">args:</span>
                <span class="s1">cmd_name</span><span class="s3">, </span><span class="s1">cmd</span><span class="s3">, </span><span class="s1">args = self.resolve_command(ctx</span><span class="s3">, </span><span class="s1">args)</span>
                <span class="s0">assert </span><span class="s1">cmd </span><span class="s0">is not None</span>
                <span class="s1">sub_ctx = cmd.make_context(</span>
                    <span class="s1">cmd_name</span><span class="s3">,</span>
                    <span class="s1">args</span><span class="s3">,</span>
                    <span class="s1">parent=ctx</span><span class="s3">,</span>
                    <span class="s1">allow_extra_args=</span><span class="s0">True</span><span class="s3">,</span>
                    <span class="s1">allow_interspersed_args=</span><span class="s0">False</span><span class="s3">,</span>
                <span class="s1">)</span>
                <span class="s1">contexts.append(sub_ctx)</span>
                <span class="s1">args</span><span class="s3">, </span><span class="s1">sub_ctx.args = sub_ctx.args</span><span class="s3">, </span><span class="s1">[]</span>

            <span class="s1">rv = []</span>
            <span class="s0">for </span><span class="s1">sub_ctx </span><span class="s0">in </span><span class="s1">contexts:</span>
                <span class="s0">with </span><span class="s1">sub_ctx:</span>
                    <span class="s1">rv.append(sub_ctx.command.invoke(sub_ctx))</span>
            <span class="s0">return </span><span class="s1">_process_result(rv)</span>

    <span class="s0">def </span><span class="s1">resolve_command(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">ctx: Context</span><span class="s3">, </span><span class="s1">args: t.List[str]</span>
    <span class="s1">) -&gt; t.Tuple[t.Optional[str]</span><span class="s3">, </span><span class="s1">t.Optional[Command]</span><span class="s3">, </span><span class="s1">t.List[str]]:</span>
        <span class="s1">cmd_name = make_str(args[</span><span class="s7">0</span><span class="s1">])</span>
        <span class="s1">original_cmd_name = cmd_name</span>

        <span class="s6"># Get the command</span>
        <span class="s1">cmd = self.get_command(ctx</span><span class="s3">, </span><span class="s1">cmd_name)</span>

        <span class="s6"># If we can't find the command but there is a normalization</span>
        <span class="s6"># function available, we try with that one.</span>
        <span class="s0">if </span><span class="s1">cmd </span><span class="s0">is None and </span><span class="s1">ctx.token_normalize_func </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">cmd_name = ctx.token_normalize_func(cmd_name)</span>
            <span class="s1">cmd = self.get_command(ctx</span><span class="s3">, </span><span class="s1">cmd_name)</span>

        <span class="s6"># If we don't find the command we want to show an error message</span>
        <span class="s6"># to the user that it was not provided.  However, there is</span>
        <span class="s6"># something else we should do: if the first argument looks like</span>
        <span class="s6"># an option we want to kick off parsing again for arguments to</span>
        <span class="s6"># resolve things like --help which now should go to the main</span>
        <span class="s6"># place.</span>
        <span class="s0">if </span><span class="s1">cmd </span><span class="s0">is None and not </span><span class="s1">ctx.resilient_parsing:</span>
            <span class="s0">if </span><span class="s1">split_opt(cmd_name)[</span><span class="s7">0</span><span class="s1">]:</span>
                <span class="s1">self.parse_args(ctx</span><span class="s3">, </span><span class="s1">ctx.args)</span>
            <span class="s1">ctx.fail(_(</span><span class="s2">&quot;No such command {name!r}.&quot;</span><span class="s1">).format(name=original_cmd_name))</span>
        <span class="s0">return </span><span class="s1">cmd_name </span><span class="s0">if </span><span class="s1">cmd </span><span class="s0">else None</span><span class="s3">, </span><span class="s1">cmd</span><span class="s3">, </span><span class="s1">args[</span><span class="s7">1</span><span class="s1">:]</span>

    <span class="s0">def </span><span class="s1">get_command(self</span><span class="s3">, </span><span class="s1">ctx: Context</span><span class="s3">, </span><span class="s1">cmd_name: str) -&gt; t.Optional[Command]:</span>
        <span class="s4">&quot;&quot;&quot;Given a context and a command name, this returns a 
        :class:`Command` object if it exists or returns `None`. 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>

    <span class="s0">def </span><span class="s1">list_commands(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; t.List[str]:</span>
        <span class="s4">&quot;&quot;&quot;Returns a list of subcommand names in the order they should 
        appear. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">[]</span>

    <span class="s0">def </span><span class="s1">shell_complete(self</span><span class="s3">, </span><span class="s1">ctx: Context</span><span class="s3">, </span><span class="s1">incomplete: str) -&gt; t.List[</span><span class="s2">&quot;CompletionItem&quot;</span><span class="s1">]:</span>
        <span class="s4">&quot;&quot;&quot;Return a list of completions for the incomplete value. Looks 
        at the names of options, subcommands, and chained 
        multi-commands. 
 
        :param ctx: Invocation context for this command. 
        :param incomplete: Value being completed. May be empty. 
 
        .. versionadded:: 8.0 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">click.shell_completion </span><span class="s0">import </span><span class="s1">CompletionItem</span>

        <span class="s1">results = [</span>
            <span class="s1">CompletionItem(name</span><span class="s3">, </span><span class="s1">help=command.get_short_help_str())</span>
            <span class="s0">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">command </span><span class="s0">in </span><span class="s1">_complete_visible_commands(ctx</span><span class="s3">, </span><span class="s1">incomplete)</span>
        <span class="s1">]</span>
        <span class="s1">results.extend(super().shell_complete(ctx</span><span class="s3">, </span><span class="s1">incomplete))</span>
        <span class="s0">return </span><span class="s1">results</span>


<span class="s0">class </span><span class="s1">Group(MultiCommand):</span>
    <span class="s4">&quot;&quot;&quot;A group allows a command to have subcommands attached. This is 
    the most common way to implement nesting in Click. 
 
    :param name: The name of the group command. 
    :param commands: A dict mapping names to :class:`Command` objects. 
        Can also be a list of :class:`Command`, which will use 
        :attr:`Command.name` to create the dict. 
    :param attrs: Other command arguments described in 
        :class:`MultiCommand`, :class:`Command`, and 
        :class:`BaseCommand`. 
 
    .. versionchanged:: 8.0 
        The ``commands`` argument can be a list of command objects. 
    &quot;&quot;&quot;</span>

    <span class="s6">#: If set, this is used by the group's :meth:`command` decorator</span>
    <span class="s6">#: as the default :class:`Command` class. This is useful to make all</span>
    <span class="s6">#: subcommands use a custom command class.</span>
    <span class="s6">#:</span>
    <span class="s6">#: .. versionadded:: 8.0</span>
    <span class="s1">command_class: t.Optional[t.Type[Command]] = </span><span class="s0">None</span>

    <span class="s6">#: If set, this is used by the group's :meth:`group` decorator</span>
    <span class="s6">#: as the default :class:`Group` class. This is useful to make all</span>
    <span class="s6">#: subgroups use a custom group class.</span>
    <span class="s6">#:</span>
    <span class="s6">#: If set to the special value :class:`type` (literally</span>
    <span class="s6">#: ``group_class = type``), this group's class will be used as the</span>
    <span class="s6">#: default class. This makes a custom group class continue to make</span>
    <span class="s6">#: custom groups.</span>
    <span class="s6">#:</span>
    <span class="s6">#: .. versionadded:: 8.0</span>
    <span class="s1">group_class: t.Optional[t.Union[t.Type[</span><span class="s2">&quot;Group&quot;</span><span class="s1">]</span><span class="s3">, </span><span class="s1">t.Type[type]]] = </span><span class="s0">None</span>
    <span class="s6"># Literal[type] isn't valid, so use Type[type]</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">name: t.Optional[str] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">commands: t.Optional[</span>
            <span class="s1">t.Union[t.MutableMapping[str</span><span class="s3">, </span><span class="s1">Command]</span><span class="s3">, </span><span class="s1">t.Sequence[Command]]</span>
        <span class="s1">] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">**attrs: t.Any</span><span class="s3">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">super().__init__(name</span><span class="s3">, </span><span class="s1">**attrs)</span>

        <span class="s0">if </span><span class="s1">commands </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">commands = {}</span>
        <span class="s0">elif </span><span class="s1">isinstance(commands</span><span class="s3">, </span><span class="s1">abc.Sequence):</span>
            <span class="s1">commands = {c.name: c </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">commands </span><span class="s0">if </span><span class="s1">c.name </span><span class="s0">is not None</span><span class="s1">}</span>

        <span class="s6">#: The registered subcommands by their exported names.</span>
        <span class="s1">self.commands: t.MutableMapping[str</span><span class="s3">, </span><span class="s1">Command] = commands</span>

    <span class="s0">def </span><span class="s1">add_command(self</span><span class="s3">, </span><span class="s1">cmd: Command</span><span class="s3">, </span><span class="s1">name: t.Optional[str] = </span><span class="s0">None</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Registers another :class:`Command` with this group.  If the name 
        is not provided, the name of the command is used. 
        &quot;&quot;&quot;</span>
        <span class="s1">name = name </span><span class="s0">or </span><span class="s1">cmd.name</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Command has no name.&quot;</span><span class="s1">)</span>
        <span class="s1">_check_multicommand(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">cmd</span><span class="s3">, </span><span class="s1">register=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">self.commands[name] = cmd</span>

    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">command(self</span><span class="s3">, </span><span class="s1">__func: t.Callable[...</span><span class="s3">, </span><span class="s1">t.Any]) -&gt; Command:</span>
        <span class="s1">...</span>

    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">command(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">*args: t.Any</span><span class="s3">, </span><span class="s1">**kwargs: t.Any</span>
    <span class="s1">) -&gt; t.Callable[[t.Callable[...</span><span class="s3">, </span><span class="s1">t.Any]]</span><span class="s3">, </span><span class="s1">Command]:</span>
        <span class="s1">...</span>

    <span class="s0">def </span><span class="s1">command(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">*args: t.Any</span><span class="s3">, </span><span class="s1">**kwargs: t.Any</span>
    <span class="s1">) -&gt; t.Union[t.Callable[[t.Callable[...</span><span class="s3">, </span><span class="s1">t.Any]]</span><span class="s3">, </span><span class="s1">Command]</span><span class="s3">, </span><span class="s1">Command]:</span>
        <span class="s4">&quot;&quot;&quot;A shortcut decorator for declaring and attaching a command to 
        the group. This takes the same arguments as :func:`command` and 
        immediately registers the created command with this group by 
        calling :meth:`add_command`. 
 
        To customize the command class used, set the 
        :attr:`command_class` attribute. 
 
        .. versionchanged:: 8.1 
            This decorator can be applied without parentheses. 
 
        .. versionchanged:: 8.0 
            Added the :attr:`command_class` attribute. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">.decorators </span><span class="s0">import </span><span class="s1">command</span>

        <span class="s1">func: t.Optional[t.Callable[...</span><span class="s3">, </span><span class="s1">t.Any]] = </span><span class="s0">None</span>

        <span class="s0">if </span><span class="s1">args </span><span class="s0">and </span><span class="s1">callable(args[</span><span class="s7">0</span><span class="s1">]):</span>
            <span class="s0">assert </span><span class="s1">(</span>
                <span class="s1">len(args) == </span><span class="s7">1 </span><span class="s0">and not </span><span class="s1">kwargs</span>
            <span class="s1">)</span><span class="s3">, </span><span class="s2">&quot;Use 'command(**kwargs)(callable)' to provide arguments.&quot;</span>
            <span class="s1">(func</span><span class="s3">,</span><span class="s1">) = args</span>
            <span class="s1">args = ()</span>

        <span class="s0">if </span><span class="s1">self.command_class </span><span class="s0">and </span><span class="s1">kwargs.get(</span><span class="s2">&quot;cls&quot;</span><span class="s1">) </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;cls&quot;</span><span class="s1">] = self.command_class</span>

        <span class="s0">def </span><span class="s1">decorator(f: t.Callable[...</span><span class="s3">, </span><span class="s1">t.Any]) -&gt; Command:</span>
            <span class="s1">cmd: Command = command(*args</span><span class="s3">, </span><span class="s1">**kwargs)(f)</span>
            <span class="s1">self.add_command(cmd)</span>
            <span class="s0">return </span><span class="s1">cmd</span>

        <span class="s0">if </span><span class="s1">func </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">decorator(func)</span>

        <span class="s0">return </span><span class="s1">decorator</span>

    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">group(self</span><span class="s3">, </span><span class="s1">__func: t.Callable[...</span><span class="s3">, </span><span class="s1">t.Any]) -&gt; </span><span class="s2">&quot;Group&quot;</span><span class="s1">:</span>
        <span class="s1">...</span>

    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">group(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">*args: t.Any</span><span class="s3">, </span><span class="s1">**kwargs: t.Any</span>
    <span class="s1">) -&gt; t.Callable[[t.Callable[...</span><span class="s3">, </span><span class="s1">t.Any]]</span><span class="s3">, </span><span class="s2">&quot;Group&quot;</span><span class="s1">]:</span>
        <span class="s1">...</span>

    <span class="s0">def </span><span class="s1">group(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">*args: t.Any</span><span class="s3">, </span><span class="s1">**kwargs: t.Any</span>
    <span class="s1">) -&gt; t.Union[t.Callable[[t.Callable[...</span><span class="s3">, </span><span class="s1">t.Any]]</span><span class="s3">, </span><span class="s2">&quot;Group&quot;</span><span class="s1">]</span><span class="s3">, </span><span class="s2">&quot;Group&quot;</span><span class="s1">]:</span>
        <span class="s4">&quot;&quot;&quot;A shortcut decorator for declaring and attaching a group to 
        the group. This takes the same arguments as :func:`group` and 
        immediately registers the created group with this group by 
        calling :meth:`add_command`. 
 
        To customize the group class used, set the :attr:`group_class` 
        attribute. 
 
        .. versionchanged:: 8.1 
            This decorator can be applied without parentheses. 
 
        .. versionchanged:: 8.0 
            Added the :attr:`group_class` attribute. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">.decorators </span><span class="s0">import </span><span class="s1">group</span>

        <span class="s1">func: t.Optional[t.Callable[...</span><span class="s3">, </span><span class="s1">t.Any]] = </span><span class="s0">None</span>

        <span class="s0">if </span><span class="s1">args </span><span class="s0">and </span><span class="s1">callable(args[</span><span class="s7">0</span><span class="s1">]):</span>
            <span class="s0">assert </span><span class="s1">(</span>
                <span class="s1">len(args) == </span><span class="s7">1 </span><span class="s0">and not </span><span class="s1">kwargs</span>
            <span class="s1">)</span><span class="s3">, </span><span class="s2">&quot;Use 'group(**kwargs)(callable)' to provide arguments.&quot;</span>
            <span class="s1">(func</span><span class="s3">,</span><span class="s1">) = args</span>
            <span class="s1">args = ()</span>

        <span class="s0">if </span><span class="s1">self.group_class </span><span class="s0">is not None and </span><span class="s1">kwargs.get(</span><span class="s2">&quot;cls&quot;</span><span class="s1">) </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.group_class </span><span class="s0">is </span><span class="s1">type:</span>
                <span class="s1">kwargs[</span><span class="s2">&quot;cls&quot;</span><span class="s1">] = type(self)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">kwargs[</span><span class="s2">&quot;cls&quot;</span><span class="s1">] = self.group_class</span>

        <span class="s0">def </span><span class="s1">decorator(f: t.Callable[...</span><span class="s3">, </span><span class="s1">t.Any]) -&gt; </span><span class="s2">&quot;Group&quot;</span><span class="s1">:</span>
            <span class="s1">cmd: Group = group(*args</span><span class="s3">, </span><span class="s1">**kwargs)(f)</span>
            <span class="s1">self.add_command(cmd)</span>
            <span class="s0">return </span><span class="s1">cmd</span>

        <span class="s0">if </span><span class="s1">func </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">decorator(func)</span>

        <span class="s0">return </span><span class="s1">decorator</span>

    <span class="s0">def </span><span class="s1">get_command(self</span><span class="s3">, </span><span class="s1">ctx: Context</span><span class="s3">, </span><span class="s1">cmd_name: str) -&gt; t.Optional[Command]:</span>
        <span class="s0">return </span><span class="s1">self.commands.get(cmd_name)</span>

    <span class="s0">def </span><span class="s1">list_commands(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; t.List[str]:</span>
        <span class="s0">return </span><span class="s1">sorted(self.commands)</span>


<span class="s0">class </span><span class="s1">CommandCollection(MultiCommand):</span>
    <span class="s4">&quot;&quot;&quot;A command collection is a multi command that merges multiple multi 
    commands together into one.  This is a straightforward implementation 
    that accepts a list of different multi commands as sources and 
    provides all the commands for each of them. 
 
    See :class:`MultiCommand` and :class:`Command` for the description of 
    ``name`` and ``attrs``. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">name: t.Optional[str] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">sources: t.Optional[t.List[MultiCommand]] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">**attrs: t.Any</span><span class="s3">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">super().__init__(name</span><span class="s3">, </span><span class="s1">**attrs)</span>
        <span class="s6">#: The list of registered multi commands.</span>
        <span class="s1">self.sources: t.List[MultiCommand] = sources </span><span class="s0">or </span><span class="s1">[]</span>

    <span class="s0">def </span><span class="s1">add_source(self</span><span class="s3">, </span><span class="s1">multi_cmd: MultiCommand) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Adds a new multi command to the chain dispatcher.&quot;&quot;&quot;</span>
        <span class="s1">self.sources.append(multi_cmd)</span>

    <span class="s0">def </span><span class="s1">get_command(self</span><span class="s3">, </span><span class="s1">ctx: Context</span><span class="s3">, </span><span class="s1">cmd_name: str) -&gt; t.Optional[Command]:</span>
        <span class="s0">for </span><span class="s1">source </span><span class="s0">in </span><span class="s1">self.sources:</span>
            <span class="s1">rv = source.get_command(ctx</span><span class="s3">, </span><span class="s1">cmd_name)</span>

            <span class="s0">if </span><span class="s1">rv </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">self.chain:</span>
                    <span class="s1">_check_multicommand(self</span><span class="s3">, </span><span class="s1">cmd_name</span><span class="s3">, </span><span class="s1">rv)</span>

                <span class="s0">return </span><span class="s1">rv</span>

        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">list_commands(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; t.List[str]:</span>
        <span class="s1">rv: t.Set[str] = set()</span>

        <span class="s0">for </span><span class="s1">source </span><span class="s0">in </span><span class="s1">self.sources:</span>
            <span class="s1">rv.update(source.list_commands(ctx))</span>

        <span class="s0">return </span><span class="s1">sorted(rv)</span>


<span class="s0">def </span><span class="s1">_check_iter(value: t.Any) -&gt; t.Iterator[t.Any]:</span>
    <span class="s4">&quot;&quot;&quot;Check if the value is iterable but not a string. Raises a type 
    error, or return an iterator over the value. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance(value</span><span class="s3">, </span><span class="s1">str):</span>
        <span class="s0">raise </span><span class="s1">TypeError</span>

    <span class="s0">return </span><span class="s1">iter(value)</span>


<span class="s0">class </span><span class="s1">Parameter:</span>
    <span class="s4">r&quot;&quot;&quot;A parameter to a command comes in two versions: they are either 
    :class:`Option`\s or :class:`Argument`\s.  Other subclasses are currently 
    not supported by design as some of the internals for parsing are 
    intentionally not finalized. 
 
    Some settings are supported by both options and arguments. 
 
    :param param_decls: the parameter declarations for this option or 
                        argument.  This is a list of flags or argument 
                        names. 
    :param type: the type that should be used.  Either a :class:`ParamType` 
                 or a Python type.  The latter is converted into the former 
                 automatically if supported. 
    :param required: controls if this is optional or not. 
    :param default: the default value if omitted.  This can also be a callable, 
                    in which case it's invoked when the default is needed 
                    without any arguments. 
    :param callback: A function to further process or validate the value 
        after type conversion. It is called as ``f(ctx, param, value)`` 
        and must return the value. It is called for all sources, 
        including prompts. 
    :param nargs: the number of arguments to match.  If not ``1`` the return 
                  value is a tuple instead of single value.  The default for 
                  nargs is ``1`` (except if the type is a tuple, then it's 
                  the arity of the tuple). If ``nargs=-1``, all remaining 
                  parameters are collected. 
    :param metavar: how the value is represented in the help page. 
    :param expose_value: if this is `True` then the value is passed onwards 
                         to the command callback and stored on the context, 
                         otherwise it's skipped. 
    :param is_eager: eager values are processed before non eager ones.  This 
                     should not be set for arguments or it will inverse the 
                     order of processing. 
    :param envvar: a string or list of strings that are environment variables 
                   that should be checked. 
    :param shell_complete: A function that returns custom shell 
        completions. Used instead of the param's type completion if 
        given. Takes ``ctx, param, incomplete`` and must return a list 
        of :class:`~click.shell_completion.CompletionItem` or a list of 
        strings. 
 
    .. versionchanged:: 8.0 
        ``process_value`` validates required parameters and bounded 
        ``nargs``, and invokes the parameter callback before returning 
        the value. This allows the callback to validate prompts. 
        ``full_process_value`` is removed. 
 
    .. versionchanged:: 8.0 
        ``autocompletion`` is renamed to ``shell_complete`` and has new 
        semantics described above. The old name is deprecated and will 
        be removed in 8.1, until then it will be wrapped to match the 
        new requirements. 
 
    .. versionchanged:: 8.0 
        For ``multiple=True, nargs&gt;1``, the default must be a list of 
        tuples. 
 
    .. versionchanged:: 8.0 
        Setting a default is no longer required for ``nargs&gt;1``, it will 
        default to ``None``. ``multiple=True`` or ``nargs=-1`` will 
        default to ``()``. 
 
    .. versionchanged:: 7.1 
        Empty environment variables are ignored rather than taking the 
        empty string value. This makes it possible for scripts to clear 
        variables if they can't unset them. 
 
    .. versionchanged:: 2.0 
        Changed signature for parameter callback to also be passed the 
        parameter. The old callback format will still work, but it will 
        raise a warning to give you a chance to migrate the code easier. 
    &quot;&quot;&quot;</span>

    <span class="s1">param_type_name = </span><span class="s2">&quot;parameter&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">param_decls: t.Optional[t.Sequence[str]] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">type: t.Optional[t.Union[types.ParamType</span><span class="s3">, </span><span class="s1">t.Any]] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">required: bool = </span><span class="s0">False</span><span class="s3">,</span>
        <span class="s1">default: t.Optional[t.Union[t.Any</span><span class="s3">, </span><span class="s1">t.Callable[[]</span><span class="s3">, </span><span class="s1">t.Any]]] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">callback: t.Optional[t.Callable[[Context</span><span class="s3">, </span><span class="s2">&quot;Parameter&quot;</span><span class="s3">, </span><span class="s1">t.Any]</span><span class="s3">, </span><span class="s1">t.Any]] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">nargs: t.Optional[int] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">multiple: bool = </span><span class="s0">False</span><span class="s3">,</span>
        <span class="s1">metavar: t.Optional[str] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">expose_value: bool = </span><span class="s0">True</span><span class="s3">,</span>
        <span class="s1">is_eager: bool = </span><span class="s0">False</span><span class="s3">,</span>
        <span class="s1">envvar: t.Optional[t.Union[str</span><span class="s3">, </span><span class="s1">t.Sequence[str]]] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">shell_complete: t.Optional[</span>
            <span class="s1">t.Callable[</span>
                <span class="s1">[Context</span><span class="s3">, </span><span class="s2">&quot;Parameter&quot;</span><span class="s3">, </span><span class="s1">str]</span><span class="s3">,</span>
                <span class="s1">t.Union[t.List[</span><span class="s2">&quot;CompletionItem&quot;</span><span class="s1">]</span><span class="s3">, </span><span class="s1">t.List[str]]</span><span class="s3">,</span>
            <span class="s1">]</span>
        <span class="s1">] = </span><span class="s0">None</span><span class="s3">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.name: t.Optional[str]</span>
        <span class="s1">self.opts: t.List[str]</span>
        <span class="s1">self.secondary_opts: t.List[str]</span>
        <span class="s1">self.name</span><span class="s3">, </span><span class="s1">self.opts</span><span class="s3">, </span><span class="s1">self.secondary_opts = self._parse_decls(</span>
            <span class="s1">param_decls </span><span class="s0">or </span><span class="s1">()</span><span class="s3">, </span><span class="s1">expose_value</span>
        <span class="s1">)</span>
        <span class="s1">self.type: types.ParamType = types.convert_type(type</span><span class="s3">, </span><span class="s1">default)</span>

        <span class="s6"># Default nargs to what the type tells us if we have that</span>
        <span class="s6"># information available.</span>
        <span class="s0">if </span><span class="s1">nargs </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.type.is_composite:</span>
                <span class="s1">nargs = self.type.arity</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">nargs = </span><span class="s7">1</span>

        <span class="s1">self.required = required</span>
        <span class="s1">self.callback = callback</span>
        <span class="s1">self.nargs = nargs</span>
        <span class="s1">self.multiple = multiple</span>
        <span class="s1">self.expose_value = expose_value</span>
        <span class="s1">self.default = default</span>
        <span class="s1">self.is_eager = is_eager</span>
        <span class="s1">self.metavar = metavar</span>
        <span class="s1">self.envvar = envvar</span>
        <span class="s1">self._custom_shell_complete = shell_complete</span>

        <span class="s0">if __debug__</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.type.is_composite </span><span class="s0">and </span><span class="s1">nargs != self.type.arity:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s2">f&quot;'nargs' must be </span><span class="s5">{</span><span class="s1">self.type.arity</span><span class="s5">} </span><span class="s2">(or None) for&quot;</span>
                    <span class="s2">f&quot; type </span><span class="s5">{</span><span class="s1">self.type</span><span class="s5">!r}</span><span class="s2">, but it was </span><span class="s5">{</span><span class="s1">nargs</span><span class="s5">}</span><span class="s2">.&quot;</span>
                <span class="s1">)</span>

            <span class="s6"># Skip no default or callable default.</span>
            <span class="s1">check_default = default </span><span class="s0">if not </span><span class="s1">callable(default) </span><span class="s0">else None</span>

            <span class="s0">if </span><span class="s1">check_default </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">multiple:</span>
                    <span class="s0">try</span><span class="s1">:</span>
                        <span class="s6"># Only check the first value against nargs.</span>
                        <span class="s1">check_default = next(_check_iter(check_default)</span><span class="s3">, </span><span class="s0">None</span><span class="s1">)</span>
                    <span class="s0">except </span><span class="s1">TypeError:</span>
                        <span class="s0">raise </span><span class="s1">ValueError(</span>
                            <span class="s2">&quot;'default' must be a list when 'multiple' is true.&quot;</span>
                        <span class="s1">) </span><span class="s0">from None</span>

                <span class="s6"># Can be None for multiple with empty default.</span>
                <span class="s0">if </span><span class="s1">nargs != </span><span class="s7">1 </span><span class="s0">and </span><span class="s1">check_default </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s0">try</span><span class="s1">:</span>
                        <span class="s1">_check_iter(check_default)</span>
                    <span class="s0">except </span><span class="s1">TypeError:</span>
                        <span class="s0">if </span><span class="s1">multiple:</span>
                            <span class="s1">message = (</span>
                                <span class="s2">&quot;'default' must be a list of lists when 'multiple' is&quot;</span>
                                <span class="s2">&quot; true and 'nargs' != 1.&quot;</span>
                            <span class="s1">)</span>
                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s1">message = </span><span class="s2">&quot;'default' must be a list when 'nargs' != 1.&quot;</span>

                        <span class="s0">raise </span><span class="s1">ValueError(message) </span><span class="s0">from None</span>

                    <span class="s0">if </span><span class="s1">nargs &gt; </span><span class="s7">1 </span><span class="s0">and </span><span class="s1">len(check_default) != nargs:</span>
                        <span class="s1">subject = </span><span class="s2">&quot;item length&quot; </span><span class="s0">if </span><span class="s1">multiple </span><span class="s0">else </span><span class="s2">&quot;length&quot;</span>
                        <span class="s0">raise </span><span class="s1">ValueError(</span>
                            <span class="s2">f&quot;'default' </span><span class="s5">{</span><span class="s1">subject</span><span class="s5">} </span><span class="s2">must match nargs=</span><span class="s5">{</span><span class="s1">nargs</span><span class="s5">}</span><span class="s2">.&quot;</span>
                        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">to_info_dict(self) -&gt; t.Dict[str</span><span class="s3">, </span><span class="s1">t.Any]:</span>
        <span class="s4">&quot;&quot;&quot;Gather information that could be useful for a tool generating 
        user-facing documentation. 
 
        Use :meth:`click.Context.to_info_dict` to traverse the entire 
        CLI structure. 
 
        .. versionadded:: 8.0 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">{</span>
            <span class="s2">&quot;name&quot;</span><span class="s1">: self.name</span><span class="s3">,</span>
            <span class="s2">&quot;param_type_name&quot;</span><span class="s1">: self.param_type_name</span><span class="s3">,</span>
            <span class="s2">&quot;opts&quot;</span><span class="s1">: self.opts</span><span class="s3">,</span>
            <span class="s2">&quot;secondary_opts&quot;</span><span class="s1">: self.secondary_opts</span><span class="s3">,</span>
            <span class="s2">&quot;type&quot;</span><span class="s1">: self.type.to_info_dict()</span><span class="s3">,</span>
            <span class="s2">&quot;required&quot;</span><span class="s1">: self.required</span><span class="s3">,</span>
            <span class="s2">&quot;nargs&quot;</span><span class="s1">: self.nargs</span><span class="s3">,</span>
            <span class="s2">&quot;multiple&quot;</span><span class="s1">: self.multiple</span><span class="s3">,</span>
            <span class="s2">&quot;default&quot;</span><span class="s1">: self.default</span><span class="s3">,</span>
            <span class="s2">&quot;envvar&quot;</span><span class="s1">: self.envvar</span><span class="s3">,</span>
        <span class="s1">}</span>

    <span class="s0">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s2">f&quot;&lt;</span><span class="s5">{</span><span class="s1">self.__class__.__name__</span><span class="s5">} {</span><span class="s1">self.name</span><span class="s5">}</span><span class="s2">&gt;&quot;</span>

    <span class="s0">def </span><span class="s1">_parse_decls(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">decls: t.Sequence[str]</span><span class="s3">, </span><span class="s1">expose_value: bool</span>
    <span class="s1">) -&gt; t.Tuple[t.Optional[str]</span><span class="s3">, </span><span class="s1">t.List[str]</span><span class="s3">, </span><span class="s1">t.List[str]]:</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">human_readable_name(self) -&gt; str:</span>
        <span class="s4">&quot;&quot;&quot;Returns the human readable name of this parameter.  This is the 
        same as the name for options, but the metavar for arguments. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.name  </span><span class="s6"># type: ignore</span>

    <span class="s0">def </span><span class="s1">make_metavar(self) -&gt; str:</span>
        <span class="s0">if </span><span class="s1">self.metavar </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.metavar</span>

        <span class="s1">metavar = self.type.get_metavar(self)</span>

        <span class="s0">if </span><span class="s1">metavar </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">metavar = self.type.name.upper()</span>

        <span class="s0">if </span><span class="s1">self.nargs != </span><span class="s7">1</span><span class="s1">:</span>
            <span class="s1">metavar += </span><span class="s2">&quot;...&quot;</span>

        <span class="s0">return </span><span class="s1">metavar</span>

    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">get_default(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">ctx: Context</span><span class="s3">, </span><span class="s1">call: </span><span class="s2">&quot;te.Literal[True]&quot; </span><span class="s1">= </span><span class="s0">True</span>
    <span class="s1">) -&gt; t.Optional[t.Any]:</span>
        <span class="s1">...</span>

    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">get_default(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">ctx: Context</span><span class="s3">, </span><span class="s1">call: bool = ...</span>
    <span class="s1">) -&gt; t.Optional[t.Union[t.Any</span><span class="s3">, </span><span class="s1">t.Callable[[]</span><span class="s3">, </span><span class="s1">t.Any]]]:</span>
        <span class="s1">...</span>

    <span class="s0">def </span><span class="s1">get_default(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">ctx: Context</span><span class="s3">, </span><span class="s1">call: bool = </span><span class="s0">True</span>
    <span class="s1">) -&gt; t.Optional[t.Union[t.Any</span><span class="s3">, </span><span class="s1">t.Callable[[]</span><span class="s3">, </span><span class="s1">t.Any]]]:</span>
        <span class="s4">&quot;&quot;&quot;Get the default for the parameter. Tries 
        :meth:`Context.lookup_default` first, then the local default. 
 
        :param ctx: Current context. 
        :param call: If the default is a callable, call it. Disable to 
            return the callable instead. 
 
        .. versionchanged:: 8.0.2 
            Type casting is no longer performed when getting a default. 
 
        .. versionchanged:: 8.0.1 
            Type casting can fail in resilient parsing mode. Invalid 
            defaults will not prevent showing help text. 
 
        .. versionchanged:: 8.0 
            Looks at ``ctx.default_map`` first. 
 
        .. versionchanged:: 8.0 
            Added the ``call`` parameter. 
        &quot;&quot;&quot;</span>
        <span class="s1">value = ctx.lookup_default(self.name</span><span class="s3">, </span><span class="s1">call=</span><span class="s0">False</span><span class="s1">)  </span><span class="s6"># type: ignore</span>

        <span class="s0">if </span><span class="s1">value </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">value = self.default</span>

        <span class="s0">if </span><span class="s1">call </span><span class="s0">and </span><span class="s1">callable(value):</span>
            <span class="s1">value = value()</span>

        <span class="s0">return </span><span class="s1">value</span>

    <span class="s0">def </span><span class="s1">add_to_parser(self</span><span class="s3">, </span><span class="s1">parser: OptionParser</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s0">def </span><span class="s1">consume_value(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">ctx: Context</span><span class="s3">, </span><span class="s1">opts: t.Mapping[str</span><span class="s3">, </span><span class="s1">t.Any]</span>
    <span class="s1">) -&gt; t.Tuple[t.Any</span><span class="s3">, </span><span class="s1">ParameterSource]:</span>
        <span class="s1">value = opts.get(self.name)  </span><span class="s6"># type: ignore</span>
        <span class="s1">source = ParameterSource.COMMANDLINE</span>

        <span class="s0">if </span><span class="s1">value </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">value = self.value_from_envvar(ctx)</span>
            <span class="s1">source = ParameterSource.ENVIRONMENT</span>

        <span class="s0">if </span><span class="s1">value </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">value = ctx.lookup_default(self.name)  </span><span class="s6"># type: ignore</span>
            <span class="s1">source = ParameterSource.DEFAULT_MAP</span>

        <span class="s0">if </span><span class="s1">value </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">value = self.get_default(ctx)</span>
            <span class="s1">source = ParameterSource.DEFAULT</span>

        <span class="s0">return </span><span class="s1">value</span><span class="s3">, </span><span class="s1">source</span>

    <span class="s0">def </span><span class="s1">type_cast_value(self</span><span class="s3">, </span><span class="s1">ctx: Context</span><span class="s3">, </span><span class="s1">value: t.Any) -&gt; t.Any:</span>
        <span class="s4">&quot;&quot;&quot;Convert and validate a value against the option's 
        :attr:`type`, :attr:`multiple`, and :attr:`nargs`. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">value </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">() </span><span class="s0">if </span><span class="s1">self.multiple </span><span class="s0">or </span><span class="s1">self.nargs == -</span><span class="s7">1 </span><span class="s0">else None</span>

        <span class="s0">def </span><span class="s1">check_iter(value: t.Any) -&gt; t.Iterator[t.Any]:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">_check_iter(value)</span>
            <span class="s0">except </span><span class="s1">TypeError:</span>
                <span class="s6"># This should only happen when passing in args manually,</span>
                <span class="s6"># the parser should construct an iterable when parsing</span>
                <span class="s6"># the command line.</span>
                <span class="s0">raise </span><span class="s1">BadParameter(</span>
                    <span class="s1">_(</span><span class="s2">&quot;Value must be an iterable.&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">ctx=ctx</span><span class="s3">, </span><span class="s1">param=self</span>
                <span class="s1">) </span><span class="s0">from None</span>

        <span class="s0">if </span><span class="s1">self.nargs == </span><span class="s7">1 </span><span class="s0">or </span><span class="s1">self.type.is_composite:</span>

            <span class="s0">def </span><span class="s1">convert(value: t.Any) -&gt; t.Any:</span>
                <span class="s0">return </span><span class="s1">self.type(value</span><span class="s3">, </span><span class="s1">param=self</span><span class="s3">, </span><span class="s1">ctx=ctx)</span>

        <span class="s0">elif </span><span class="s1">self.nargs == -</span><span class="s7">1</span><span class="s1">:</span>

            <span class="s0">def </span><span class="s1">convert(value: t.Any) -&gt; t.Any:  </span><span class="s6"># t.Tuple[t.Any, ...]</span>
                <span class="s0">return </span><span class="s1">tuple(self.type(x</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">ctx) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">check_iter(value))</span>

        <span class="s0">else</span><span class="s1">:  </span><span class="s6"># nargs &gt; 1</span>

            <span class="s0">def </span><span class="s1">convert(value: t.Any) -&gt; t.Any:  </span><span class="s6"># t.Tuple[t.Any, ...]</span>
                <span class="s1">value = tuple(check_iter(value))</span>

                <span class="s0">if </span><span class="s1">len(value) != self.nargs:</span>
                    <span class="s0">raise </span><span class="s1">BadParameter(</span>
                        <span class="s1">ngettext(</span>
                            <span class="s2">&quot;Takes {nargs} values but 1 was given.&quot;</span><span class="s3">,</span>
                            <span class="s2">&quot;Takes {nargs} values but {len} were given.&quot;</span><span class="s3">,</span>
                            <span class="s1">len(value)</span><span class="s3">,</span>
                        <span class="s1">).format(nargs=self.nargs</span><span class="s3">, </span><span class="s1">len=len(value))</span><span class="s3">,</span>
                        <span class="s1">ctx=ctx</span><span class="s3">,</span>
                        <span class="s1">param=self</span><span class="s3">,</span>
                    <span class="s1">)</span>

                <span class="s0">return </span><span class="s1">tuple(self.type(x</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">ctx) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">value)</span>

        <span class="s0">if </span><span class="s1">self.multiple:</span>
            <span class="s0">return </span><span class="s1">tuple(convert(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">check_iter(value))</span>

        <span class="s0">return </span><span class="s1">convert(value)</span>

    <span class="s0">def </span><span class="s1">value_is_missing(self</span><span class="s3">, </span><span class="s1">value: t.Any) -&gt; bool:</span>
        <span class="s0">if </span><span class="s1">value </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return True</span>

        <span class="s0">if </span><span class="s1">(self.nargs != </span><span class="s7">1 </span><span class="s0">or </span><span class="s1">self.multiple) </span><span class="s0">and </span><span class="s1">value == ():</span>
            <span class="s0">return True</span>

        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">process_value(self</span><span class="s3">, </span><span class="s1">ctx: Context</span><span class="s3">, </span><span class="s1">value: t.Any) -&gt; t.Any:</span>
        <span class="s1">value = self.type_cast_value(ctx</span><span class="s3">, </span><span class="s1">value)</span>

        <span class="s0">if </span><span class="s1">self.required </span><span class="s0">and </span><span class="s1">self.value_is_missing(value):</span>
            <span class="s0">raise </span><span class="s1">MissingParameter(ctx=ctx</span><span class="s3">, </span><span class="s1">param=self)</span>

        <span class="s0">if </span><span class="s1">self.callback </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">value = self.callback(ctx</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">value)</span>

        <span class="s0">return </span><span class="s1">value</span>

    <span class="s0">def </span><span class="s1">resolve_envvar_value(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; t.Optional[str]:</span>
        <span class="s0">if </span><span class="s1">self.envvar </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return None</span>

        <span class="s0">if </span><span class="s1">isinstance(self.envvar</span><span class="s3">, </span><span class="s1">str):</span>
            <span class="s1">rv = os.environ.get(self.envvar)</span>

            <span class="s0">if </span><span class="s1">rv:</span>
                <span class="s0">return </span><span class="s1">rv</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">envvar </span><span class="s0">in </span><span class="s1">self.envvar:</span>
                <span class="s1">rv = os.environ.get(envvar)</span>

                <span class="s0">if </span><span class="s1">rv:</span>
                    <span class="s0">return </span><span class="s1">rv</span>

        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">value_from_envvar(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; t.Optional[t.Any]:</span>
        <span class="s1">rv: t.Optional[t.Any] = self.resolve_envvar_value(ctx)</span>

        <span class="s0">if </span><span class="s1">rv </span><span class="s0">is not None and </span><span class="s1">self.nargs != </span><span class="s7">1</span><span class="s1">:</span>
            <span class="s1">rv = self.type.split_envvar_value(rv)</span>

        <span class="s0">return </span><span class="s1">rv</span>

    <span class="s0">def </span><span class="s1">handle_parse_result(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">ctx: Context</span><span class="s3">, </span><span class="s1">opts: t.Mapping[str</span><span class="s3">, </span><span class="s1">t.Any]</span><span class="s3">, </span><span class="s1">args: t.List[str]</span>
    <span class="s1">) -&gt; t.Tuple[t.Any</span><span class="s3">, </span><span class="s1">t.List[str]]:</span>
        <span class="s0">with </span><span class="s1">augment_usage_errors(ctx</span><span class="s3">, </span><span class="s1">param=self):</span>
            <span class="s1">value</span><span class="s3">, </span><span class="s1">source = self.consume_value(ctx</span><span class="s3">, </span><span class="s1">opts)</span>
            <span class="s1">ctx.set_parameter_source(self.name</span><span class="s3">, </span><span class="s1">source)  </span><span class="s6"># type: ignore</span>

            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">value = self.process_value(ctx</span><span class="s3">, </span><span class="s1">value)</span>
            <span class="s0">except </span><span class="s1">Exception:</span>
                <span class="s0">if not </span><span class="s1">ctx.resilient_parsing:</span>
                    <span class="s0">raise</span>

                <span class="s1">value = </span><span class="s0">None</span>

        <span class="s0">if </span><span class="s1">self.expose_value:</span>
            <span class="s1">ctx.params[self.name] = value  </span><span class="s6"># type: ignore</span>

        <span class="s0">return </span><span class="s1">value</span><span class="s3">, </span><span class="s1">args</span>

    <span class="s0">def </span><span class="s1">get_help_record(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; t.Optional[t.Tuple[str</span><span class="s3">, </span><span class="s1">str]]:</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">get_usage_pieces(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; t.List[str]:</span>
        <span class="s0">return </span><span class="s1">[]</span>

    <span class="s0">def </span><span class="s1">get_error_hint(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; str:</span>
        <span class="s4">&quot;&quot;&quot;Get a stringified version of the param for use in error messages to 
        indicate which param caused the error. 
        &quot;&quot;&quot;</span>
        <span class="s1">hint_list = self.opts </span><span class="s0">or </span><span class="s1">[self.human_readable_name]</span>
        <span class="s0">return </span><span class="s2">&quot; / &quot;</span><span class="s1">.join(</span><span class="s2">f&quot;'</span><span class="s5">{</span><span class="s1">x</span><span class="s5">}</span><span class="s2">'&quot; </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">hint_list)</span>

    <span class="s0">def </span><span class="s1">shell_complete(self</span><span class="s3">, </span><span class="s1">ctx: Context</span><span class="s3">, </span><span class="s1">incomplete: str) -&gt; t.List[</span><span class="s2">&quot;CompletionItem&quot;</span><span class="s1">]:</span>
        <span class="s4">&quot;&quot;&quot;Return a list of completions for the incomplete value. If a 
        ``shell_complete`` function was given during init, it is used. 
        Otherwise, the :attr:`type` 
        :meth:`~click.types.ParamType.shell_complete` function is used. 
 
        :param ctx: Invocation context for this command. 
        :param incomplete: Value being completed. May be empty. 
 
        .. versionadded:: 8.0 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._custom_shell_complete </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">results = self._custom_shell_complete(ctx</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">incomplete)</span>

            <span class="s0">if </span><span class="s1">results </span><span class="s0">and </span><span class="s1">isinstance(results[</span><span class="s7">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">str):</span>
                <span class="s0">from </span><span class="s1">click.shell_completion </span><span class="s0">import </span><span class="s1">CompletionItem</span>

                <span class="s1">results = [CompletionItem(c) </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">results]</span>

            <span class="s0">return </span><span class="s1">t.cast(t.List[</span><span class="s2">&quot;CompletionItem&quot;</span><span class="s1">]</span><span class="s3">, </span><span class="s1">results)</span>

        <span class="s0">return </span><span class="s1">self.type.shell_complete(ctx</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">incomplete)</span>


<span class="s0">class </span><span class="s1">Option(Parameter):</span>
    <span class="s4">&quot;&quot;&quot;Options are usually optional values on the command line and 
    have some extra features that arguments don't have. 
 
    All other parameters are passed onwards to the parameter constructor. 
 
    :param show_default: Show the default value for this option in its 
        help text. Values are not shown by default, unless 
        :attr:`Context.show_default` is ``True``. If this value is a 
        string, it shows that string in parentheses instead of the 
        actual value. This is particularly useful for dynamic options. 
        For single option boolean flags, the default remains hidden if 
        its value is ``False``. 
    :param show_envvar: Controls if an environment variable should be 
        shown on the help page. Normally, environment variables are not 
        shown. 
    :param prompt: If set to ``True`` or a non empty string then the 
        user will be prompted for input. If set to ``True`` the prompt 
        will be the option name capitalized. 
    :param confirmation_prompt: Prompt a second time to confirm the 
        value if it was prompted for. Can be set to a string instead of 
        ``True`` to customize the message. 
    :param prompt_required: If set to ``False``, the user will be 
        prompted for input only when the option was specified as a flag 
        without a value. 
    :param hide_input: If this is ``True`` then the input on the prompt 
        will be hidden from the user. This is useful for password input. 
    :param is_flag: forces this option to act as a flag.  The default is 
                    auto detection. 
    :param flag_value: which value should be used for this flag if it's 
                       enabled.  This is set to a boolean automatically if 
                       the option string contains a slash to mark two options. 
    :param multiple: if this is set to `True` then the argument is accepted 
                     multiple times and recorded.  This is similar to ``nargs`` 
                     in how it works but supports arbitrary number of 
                     arguments. 
    :param count: this flag makes an option increment an integer. 
    :param allow_from_autoenv: if this is enabled then the value of this 
                               parameter will be pulled from an environment 
                               variable in case a prefix is defined on the 
                               context. 
    :param help: the help string. 
    :param hidden: hide this option from help outputs. 
    :param attrs: Other command arguments described in :class:`Parameter`. 
 
    .. versionchanged:: 8.1.0 
        Help text indentation is cleaned here instead of only in the 
        ``@option`` decorator. 
 
    .. versionchanged:: 8.1.0 
        The ``show_default`` parameter overrides 
        ``Context.show_default``. 
 
    .. versionchanged:: 8.1.0 
        The default of a single option boolean flag is not shown if the 
        default value is ``False``. 
 
    .. versionchanged:: 8.0.1 
        ``type`` is detected from ``flag_value`` if given. 
    &quot;&quot;&quot;</span>

    <span class="s1">param_type_name = </span><span class="s2">&quot;option&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">param_decls: t.Optional[t.Sequence[str]] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">show_default: t.Union[bool</span><span class="s3">, </span><span class="s1">str</span><span class="s3">, </span><span class="s0">None</span><span class="s1">] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">prompt: t.Union[bool</span><span class="s3">, </span><span class="s1">str] = </span><span class="s0">False</span><span class="s3">,</span>
        <span class="s1">confirmation_prompt: t.Union[bool</span><span class="s3">, </span><span class="s1">str] = </span><span class="s0">False</span><span class="s3">,</span>
        <span class="s1">prompt_required: bool = </span><span class="s0">True</span><span class="s3">,</span>
        <span class="s1">hide_input: bool = </span><span class="s0">False</span><span class="s3">,</span>
        <span class="s1">is_flag: t.Optional[bool] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">flag_value: t.Optional[t.Any] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">multiple: bool = </span><span class="s0">False</span><span class="s3">,</span>
        <span class="s1">count: bool = </span><span class="s0">False</span><span class="s3">,</span>
        <span class="s1">allow_from_autoenv: bool = </span><span class="s0">True</span><span class="s3">,</span>
        <span class="s1">type: t.Optional[t.Union[types.ParamType</span><span class="s3">, </span><span class="s1">t.Any]] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">help: t.Optional[str] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">hidden: bool = </span><span class="s0">False</span><span class="s3">,</span>
        <span class="s1">show_choices: bool = </span><span class="s0">True</span><span class="s3">,</span>
        <span class="s1">show_envvar: bool = </span><span class="s0">False</span><span class="s3">,</span>
        <span class="s1">**attrs: t.Any</span><span class="s3">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">help:</span>
            <span class="s1">help = inspect.cleandoc(help)</span>

        <span class="s1">default_is_missing = </span><span class="s2">&quot;default&quot; </span><span class="s0">not in </span><span class="s1">attrs</span>
        <span class="s1">super().__init__(param_decls</span><span class="s3">, </span><span class="s1">type=type</span><span class="s3">, </span><span class="s1">multiple=multiple</span><span class="s3">, </span><span class="s1">**attrs)</span>

        <span class="s0">if </span><span class="s1">prompt </span><span class="s0">is True</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.name </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;'name' is required with 'prompt=True'.&quot;</span><span class="s1">)</span>

            <span class="s1">prompt_text: t.Optional[str] = self.name.replace(</span><span class="s2">&quot;_&quot;</span><span class="s3">, </span><span class="s2">&quot; &quot;</span><span class="s1">).capitalize()</span>
        <span class="s0">elif </span><span class="s1">prompt </span><span class="s0">is False</span><span class="s1">:</span>
            <span class="s1">prompt_text = </span><span class="s0">None</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">prompt_text = prompt</span>

        <span class="s1">self.prompt = prompt_text</span>
        <span class="s1">self.confirmation_prompt = confirmation_prompt</span>
        <span class="s1">self.prompt_required = prompt_required</span>
        <span class="s1">self.hide_input = hide_input</span>
        <span class="s1">self.hidden = hidden</span>

        <span class="s6"># If prompt is enabled but not required, then the option can be</span>
        <span class="s6"># used as a flag to indicate using prompt or flag_value.</span>
        <span class="s1">self._flag_needs_value = self.prompt </span><span class="s0">is not None and not </span><span class="s1">self.prompt_required</span>

        <span class="s0">if </span><span class="s1">is_flag </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">flag_value </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s6"># Implicitly a flag because flag_value was set.</span>
                <span class="s1">is_flag = </span><span class="s0">True</span>
            <span class="s0">elif </span><span class="s1">self._flag_needs_value:</span>
                <span class="s6"># Not a flag, but when used as a flag it shows a prompt.</span>
                <span class="s1">is_flag = </span><span class="s0">False</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s6"># Implicitly a flag because flag options were given.</span>
                <span class="s1">is_flag = bool(self.secondary_opts)</span>
        <span class="s0">elif </span><span class="s1">is_flag </span><span class="s0">is False and not </span><span class="s1">self._flag_needs_value:</span>
            <span class="s6"># Not a flag, and prompt is not enabled, can be used as a</span>
            <span class="s6"># flag if flag_value is set.</span>
            <span class="s1">self._flag_needs_value = flag_value </span><span class="s0">is not None</span>

        <span class="s1">self.default: t.Union[t.Any</span><span class="s3">, </span><span class="s1">t.Callable[[]</span><span class="s3">, </span><span class="s1">t.Any]]</span>

        <span class="s0">if </span><span class="s1">is_flag </span><span class="s0">and </span><span class="s1">default_is_missing </span><span class="s0">and not </span><span class="s1">self.required:</span>
            <span class="s0">if </span><span class="s1">multiple:</span>
                <span class="s1">self.default = ()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.default = </span><span class="s0">False</span>

        <span class="s0">if </span><span class="s1">flag_value </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">flag_value = </span><span class="s0">not </span><span class="s1">self.default</span>

        <span class="s1">self.type: types.ParamType</span>
        <span class="s0">if </span><span class="s1">is_flag </span><span class="s0">and </span><span class="s1">type </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s6"># Re-guess the type from the flag value instead of the</span>
            <span class="s6"># default.</span>
            <span class="s1">self.type = types.convert_type(</span><span class="s0">None</span><span class="s3">, </span><span class="s1">flag_value)</span>

        <span class="s1">self.is_flag: bool = is_flag</span>
        <span class="s1">self.is_bool_flag: bool = is_flag </span><span class="s0">and </span><span class="s1">isinstance(self.type</span><span class="s3">, </span><span class="s1">types.BoolParamType)</span>
        <span class="s1">self.flag_value: t.Any = flag_value</span>

        <span class="s6"># Counting</span>
        <span class="s1">self.count = count</span>
        <span class="s0">if </span><span class="s1">count:</span>
            <span class="s0">if </span><span class="s1">type </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">self.type = types.IntRange(min=</span><span class="s7">0</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">default_is_missing:</span>
                <span class="s1">self.default = </span><span class="s7">0</span>

        <span class="s1">self.allow_from_autoenv = allow_from_autoenv</span>
        <span class="s1">self.help = help</span>
        <span class="s1">self.show_default = show_default</span>
        <span class="s1">self.show_choices = show_choices</span>
        <span class="s1">self.show_envvar = show_envvar</span>

        <span class="s0">if __debug__</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.nargs == -</span><span class="s7">1</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;nargs=-1 is not supported for options.&quot;</span><span class="s1">)</span>

            <span class="s0">if </span><span class="s1">self.prompt </span><span class="s0">and </span><span class="s1">self.is_flag </span><span class="s0">and not </span><span class="s1">self.is_bool_flag:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;'prompt' is not valid for non-boolean flag.&quot;</span><span class="s1">)</span>

            <span class="s0">if not </span><span class="s1">self.is_bool_flag </span><span class="s0">and </span><span class="s1">self.secondary_opts:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Secondary flag is not valid for non-boolean flag.&quot;</span><span class="s1">)</span>

            <span class="s0">if </span><span class="s1">self.is_bool_flag </span><span class="s0">and </span><span class="s1">self.hide_input </span><span class="s0">and </span><span class="s1">self.prompt </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span>
                    <span class="s2">&quot;'prompt' with 'hide_input' is not valid for boolean flag.&quot;</span>
                <span class="s1">)</span>

            <span class="s0">if </span><span class="s1">self.count:</span>
                <span class="s0">if </span><span class="s1">self.multiple:</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;'count' is not valid with 'multiple'.&quot;</span><span class="s1">)</span>

                <span class="s0">if </span><span class="s1">self.is_flag:</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;'count' is not valid with 'is_flag'.&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">to_info_dict(self) -&gt; t.Dict[str</span><span class="s3">, </span><span class="s1">t.Any]:</span>
        <span class="s1">info_dict = super().to_info_dict()</span>
        <span class="s1">info_dict.update(</span>
            <span class="s1">help=self.help</span><span class="s3">,</span>
            <span class="s1">prompt=self.prompt</span><span class="s3">,</span>
            <span class="s1">is_flag=self.is_flag</span><span class="s3">,</span>
            <span class="s1">flag_value=self.flag_value</span><span class="s3">,</span>
            <span class="s1">count=self.count</span><span class="s3">,</span>
            <span class="s1">hidden=self.hidden</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">info_dict</span>

    <span class="s0">def </span><span class="s1">_parse_decls(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">decls: t.Sequence[str]</span><span class="s3">, </span><span class="s1">expose_value: bool</span>
    <span class="s1">) -&gt; t.Tuple[t.Optional[str]</span><span class="s3">, </span><span class="s1">t.List[str]</span><span class="s3">, </span><span class="s1">t.List[str]]:</span>
        <span class="s1">opts = []</span>
        <span class="s1">secondary_opts = []</span>
        <span class="s1">name = </span><span class="s0">None</span>
        <span class="s1">possible_names = []</span>

        <span class="s0">for </span><span class="s1">decl </span><span class="s0">in </span><span class="s1">decls:</span>
            <span class="s0">if </span><span class="s1">decl.isidentifier():</span>
                <span class="s0">if </span><span class="s1">name </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">f&quot;Name '</span><span class="s5">{</span><span class="s1">name</span><span class="s5">}</span><span class="s2">' defined twice&quot;</span><span class="s1">)</span>
                <span class="s1">name = decl</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">split_char = </span><span class="s2">&quot;;&quot; </span><span class="s0">if </span><span class="s1">decl[:</span><span class="s7">1</span><span class="s1">] == </span><span class="s2">&quot;/&quot; </span><span class="s0">else </span><span class="s2">&quot;/&quot;</span>
                <span class="s0">if </span><span class="s1">split_char </span><span class="s0">in </span><span class="s1">decl:</span>
                    <span class="s1">first</span><span class="s3">, </span><span class="s1">second = decl.split(split_char</span><span class="s3">, </span><span class="s7">1</span><span class="s1">)</span>
                    <span class="s1">first = first.rstrip()</span>
                    <span class="s0">if </span><span class="s1">first:</span>
                        <span class="s1">possible_names.append(split_opt(first))</span>
                        <span class="s1">opts.append(first)</span>
                    <span class="s1">second = second.lstrip()</span>
                    <span class="s0">if </span><span class="s1">second:</span>
                        <span class="s1">secondary_opts.append(second.lstrip())</span>
                    <span class="s0">if </span><span class="s1">first == second:</span>
                        <span class="s0">raise </span><span class="s1">ValueError(</span>
                            <span class="s2">f&quot;Boolean option </span><span class="s5">{</span><span class="s1">decl</span><span class="s5">!r} </span><span class="s2">cannot use the&quot;</span>
                            <span class="s2">&quot; same flag for true/false.&quot;</span>
                        <span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">possible_names.append(split_opt(decl))</span>
                    <span class="s1">opts.append(decl)</span>

        <span class="s0">if </span><span class="s1">name </span><span class="s0">is None and </span><span class="s1">possible_names:</span>
            <span class="s1">possible_names.sort(key=</span><span class="s0">lambda </span><span class="s1">x: -len(x[</span><span class="s7">0</span><span class="s1">]))  </span><span class="s6"># group long options first</span>
            <span class="s1">name = possible_names[</span><span class="s7">0</span><span class="s1">][</span><span class="s7">1</span><span class="s1">].replace(</span><span class="s2">&quot;-&quot;</span><span class="s3">, </span><span class="s2">&quot;_&quot;</span><span class="s1">).lower()</span>
            <span class="s0">if not </span><span class="s1">name.isidentifier():</span>
                <span class="s1">name = </span><span class="s0">None</span>

        <span class="s0">if </span><span class="s1">name </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">expose_value:</span>
                <span class="s0">return None</span><span class="s3">, </span><span class="s1">opts</span><span class="s3">, </span><span class="s1">secondary_opts</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Could not determine name for option&quot;</span><span class="s1">)</span>

        <span class="s0">if not </span><span class="s1">opts </span><span class="s0">and not </span><span class="s1">secondary_opts:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s2">f&quot;No options defined but a name was passed (</span><span class="s5">{</span><span class="s1">name</span><span class="s5">}</span><span class="s2">).&quot;</span>
                <span class="s2">&quot; Did you mean to declare an argument instead? Did&quot;</span>
                <span class="s2">f&quot; you mean to pass '--</span><span class="s5">{</span><span class="s1">name</span><span class="s5">}</span><span class="s2">'?&quot;</span>
            <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">name</span><span class="s3">, </span><span class="s1">opts</span><span class="s3">, </span><span class="s1">secondary_opts</span>

    <span class="s0">def </span><span class="s1">add_to_parser(self</span><span class="s3">, </span><span class="s1">parser: OptionParser</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">self.multiple:</span>
            <span class="s1">action = </span><span class="s2">&quot;append&quot;</span>
        <span class="s0">elif </span><span class="s1">self.count:</span>
            <span class="s1">action = </span><span class="s2">&quot;count&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">action = </span><span class="s2">&quot;store&quot;</span>

        <span class="s0">if </span><span class="s1">self.is_flag:</span>
            <span class="s1">action = </span><span class="s2">f&quot;</span><span class="s5">{</span><span class="s1">action</span><span class="s5">}</span><span class="s2">_const&quot;</span>

            <span class="s0">if </span><span class="s1">self.is_bool_flag </span><span class="s0">and </span><span class="s1">self.secondary_opts:</span>
                <span class="s1">parser.add_option(</span>
                    <span class="s1">obj=self</span><span class="s3">, </span><span class="s1">opts=self.opts</span><span class="s3">, </span><span class="s1">dest=self.name</span><span class="s3">, </span><span class="s1">action=action</span><span class="s3">, </span><span class="s1">const=</span><span class="s0">True</span>
                <span class="s1">)</span>
                <span class="s1">parser.add_option(</span>
                    <span class="s1">obj=self</span><span class="s3">,</span>
                    <span class="s1">opts=self.secondary_opts</span><span class="s3">,</span>
                    <span class="s1">dest=self.name</span><span class="s3">,</span>
                    <span class="s1">action=action</span><span class="s3">,</span>
                    <span class="s1">const=</span><span class="s0">False</span><span class="s3">,</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">parser.add_option(</span>
                    <span class="s1">obj=self</span><span class="s3">,</span>
                    <span class="s1">opts=self.opts</span><span class="s3">,</span>
                    <span class="s1">dest=self.name</span><span class="s3">,</span>
                    <span class="s1">action=action</span><span class="s3">,</span>
                    <span class="s1">const=self.flag_value</span><span class="s3">,</span>
                <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">parser.add_option(</span>
                <span class="s1">obj=self</span><span class="s3">,</span>
                <span class="s1">opts=self.opts</span><span class="s3">,</span>
                <span class="s1">dest=self.name</span><span class="s3">,</span>
                <span class="s1">action=action</span><span class="s3">,</span>
                <span class="s1">nargs=self.nargs</span><span class="s3">,</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_help_record(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; t.Optional[t.Tuple[str</span><span class="s3">, </span><span class="s1">str]]:</span>
        <span class="s0">if </span><span class="s1">self.hidden:</span>
            <span class="s0">return None</span>

        <span class="s1">any_prefix_is_slash = </span><span class="s0">False</span>

        <span class="s0">def </span><span class="s1">_write_opts(opts: t.Sequence[str]) -&gt; str:</span>
            <span class="s0">nonlocal </span><span class="s1">any_prefix_is_slash</span>

            <span class="s1">rv</span><span class="s3">, </span><span class="s1">any_slashes = join_options(opts)</span>

            <span class="s0">if </span><span class="s1">any_slashes:</span>
                <span class="s1">any_prefix_is_slash = </span><span class="s0">True</span>

            <span class="s0">if not </span><span class="s1">self.is_flag </span><span class="s0">and not </span><span class="s1">self.count:</span>
                <span class="s1">rv += </span><span class="s2">f&quot; </span><span class="s5">{</span><span class="s1">self.make_metavar()</span><span class="s5">}</span><span class="s2">&quot;</span>

            <span class="s0">return </span><span class="s1">rv</span>

        <span class="s1">rv = [_write_opts(self.opts)]</span>

        <span class="s0">if </span><span class="s1">self.secondary_opts:</span>
            <span class="s1">rv.append(_write_opts(self.secondary_opts))</span>

        <span class="s1">help = self.help </span><span class="s0">or </span><span class="s2">&quot;&quot;</span>
        <span class="s1">extra = []</span>

        <span class="s0">if </span><span class="s1">self.show_envvar:</span>
            <span class="s1">envvar = self.envvar</span>

            <span class="s0">if </span><span class="s1">envvar </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">(</span>
                    <span class="s1">self.allow_from_autoenv</span>
                    <span class="s0">and </span><span class="s1">ctx.auto_envvar_prefix </span><span class="s0">is not None</span>
                    <span class="s0">and </span><span class="s1">self.name </span><span class="s0">is not None</span>
                <span class="s1">):</span>
                    <span class="s1">envvar = </span><span class="s2">f&quot;</span><span class="s5">{</span><span class="s1">ctx.auto_envvar_prefix</span><span class="s5">}</span><span class="s2">_</span><span class="s5">{</span><span class="s1">self.name.upper()</span><span class="s5">}</span><span class="s2">&quot;</span>

            <span class="s0">if </span><span class="s1">envvar </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">var_str = (</span>
                    <span class="s1">envvar</span>
                    <span class="s0">if </span><span class="s1">isinstance(envvar</span><span class="s3">, </span><span class="s1">str)</span>
                    <span class="s0">else </span><span class="s2">&quot;, &quot;</span><span class="s1">.join(str(d) </span><span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">envvar)</span>
                <span class="s1">)</span>
                <span class="s1">extra.append(_(</span><span class="s2">&quot;env var: {var}&quot;</span><span class="s1">).format(var=var_str))</span>

        <span class="s6"># Temporarily enable resilient parsing to avoid type casting</span>
        <span class="s6"># failing for the default. Might be possible to extend this to</span>
        <span class="s6"># help formatting in general.</span>
        <span class="s1">resilient = ctx.resilient_parsing</span>
        <span class="s1">ctx.resilient_parsing = </span><span class="s0">True</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">default_value = self.get_default(ctx</span><span class="s3">, </span><span class="s1">call=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">ctx.resilient_parsing = resilient</span>

        <span class="s1">show_default = </span><span class="s0">False</span>
        <span class="s1">show_default_is_str = </span><span class="s0">False</span>

        <span class="s0">if </span><span class="s1">self.show_default </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(self.show_default</span><span class="s3">, </span><span class="s1">str):</span>
                <span class="s1">show_default_is_str = show_default = </span><span class="s0">True</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">show_default = self.show_default</span>
        <span class="s0">elif </span><span class="s1">ctx.show_default </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">show_default = ctx.show_default</span>

        <span class="s0">if </span><span class="s1">show_default_is_str </span><span class="s0">or </span><span class="s1">(show_default </span><span class="s0">and </span><span class="s1">(default_value </span><span class="s0">is not None</span><span class="s1">)):</span>
            <span class="s0">if </span><span class="s1">show_default_is_str:</span>
                <span class="s1">default_string = </span><span class="s2">f&quot;(</span><span class="s5">{</span><span class="s1">self.show_default</span><span class="s5">}</span><span class="s2">)&quot;</span>
            <span class="s0">elif </span><span class="s1">isinstance(default_value</span><span class="s3">, </span><span class="s1">(list</span><span class="s3">, </span><span class="s1">tuple)):</span>
                <span class="s1">default_string = </span><span class="s2">&quot;, &quot;</span><span class="s1">.join(str(d) </span><span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">default_value)</span>
            <span class="s0">elif </span><span class="s1">inspect.isfunction(default_value):</span>
                <span class="s1">default_string = _(</span><span class="s2">&quot;(dynamic)&quot;</span><span class="s1">)</span>
            <span class="s0">elif </span><span class="s1">self.is_bool_flag </span><span class="s0">and </span><span class="s1">self.secondary_opts:</span>
                <span class="s6"># For boolean flags that have distinct True/False opts,</span>
                <span class="s6"># use the opt without prefix instead of the value.</span>
                <span class="s1">default_string = split_opt(</span>
                    <span class="s1">(self.opts </span><span class="s0">if </span><span class="s1">self.default </span><span class="s0">else </span><span class="s1">self.secondary_opts)[</span><span class="s7">0</span><span class="s1">]</span>
                <span class="s1">)[</span><span class="s7">1</span><span class="s1">]</span>
            <span class="s0">elif </span><span class="s1">self.is_bool_flag </span><span class="s0">and not </span><span class="s1">self.secondary_opts </span><span class="s0">and not </span><span class="s1">default_value:</span>
                <span class="s1">default_string = </span><span class="s2">&quot;&quot;</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">default_string = str(default_value)</span>

            <span class="s0">if </span><span class="s1">default_string:</span>
                <span class="s1">extra.append(_(</span><span class="s2">&quot;default: {default}&quot;</span><span class="s1">).format(default=default_string))</span>

        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">isinstance(self.type</span><span class="s3">, </span><span class="s1">types._NumberRangeBase)</span>
            <span class="s6"># skip count with default range type</span>
            <span class="s0">and not </span><span class="s1">(self.count </span><span class="s0">and </span><span class="s1">self.type.min == </span><span class="s7">0 </span><span class="s0">and </span><span class="s1">self.type.max </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s1">range_str = self.type._describe_range()</span>

            <span class="s0">if </span><span class="s1">range_str:</span>
                <span class="s1">extra.append(range_str)</span>

        <span class="s0">if </span><span class="s1">self.required:</span>
            <span class="s1">extra.append(_(</span><span class="s2">&quot;required&quot;</span><span class="s1">))</span>

        <span class="s0">if </span><span class="s1">extra:</span>
            <span class="s1">extra_str = </span><span class="s2">&quot;; &quot;</span><span class="s1">.join(extra)</span>
            <span class="s1">help = </span><span class="s2">f&quot;</span><span class="s5">{</span><span class="s1">help</span><span class="s5">}  </span><span class="s2">[</span><span class="s5">{</span><span class="s1">extra_str</span><span class="s5">}</span><span class="s2">]&quot; </span><span class="s0">if </span><span class="s1">help </span><span class="s0">else </span><span class="s2">f&quot;[</span><span class="s5">{</span><span class="s1">extra_str</span><span class="s5">}</span><span class="s2">]&quot;</span>

        <span class="s0">return </span><span class="s1">(</span><span class="s2">&quot;; &quot; </span><span class="s0">if </span><span class="s1">any_prefix_is_slash </span><span class="s0">else </span><span class="s2">&quot; / &quot;</span><span class="s1">).join(rv)</span><span class="s3">, </span><span class="s1">help</span>

    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">get_default(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">ctx: Context</span><span class="s3">, </span><span class="s1">call: </span><span class="s2">&quot;te.Literal[True]&quot; </span><span class="s1">= </span><span class="s0">True</span>
    <span class="s1">) -&gt; t.Optional[t.Any]:</span>
        <span class="s1">...</span>

    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">get_default(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">ctx: Context</span><span class="s3">, </span><span class="s1">call: bool = ...</span>
    <span class="s1">) -&gt; t.Optional[t.Union[t.Any</span><span class="s3">, </span><span class="s1">t.Callable[[]</span><span class="s3">, </span><span class="s1">t.Any]]]:</span>
        <span class="s1">...</span>

    <span class="s0">def </span><span class="s1">get_default(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">ctx: Context</span><span class="s3">, </span><span class="s1">call: bool = </span><span class="s0">True</span>
    <span class="s1">) -&gt; t.Optional[t.Union[t.Any</span><span class="s3">, </span><span class="s1">t.Callable[[]</span><span class="s3">, </span><span class="s1">t.Any]]]:</span>
        <span class="s6"># If we're a non boolean flag our default is more complex because</span>
        <span class="s6"># we need to look at all flags in the same group to figure out</span>
        <span class="s6"># if we're the default one in which case we return the flag</span>
        <span class="s6"># value as default.</span>
        <span class="s0">if </span><span class="s1">self.is_flag </span><span class="s0">and not </span><span class="s1">self.is_bool_flag:</span>
            <span class="s0">for </span><span class="s1">param </span><span class="s0">in </span><span class="s1">ctx.command.params:</span>
                <span class="s0">if </span><span class="s1">param.name == self.name </span><span class="s0">and </span><span class="s1">param.default:</span>
                    <span class="s0">return </span><span class="s1">t.cast(Option</span><span class="s3">, </span><span class="s1">param).flag_value</span>

            <span class="s0">return None</span>

        <span class="s0">return </span><span class="s1">super().get_default(ctx</span><span class="s3">, </span><span class="s1">call=call)</span>

    <span class="s0">def </span><span class="s1">prompt_for_value(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; t.Any:</span>
        <span class="s4">&quot;&quot;&quot;This is an alternative flow that can be activated in the full 
        value processing if a value does not exist.  It will prompt the 
        user until a valid value exists and then returns the processed 
        value as result. 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">self.prompt </span><span class="s0">is not None</span>

        <span class="s6"># Calculate the default before prompting anything to be stable.</span>
        <span class="s1">default = self.get_default(ctx)</span>

        <span class="s6"># If this is a prompt for a flag we need to handle this</span>
        <span class="s6"># differently.</span>
        <span class="s0">if </span><span class="s1">self.is_bool_flag:</span>
            <span class="s0">return </span><span class="s1">confirm(self.prompt</span><span class="s3">, </span><span class="s1">default)</span>

        <span class="s0">return </span><span class="s1">prompt(</span>
            <span class="s1">self.prompt</span><span class="s3">,</span>
            <span class="s1">default=default</span><span class="s3">,</span>
            <span class="s1">type=self.type</span><span class="s3">,</span>
            <span class="s1">hide_input=self.hide_input</span><span class="s3">,</span>
            <span class="s1">show_choices=self.show_choices</span><span class="s3">,</span>
            <span class="s1">confirmation_prompt=self.confirmation_prompt</span><span class="s3">,</span>
            <span class="s1">value_proc=</span><span class="s0">lambda </span><span class="s1">x: self.process_value(ctx</span><span class="s3">, </span><span class="s1">x)</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">resolve_envvar_value(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; t.Optional[str]:</span>
        <span class="s1">rv = super().resolve_envvar_value(ctx)</span>

        <span class="s0">if </span><span class="s1">rv </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">rv</span>

        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">self.allow_from_autoenv</span>
            <span class="s0">and </span><span class="s1">ctx.auto_envvar_prefix </span><span class="s0">is not None</span>
            <span class="s0">and </span><span class="s1">self.name </span><span class="s0">is not None</span>
        <span class="s1">):</span>
            <span class="s1">envvar = </span><span class="s2">f&quot;</span><span class="s5">{</span><span class="s1">ctx.auto_envvar_prefix</span><span class="s5">}</span><span class="s2">_</span><span class="s5">{</span><span class="s1">self.name.upper()</span><span class="s5">}</span><span class="s2">&quot;</span>
            <span class="s1">rv = os.environ.get(envvar)</span>

            <span class="s0">if </span><span class="s1">rv:</span>
                <span class="s0">return </span><span class="s1">rv</span>

        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">value_from_envvar(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; t.Optional[t.Any]:</span>
        <span class="s1">rv: t.Optional[t.Any] = self.resolve_envvar_value(ctx)</span>

        <span class="s0">if </span><span class="s1">rv </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return None</span>

        <span class="s1">value_depth = (self.nargs != </span><span class="s7">1</span><span class="s1">) + bool(self.multiple)</span>

        <span class="s0">if </span><span class="s1">value_depth &gt; </span><span class="s7">0</span><span class="s1">:</span>
            <span class="s1">rv = self.type.split_envvar_value(rv)</span>

            <span class="s0">if </span><span class="s1">self.multiple </span><span class="s0">and </span><span class="s1">self.nargs != </span><span class="s7">1</span><span class="s1">:</span>
                <span class="s1">rv = batch(rv</span><span class="s3">, </span><span class="s1">self.nargs)</span>

        <span class="s0">return </span><span class="s1">rv</span>

    <span class="s0">def </span><span class="s1">consume_value(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">ctx: Context</span><span class="s3">, </span><span class="s1">opts: t.Mapping[str</span><span class="s3">, </span><span class="s2">&quot;Parameter&quot;</span><span class="s1">]</span>
    <span class="s1">) -&gt; t.Tuple[t.Any</span><span class="s3">, </span><span class="s1">ParameterSource]:</span>
        <span class="s1">value</span><span class="s3">, </span><span class="s1">source = super().consume_value(ctx</span><span class="s3">, </span><span class="s1">opts)</span>

        <span class="s6"># The parser will emit a sentinel value if the option can be</span>
        <span class="s6"># given as a flag without a value. This is different from None</span>
        <span class="s6"># to distinguish from the flag not being given at all.</span>
        <span class="s0">if </span><span class="s1">value </span><span class="s0">is </span><span class="s1">_flag_needs_value:</span>
            <span class="s0">if </span><span class="s1">self.prompt </span><span class="s0">is not None and not </span><span class="s1">ctx.resilient_parsing:</span>
                <span class="s1">value = self.prompt_for_value(ctx)</span>
                <span class="s1">source = ParameterSource.PROMPT</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">value = self.flag_value</span>
                <span class="s1">source = ParameterSource.COMMANDLINE</span>

        <span class="s0">elif </span><span class="s1">(</span>
            <span class="s1">self.multiple</span>
            <span class="s0">and </span><span class="s1">value </span><span class="s0">is not None</span>
            <span class="s0">and </span><span class="s1">any(v </span><span class="s0">is </span><span class="s1">_flag_needs_value </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">value)</span>
        <span class="s1">):</span>
            <span class="s1">value = [self.flag_value </span><span class="s0">if </span><span class="s1">v </span><span class="s0">is </span><span class="s1">_flag_needs_value </span><span class="s0">else </span><span class="s1">v </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">value]</span>
            <span class="s1">source = ParameterSource.COMMANDLINE</span>

        <span class="s6"># The value wasn't set, or used the param's default, prompt if</span>
        <span class="s6"># prompting is enabled.</span>
        <span class="s0">elif </span><span class="s1">(</span>
            <span class="s1">source </span><span class="s0">in </span><span class="s1">{</span><span class="s0">None</span><span class="s3">, </span><span class="s1">ParameterSource.DEFAULT}</span>
            <span class="s0">and </span><span class="s1">self.prompt </span><span class="s0">is not None</span>
            <span class="s0">and </span><span class="s1">(self.required </span><span class="s0">or </span><span class="s1">self.prompt_required)</span>
            <span class="s0">and not </span><span class="s1">ctx.resilient_parsing</span>
        <span class="s1">):</span>
            <span class="s1">value = self.prompt_for_value(ctx)</span>
            <span class="s1">source = ParameterSource.PROMPT</span>

        <span class="s0">return </span><span class="s1">value</span><span class="s3">, </span><span class="s1">source</span>


<span class="s0">class </span><span class="s1">Argument(Parameter):</span>
    <span class="s4">&quot;&quot;&quot;Arguments are positional parameters to a command.  They generally 
    provide fewer features than options but can have infinite ``nargs`` 
    and are required by default. 
 
    All parameters are passed onwards to the constructor of :class:`Parameter`. 
    &quot;&quot;&quot;</span>

    <span class="s1">param_type_name = </span><span class="s2">&quot;argument&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">param_decls: t.Sequence[str]</span><span class="s3">,</span>
        <span class="s1">required: t.Optional[bool] = </span><span class="s0">None</span><span class="s3">,</span>
        <span class="s1">**attrs: t.Any</span><span class="s3">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">required </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">attrs.get(</span><span class="s2">&quot;default&quot;</span><span class="s1">) </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">required = </span><span class="s0">False</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">required = attrs.get(</span><span class="s2">&quot;nargs&quot;</span><span class="s3">, </span><span class="s7">1</span><span class="s1">) &gt; </span><span class="s7">0</span>

        <span class="s0">if </span><span class="s2">&quot;multiple&quot; </span><span class="s0">in </span><span class="s1">attrs:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;__init__() got an unexpected keyword argument 'multiple'.&quot;</span><span class="s1">)</span>

        <span class="s1">super().__init__(param_decls</span><span class="s3">, </span><span class="s1">required=required</span><span class="s3">, </span><span class="s1">**attrs)</span>

        <span class="s0">if __debug__</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.default </span><span class="s0">is not None and </span><span class="s1">self.nargs == -</span><span class="s7">1</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;'default' is not supported for nargs=-1.&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">human_readable_name(self) -&gt; str:</span>
        <span class="s0">if </span><span class="s1">self.metavar </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.metavar</span>
        <span class="s0">return </span><span class="s1">self.name.upper()  </span><span class="s6"># type: ignore</span>

    <span class="s0">def </span><span class="s1">make_metavar(self) -&gt; str:</span>
        <span class="s0">if </span><span class="s1">self.metavar </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.metavar</span>
        <span class="s1">var = self.type.get_metavar(self)</span>
        <span class="s0">if not </span><span class="s1">var:</span>
            <span class="s1">var = self.name.upper()  </span><span class="s6"># type: ignore</span>
        <span class="s0">if not </span><span class="s1">self.required:</span>
            <span class="s1">var = </span><span class="s2">f&quot;[</span><span class="s5">{</span><span class="s1">var</span><span class="s5">}</span><span class="s2">]&quot;</span>
        <span class="s0">if </span><span class="s1">self.nargs != </span><span class="s7">1</span><span class="s1">:</span>
            <span class="s1">var += </span><span class="s2">&quot;...&quot;</span>
        <span class="s0">return </span><span class="s1">var</span>

    <span class="s0">def </span><span class="s1">_parse_decls(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">decls: t.Sequence[str]</span><span class="s3">, </span><span class="s1">expose_value: bool</span>
    <span class="s1">) -&gt; t.Tuple[t.Optional[str]</span><span class="s3">, </span><span class="s1">t.List[str]</span><span class="s3">, </span><span class="s1">t.List[str]]:</span>
        <span class="s0">if not </span><span class="s1">decls:</span>
            <span class="s0">if not </span><span class="s1">expose_value:</span>
                <span class="s0">return None</span><span class="s3">, </span><span class="s1">[]</span><span class="s3">, </span><span class="s1">[]</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Could not determine name for argument&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">len(decls) == </span><span class="s7">1</span><span class="s1">:</span>
            <span class="s1">name = arg = decls[</span><span class="s7">0</span><span class="s1">]</span>
            <span class="s1">name = name.replace(</span><span class="s2">&quot;-&quot;</span><span class="s3">, </span><span class="s2">&quot;_&quot;</span><span class="s1">).lower()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s2">&quot;Arguments take exactly one parameter declaration, got&quot;</span>
                <span class="s2">f&quot; </span><span class="s5">{</span><span class="s1">len(decls)</span><span class="s5">}</span><span class="s2">.&quot;</span>
            <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">name</span><span class="s3">, </span><span class="s1">[arg]</span><span class="s3">, </span><span class="s1">[]</span>

    <span class="s0">def </span><span class="s1">get_usage_pieces(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; t.List[str]:</span>
        <span class="s0">return </span><span class="s1">[self.make_metavar()]</span>

    <span class="s0">def </span><span class="s1">get_error_hint(self</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; str:</span>
        <span class="s0">return </span><span class="s2">f&quot;'</span><span class="s5">{</span><span class="s1">self.make_metavar()</span><span class="s5">}</span><span class="s2">'&quot;</span>

    <span class="s0">def </span><span class="s1">add_to_parser(self</span><span class="s3">, </span><span class="s1">parser: OptionParser</span><span class="s3">, </span><span class="s1">ctx: Context) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">parser.add_argument(dest=self.name</span><span class="s3">, </span><span class="s1">nargs=self.nargs</span><span class="s3">, </span><span class="s1">obj=self)</span>
</pre>
</body>
</html>