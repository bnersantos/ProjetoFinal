<html>
<head>
<title>attributes.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5d69bb;}
.s1 { color: #d8d8d8;}
.s2 { color: #717ed3; font-style: italic;}
.s3 { color: #cc8b60;}
.s4 { color: #96bf7d;}
.s5 { color: #cc7832;}
.s6 { color: #d7539b; font-weight: bold;}
</style>
</head>
<body bgcolor="#1a1a25">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
attributes.py</font>
</center></td></tr></table>
<pre><span class="s0"># orm/attributes.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>
<span class="s0"># mypy: allow-untyped-defs, allow-untyped-calls</span>

<span class="s2">&quot;&quot;&quot;Defines instrumentation for class attributes and their interaction 
with instances. 
 
This module is usually not directly visible to user applications, but 
defines a large part of the ORM's interactivity. 
 
 
&quot;&quot;&quot;</span>

<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">annotations</span>

<span class="s3">import </span><span class="s1">dataclasses</span>
<span class="s3">import </span><span class="s1">operator</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Callable</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">cast</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">ClassVar</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Dict</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Iterable</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">List</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">NamedTuple</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Optional</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">overload</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Sequence</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Tuple</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Type</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TypeVar</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Union</span>

<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">collections</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">exc </span><span class="s3">as </span><span class="s1">orm_exc</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">interfaces</span>
<span class="s3">from </span><span class="s1">._typing </span><span class="s3">import </span><span class="s1">insp_is_aliased_class</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">_DeclarativeMapped</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">ATTR_EMPTY</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">ATTR_WAS_SET</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">CALLABLES_OK</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">DEFERRED_HISTORY_LOAD</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">INCLUDE_PENDING_MUTATIONS  </span><span class="s0"># noqa</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">INIT_OK</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">instance_dict </span><span class="s3">as </span><span class="s1">instance_dict</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">instance_state </span><span class="s3">as </span><span class="s1">instance_state</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">instance_str</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">LOAD_AGAINST_COMMITTED</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">LoaderCallableStatus</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">manager_of_class </span><span class="s3">as </span><span class="s1">manager_of_class</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">Mapped </span><span class="s3">as </span><span class="s1">Mapped  </span><span class="s0"># noqa</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">NEVER_SET  </span><span class="s0"># noqa</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">NO_AUTOFLUSH</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">NO_CHANGE  </span><span class="s0"># noqa</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">NO_KEY</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">NO_RAISE</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">NO_VALUE</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">NON_PERSISTENT_OK  </span><span class="s0"># noqa</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">opt_manager_of_class </span><span class="s3">as </span><span class="s1">opt_manager_of_class</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">PASSIVE_CLASS_MISMATCH  </span><span class="s0"># noqa</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">PASSIVE_NO_FETCH</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">PASSIVE_NO_FETCH_RELATED  </span><span class="s0"># noqa</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">PASSIVE_NO_INITIALIZE</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">PASSIVE_NO_RESULT</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">PASSIVE_OFF</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">PASSIVE_ONLY_PERSISTENT</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">PASSIVE_RETURN_NO_VALUE</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">PassiveFlag</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">RELATED_OBJECT_OK  </span><span class="s0"># noqa</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">SQL_OK  </span><span class="s0"># noqa</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">SQLORMExpression</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">state_str</span>
<span class="s3">from </span><span class="s1">.. </span><span class="s3">import </span><span class="s1">event</span>
<span class="s3">from </span><span class="s1">.. </span><span class="s3">import </span><span class="s1">exc</span>
<span class="s3">from </span><span class="s1">.. </span><span class="s3">import </span><span class="s1">inspection</span>
<span class="s3">from </span><span class="s1">.. </span><span class="s3">import </span><span class="s1">util</span>
<span class="s3">from </span><span class="s1">..event </span><span class="s3">import </span><span class="s1">dispatcher</span>
<span class="s3">from </span><span class="s1">..event </span><span class="s3">import </span><span class="s1">EventTarget</span>
<span class="s3">from </span><span class="s1">..sql </span><span class="s3">import </span><span class="s1">base </span><span class="s3">as </span><span class="s1">sql_base</span>
<span class="s3">from </span><span class="s1">..sql </span><span class="s3">import </span><span class="s1">cache_key</span>
<span class="s3">from </span><span class="s1">..sql </span><span class="s3">import </span><span class="s1">coercions</span>
<span class="s3">from </span><span class="s1">..sql </span><span class="s3">import </span><span class="s1">roles</span>
<span class="s3">from </span><span class="s1">..sql </span><span class="s3">import </span><span class="s1">visitors</span>
<span class="s3">from </span><span class="s1">..sql.cache_key </span><span class="s3">import </span><span class="s1">HasCacheKey</span>
<span class="s3">from </span><span class="s1">..sql.visitors </span><span class="s3">import </span><span class="s1">_TraverseInternalsType</span>
<span class="s3">from </span><span class="s1">..sql.visitors </span><span class="s3">import </span><span class="s1">InternalTraversal</span>
<span class="s3">from </span><span class="s1">..util.typing </span><span class="s3">import </span><span class="s1">Literal</span>
<span class="s3">from </span><span class="s1">..util.typing </span><span class="s3">import </span><span class="s1">Self</span>
<span class="s3">from </span><span class="s1">..util.typing </span><span class="s3">import </span><span class="s1">TypeGuard</span>

<span class="s3">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s3">from </span><span class="s1">._typing </span><span class="s3">import </span><span class="s1">_EntityType</span>
    <span class="s3">from </span><span class="s1">._typing </span><span class="s3">import </span><span class="s1">_ExternalEntityType</span>
    <span class="s3">from </span><span class="s1">._typing </span><span class="s3">import </span><span class="s1">_InstanceDict</span>
    <span class="s3">from </span><span class="s1">._typing </span><span class="s3">import </span><span class="s1">_InternalEntityType</span>
    <span class="s3">from </span><span class="s1">._typing </span><span class="s3">import </span><span class="s1">_LoaderCallable</span>
    <span class="s3">from </span><span class="s1">._typing </span><span class="s3">import </span><span class="s1">_O</span>
    <span class="s3">from </span><span class="s1">.collections </span><span class="s3">import </span><span class="s1">_AdaptedCollectionProtocol</span>
    <span class="s3">from </span><span class="s1">.collections </span><span class="s3">import </span><span class="s1">CollectionAdapter</span>
    <span class="s3">from </span><span class="s1">.interfaces </span><span class="s3">import </span><span class="s1">MapperProperty</span>
    <span class="s3">from </span><span class="s1">.relationships </span><span class="s3">import </span><span class="s1">RelationshipProperty</span>
    <span class="s3">from </span><span class="s1">.state </span><span class="s3">import </span><span class="s1">InstanceState</span>
    <span class="s3">from </span><span class="s1">.util </span><span class="s3">import </span><span class="s1">AliasedInsp</span>
    <span class="s3">from </span><span class="s1">.writeonly </span><span class="s3">import </span><span class="s1">WriteOnlyAttributeImpl</span>
    <span class="s3">from </span><span class="s1">..event.base </span><span class="s3">import </span><span class="s1">_Dispatch</span>
    <span class="s3">from </span><span class="s1">..sql._typing </span><span class="s3">import </span><span class="s1">_ColumnExpressionArgument</span>
    <span class="s3">from </span><span class="s1">..sql._typing </span><span class="s3">import </span><span class="s1">_DMLColumnArgument</span>
    <span class="s3">from </span><span class="s1">..sql._typing </span><span class="s3">import </span><span class="s1">_InfoType</span>
    <span class="s3">from </span><span class="s1">..sql._typing </span><span class="s3">import </span><span class="s1">_PropagateAttrsType</span>
    <span class="s3">from </span><span class="s1">..sql.annotation </span><span class="s3">import </span><span class="s1">_AnnotationDict</span>
    <span class="s3">from </span><span class="s1">..sql.elements </span><span class="s3">import </span><span class="s1">ColumnElement</span>
    <span class="s3">from </span><span class="s1">..sql.elements </span><span class="s3">import </span><span class="s1">Label</span>
    <span class="s3">from </span><span class="s1">..sql.operators </span><span class="s3">import </span><span class="s1">OperatorType</span>
    <span class="s3">from </span><span class="s1">..sql.selectable </span><span class="s3">import </span><span class="s1">FromClause</span>


<span class="s1">_T = TypeVar(</span><span class="s4">&quot;_T&quot;</span><span class="s1">)</span>
<span class="s1">_T_co = TypeVar(</span><span class="s4">&quot;_T_co&quot;</span><span class="s5">, </span><span class="s1">bound=Any</span><span class="s5">, </span><span class="s1">covariant=</span><span class="s3">True</span><span class="s1">)</span>


<span class="s1">_AllPendingType = Sequence[</span>
    <span class="s1">Tuple[Optional[</span><span class="s4">&quot;InstanceState[Any]&quot;</span><span class="s1">]</span><span class="s5">, </span><span class="s1">Optional[object]]</span>
<span class="s1">]</span>


<span class="s1">_UNKNOWN_ATTR_KEY = object()</span>


<span class="s1">@inspection._self_inspects</span>
<span class="s3">class </span><span class="s1">QueryableAttribute(</span>
    <span class="s1">_DeclarativeMapped[_T_co]</span><span class="s5">,</span>
    <span class="s1">SQLORMExpression[_T_co]</span><span class="s5">,</span>
    <span class="s1">interfaces.InspectionAttr</span><span class="s5">,</span>
    <span class="s1">interfaces.PropComparator[_T_co]</span><span class="s5">,</span>
    <span class="s1">roles.JoinTargetRole</span><span class="s5">,</span>
    <span class="s1">roles.OnClauseRole</span><span class="s5">,</span>
    <span class="s1">sql_base.Immutable</span><span class="s5">,</span>
    <span class="s1">cache_key.SlotsMemoizedHasCacheKey</span><span class="s5">,</span>
    <span class="s1">util.MemoizedSlots</span><span class="s5">,</span>
    <span class="s1">EventTarget</span><span class="s5">,</span>
<span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Base class for :term:`descriptor` objects that intercept 
    attribute events on behalf of a :class:`.MapperProperty` 
    object.  The actual :class:`.MapperProperty` is accessible 
    via the :attr:`.QueryableAttribute.property` 
    attribute. 
 
 
    .. seealso:: 
 
        :class:`.InstrumentedAttribute` 
 
        :class:`.MapperProperty` 
 
        :attr:`_orm.Mapper.all_orm_descriptors` 
 
        :attr:`_orm.Mapper.attrs` 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = (</span>
        <span class="s4">&quot;class_&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;key&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;impl&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;comparator&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;property&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;parent&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;expression&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;_of_type&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;_extra_criteria&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;_slots_dispatch&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;_propagate_attrs&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;_doc&quot;</span><span class="s5">,</span>
    <span class="s1">)</span>

    <span class="s1">is_attribute = </span><span class="s3">True</span>

    <span class="s1">dispatch: dispatcher[QueryableAttribute[_T_co]]</span>

    <span class="s1">class_: _ExternalEntityType[Any]</span>
    <span class="s1">key: str</span>
    <span class="s1">parententity: _InternalEntityType[Any]</span>
    <span class="s1">impl: AttributeImpl</span>
    <span class="s1">comparator: interfaces.PropComparator[_T_co]</span>
    <span class="s1">_of_type: Optional[_InternalEntityType[Any]]</span>
    <span class="s1">_extra_criteria: Tuple[ColumnElement[bool]</span><span class="s5">, </span><span class="s1">...]</span>
    <span class="s1">_doc: Optional[str]</span>

    <span class="s0"># PropComparator has a __visit_name__ to participate within</span>
    <span class="s0"># traversals.   Disambiguate the attribute vs. a comparator.</span>
    <span class="s1">__visit_name__ = </span><span class="s4">&quot;orm_instrumented_attribute&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">class_: _ExternalEntityType[_O]</span><span class="s5">,</span>
        <span class="s1">key: str</span><span class="s5">,</span>
        <span class="s1">parententity: _InternalEntityType[_O]</span><span class="s5">,</span>
        <span class="s1">comparator: interfaces.PropComparator[_T_co]</span><span class="s5">,</span>
        <span class="s1">impl: Optional[AttributeImpl] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">of_type: Optional[_InternalEntityType[Any]] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">extra_criteria: Tuple[ColumnElement[bool]</span><span class="s5">, </span><span class="s1">...] = ()</span><span class="s5">,</span>
    <span class="s1">):</span>
        <span class="s1">self.class_ = class_</span>
        <span class="s1">self.key = key</span>

        <span class="s1">self._parententity = self.parent = parententity</span>

        <span class="s0"># this attribute is non-None after mappers are set up, however in the</span>
        <span class="s0"># interim class manager setup, there's a check for None to see if it</span>
        <span class="s0"># needs to be populated, so we assign None here leaving the attribute</span>
        <span class="s0"># in a temporarily not-type-correct state</span>
        <span class="s1">self.impl = impl  </span><span class="s0"># type: ignore</span>

        <span class="s3">assert </span><span class="s1">comparator </span><span class="s3">is not None</span>
        <span class="s1">self.comparator = comparator</span>
        <span class="s1">self._of_type = of_type</span>
        <span class="s1">self._extra_criteria = extra_criteria</span>
        <span class="s1">self._doc = </span><span class="s3">None</span>

        <span class="s1">manager = opt_manager_of_class(class_)</span>
        <span class="s0"># manager is None in the case of AliasedClass</span>
        <span class="s3">if </span><span class="s1">manager:</span>
            <span class="s0"># propagate existing event listeners from</span>
            <span class="s0"># immediate superclass</span>
            <span class="s3">for </span><span class="s1">base </span><span class="s3">in </span><span class="s1">manager._bases:</span>
                <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">base:</span>
                    <span class="s1">self.dispatch._update(base[key].dispatch)</span>
                    <span class="s3">if </span><span class="s1">base[key].dispatch._active_history:</span>
                        <span class="s1">self.dispatch._active_history = </span><span class="s3">True  </span><span class="s0"># type: ignore</span>

    <span class="s1">_cache_key_traversal = [</span>
        <span class="s1">(</span><span class="s4">&quot;key&quot;</span><span class="s5">, </span><span class="s1">visitors.ExtendedInternalTraversal.dp_string)</span><span class="s5">,</span>
        <span class="s1">(</span><span class="s4">&quot;_parententity&quot;</span><span class="s5">, </span><span class="s1">visitors.ExtendedInternalTraversal.dp_multi)</span><span class="s5">,</span>
        <span class="s1">(</span><span class="s4">&quot;_of_type&quot;</span><span class="s5">, </span><span class="s1">visitors.ExtendedInternalTraversal.dp_multi)</span><span class="s5">,</span>
        <span class="s1">(</span><span class="s4">&quot;_extra_criteria&quot;</span><span class="s5">, </span><span class="s1">visitors.InternalTraversal.dp_clauseelement_list)</span><span class="s5">,</span>
    <span class="s1">]</span>

    <span class="s3">def </span><span class="s1">__reduce__(self) -&gt; Any:</span>
        <span class="s0"># this method is only used in terms of the</span>
        <span class="s0"># sqlalchemy.ext.serializer extension</span>
        <span class="s3">return </span><span class="s1">(</span>
            <span class="s1">_queryable_attribute_unreduce</span><span class="s5">,</span>
            <span class="s1">(</span>
                <span class="s1">self.key</span><span class="s5">,</span>
                <span class="s1">self._parententity.mapper.class_</span><span class="s5">,</span>
                <span class="s1">self._parententity</span><span class="s5">,</span>
                <span class="s1">self._parententity.entity</span><span class="s5">,</span>
            <span class="s1">)</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">_impl_uses_objects(self) -&gt; bool:</span>
        <span class="s3">return </span><span class="s1">self.impl.uses_objects</span>

    <span class="s3">def </span><span class="s1">get_history(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">instance: Any</span><span class="s5">, </span><span class="s1">passive: PassiveFlag = PASSIVE_OFF</span>
    <span class="s1">) -&gt; History:</span>
        <span class="s3">return </span><span class="s1">self.impl.get_history(</span>
            <span class="s1">instance_state(instance)</span><span class="s5">, </span><span class="s1">instance_dict(instance)</span><span class="s5">, </span><span class="s1">passive</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">info(self) -&gt; _InfoType:</span>
        <span class="s2">&quot;&quot;&quot;Return the 'info' dictionary for the underlying SQL element. 
 
        The behavior here is as follows: 
 
        * If the attribute is a column-mapped property, i.e. 
          :class:`.ColumnProperty`, which is mapped directly 
          to a schema-level :class:`_schema.Column` object, this attribute 
          will return the :attr:`.SchemaItem.info` dictionary associated 
          with the core-level :class:`_schema.Column` object. 
 
        * If the attribute is a :class:`.ColumnProperty` but is mapped to 
          any other kind of SQL expression other than a 
          :class:`_schema.Column`, 
          the attribute will refer to the :attr:`.MapperProperty.info` 
          dictionary associated directly with the :class:`.ColumnProperty`, 
          assuming the SQL expression itself does not have its own ``.info`` 
          attribute (which should be the case, unless a user-defined SQL 
          construct has defined one). 
 
        * If the attribute refers to any other kind of 
          :class:`.MapperProperty`, including :class:`.Relationship`, 
          the attribute will refer to the :attr:`.MapperProperty.info` 
          dictionary associated with that :class:`.MapperProperty`. 
 
        * To access the :attr:`.MapperProperty.info` dictionary of the 
          :class:`.MapperProperty` unconditionally, including for a 
          :class:`.ColumnProperty` that's associated directly with a 
          :class:`_schema.Column`, the attribute can be referred to using 
          :attr:`.QueryableAttribute.property` attribute, as 
          ``MyClass.someattribute.property.info``. 
 
        .. seealso:: 
 
            :attr:`.SchemaItem.info` 
 
            :attr:`.MapperProperty.info` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.comparator.info</span>

    <span class="s1">parent: _InternalEntityType[Any]</span>
    <span class="s4">&quot;&quot;&quot;Return an inspection instance representing the parent. 
 
    This will be either an instance of :class:`_orm.Mapper` 
    or :class:`.AliasedInsp`, depending upon the nature 
    of the parent entity which this attribute is associated 
    with. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">expression: ColumnElement[_T_co]</span>
    <span class="s4">&quot;&quot;&quot;The SQL expression object represented by this 
    :class:`.QueryableAttribute`. 
 
    This will typically be an instance of a :class:`_sql.ColumnElement` 
    subclass representing a column expression. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">_memoized_attr_expression(self) -&gt; ColumnElement[_T]:</span>
        <span class="s1">annotations: _AnnotationDict</span>

        <span class="s0"># applies only to Proxy() as used by hybrid.</span>
        <span class="s0"># currently is an exception to typing rather than feeding through</span>
        <span class="s0"># non-string keys.</span>
        <span class="s0"># ideally Proxy() would have a separate set of methods to deal</span>
        <span class="s0"># with this case.</span>
        <span class="s1">entity_namespace = self._entity_namespace</span>
        <span class="s3">assert </span><span class="s1">isinstance(entity_namespace</span><span class="s5">, </span><span class="s1">HasCacheKey)</span>

        <span class="s3">if </span><span class="s1">self.key </span><span class="s3">is </span><span class="s1">_UNKNOWN_ATTR_KEY:</span>
            <span class="s1">annotations = {</span><span class="s4">&quot;entity_namespace&quot;</span><span class="s1">: entity_namespace}</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">annotations = {</span>
                <span class="s4">&quot;proxy_key&quot;</span><span class="s1">: self.key</span><span class="s5">,</span>
                <span class="s4">&quot;proxy_owner&quot;</span><span class="s1">: self._parententity</span><span class="s5">,</span>
                <span class="s4">&quot;entity_namespace&quot;</span><span class="s1">: entity_namespace</span><span class="s5">,</span>
            <span class="s1">}</span>

        <span class="s1">ce = self.comparator.__clause_element__()</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">TYPE_CHECKING:</span>
                <span class="s3">assert </span><span class="s1">isinstance(ce</span><span class="s5">, </span><span class="s1">ColumnElement)</span>
            <span class="s1">anno = ce._annotate</span>
        <span class="s3">except </span><span class="s1">AttributeError </span><span class="s3">as </span><span class="s1">ae:</span>
            <span class="s3">raise </span><span class="s1">exc.InvalidRequestError(</span>
                <span class="s4">'When interpreting attribute &quot;%s&quot; as a SQL expression, '</span>
                <span class="s4">&quot;expected __clause_element__() to return &quot;</span>
                <span class="s4">&quot;a ClauseElement object, got: %r&quot; </span><span class="s1">% (self</span><span class="s5">, </span><span class="s1">ce)</span>
            <span class="s1">) </span><span class="s3">from </span><span class="s1">ae</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">anno(annotations)</span>

    <span class="s3">def </span><span class="s1">_memoized_attr__propagate_attrs(self) -&gt; _PropagateAttrsType:</span>
        <span class="s0"># this suits the case in coercions where we don't actually</span>
        <span class="s0"># call ``__clause_element__()`` but still need to get</span>
        <span class="s0"># resolved._propagate_attrs.  See #6558.</span>
        <span class="s3">return </span><span class="s1">util.immutabledict(</span>
            <span class="s1">{</span>
                <span class="s4">&quot;compile_state_plugin&quot;</span><span class="s1">: </span><span class="s4">&quot;orm&quot;</span><span class="s5">,</span>
                <span class="s4">&quot;plugin_subject&quot;</span><span class="s1">: self._parentmapper</span><span class="s5">,</span>
            <span class="s1">}</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">_entity_namespace(self) -&gt; _InternalEntityType[Any]:</span>
        <span class="s3">return </span><span class="s1">self._parententity</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">_annotations(self) -&gt; _AnnotationDict:</span>
        <span class="s3">return </span><span class="s1">self.__clause_element__()._annotations</span>

    <span class="s3">def </span><span class="s1">__clause_element__(self) -&gt; ColumnElement[_T_co]:</span>
        <span class="s3">return </span><span class="s1">self.expression</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">_from_objects(self) -&gt; List[FromClause]:</span>
        <span class="s3">return </span><span class="s1">self.expression._from_objects</span>

    <span class="s3">def </span><span class="s1">_bulk_update_tuples(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">value: Any</span>
    <span class="s1">) -&gt; Sequence[Tuple[_DMLColumnArgument</span><span class="s5">, </span><span class="s1">Any]]:</span>
        <span class="s2">&quot;&quot;&quot;Return setter tuples for a bulk UPDATE.&quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">self.comparator._bulk_update_tuples(value)</span>

    <span class="s3">def </span><span class="s1">adapt_to_entity(self</span><span class="s5">, </span><span class="s1">adapt_to_entity: AliasedInsp[Any]) -&gt; Self:</span>
        <span class="s3">assert not </span><span class="s1">self._of_type</span>
        <span class="s3">return </span><span class="s1">self.__class__(</span>
            <span class="s1">adapt_to_entity.entity</span><span class="s5">,</span>
            <span class="s1">self.key</span><span class="s5">,</span>
            <span class="s1">impl=self.impl</span><span class="s5">,</span>
            <span class="s1">comparator=self.comparator.adapt_to_entity(adapt_to_entity)</span><span class="s5">,</span>
            <span class="s1">parententity=adapt_to_entity</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">of_type(self</span><span class="s5">, </span><span class="s1">entity: _EntityType[_T]) -&gt; QueryableAttribute[_T]:</span>
        <span class="s3">return </span><span class="s1">QueryableAttribute(</span>
            <span class="s1">self.class_</span><span class="s5">,</span>
            <span class="s1">self.key</span><span class="s5">,</span>
            <span class="s1">self._parententity</span><span class="s5">,</span>
            <span class="s1">impl=self.impl</span><span class="s5">,</span>
            <span class="s1">comparator=self.comparator.of_type(entity)</span><span class="s5">,</span>
            <span class="s1">of_type=inspection.inspect(entity)</span><span class="s5">,</span>
            <span class="s1">extra_criteria=self._extra_criteria</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">and_(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">*clauses: _ColumnExpressionArgument[bool]</span>
    <span class="s1">) -&gt; QueryableAttribute[bool]:</span>
        <span class="s3">if </span><span class="s1">TYPE_CHECKING:</span>
            <span class="s3">assert </span><span class="s1">isinstance(self.comparator</span><span class="s5">, </span><span class="s1">RelationshipProperty.Comparator)</span>

        <span class="s1">exprs = tuple(</span>
            <span class="s1">coercions.expect(roles.WhereHavingRole</span><span class="s5">, </span><span class="s1">clause)</span>
            <span class="s3">for </span><span class="s1">clause </span><span class="s3">in </span><span class="s1">util.coerce_generator_arg(clauses)</span>
        <span class="s1">)</span>

        <span class="s3">return </span><span class="s1">QueryableAttribute(</span>
            <span class="s1">self.class_</span><span class="s5">,</span>
            <span class="s1">self.key</span><span class="s5">,</span>
            <span class="s1">self._parententity</span><span class="s5">,</span>
            <span class="s1">impl=self.impl</span><span class="s5">,</span>
            <span class="s1">comparator=self.comparator.and_(*exprs)</span><span class="s5">,</span>
            <span class="s1">of_type=self._of_type</span><span class="s5">,</span>
            <span class="s1">extra_criteria=self._extra_criteria + exprs</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_clone(self</span><span class="s5">, </span><span class="s1">**kw: Any) -&gt; QueryableAttribute[_T]:</span>
        <span class="s3">return </span><span class="s1">QueryableAttribute(</span>
            <span class="s1">self.class_</span><span class="s5">,</span>
            <span class="s1">self.key</span><span class="s5">,</span>
            <span class="s1">self._parententity</span><span class="s5">,</span>
            <span class="s1">impl=self.impl</span><span class="s5">,</span>
            <span class="s1">comparator=self.comparator</span><span class="s5">,</span>
            <span class="s1">of_type=self._of_type</span><span class="s5">,</span>
            <span class="s1">extra_criteria=self._extra_criteria</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">label(self</span><span class="s5">, </span><span class="s1">name: Optional[str]) -&gt; Label[_T_co]:</span>
        <span class="s3">return </span><span class="s1">self.__clause_element__().label(name)</span>

    <span class="s3">def </span><span class="s1">operate(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">op: OperatorType</span><span class="s5">, </span><span class="s1">*other: Any</span><span class="s5">, </span><span class="s1">**kwargs: Any</span>
    <span class="s1">) -&gt; ColumnElement[Any]:</span>
        <span class="s3">return </span><span class="s1">op(self.comparator</span><span class="s5">, </span><span class="s1">*other</span><span class="s5">, </span><span class="s1">**kwargs)  </span><span class="s0"># type: ignore[no-any-return]  # noqa: E501</span>

    <span class="s3">def </span><span class="s1">reverse_operate(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">op: OperatorType</span><span class="s5">, </span><span class="s1">other: Any</span><span class="s5">, </span><span class="s1">**kwargs: Any</span>
    <span class="s1">) -&gt; ColumnElement[Any]:</span>
        <span class="s3">return </span><span class="s1">op(other</span><span class="s5">, </span><span class="s1">self.comparator</span><span class="s5">, </span><span class="s1">**kwargs)  </span><span class="s0"># type: ignore[no-any-return]  # noqa: E501</span>

    <span class="s3">def </span><span class="s1">hasparent(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">state: InstanceState[Any]</span><span class="s5">, </span><span class="s1">optimistic: bool = </span><span class="s3">False</span>
    <span class="s1">) -&gt; bool:</span>
        <span class="s3">return </span><span class="s1">self.impl.hasparent(state</span><span class="s5">, </span><span class="s1">optimistic=optimistic) </span><span class="s3">is not False</span>

    <span class="s3">def </span><span class="s1">__getattr__(self</span><span class="s5">, </span><span class="s1">key: str) -&gt; Any:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">util.MemoizedSlots.__getattr__(self</span><span class="s5">, </span><span class="s1">key)</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s3">pass</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">getattr(self.comparator</span><span class="s5">, </span><span class="s1">key)</span>
        <span class="s3">except </span><span class="s1">AttributeError </span><span class="s3">as </span><span class="s1">err:</span>
            <span class="s3">raise </span><span class="s1">AttributeError(</span>
                <span class="s4">&quot;Neither %r object nor %r object associated with %s &quot;</span>
                <span class="s4">&quot;has an attribute %r&quot;</span>
                <span class="s1">% (</span>
                    <span class="s1">type(self).__name__</span><span class="s5">,</span>
                    <span class="s1">type(self.comparator).__name__</span><span class="s5">,</span>
                    <span class="s1">self</span><span class="s5">,</span>
                    <span class="s1">key</span><span class="s5">,</span>
                <span class="s1">)</span>
            <span class="s1">) </span><span class="s3">from </span><span class="s1">err</span>

    <span class="s3">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s3">return </span><span class="s4">f&quot;</span><span class="s6">{</span><span class="s1">self.class_.__name__</span><span class="s6">}</span><span class="s4">.</span><span class="s6">{</span><span class="s1">self.key</span><span class="s6">}</span><span class="s4">&quot;</span>

    <span class="s3">def </span><span class="s1">_memoized_attr_property(self) -&gt; Optional[MapperProperty[Any]]:</span>
        <span class="s3">return </span><span class="s1">self.comparator.property</span>


<span class="s3">def </span><span class="s1">_queryable_attribute_unreduce(</span>
    <span class="s1">key: str</span><span class="s5">,</span>
    <span class="s1">mapped_class: Type[_O]</span><span class="s5">,</span>
    <span class="s1">parententity: _InternalEntityType[_O]</span><span class="s5">,</span>
    <span class="s1">entity: _ExternalEntityType[Any]</span><span class="s5">,</span>
<span class="s1">) -&gt; Any:</span>
    <span class="s0"># this method is only used in terms of the</span>
    <span class="s0"># sqlalchemy.ext.serializer extension</span>
    <span class="s3">if </span><span class="s1">insp_is_aliased_class(parententity):</span>
        <span class="s3">return </span><span class="s1">entity._get_from_serialized(key</span><span class="s5">, </span><span class="s1">mapped_class</span><span class="s5">, </span><span class="s1">parententity)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">getattr(entity</span><span class="s5">, </span><span class="s1">key)</span>


<span class="s3">class </span><span class="s1">InstrumentedAttribute(QueryableAttribute[_T_co]):</span>
    <span class="s2">&quot;&quot;&quot;Class bound instrumented attribute which adds basic 
    :term:`descriptor` methods. 
 
    See :class:`.QueryableAttribute` for a description of most features. 
 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = ()</span>

    <span class="s1">inherit_cache = </span><span class="s3">True</span>
    <span class="s4">&quot;&quot;&quot;:meta private:&quot;&quot;&quot;</span>

    <span class="s0"># hack to make __doc__ writeable on instances of</span>
    <span class="s0"># InstrumentedAttribute, while still keeping classlevel</span>
    <span class="s0"># __doc__ correct</span>

    <span class="s1">@util.rw_hybridproperty</span>
    <span class="s3">def </span><span class="s1">__doc__(self) -&gt; Optional[str]:</span>
        <span class="s3">return </span><span class="s1">self._doc</span>

    <span class="s1">@__doc__.setter  </span><span class="s0"># type: ignore</span>
    <span class="s3">def </span><span class="s1">__doc__(self</span><span class="s5">, </span><span class="s1">value: Optional[str]) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">self._doc = value</span>

    <span class="s1">@__doc__.classlevel  </span><span class="s0"># type: ignore</span>
    <span class="s3">def </span><span class="s1">__doc__(cls) -&gt; Optional[str]:</span>
        <span class="s3">return </span><span class="s1">super().__doc__</span>

    <span class="s3">def </span><span class="s1">__set__(self</span><span class="s5">, </span><span class="s1">instance: object</span><span class="s5">, </span><span class="s1">value: Any) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">self.impl.set(</span>
            <span class="s1">instance_state(instance)</span><span class="s5">, </span><span class="s1">instance_dict(instance)</span><span class="s5">, </span><span class="s1">value</span><span class="s5">, </span><span class="s3">None</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__delete__(self</span><span class="s5">, </span><span class="s1">instance: object) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">self.impl.delete(instance_state(instance)</span><span class="s5">, </span><span class="s1">instance_dict(instance))</span>

    <span class="s1">@overload</span>
    <span class="s3">def </span><span class="s1">__get__(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">instance: </span><span class="s3">None</span><span class="s5">, </span><span class="s1">owner: Any</span>
    <span class="s1">) -&gt; InstrumentedAttribute[_T_co]: ...</span>

    <span class="s1">@overload</span>
    <span class="s3">def </span><span class="s1">__get__(self</span><span class="s5">, </span><span class="s1">instance: object</span><span class="s5">, </span><span class="s1">owner: Any) -&gt; _T_co: ...</span>

    <span class="s3">def </span><span class="s1">__get__(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">instance: Optional[object]</span><span class="s5">, </span><span class="s1">owner: Any</span>
    <span class="s1">) -&gt; Union[InstrumentedAttribute[_T_co]</span><span class="s5">, </span><span class="s1">_T_co]:</span>
        <span class="s3">if </span><span class="s1">instance </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self</span>

        <span class="s1">dict_ = instance_dict(instance)</span>
        <span class="s3">if </span><span class="s1">self.impl.supports_population </span><span class="s3">and </span><span class="s1">self.key </span><span class="s3">in </span><span class="s1">dict_:</span>
            <span class="s3">return </span><span class="s1">dict_[self.key]  </span><span class="s0"># type: ignore[no-any-return]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">state = instance_state(instance)</span>
            <span class="s3">except </span><span class="s1">AttributeError </span><span class="s3">as </span><span class="s1">err:</span>
                <span class="s3">raise </span><span class="s1">orm_exc.UnmappedInstanceError(instance) </span><span class="s3">from </span><span class="s1">err</span>
            <span class="s3">return </span><span class="s1">self.impl.get(state</span><span class="s5">, </span><span class="s1">dict_)  </span><span class="s0"># type: ignore[no-any-return]</span>


<span class="s1">@dataclasses.dataclass(frozen=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">class </span><span class="s1">AdHocHasEntityNamespace(HasCacheKey):</span>
    <span class="s1">_traverse_internals: ClassVar[_TraverseInternalsType] = [</span>
        <span class="s1">(</span><span class="s4">&quot;_entity_namespace&quot;</span><span class="s5">, </span><span class="s1">InternalTraversal.dp_has_cache_key)</span><span class="s5">,</span>
    <span class="s1">]</span>

    <span class="s0"># py37 compat, no slots=True on dataclass</span>
    <span class="s1">__slots__ = (</span><span class="s4">&quot;_entity_namespace&quot;</span><span class="s5">,</span><span class="s1">)</span>
    <span class="s1">_entity_namespace: _InternalEntityType[Any]</span>
    <span class="s1">is_mapper: ClassVar[bool] = </span><span class="s3">False</span>
    <span class="s1">is_aliased_class: ClassVar[bool] = </span><span class="s3">False</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">entity_namespace(self):</span>
        <span class="s3">return </span><span class="s1">self._entity_namespace.entity_namespace</span>


<span class="s3">def </span><span class="s1">create_proxied_attribute(</span>
    <span class="s1">descriptor: Any</span><span class="s5">,</span>
<span class="s1">) -&gt; Callable[...</span><span class="s5">, </span><span class="s1">QueryableAttribute[Any]]:</span>
    <span class="s2">&quot;&quot;&quot;Create an QueryableAttribute / user descriptor hybrid. 
 
    Returns a new QueryableAttribute type that delegates descriptor 
    behavior and getattr() to the given descriptor. 
    &quot;&quot;&quot;</span>

    <span class="s0"># TODO: can move this to descriptor_props if the need for this</span>
    <span class="s0"># function is removed from ext/hybrid.py</span>

    <span class="s3">class </span><span class="s1">Proxy(QueryableAttribute[Any]):</span>
        <span class="s2">&quot;&quot;&quot;Presents the :class:`.QueryableAttribute` interface as a 
        proxy on top of a Python descriptor / :class:`.PropComparator` 
        combination. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">_extra_criteria = ()</span>

        <span class="s0"># the attribute error catches inside of __getattr__ basically create a</span>
        <span class="s0"># singularity if you try putting slots on this too</span>
        <span class="s0"># __slots__ = (&quot;descriptor&quot;, &quot;original_property&quot;, &quot;_comparator&quot;)</span>

        <span class="s3">def </span><span class="s1">__init__(</span>
            <span class="s1">self</span><span class="s5">,</span>
            <span class="s1">class_</span><span class="s5">,</span>
            <span class="s1">key</span><span class="s5">,</span>
            <span class="s1">descriptor</span><span class="s5">,</span>
            <span class="s1">comparator</span><span class="s5">,</span>
            <span class="s1">adapt_to_entity=</span><span class="s3">None</span><span class="s5">,</span>
            <span class="s1">doc=</span><span class="s3">None</span><span class="s5">,</span>
            <span class="s1">original_property=</span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">):</span>
            <span class="s1">self.class_ = class_</span>
            <span class="s1">self.key = key</span>
            <span class="s1">self.descriptor = descriptor</span>
            <span class="s1">self.original_property = original_property</span>
            <span class="s1">self._comparator = comparator</span>
            <span class="s1">self._adapt_to_entity = adapt_to_entity</span>
            <span class="s1">self._doc = self.__doc__ = doc</span>

        <span class="s1">@property</span>
        <span class="s3">def </span><span class="s1">_parententity(self):</span>
            <span class="s3">return </span><span class="s1">inspection.inspect(self.class_</span><span class="s5">, </span><span class="s1">raiseerr=</span><span class="s3">False</span><span class="s1">)</span>

        <span class="s1">@property</span>
        <span class="s3">def </span><span class="s1">parent(self):</span>
            <span class="s3">return </span><span class="s1">inspection.inspect(self.class_</span><span class="s5">, </span><span class="s1">raiseerr=</span><span class="s3">False</span><span class="s1">)</span>

        <span class="s1">_is_internal_proxy = </span><span class="s3">True</span>

        <span class="s1">_cache_key_traversal = [</span>
            <span class="s1">(</span><span class="s4">&quot;key&quot;</span><span class="s5">, </span><span class="s1">visitors.ExtendedInternalTraversal.dp_string)</span><span class="s5">,</span>
            <span class="s1">(</span><span class="s4">&quot;_parententity&quot;</span><span class="s5">, </span><span class="s1">visitors.ExtendedInternalTraversal.dp_multi)</span><span class="s5">,</span>
        <span class="s1">]</span>

        <span class="s1">@property</span>
        <span class="s3">def </span><span class="s1">_impl_uses_objects(self):</span>
            <span class="s3">return </span><span class="s1">(</span>
                <span class="s1">self.original_property </span><span class="s3">is not None</span>
                <span class="s3">and </span><span class="s1">getattr(self.class_</span><span class="s5">, </span><span class="s1">self.key).impl.uses_objects</span>
            <span class="s1">)</span>

        <span class="s1">@property</span>
        <span class="s3">def </span><span class="s1">_entity_namespace(self):</span>
            <span class="s3">if </span><span class="s1">hasattr(self._comparator</span><span class="s5">, </span><span class="s4">&quot;_parententity&quot;</span><span class="s1">):</span>
                <span class="s3">return </span><span class="s1">self._comparator._parententity</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># used by hybrid attributes which try to remain</span>
                <span class="s0"># agnostic of any ORM concepts like mappers</span>
                <span class="s3">return </span><span class="s1">AdHocHasEntityNamespace(self._parententity)</span>

        <span class="s1">@property</span>
        <span class="s3">def </span><span class="s1">property(self):</span>
            <span class="s3">return </span><span class="s1">self.comparator.property</span>

        <span class="s1">@util.memoized_property</span>
        <span class="s3">def </span><span class="s1">comparator(self):</span>
            <span class="s3">if </span><span class="s1">callable(self._comparator):</span>
                <span class="s1">self._comparator = self._comparator()</span>
            <span class="s3">if </span><span class="s1">self._adapt_to_entity:</span>
                <span class="s1">self._comparator = self._comparator.adapt_to_entity(</span>
                    <span class="s1">self._adapt_to_entity</span>
                <span class="s1">)</span>
            <span class="s3">return </span><span class="s1">self._comparator</span>

        <span class="s3">def </span><span class="s1">adapt_to_entity(self</span><span class="s5">, </span><span class="s1">adapt_to_entity):</span>
            <span class="s3">return </span><span class="s1">self.__class__(</span>
                <span class="s1">adapt_to_entity.entity</span><span class="s5">,</span>
                <span class="s1">self.key</span><span class="s5">,</span>
                <span class="s1">self.descriptor</span><span class="s5">,</span>
                <span class="s1">self._comparator</span><span class="s5">,</span>
                <span class="s1">adapt_to_entity</span><span class="s5">,</span>
            <span class="s1">)</span>

        <span class="s3">def </span><span class="s1">_clone(self</span><span class="s5">, </span><span class="s1">**kw):</span>
            <span class="s3">return </span><span class="s1">self.__class__(</span>
                <span class="s1">self.class_</span><span class="s5">,</span>
                <span class="s1">self.key</span><span class="s5">,</span>
                <span class="s1">self.descriptor</span><span class="s5">,</span>
                <span class="s1">self._comparator</span><span class="s5">,</span>
                <span class="s1">adapt_to_entity=self._adapt_to_entity</span><span class="s5">,</span>
                <span class="s1">original_property=self.original_property</span><span class="s5">,</span>
            <span class="s1">)</span>

        <span class="s3">def </span><span class="s1">__get__(self</span><span class="s5">, </span><span class="s1">instance</span><span class="s5">, </span><span class="s1">owner):</span>
            <span class="s1">retval = self.descriptor.__get__(instance</span><span class="s5">, </span><span class="s1">owner)</span>
            <span class="s0"># detect if this is a plain Python @property, which just returns</span>
            <span class="s0"># itself for class level access.  If so, then return us.</span>
            <span class="s0"># Otherwise, return the object returned by the descriptor.</span>
            <span class="s3">if </span><span class="s1">retval </span><span class="s3">is </span><span class="s1">self.descriptor </span><span class="s3">and </span><span class="s1">instance </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">self</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">retval</span>

        <span class="s3">def </span><span class="s1">__str__(self) -&gt; str:</span>
            <span class="s3">return </span><span class="s4">f&quot;</span><span class="s6">{</span><span class="s1">self.class_.__name__</span><span class="s6">}</span><span class="s4">.</span><span class="s6">{</span><span class="s1">self.key</span><span class="s6">}</span><span class="s4">&quot;</span>

        <span class="s3">def </span><span class="s1">__getattr__(self</span><span class="s5">, </span><span class="s1">attribute):</span>
            <span class="s2">&quot;&quot;&quot;Delegate __getattr__ to the original descriptor and/or 
            comparator.&quot;&quot;&quot;</span>

            <span class="s0"># this is unfortunately very complicated, and is easily prone</span>
            <span class="s0"># to recursion overflows when implementations of related</span>
            <span class="s0"># __getattr__ schemes are changed</span>

            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">util.MemoizedSlots.__getattr__(self</span><span class="s5">, </span><span class="s1">attribute)</span>
            <span class="s3">except </span><span class="s1">AttributeError:</span>
                <span class="s3">pass</span>

            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">getattr(descriptor</span><span class="s5">, </span><span class="s1">attribute)</span>
            <span class="s3">except </span><span class="s1">AttributeError </span><span class="s3">as </span><span class="s1">err:</span>
                <span class="s3">if </span><span class="s1">attribute == </span><span class="s4">&quot;comparator&quot;</span><span class="s1">:</span>
                    <span class="s3">raise </span><span class="s1">AttributeError(</span><span class="s4">&quot;comparator&quot;</span><span class="s1">) </span><span class="s3">from </span><span class="s1">err</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s0"># comparator itself might be unreachable</span>
                    <span class="s1">comparator = self.comparator</span>
                <span class="s3">except </span><span class="s1">AttributeError </span><span class="s3">as </span><span class="s1">err2:</span>
                    <span class="s3">raise </span><span class="s1">AttributeError(</span>
                        <span class="s4">&quot;Neither %r object nor unconfigured comparator &quot;</span>
                        <span class="s4">&quot;object associated with %s has an attribute %r&quot;</span>
                        <span class="s1">% (type(descriptor).__name__</span><span class="s5">, </span><span class="s1">self</span><span class="s5">, </span><span class="s1">attribute)</span>
                    <span class="s1">) </span><span class="s3">from </span><span class="s1">err2</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">try</span><span class="s1">:</span>
                        <span class="s3">return </span><span class="s1">getattr(comparator</span><span class="s5">, </span><span class="s1">attribute)</span>
                    <span class="s3">except </span><span class="s1">AttributeError </span><span class="s3">as </span><span class="s1">err3:</span>
                        <span class="s3">raise </span><span class="s1">AttributeError(</span>
                            <span class="s4">&quot;Neither %r object nor %r object &quot;</span>
                            <span class="s4">&quot;associated with %s has an attribute %r&quot;</span>
                            <span class="s1">% (</span>
                                <span class="s1">type(descriptor).__name__</span><span class="s5">,</span>
                                <span class="s1">type(comparator).__name__</span><span class="s5">,</span>
                                <span class="s1">self</span><span class="s5">,</span>
                                <span class="s1">attribute</span><span class="s5">,</span>
                            <span class="s1">)</span>
                        <span class="s1">) </span><span class="s3">from </span><span class="s1">err3</span>

    <span class="s1">Proxy.__name__ = type(descriptor).__name__ + </span><span class="s4">&quot;Proxy&quot;</span>

    <span class="s1">util.monkeypatch_proxied_specials(</span>
        <span class="s1">Proxy</span><span class="s5">, </span><span class="s1">type(descriptor)</span><span class="s5">, </span><span class="s1">name=</span><span class="s4">&quot;descriptor&quot;</span><span class="s5">, </span><span class="s1">from_instance=descriptor</span>
    <span class="s1">)</span>
    <span class="s3">return </span><span class="s1">Proxy</span>


<span class="s1">OP_REMOVE = util.symbol(</span><span class="s4">&quot;REMOVE&quot;</span><span class="s1">)</span>
<span class="s1">OP_APPEND = util.symbol(</span><span class="s4">&quot;APPEND&quot;</span><span class="s1">)</span>
<span class="s1">OP_REPLACE = util.symbol(</span><span class="s4">&quot;REPLACE&quot;</span><span class="s1">)</span>
<span class="s1">OP_BULK_REPLACE = util.symbol(</span><span class="s4">&quot;BULK_REPLACE&quot;</span><span class="s1">)</span>
<span class="s1">OP_MODIFIED = util.symbol(</span><span class="s4">&quot;MODIFIED&quot;</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">AttributeEventToken:</span>
    <span class="s2">&quot;&quot;&quot;A token propagated throughout the course of a chain of attribute 
    events. 
 
    Serves as an indicator of the source of the event and also provides 
    a means of controlling propagation across a chain of attribute 
    operations. 
 
    The :class:`.Event` object is sent as the ``initiator`` argument 
    when dealing with events such as :meth:`.AttributeEvents.append`, 
    :meth:`.AttributeEvents.set`, 
    and :meth:`.AttributeEvents.remove`. 
 
    The :class:`.Event` object is currently interpreted by the backref 
    event handlers, and is used to control the propagation of operations 
    across two mutually-dependent attributes. 
 
    .. versionchanged:: 2.0  Changed the name from ``AttributeEvent`` 
       to ``AttributeEventToken``. 
 
    :attribute impl: The :class:`.AttributeImpl` which is the current event 
     initiator. 
 
    :attribute op: The symbol :attr:`.OP_APPEND`, :attr:`.OP_REMOVE`, 
     :attr:`.OP_REPLACE`, or :attr:`.OP_BULK_REPLACE`, indicating the 
     source operation. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = </span><span class="s4">&quot;impl&quot;</span><span class="s5">, </span><span class="s4">&quot;op&quot;</span><span class="s5">, </span><span class="s4">&quot;parent_token&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s5">, </span><span class="s1">attribute_impl: AttributeImpl</span><span class="s5">, </span><span class="s1">op: util.symbol):</span>
        <span class="s1">self.impl = attribute_impl</span>
        <span class="s1">self.op = op</span>
        <span class="s1">self.parent_token = self.impl.parent_token</span>

    <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s5">, </span><span class="s1">other):</span>
        <span class="s3">return </span><span class="s1">(</span>
            <span class="s1">isinstance(other</span><span class="s5">, </span><span class="s1">AttributeEventToken)</span>
            <span class="s3">and </span><span class="s1">other.impl </span><span class="s3">is </span><span class="s1">self.impl</span>
            <span class="s3">and </span><span class="s1">other.op == self.op</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">key(self):</span>
        <span class="s3">return </span><span class="s1">self.impl.key</span>

    <span class="s3">def </span><span class="s1">hasparent(self</span><span class="s5">, </span><span class="s1">state):</span>
        <span class="s3">return </span><span class="s1">self.impl.hasparent(state)</span>


<span class="s1">AttributeEvent = AttributeEventToken  </span><span class="s0"># legacy</span>
<span class="s1">Event = AttributeEventToken  </span><span class="s0"># legacy</span>


<span class="s3">class </span><span class="s1">AttributeImpl:</span>
    <span class="s2">&quot;&quot;&quot;internal implementation for instrumented attributes.&quot;&quot;&quot;</span>

    <span class="s1">collection: bool</span>
    <span class="s1">default_accepts_scalar_loader: bool</span>
    <span class="s1">uses_objects: bool</span>
    <span class="s1">supports_population: bool</span>
    <span class="s1">dynamic: bool</span>

    <span class="s1">_is_has_collection_adapter = </span><span class="s3">False</span>

    <span class="s1">_replace_token: AttributeEventToken</span>
    <span class="s1">_remove_token: AttributeEventToken</span>
    <span class="s1">_append_token: AttributeEventToken</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">class_: _ExternalEntityType[_O]</span><span class="s5">,</span>
        <span class="s1">key: str</span><span class="s5">,</span>
        <span class="s1">callable_: Optional[_LoaderCallable]</span><span class="s5">,</span>
        <span class="s1">dispatch: _Dispatch[QueryableAttribute[Any]]</span><span class="s5">,</span>
        <span class="s1">trackparent: bool = </span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">compare_function: Optional[Callable[...</span><span class="s5">, </span><span class="s1">bool]] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">active_history: bool = </span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">parent_token: Optional[AttributeEventToken] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">load_on_unexpire: bool = </span><span class="s3">True</span><span class="s5">,</span>
        <span class="s1">send_modified_events: bool = </span><span class="s3">True</span><span class="s5">,</span>
        <span class="s1">accepts_scalar_loader: Optional[bool] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">**kwargs: Any</span><span class="s5">,</span>
    <span class="s1">):</span>
        <span class="s2">r&quot;&quot;&quot;Construct an AttributeImpl. 
 
        :param \class_: associated class 
 
        :param key: string name of the attribute 
 
        :param \callable_: 
          optional function which generates a callable based on a parent 
          instance, which produces the &quot;default&quot; values for a scalar or 
          collection attribute when it's first accessed, if not present 
          already. 
 
        :param trackparent: 
          if True, attempt to track if an instance has a parent attached 
          to it via this attribute. 
 
        :param compare_function: 
          a function that compares two values which are normally 
          assignable to this attribute. 
 
        :param active_history: 
          indicates that get_history() should always return the &quot;old&quot; value, 
          even if it means executing a lazy callable upon attribute change. 
 
        :param parent_token: 
          Usually references the MapperProperty, used as a key for 
          the hasparent() function to identify an &quot;owning&quot; attribute. 
          Allows multiple AttributeImpls to all match a single 
          owner attribute. 
 
        :param load_on_unexpire: 
          if False, don't include this attribute in a load-on-expired 
          operation, i.e. the &quot;expired_attribute_loader&quot; process. 
          The attribute can still be in the &quot;expired&quot; list and be 
          considered to be &quot;expired&quot;.   Previously, this flag was called 
          &quot;expire_missing&quot; and is only used by a deferred column 
          attribute. 
 
        :param send_modified_events: 
          if False, the InstanceState._modified_event method will have no 
          effect; this means the attribute will never show up as changed in a 
          history entry. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.class_ = class_</span>
        <span class="s1">self.key = key</span>
        <span class="s1">self.callable_ = callable_</span>
        <span class="s1">self.dispatch = dispatch</span>
        <span class="s1">self.trackparent = trackparent</span>
        <span class="s1">self.parent_token = parent_token </span><span class="s3">or </span><span class="s1">self</span>
        <span class="s1">self.send_modified_events = send_modified_events</span>
        <span class="s3">if </span><span class="s1">compare_function </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.is_equal = operator.eq</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.is_equal = compare_function</span>

        <span class="s3">if </span><span class="s1">accepts_scalar_loader </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.accepts_scalar_loader = accepts_scalar_loader</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.accepts_scalar_loader = self.default_accepts_scalar_loader</span>

        <span class="s1">_deferred_history = kwargs.pop(</span><span class="s4">&quot;_deferred_history&quot;</span><span class="s5">, </span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">self._deferred_history = _deferred_history</span>

        <span class="s3">if </span><span class="s1">active_history:</span>
            <span class="s1">self.dispatch._active_history = </span><span class="s3">True</span>

        <span class="s1">self.load_on_unexpire = load_on_unexpire</span>
        <span class="s1">self._modified_token = AttributeEventToken(self</span><span class="s5">, </span><span class="s1">OP_MODIFIED)</span>

    <span class="s1">__slots__ = (</span>
        <span class="s4">&quot;class_&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;key&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;callable_&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;dispatch&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;trackparent&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;parent_token&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;send_modified_events&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;is_equal&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;load_on_unexpire&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;_modified_token&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;accepts_scalar_loader&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;_deferred_history&quot;</span><span class="s5">,</span>
    <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s3">return </span><span class="s4">f&quot;</span><span class="s6">{</span><span class="s1">self.class_.__name__</span><span class="s6">}</span><span class="s4">.</span><span class="s6">{</span><span class="s1">self.key</span><span class="s6">}</span><span class="s4">&quot;</span>

    <span class="s3">def </span><span class="s1">_get_active_history(self):</span>
        <span class="s2">&quot;&quot;&quot;Backwards compat for impl.active_history&quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">self.dispatch._active_history</span>

    <span class="s3">def </span><span class="s1">_set_active_history(self</span><span class="s5">, </span><span class="s1">value):</span>
        <span class="s1">self.dispatch._active_history = value</span>

    <span class="s1">active_history = property(_get_active_history</span><span class="s5">, </span><span class="s1">_set_active_history)</span>

    <span class="s3">def </span><span class="s1">hasparent(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">state: InstanceState[Any]</span><span class="s5">, </span><span class="s1">optimistic: bool = </span><span class="s3">False</span>
    <span class="s1">) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot;Return the boolean value of a `hasparent` flag attached to 
        the given state. 
 
        The `optimistic` flag determines what the default return value 
        should be if no `hasparent` flag can be located. 
 
        As this function is used to determine if an instance is an 
        *orphan*, instances that were loaded from storage should be 
        assumed to not be orphans, until a True/False value for this 
        flag is set. 
 
        An instance attribute that is loaded by a callable function 
        will also not have a `hasparent` flag. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">msg = </span><span class="s4">&quot;This AttributeImpl is not configured to track parents.&quot;</span>
        <span class="s3">assert </span><span class="s1">self.trackparent</span><span class="s5">, </span><span class="s1">msg</span>

        <span class="s3">return </span><span class="s1">(</span>
            <span class="s1">state.parents.get(id(self.parent_token)</span><span class="s5">, </span><span class="s1">optimistic) </span><span class="s3">is not False</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">sethasparent(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">parent_state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">value: bool</span><span class="s5">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Set a boolean flag on the given item corresponding to 
        whether or not it is attached to a parent object via the 
        attribute represented by this ``InstrumentedAttribute``. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">msg = </span><span class="s4">&quot;This AttributeImpl is not configured to track parents.&quot;</span>
        <span class="s3">assert </span><span class="s1">self.trackparent</span><span class="s5">, </span><span class="s1">msg</span>

        <span class="s1">id_ = id(self.parent_token)</span>
        <span class="s3">if </span><span class="s1">value:</span>
            <span class="s1">state.parents[id_] = parent_state</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">id_ </span><span class="s3">in </span><span class="s1">state.parents:</span>
                <span class="s1">last_parent = state.parents[id_]</span>

                <span class="s3">if </span><span class="s1">(</span>
                    <span class="s1">last_parent </span><span class="s3">is not False</span>
                    <span class="s3">and </span><span class="s1">last_parent.key != parent_state.key</span>
                <span class="s1">):</span>
                    <span class="s3">if </span><span class="s1">last_parent.obj() </span><span class="s3">is None</span><span class="s1">:</span>
                        <span class="s3">raise </span><span class="s1">orm_exc.StaleDataError(</span>
                            <span class="s4">&quot;Removing state %s from parent &quot;</span>
                            <span class="s4">&quot;state %s along attribute '%s', &quot;</span>
                            <span class="s4">&quot;but the parent record &quot;</span>
                            <span class="s4">&quot;has gone stale, can't be sure this &quot;</span>
                            <span class="s4">&quot;is the most recent parent.&quot;</span>
                            <span class="s1">% (</span>
                                <span class="s1">state_str(state)</span><span class="s5">,</span>
                                <span class="s1">state_str(parent_state)</span><span class="s5">,</span>
                                <span class="s1">self.key</span><span class="s5">,</span>
                            <span class="s1">)</span>
                        <span class="s1">)</span>

                    <span class="s3">return</span>

            <span class="s1">state.parents[id_] = </span><span class="s3">False</span>

    <span class="s3">def </span><span class="s1">get_history(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">passive: PassiveFlag = PASSIVE_OFF</span><span class="s5">,</span>
    <span class="s1">) -&gt; History:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s3">def </span><span class="s1">get_all_pending(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">passive: PassiveFlag = PASSIVE_NO_INITIALIZE</span><span class="s5">,</span>
    <span class="s1">) -&gt; _AllPendingType:</span>
        <span class="s2">&quot;&quot;&quot;Return a list of tuples of (state, obj) 
        for all objects in this attribute's current state 
        + history. 
 
        Only applies to object-based attributes. 
 
        This is an inlining of existing functionality 
        which roughly corresponds to: 
 
            get_state_history( 
                        state, 
                        key, 
                        passive=PASSIVE_NO_INITIALIZE).sum() 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s3">def </span><span class="s1">_default_value(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">state: InstanceState[Any]</span><span class="s5">, </span><span class="s1">dict_: _InstanceDict</span>
    <span class="s1">) -&gt; Any:</span>
        <span class="s2">&quot;&quot;&quot;Produce an empty value for an uninitialized scalar attribute.&quot;&quot;&quot;</span>

        <span class="s3">assert </span><span class="s1">self.key </span><span class="s3">not in </span><span class="s1">dict_</span><span class="s5">, </span><span class="s1">(</span>
            <span class="s4">&quot;_default_value should only be invoked for an &quot;</span>
            <span class="s4">&quot;uninitialized or expired attribute&quot;</span>
        <span class="s1">)</span>

        <span class="s1">value = </span><span class="s3">None</span>
        <span class="s3">for </span><span class="s1">fn </span><span class="s3">in </span><span class="s1">self.dispatch.init_scalar:</span>
            <span class="s1">ret = fn(state</span><span class="s5">, </span><span class="s1">value</span><span class="s5">, </span><span class="s1">dict_)</span>
            <span class="s3">if </span><span class="s1">ret </span><span class="s3">is not </span><span class="s1">ATTR_EMPTY:</span>
                <span class="s1">value = ret</span>

        <span class="s3">return </span><span class="s1">value</span>

    <span class="s3">def </span><span class="s1">get(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">passive: PassiveFlag = PASSIVE_OFF</span><span class="s5">,</span>
    <span class="s1">) -&gt; Any:</span>
        <span class="s2">&quot;&quot;&quot;Retrieve a value from the given object. 
        If a callable is assembled on this object's attribute, and 
        passive is False, the callable will be executed and the 
        resulting value will be set as the new value for this attribute. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.key </span><span class="s3">in </span><span class="s1">dict_:</span>
            <span class="s3">return </span><span class="s1">dict_[self.key]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># if history present, don't load</span>
            <span class="s1">key = self.key</span>
            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">key </span><span class="s3">not in </span><span class="s1">state.committed_state</span>
                <span class="s3">or </span><span class="s1">state.committed_state[key] </span><span class="s3">is </span><span class="s1">NO_VALUE</span>
            <span class="s1">):</span>
                <span class="s3">if not </span><span class="s1">passive &amp; CALLABLES_OK:</span>
                    <span class="s3">return </span><span class="s1">PASSIVE_NO_RESULT</span>

                <span class="s1">value = self._fire_loader_callables(state</span><span class="s5">, </span><span class="s1">key</span><span class="s5">, </span><span class="s1">passive)</span>

                <span class="s3">if </span><span class="s1">value </span><span class="s3">is </span><span class="s1">PASSIVE_NO_RESULT </span><span class="s3">or </span><span class="s1">value </span><span class="s3">is </span><span class="s1">NO_VALUE:</span>
                    <span class="s3">return </span><span class="s1">value</span>
                <span class="s3">elif </span><span class="s1">value </span><span class="s3">is </span><span class="s1">ATTR_WAS_SET:</span>
                    <span class="s3">try</span><span class="s1">:</span>
                        <span class="s3">return </span><span class="s1">dict_[key]</span>
                    <span class="s3">except </span><span class="s1">KeyError </span><span class="s3">as </span><span class="s1">err:</span>
                        <span class="s0"># TODO: no test coverage here.</span>
                        <span class="s3">raise </span><span class="s1">KeyError(</span>
                            <span class="s4">&quot;Deferred loader for attribute &quot;</span>
                            <span class="s4">&quot;%r failed to populate &quot;</span>
                            <span class="s4">&quot;correctly&quot; </span><span class="s1">% key</span>
                        <span class="s1">) </span><span class="s3">from </span><span class="s1">err</span>
                <span class="s3">elif </span><span class="s1">value </span><span class="s3">is not </span><span class="s1">ATTR_EMPTY:</span>
                    <span class="s3">return </span><span class="s1">self.set_committed_value(state</span><span class="s5">, </span><span class="s1">dict_</span><span class="s5">, </span><span class="s1">value)</span>

            <span class="s3">if not </span><span class="s1">passive &amp; INIT_OK:</span>
                <span class="s3">return </span><span class="s1">NO_VALUE</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">self._default_value(state</span><span class="s5">, </span><span class="s1">dict_)</span>

    <span class="s3">def </span><span class="s1">_fire_loader_callables(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">state: InstanceState[Any]</span><span class="s5">, </span><span class="s1">key: str</span><span class="s5">, </span><span class="s1">passive: PassiveFlag</span>
    <span class="s1">) -&gt; Any:</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">self.accepts_scalar_loader</span>
            <span class="s3">and </span><span class="s1">self.load_on_unexpire</span>
            <span class="s3">and </span><span class="s1">key </span><span class="s3">in </span><span class="s1">state.expired_attributes</span>
        <span class="s1">):</span>
            <span class="s3">return </span><span class="s1">state._load_expired(state</span><span class="s5">, </span><span class="s1">passive)</span>
        <span class="s3">elif </span><span class="s1">key </span><span class="s3">in </span><span class="s1">state.callables:</span>
            <span class="s1">callable_ = state.callables[key]</span>
            <span class="s3">return </span><span class="s1">callable_(state</span><span class="s5">, </span><span class="s1">passive)</span>
        <span class="s3">elif </span><span class="s1">self.callable_:</span>
            <span class="s3">return </span><span class="s1">self.callable_(state</span><span class="s5">, </span><span class="s1">passive)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">ATTR_EMPTY</span>

    <span class="s3">def </span><span class="s1">append(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">value: Any</span><span class="s5">,</span>
        <span class="s1">initiator: Optional[AttributeEventToken]</span><span class="s5">,</span>
        <span class="s1">passive: PassiveFlag = PASSIVE_OFF</span><span class="s5">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">self.set(state</span><span class="s5">, </span><span class="s1">dict_</span><span class="s5">, </span><span class="s1">value</span><span class="s5">, </span><span class="s1">initiator</span><span class="s5">, </span><span class="s1">passive=passive)</span>

    <span class="s3">def </span><span class="s1">remove(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">value: Any</span><span class="s5">,</span>
        <span class="s1">initiator: Optional[AttributeEventToken]</span><span class="s5">,</span>
        <span class="s1">passive: PassiveFlag = PASSIVE_OFF</span><span class="s5">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">self.set(</span>
            <span class="s1">state</span><span class="s5">, </span><span class="s1">dict_</span><span class="s5">, </span><span class="s3">None</span><span class="s5">, </span><span class="s1">initiator</span><span class="s5">, </span><span class="s1">passive=passive</span><span class="s5">, </span><span class="s1">check_old=value</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">pop(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">value: Any</span><span class="s5">,</span>
        <span class="s1">initiator: Optional[AttributeEventToken]</span><span class="s5">,</span>
        <span class="s1">passive: PassiveFlag = PASSIVE_OFF</span><span class="s5">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">self.set(</span>
            <span class="s1">state</span><span class="s5">,</span>
            <span class="s1">dict_</span><span class="s5">,</span>
            <span class="s3">None</span><span class="s5">,</span>
            <span class="s1">initiator</span><span class="s5">,</span>
            <span class="s1">passive=passive</span><span class="s5">,</span>
            <span class="s1">check_old=value</span><span class="s5">,</span>
            <span class="s1">pop=</span><span class="s3">True</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">set(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">value: Any</span><span class="s5">,</span>
        <span class="s1">initiator: Optional[AttributeEventToken] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">passive: PassiveFlag = PASSIVE_OFF</span><span class="s5">,</span>
        <span class="s1">check_old: Any = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">pop: bool = </span><span class="s3">False</span><span class="s5">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s3">def </span><span class="s1">delete(self</span><span class="s5">, </span><span class="s1">state: InstanceState[Any]</span><span class="s5">, </span><span class="s1">dict_: _InstanceDict) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s3">def </span><span class="s1">get_committed_value(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">passive: PassiveFlag = PASSIVE_OFF</span><span class="s5">,</span>
    <span class="s1">) -&gt; Any:</span>
        <span class="s2">&quot;&quot;&quot;return the unchanged value of this attribute&quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">self.key </span><span class="s3">in </span><span class="s1">state.committed_state:</span>
            <span class="s1">value = state.committed_state[self.key]</span>
            <span class="s3">if </span><span class="s1">value </span><span class="s3">is </span><span class="s1">NO_VALUE:</span>
                <span class="s3">return None</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">value</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.get(state</span><span class="s5">, </span><span class="s1">dict_</span><span class="s5">, </span><span class="s1">passive=passive)</span>

    <span class="s3">def </span><span class="s1">set_committed_value(self</span><span class="s5">, </span><span class="s1">state</span><span class="s5">, </span><span class="s1">dict_</span><span class="s5">, </span><span class="s1">value):</span>
        <span class="s2">&quot;&quot;&quot;set an attribute value on the given instance and 'commit' it.&quot;&quot;&quot;</span>

        <span class="s1">dict_[self.key] = value</span>
        <span class="s1">state._commit(dict_</span><span class="s5">, </span><span class="s1">[self.key])</span>
        <span class="s3">return </span><span class="s1">value</span>


<span class="s3">class </span><span class="s1">ScalarAttributeImpl(AttributeImpl):</span>
    <span class="s2">&quot;&quot;&quot;represents a scalar value-holding InstrumentedAttribute.&quot;&quot;&quot;</span>

    <span class="s1">default_accepts_scalar_loader = </span><span class="s3">True</span>
    <span class="s1">uses_objects = </span><span class="s3">False</span>
    <span class="s1">supports_population = </span><span class="s3">True</span>
    <span class="s1">collection = </span><span class="s3">False</span>
    <span class="s1">dynamic = </span><span class="s3">False</span>

    <span class="s1">__slots__ = </span><span class="s4">&quot;_replace_token&quot;</span><span class="s5">, </span><span class="s4">&quot;_append_token&quot;</span><span class="s5">, </span><span class="s4">&quot;_remove_token&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s5">, </span><span class="s1">*arg</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">super().__init__(*arg</span><span class="s5">, </span><span class="s1">**kw)</span>
        <span class="s1">self._replace_token = self._append_token = AttributeEventToken(</span>
            <span class="s1">self</span><span class="s5">, </span><span class="s1">OP_REPLACE</span>
        <span class="s1">)</span>
        <span class="s1">self._remove_token = AttributeEventToken(self</span><span class="s5">, </span><span class="s1">OP_REMOVE)</span>

    <span class="s3">def </span><span class="s1">delete(self</span><span class="s5">, </span><span class="s1">state: InstanceState[Any]</span><span class="s5">, </span><span class="s1">dict_: _InstanceDict) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">self.dispatch._active_history:</span>
            <span class="s1">old = self.get(state</span><span class="s5">, </span><span class="s1">dict_</span><span class="s5">, </span><span class="s1">PASSIVE_RETURN_NO_VALUE)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">old = dict_.get(self.key</span><span class="s5">, </span><span class="s1">NO_VALUE)</span>

        <span class="s3">if </span><span class="s1">self.dispatch.remove:</span>
            <span class="s1">self.fire_remove_event(state</span><span class="s5">, </span><span class="s1">dict_</span><span class="s5">, </span><span class="s1">old</span><span class="s5">, </span><span class="s1">self._remove_token)</span>
        <span class="s1">state._modified_event(dict_</span><span class="s5">, </span><span class="s1">self</span><span class="s5">, </span><span class="s1">old)</span>

        <span class="s1">existing = dict_.pop(self.key</span><span class="s5">, </span><span class="s1">NO_VALUE)</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">existing </span><span class="s3">is </span><span class="s1">NO_VALUE</span>
            <span class="s3">and </span><span class="s1">old </span><span class="s3">is </span><span class="s1">NO_VALUE</span>
            <span class="s3">and not </span><span class="s1">state.expired</span>
            <span class="s3">and </span><span class="s1">self.key </span><span class="s3">not in </span><span class="s1">state.expired_attributes</span>
        <span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">AttributeError(</span><span class="s4">&quot;%s object does not have a value&quot; </span><span class="s1">% self)</span>

    <span class="s3">def </span><span class="s1">get_history(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: Dict[str</span><span class="s5">, </span><span class="s1">Any]</span><span class="s5">,</span>
        <span class="s1">passive: PassiveFlag = PASSIVE_OFF</span><span class="s5">,</span>
    <span class="s1">) -&gt; History:</span>
        <span class="s3">if </span><span class="s1">self.key </span><span class="s3">in </span><span class="s1">dict_:</span>
            <span class="s3">return </span><span class="s1">History.from_scalar_attribute(self</span><span class="s5">, </span><span class="s1">state</span><span class="s5">, </span><span class="s1">dict_[self.key])</span>
        <span class="s3">elif </span><span class="s1">self.key </span><span class="s3">in </span><span class="s1">state.committed_state:</span>
            <span class="s3">return </span><span class="s1">History.from_scalar_attribute(self</span><span class="s5">, </span><span class="s1">state</span><span class="s5">, </span><span class="s1">NO_VALUE)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">passive &amp; INIT_OK:</span>
                <span class="s1">passive ^= INIT_OK</span>
            <span class="s1">current = self.get(state</span><span class="s5">, </span><span class="s1">dict_</span><span class="s5">, </span><span class="s1">passive=passive)</span>
            <span class="s3">if </span><span class="s1">current </span><span class="s3">is </span><span class="s1">PASSIVE_NO_RESULT:</span>
                <span class="s3">return </span><span class="s1">HISTORY_BLANK</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">History.from_scalar_attribute(self</span><span class="s5">, </span><span class="s1">state</span><span class="s5">, </span><span class="s1">current)</span>

    <span class="s3">def </span><span class="s1">set(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: Dict[str</span><span class="s5">, </span><span class="s1">Any]</span><span class="s5">,</span>
        <span class="s1">value: Any</span><span class="s5">,</span>
        <span class="s1">initiator: Optional[AttributeEventToken] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">passive: PassiveFlag = PASSIVE_OFF</span><span class="s5">,</span>
        <span class="s1">check_old: Optional[object] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">pop: bool = </span><span class="s3">False</span><span class="s5">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">self.dispatch._active_history:</span>
            <span class="s1">old = self.get(state</span><span class="s5">, </span><span class="s1">dict_</span><span class="s5">, </span><span class="s1">PASSIVE_RETURN_NO_VALUE)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">old = dict_.get(self.key</span><span class="s5">, </span><span class="s1">NO_VALUE)</span>

        <span class="s3">if </span><span class="s1">self.dispatch.set:</span>
            <span class="s1">value = self.fire_replace_event(</span>
                <span class="s1">state</span><span class="s5">, </span><span class="s1">dict_</span><span class="s5">, </span><span class="s1">value</span><span class="s5">, </span><span class="s1">old</span><span class="s5">, </span><span class="s1">initiator</span>
            <span class="s1">)</span>
        <span class="s1">state._modified_event(dict_</span><span class="s5">, </span><span class="s1">self</span><span class="s5">, </span><span class="s1">old)</span>
        <span class="s1">dict_[self.key] = value</span>

    <span class="s3">def </span><span class="s1">fire_replace_event(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">value: _T</span><span class="s5">,</span>
        <span class="s1">previous: Any</span><span class="s5">,</span>
        <span class="s1">initiator: Optional[AttributeEventToken]</span><span class="s5">,</span>
    <span class="s1">) -&gt; _T:</span>
        <span class="s3">for </span><span class="s1">fn </span><span class="s3">in </span><span class="s1">self.dispatch.set:</span>
            <span class="s1">value = fn(</span>
                <span class="s1">state</span><span class="s5">, </span><span class="s1">value</span><span class="s5">, </span><span class="s1">previous</span><span class="s5">, </span><span class="s1">initiator </span><span class="s3">or </span><span class="s1">self._replace_token</span>
            <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">value</span>

    <span class="s3">def </span><span class="s1">fire_remove_event(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">value: Any</span><span class="s5">,</span>
        <span class="s1">initiator: Optional[AttributeEventToken]</span><span class="s5">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">for </span><span class="s1">fn </span><span class="s3">in </span><span class="s1">self.dispatch.remove:</span>
            <span class="s1">fn(state</span><span class="s5">, </span><span class="s1">value</span><span class="s5">, </span><span class="s1">initiator </span><span class="s3">or </span><span class="s1">self._remove_token)</span>


<span class="s3">class </span><span class="s1">ScalarObjectAttributeImpl(ScalarAttributeImpl):</span>
    <span class="s2">&quot;&quot;&quot;represents a scalar-holding InstrumentedAttribute, 
    where the target object is also instrumented. 
 
    Adds events to delete/set operations. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">default_accepts_scalar_loader = </span><span class="s3">False</span>
    <span class="s1">uses_objects = </span><span class="s3">True</span>
    <span class="s1">supports_population = </span><span class="s3">True</span>
    <span class="s1">collection = </span><span class="s3">False</span>

    <span class="s1">__slots__ = ()</span>

    <span class="s3">def </span><span class="s1">delete(self</span><span class="s5">, </span><span class="s1">state: InstanceState[Any]</span><span class="s5">, </span><span class="s1">dict_: _InstanceDict) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">self.dispatch._active_history:</span>
            <span class="s1">old = self.get(</span>
                <span class="s1">state</span><span class="s5">,</span>
                <span class="s1">dict_</span><span class="s5">,</span>
                <span class="s1">passive=PASSIVE_ONLY_PERSISTENT</span>
                <span class="s1">| NO_AUTOFLUSH</span>
                <span class="s1">| LOAD_AGAINST_COMMITTED</span><span class="s5">,</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">old = self.get(</span>
                <span class="s1">state</span><span class="s5">,</span>
                <span class="s1">dict_</span><span class="s5">,</span>
                <span class="s1">passive=PASSIVE_NO_FETCH ^ INIT_OK</span>
                <span class="s1">| LOAD_AGAINST_COMMITTED</span>
                <span class="s1">| NO_RAISE</span><span class="s5">,</span>
            <span class="s1">)</span>

        <span class="s1">self.fire_remove_event(state</span><span class="s5">, </span><span class="s1">dict_</span><span class="s5">, </span><span class="s1">old</span><span class="s5">, </span><span class="s1">self._remove_token)</span>

        <span class="s1">existing = dict_.pop(self.key</span><span class="s5">, </span><span class="s1">NO_VALUE)</span>

        <span class="s0"># if the attribute is expired, we currently have no way to tell</span>
        <span class="s0"># that an object-attribute was expired vs. not loaded.   So</span>
        <span class="s0"># for this test, we look to see if the object has a DB identity.</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">existing </span><span class="s3">is </span><span class="s1">NO_VALUE</span>
            <span class="s3">and </span><span class="s1">old </span><span class="s3">is not </span><span class="s1">PASSIVE_NO_RESULT</span>
            <span class="s3">and </span><span class="s1">state.key </span><span class="s3">is None</span>
        <span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">AttributeError(</span><span class="s4">&quot;%s object does not have a value&quot; </span><span class="s1">% self)</span>

    <span class="s3">def </span><span class="s1">get_history(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">passive: PassiveFlag = PASSIVE_OFF</span><span class="s5">,</span>
    <span class="s1">) -&gt; History:</span>
        <span class="s3">if </span><span class="s1">self.key </span><span class="s3">in </span><span class="s1">dict_:</span>
            <span class="s1">current = dict_[self.key]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">passive &amp; INIT_OK:</span>
                <span class="s1">passive ^= INIT_OK</span>
            <span class="s1">current = self.get(state</span><span class="s5">, </span><span class="s1">dict_</span><span class="s5">, </span><span class="s1">passive=passive)</span>
            <span class="s3">if </span><span class="s1">current </span><span class="s3">is </span><span class="s1">PASSIVE_NO_RESULT:</span>
                <span class="s3">return </span><span class="s1">HISTORY_BLANK</span>

        <span class="s3">if not </span><span class="s1">self._deferred_history:</span>
            <span class="s3">return </span><span class="s1">History.from_object_attribute(self</span><span class="s5">, </span><span class="s1">state</span><span class="s5">, </span><span class="s1">current)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">original = state.committed_state.get(self.key</span><span class="s5">, </span><span class="s1">_NO_HISTORY)</span>
            <span class="s3">if </span><span class="s1">original </span><span class="s3">is </span><span class="s1">PASSIVE_NO_RESULT:</span>
                <span class="s1">loader_passive = passive | (</span>
                    <span class="s1">PASSIVE_ONLY_PERSISTENT</span>
                    <span class="s1">| NO_AUTOFLUSH</span>
                    <span class="s1">| LOAD_AGAINST_COMMITTED</span>
                    <span class="s1">| NO_RAISE</span>
                    <span class="s1">| DEFERRED_HISTORY_LOAD</span>
                <span class="s1">)</span>
                <span class="s1">original = self._fire_loader_callables(</span>
                    <span class="s1">state</span><span class="s5">, </span><span class="s1">self.key</span><span class="s5">, </span><span class="s1">loader_passive</span>
                <span class="s1">)</span>
            <span class="s3">return </span><span class="s1">History.from_object_attribute(</span>
                <span class="s1">self</span><span class="s5">, </span><span class="s1">state</span><span class="s5">, </span><span class="s1">current</span><span class="s5">, </span><span class="s1">original=original</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">get_all_pending(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">passive: PassiveFlag = PASSIVE_NO_INITIALIZE</span><span class="s5">,</span>
    <span class="s1">) -&gt; _AllPendingType:</span>
        <span class="s3">if </span><span class="s1">self.key </span><span class="s3">in </span><span class="s1">dict_:</span>
            <span class="s1">current = dict_[self.key]</span>
        <span class="s3">elif </span><span class="s1">passive &amp; CALLABLES_OK:</span>
            <span class="s1">current = self.get(state</span><span class="s5">, </span><span class="s1">dict_</span><span class="s5">, </span><span class="s1">passive=passive)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">[]</span>

        <span class="s1">ret: _AllPendingType</span>

        <span class="s0"># can't use __hash__(), can't use __eq__() here</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">current </span><span class="s3">is not None</span>
            <span class="s3">and </span><span class="s1">current </span><span class="s3">is not </span><span class="s1">PASSIVE_NO_RESULT</span>
            <span class="s3">and </span><span class="s1">current </span><span class="s3">is not </span><span class="s1">NO_VALUE</span>
        <span class="s1">):</span>
            <span class="s1">ret = [(instance_state(current)</span><span class="s5">, </span><span class="s1">current)]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">ret = [(</span><span class="s3">None</span><span class="s5">, </span><span class="s3">None</span><span class="s1">)]</span>

        <span class="s3">if </span><span class="s1">self.key </span><span class="s3">in </span><span class="s1">state.committed_state:</span>
            <span class="s1">original = state.committed_state[self.key]</span>
            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">original </span><span class="s3">is not None</span>
                <span class="s3">and </span><span class="s1">original </span><span class="s3">is not </span><span class="s1">PASSIVE_NO_RESULT</span>
                <span class="s3">and </span><span class="s1">original </span><span class="s3">is not </span><span class="s1">NO_VALUE</span>
                <span class="s3">and </span><span class="s1">original </span><span class="s3">is not </span><span class="s1">current</span>
            <span class="s1">):</span>
                <span class="s1">ret.append((instance_state(original)</span><span class="s5">, </span><span class="s1">original))</span>
        <span class="s3">return </span><span class="s1">ret</span>

    <span class="s3">def </span><span class="s1">set(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">value: Any</span><span class="s5">,</span>
        <span class="s1">initiator: Optional[AttributeEventToken] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">passive: PassiveFlag = PASSIVE_OFF</span><span class="s5">,</span>
        <span class="s1">check_old: Any = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">pop: bool = </span><span class="s3">False</span><span class="s5">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Set a value on the given InstanceState.&quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">self.dispatch._active_history:</span>
            <span class="s1">old = self.get(</span>
                <span class="s1">state</span><span class="s5">,</span>
                <span class="s1">dict_</span><span class="s5">,</span>
                <span class="s1">passive=PASSIVE_ONLY_PERSISTENT</span>
                <span class="s1">| NO_AUTOFLUSH</span>
                <span class="s1">| LOAD_AGAINST_COMMITTED</span><span class="s5">,</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">old = self.get(</span>
                <span class="s1">state</span><span class="s5">,</span>
                <span class="s1">dict_</span><span class="s5">,</span>
                <span class="s1">passive=PASSIVE_NO_FETCH ^ INIT_OK</span>
                <span class="s1">| LOAD_AGAINST_COMMITTED</span>
                <span class="s1">| NO_RAISE</span><span class="s5">,</span>
            <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">check_old </span><span class="s3">is not None</span>
            <span class="s3">and </span><span class="s1">old </span><span class="s3">is not </span><span class="s1">PASSIVE_NO_RESULT</span>
            <span class="s3">and </span><span class="s1">check_old </span><span class="s3">is not </span><span class="s1">old</span>
        <span class="s1">):</span>
            <span class="s3">if </span><span class="s1">pop:</span>
                <span class="s3">return</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;Object %s not associated with %s on attribute '%s'&quot;</span>
                    <span class="s1">% (instance_str(check_old)</span><span class="s5">, </span><span class="s1">state_str(state)</span><span class="s5">, </span><span class="s1">self.key)</span>
                <span class="s1">)</span>

        <span class="s1">value = self.fire_replace_event(state</span><span class="s5">, </span><span class="s1">dict_</span><span class="s5">, </span><span class="s1">value</span><span class="s5">, </span><span class="s1">old</span><span class="s5">, </span><span class="s1">initiator)</span>
        <span class="s1">dict_[self.key] = value</span>

    <span class="s3">def </span><span class="s1">fire_remove_event(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">value: Any</span><span class="s5">,</span>
        <span class="s1">initiator: Optional[AttributeEventToken]</span><span class="s5">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">self.trackparent </span><span class="s3">and </span><span class="s1">value </span><span class="s3">not in </span><span class="s1">(</span>
            <span class="s3">None</span><span class="s5">,</span>
            <span class="s1">PASSIVE_NO_RESULT</span><span class="s5">,</span>
            <span class="s1">NO_VALUE</span><span class="s5">,</span>
        <span class="s1">):</span>
            <span class="s1">self.sethasparent(instance_state(value)</span><span class="s5">, </span><span class="s1">state</span><span class="s5">, </span><span class="s3">False</span><span class="s1">)</span>

        <span class="s3">for </span><span class="s1">fn </span><span class="s3">in </span><span class="s1">self.dispatch.remove:</span>
            <span class="s1">fn(state</span><span class="s5">, </span><span class="s1">value</span><span class="s5">, </span><span class="s1">initiator </span><span class="s3">or </span><span class="s1">self._remove_token)</span>

        <span class="s1">state._modified_event(dict_</span><span class="s5">, </span><span class="s1">self</span><span class="s5">, </span><span class="s1">value)</span>

    <span class="s3">def </span><span class="s1">fire_replace_event(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">value: _T</span><span class="s5">,</span>
        <span class="s1">previous: Any</span><span class="s5">,</span>
        <span class="s1">initiator: Optional[AttributeEventToken]</span><span class="s5">,</span>
    <span class="s1">) -&gt; _T:</span>
        <span class="s3">if </span><span class="s1">self.trackparent:</span>
            <span class="s3">if </span><span class="s1">previous </span><span class="s3">is not </span><span class="s1">value </span><span class="s3">and </span><span class="s1">previous </span><span class="s3">not in </span><span class="s1">(</span>
                <span class="s3">None</span><span class="s5">,</span>
                <span class="s1">PASSIVE_NO_RESULT</span><span class="s5">,</span>
                <span class="s1">NO_VALUE</span><span class="s5">,</span>
            <span class="s1">):</span>
                <span class="s1">self.sethasparent(instance_state(previous)</span><span class="s5">, </span><span class="s1">state</span><span class="s5">, </span><span class="s3">False</span><span class="s1">)</span>

        <span class="s3">for </span><span class="s1">fn </span><span class="s3">in </span><span class="s1">self.dispatch.set:</span>
            <span class="s1">value = fn(</span>
                <span class="s1">state</span><span class="s5">, </span><span class="s1">value</span><span class="s5">, </span><span class="s1">previous</span><span class="s5">, </span><span class="s1">initiator </span><span class="s3">or </span><span class="s1">self._replace_token</span>
            <span class="s1">)</span>

        <span class="s1">state._modified_event(dict_</span><span class="s5">, </span><span class="s1">self</span><span class="s5">, </span><span class="s1">previous)</span>

        <span class="s3">if </span><span class="s1">self.trackparent:</span>
            <span class="s3">if </span><span class="s1">value </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">self.sethasparent(instance_state(value)</span><span class="s5">, </span><span class="s1">state</span><span class="s5">, </span><span class="s3">True</span><span class="s1">)</span>

        <span class="s3">return </span><span class="s1">value</span>


<span class="s3">class </span><span class="s1">HasCollectionAdapter:</span>
    <span class="s1">__slots__ = ()</span>

    <span class="s1">collection: bool</span>
    <span class="s1">_is_has_collection_adapter = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">_dispose_previous_collection(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">collection: _AdaptedCollectionProtocol</span><span class="s5">,</span>
        <span class="s1">adapter: CollectionAdapter</span><span class="s5">,</span>
        <span class="s1">fire_event: bool</span><span class="s5">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s1">@overload</span>
    <span class="s3">def </span><span class="s1">get_collection(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">user_data: Literal[</span><span class="s3">None</span><span class="s1">] = ...</span><span class="s5">,</span>
        <span class="s1">passive: Literal[PassiveFlag.PASSIVE_OFF] = ...</span><span class="s5">,</span>
    <span class="s1">) -&gt; CollectionAdapter: ...</span>

    <span class="s1">@overload</span>
    <span class="s3">def </span><span class="s1">get_collection(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">user_data: _AdaptedCollectionProtocol = ...</span><span class="s5">,</span>
        <span class="s1">passive: PassiveFlag = ...</span><span class="s5">,</span>
    <span class="s1">) -&gt; CollectionAdapter: ...</span>

    <span class="s1">@overload</span>
    <span class="s3">def </span><span class="s1">get_collection(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">user_data: Optional[_AdaptedCollectionProtocol] = ...</span><span class="s5">,</span>
        <span class="s1">passive: PassiveFlag = ...</span><span class="s5">,</span>
    <span class="s1">) -&gt; Union[</span>
        <span class="s1">Literal[LoaderCallableStatus.PASSIVE_NO_RESULT]</span><span class="s5">, </span><span class="s1">CollectionAdapter</span>
    <span class="s1">]: ...</span>

    <span class="s3">def </span><span class="s1">get_collection(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">user_data: Optional[_AdaptedCollectionProtocol] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">passive: PassiveFlag = PassiveFlag.PASSIVE_OFF</span><span class="s5">,</span>
    <span class="s1">) -&gt; Union[</span>
        <span class="s1">Literal[LoaderCallableStatus.PASSIVE_NO_RESULT]</span><span class="s5">, </span><span class="s1">CollectionAdapter</span>
    <span class="s1">]:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s3">def </span><span class="s1">set(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">value: Any</span><span class="s5">,</span>
        <span class="s1">initiator: Optional[AttributeEventToken] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">passive: PassiveFlag = PassiveFlag.PASSIVE_OFF</span><span class="s5">,</span>
        <span class="s1">check_old: Any = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">pop: bool = </span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">_adapt: bool = </span><span class="s3">True</span><span class="s5">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>


<span class="s3">if </span><span class="s1">TYPE_CHECKING:</span>

    <span class="s3">def </span><span class="s1">_is_collection_attribute_impl(</span>
        <span class="s1">impl: AttributeImpl</span><span class="s5">,</span>
    <span class="s1">) -&gt; TypeGuard[CollectionAttributeImpl]: ...</span>

<span class="s3">else</span><span class="s1">:</span>
    <span class="s1">_is_collection_attribute_impl = operator.attrgetter(</span><span class="s4">&quot;collection&quot;</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">CollectionAttributeImpl(HasCollectionAdapter</span><span class="s5">, </span><span class="s1">AttributeImpl):</span>
    <span class="s2">&quot;&quot;&quot;A collection-holding attribute that instruments changes in membership. 
 
    Only handles collections of instrumented objects. 
 
    InstrumentedCollectionAttribute holds an arbitrary, user-specified 
    container object (defaulting to a list) and brokers access to the 
    CollectionAdapter, a &quot;view&quot; onto that object that presents consistent bag 
    semantics to the orm layer independent of the user data implementation. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">uses_objects = </span><span class="s3">True</span>
    <span class="s1">collection = </span><span class="s3">True</span>
    <span class="s1">default_accepts_scalar_loader = </span><span class="s3">False</span>
    <span class="s1">supports_population = </span><span class="s3">True</span>
    <span class="s1">dynamic = </span><span class="s3">False</span>

    <span class="s1">_bulk_replace_token: AttributeEventToken</span>

    <span class="s1">__slots__ = (</span>
        <span class="s4">&quot;copy&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;collection_factory&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;_append_token&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;_remove_token&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;_bulk_replace_token&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;_duck_typed_as&quot;</span><span class="s5">,</span>
    <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">class_</span><span class="s5">,</span>
        <span class="s1">key</span><span class="s5">,</span>
        <span class="s1">callable_</span><span class="s5">,</span>
        <span class="s1">dispatch</span><span class="s5">,</span>
        <span class="s1">typecallable=</span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">trackparent=</span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">copy_function=</span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">compare_function=</span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">**kwargs</span><span class="s5">,</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">class_</span><span class="s5">,</span>
            <span class="s1">key</span><span class="s5">,</span>
            <span class="s1">callable_</span><span class="s5">,</span>
            <span class="s1">dispatch</span><span class="s5">,</span>
            <span class="s1">trackparent=trackparent</span><span class="s5">,</span>
            <span class="s1">compare_function=compare_function</span><span class="s5">,</span>
            <span class="s1">**kwargs</span><span class="s5">,</span>
        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">copy_function </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">copy_function = self.__copy</span>
        <span class="s1">self.copy = copy_function</span>
        <span class="s1">self.collection_factory = typecallable</span>
        <span class="s1">self._append_token = AttributeEventToken(self</span><span class="s5">, </span><span class="s1">OP_APPEND)</span>
        <span class="s1">self._remove_token = AttributeEventToken(self</span><span class="s5">, </span><span class="s1">OP_REMOVE)</span>
        <span class="s1">self._bulk_replace_token = AttributeEventToken(self</span><span class="s5">, </span><span class="s1">OP_BULK_REPLACE)</span>
        <span class="s1">self._duck_typed_as = util.duck_type_collection(</span>
            <span class="s1">self.collection_factory()</span>
        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">getattr(self.collection_factory</span><span class="s5">, </span><span class="s4">&quot;_sa_linker&quot;</span><span class="s5">, </span><span class="s3">None</span><span class="s1">):</span>

            <span class="s1">@event.listens_for(self</span><span class="s5">, </span><span class="s4">&quot;init_collection&quot;</span><span class="s1">)</span>
            <span class="s3">def </span><span class="s1">link(target</span><span class="s5">, </span><span class="s1">collection</span><span class="s5">, </span><span class="s1">collection_adapter):</span>
                <span class="s1">collection._sa_linker(collection_adapter)</span>

            <span class="s1">@event.listens_for(self</span><span class="s5">, </span><span class="s4">&quot;dispose_collection&quot;</span><span class="s1">)</span>
            <span class="s3">def </span><span class="s1">unlink(target</span><span class="s5">, </span><span class="s1">collection</span><span class="s5">, </span><span class="s1">collection_adapter):</span>
                <span class="s1">collection._sa_linker(</span><span class="s3">None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__copy(self</span><span class="s5">, </span><span class="s1">item):</span>
        <span class="s3">return </span><span class="s1">[y </span><span class="s3">for </span><span class="s1">y </span><span class="s3">in </span><span class="s1">collections.collection_adapter(item)]</span>

    <span class="s3">def </span><span class="s1">get_history(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">passive: PassiveFlag = PASSIVE_OFF</span><span class="s5">,</span>
    <span class="s1">) -&gt; History:</span>
        <span class="s1">current = self.get(state</span><span class="s5">, </span><span class="s1">dict_</span><span class="s5">, </span><span class="s1">passive=passive)</span>

        <span class="s3">if </span><span class="s1">current </span><span class="s3">is </span><span class="s1">PASSIVE_NO_RESULT:</span>
            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">passive &amp; PassiveFlag.INCLUDE_PENDING_MUTATIONS</span>
                <span class="s3">and </span><span class="s1">self.key </span><span class="s3">in </span><span class="s1">state._pending_mutations</span>
            <span class="s1">):</span>
                <span class="s1">pending = state._pending_mutations[self.key]</span>
                <span class="s3">return </span><span class="s1">pending.merge_with_history(HISTORY_BLANK)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">HISTORY_BLANK</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">passive &amp; PassiveFlag.INCLUDE_PENDING_MUTATIONS:</span>
                <span class="s0"># this collection is loaded / present.  should not be any</span>
                <span class="s0"># pending mutations</span>
                <span class="s3">assert </span><span class="s1">self.key </span><span class="s3">not in </span><span class="s1">state._pending_mutations</span>

            <span class="s3">return </span><span class="s1">History.from_collection(self</span><span class="s5">, </span><span class="s1">state</span><span class="s5">, </span><span class="s1">current)</span>

    <span class="s3">def </span><span class="s1">get_all_pending(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">passive: PassiveFlag = PASSIVE_NO_INITIALIZE</span><span class="s5">,</span>
    <span class="s1">) -&gt; _AllPendingType:</span>
        <span class="s0"># NOTE: passive is ignored here at the moment</span>

        <span class="s3">if </span><span class="s1">self.key </span><span class="s3">not in </span><span class="s1">dict_:</span>
            <span class="s3">return </span><span class="s1">[]</span>

        <span class="s1">current = dict_[self.key]</span>
        <span class="s1">current = getattr(current</span><span class="s5">, </span><span class="s4">&quot;_sa_adapter&quot;</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">self.key </span><span class="s3">in </span><span class="s1">state.committed_state:</span>
            <span class="s1">original = state.committed_state[self.key]</span>
            <span class="s3">if </span><span class="s1">original </span><span class="s3">is not </span><span class="s1">NO_VALUE:</span>
                <span class="s1">current_states = [</span>
                    <span class="s1">((c </span><span class="s3">is not None</span><span class="s1">) </span><span class="s3">and </span><span class="s1">instance_state(c) </span><span class="s3">or None</span><span class="s5">, </span><span class="s1">c)</span>
                    <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">current</span>
                <span class="s1">]</span>
                <span class="s1">original_states = [</span>
                    <span class="s1">((c </span><span class="s3">is not None</span><span class="s1">) </span><span class="s3">and </span><span class="s1">instance_state(c) </span><span class="s3">or None</span><span class="s5">, </span><span class="s1">c)</span>
                    <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">original</span>
                <span class="s1">]</span>

                <span class="s1">current_set = dict(current_states)</span>
                <span class="s1">original_set = dict(original_states)</span>

                <span class="s3">return </span><span class="s1">(</span>
                    <span class="s1">[</span>
                        <span class="s1">(s</span><span class="s5">, </span><span class="s1">o)</span>
                        <span class="s3">for </span><span class="s1">s</span><span class="s5">, </span><span class="s1">o </span><span class="s3">in </span><span class="s1">current_states</span>
                        <span class="s3">if </span><span class="s1">s </span><span class="s3">not in </span><span class="s1">original_set</span>
                    <span class="s1">]</span>
                    <span class="s1">+ [(s</span><span class="s5">, </span><span class="s1">o) </span><span class="s3">for </span><span class="s1">s</span><span class="s5">, </span><span class="s1">o </span><span class="s3">in </span><span class="s1">current_states </span><span class="s3">if </span><span class="s1">s </span><span class="s3">in </span><span class="s1">original_set]</span>
                    <span class="s1">+ [</span>
                        <span class="s1">(s</span><span class="s5">, </span><span class="s1">o)</span>
                        <span class="s3">for </span><span class="s1">s</span><span class="s5">, </span><span class="s1">o </span><span class="s3">in </span><span class="s1">original_states</span>
                        <span class="s3">if </span><span class="s1">s </span><span class="s3">not in </span><span class="s1">current_set</span>
                    <span class="s1">]</span>
                <span class="s1">)</span>

        <span class="s3">return </span><span class="s1">[(instance_state(o)</span><span class="s5">, </span><span class="s1">o) </span><span class="s3">for </span><span class="s1">o </span><span class="s3">in </span><span class="s1">current]</span>

    <span class="s3">def </span><span class="s1">fire_append_event(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">value: _T</span><span class="s5">,</span>
        <span class="s1">initiator: Optional[AttributeEventToken]</span><span class="s5">,</span>
        <span class="s1">key: Optional[Any]</span><span class="s5">,</span>
    <span class="s1">) -&gt; _T:</span>
        <span class="s3">for </span><span class="s1">fn </span><span class="s3">in </span><span class="s1">self.dispatch.append:</span>
            <span class="s1">value = fn(state</span><span class="s5">, </span><span class="s1">value</span><span class="s5">, </span><span class="s1">initiator </span><span class="s3">or </span><span class="s1">self._append_token</span><span class="s5">, </span><span class="s1">key=key)</span>

        <span class="s1">state._modified_event(dict_</span><span class="s5">, </span><span class="s1">self</span><span class="s5">, </span><span class="s1">NO_VALUE</span><span class="s5">, </span><span class="s3">True</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">self.trackparent </span><span class="s3">and </span><span class="s1">value </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.sethasparent(instance_state(value)</span><span class="s5">, </span><span class="s1">state</span><span class="s5">, </span><span class="s3">True</span><span class="s1">)</span>

        <span class="s3">return </span><span class="s1">value</span>

    <span class="s3">def </span><span class="s1">fire_append_wo_mutation_event(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">value: _T</span><span class="s5">,</span>
        <span class="s1">initiator: Optional[AttributeEventToken]</span><span class="s5">,</span>
        <span class="s1">key: Optional[Any]</span><span class="s5">,</span>
    <span class="s1">) -&gt; _T:</span>
        <span class="s3">for </span><span class="s1">fn </span><span class="s3">in </span><span class="s1">self.dispatch.append_wo_mutation:</span>
            <span class="s1">value = fn(state</span><span class="s5">, </span><span class="s1">value</span><span class="s5">, </span><span class="s1">initiator </span><span class="s3">or </span><span class="s1">self._append_token</span><span class="s5">, </span><span class="s1">key=key)</span>

        <span class="s3">return </span><span class="s1">value</span>

    <span class="s3">def </span><span class="s1">fire_pre_remove_event(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">initiator: Optional[AttributeEventToken]</span><span class="s5">,</span>
        <span class="s1">key: Optional[Any]</span><span class="s5">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;A special event used for pop() operations. 
 
        The &quot;remove&quot; event needs to have the item to be removed passed to 
        it, which in the case of pop from a set, we don't have a way to access 
        the item before the operation.   the event is used for all pop() 
        operations (even though set.pop is the one where it is really needed). 
 
        &quot;&quot;&quot;</span>
        <span class="s1">state._modified_event(dict_</span><span class="s5">, </span><span class="s1">self</span><span class="s5">, </span><span class="s1">NO_VALUE</span><span class="s5">, </span><span class="s3">True</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">fire_remove_event(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">value: Any</span><span class="s5">,</span>
        <span class="s1">initiator: Optional[AttributeEventToken]</span><span class="s5">,</span>
        <span class="s1">key: Optional[Any]</span><span class="s5">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">self.trackparent </span><span class="s3">and </span><span class="s1">value </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.sethasparent(instance_state(value)</span><span class="s5">, </span><span class="s1">state</span><span class="s5">, </span><span class="s3">False</span><span class="s1">)</span>

        <span class="s3">for </span><span class="s1">fn </span><span class="s3">in </span><span class="s1">self.dispatch.remove:</span>
            <span class="s1">fn(state</span><span class="s5">, </span><span class="s1">value</span><span class="s5">, </span><span class="s1">initiator </span><span class="s3">or </span><span class="s1">self._remove_token</span><span class="s5">, </span><span class="s1">key=key)</span>

        <span class="s1">state._modified_event(dict_</span><span class="s5">, </span><span class="s1">self</span><span class="s5">, </span><span class="s1">NO_VALUE</span><span class="s5">, </span><span class="s3">True</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">delete(self</span><span class="s5">, </span><span class="s1">state: InstanceState[Any]</span><span class="s5">, </span><span class="s1">dict_: _InstanceDict) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">self.key </span><span class="s3">not in </span><span class="s1">dict_:</span>
            <span class="s3">return</span>

        <span class="s1">state._modified_event(dict_</span><span class="s5">, </span><span class="s1">self</span><span class="s5">, </span><span class="s1">NO_VALUE</span><span class="s5">, </span><span class="s3">True</span><span class="s1">)</span>

        <span class="s1">collection = self.get_collection(state</span><span class="s5">, </span><span class="s1">state.dict)</span>
        <span class="s1">collection.clear_with_event()</span>

        <span class="s0"># key is always present because we checked above.  e.g.</span>
        <span class="s0"># del is a no-op if collection not present.</span>
        <span class="s3">del </span><span class="s1">dict_[self.key]</span>

    <span class="s3">def </span><span class="s1">_default_value(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">state: InstanceState[Any]</span><span class="s5">, </span><span class="s1">dict_: _InstanceDict</span>
    <span class="s1">) -&gt; _AdaptedCollectionProtocol:</span>
        <span class="s2">&quot;&quot;&quot;Produce an empty collection for an un-initialized attribute&quot;&quot;&quot;</span>

        <span class="s3">assert </span><span class="s1">self.key </span><span class="s3">not in </span><span class="s1">dict_</span><span class="s5">, </span><span class="s1">(</span>
            <span class="s4">&quot;_default_value should only be invoked for an &quot;</span>
            <span class="s4">&quot;uninitialized or expired attribute&quot;</span>
        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">self.key </span><span class="s3">in </span><span class="s1">state._empty_collections:</span>
            <span class="s3">return </span><span class="s1">state._empty_collections[self.key]</span>

        <span class="s1">adapter</span><span class="s5">, </span><span class="s1">user_data = self._initialize_collection(state)</span>
        <span class="s1">adapter._set_empty(user_data)</span>
        <span class="s3">return </span><span class="s1">user_data</span>

    <span class="s3">def </span><span class="s1">_initialize_collection(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">state: InstanceState[Any]</span>
    <span class="s1">) -&gt; Tuple[CollectionAdapter</span><span class="s5">, </span><span class="s1">_AdaptedCollectionProtocol]:</span>
        <span class="s1">adapter</span><span class="s5">, </span><span class="s1">collection = state.manager.initialize_collection(</span>
            <span class="s1">self.key</span><span class="s5">, </span><span class="s1">state</span><span class="s5">, </span><span class="s1">self.collection_factory</span>
        <span class="s1">)</span>

        <span class="s1">self.dispatch.init_collection(state</span><span class="s5">, </span><span class="s1">collection</span><span class="s5">, </span><span class="s1">adapter)</span>

        <span class="s3">return </span><span class="s1">adapter</span><span class="s5">, </span><span class="s1">collection</span>

    <span class="s3">def </span><span class="s1">append(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">value: Any</span><span class="s5">,</span>
        <span class="s1">initiator: Optional[AttributeEventToken]</span><span class="s5">,</span>
        <span class="s1">passive: PassiveFlag = PASSIVE_OFF</span><span class="s5">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">collection = self.get_collection(</span>
            <span class="s1">state</span><span class="s5">, </span><span class="s1">dict_</span><span class="s5">, </span><span class="s1">user_data=</span><span class="s3">None</span><span class="s5">, </span><span class="s1">passive=passive</span>
        <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">collection </span><span class="s3">is </span><span class="s1">PASSIVE_NO_RESULT:</span>
            <span class="s1">value = self.fire_append_event(</span>
                <span class="s1">state</span><span class="s5">, </span><span class="s1">dict_</span><span class="s5">, </span><span class="s1">value</span><span class="s5">, </span><span class="s1">initiator</span><span class="s5">, </span><span class="s1">key=NO_KEY</span>
            <span class="s1">)</span>
            <span class="s3">assert </span><span class="s1">(</span>
                <span class="s1">self.key </span><span class="s3">not in </span><span class="s1">dict_</span>
            <span class="s1">)</span><span class="s5">, </span><span class="s4">&quot;Collection was loaded during event handling.&quot;</span>
            <span class="s1">state._get_pending_mutation(self.key).append(value)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">TYPE_CHECKING:</span>
                <span class="s3">assert </span><span class="s1">isinstance(collection</span><span class="s5">, </span><span class="s1">CollectionAdapter)</span>
            <span class="s1">collection.append_with_event(value</span><span class="s5">, </span><span class="s1">initiator)</span>

    <span class="s3">def </span><span class="s1">remove(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">value: Any</span><span class="s5">,</span>
        <span class="s1">initiator: Optional[AttributeEventToken]</span><span class="s5">,</span>
        <span class="s1">passive: PassiveFlag = PASSIVE_OFF</span><span class="s5">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">collection = self.get_collection(</span>
            <span class="s1">state</span><span class="s5">, </span><span class="s1">state.dict</span><span class="s5">, </span><span class="s1">user_data=</span><span class="s3">None</span><span class="s5">, </span><span class="s1">passive=passive</span>
        <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">collection </span><span class="s3">is </span><span class="s1">PASSIVE_NO_RESULT:</span>
            <span class="s1">self.fire_remove_event(state</span><span class="s5">, </span><span class="s1">dict_</span><span class="s5">, </span><span class="s1">value</span><span class="s5">, </span><span class="s1">initiator</span><span class="s5">, </span><span class="s1">key=NO_KEY)</span>
            <span class="s3">assert </span><span class="s1">(</span>
                <span class="s1">self.key </span><span class="s3">not in </span><span class="s1">dict_</span>
            <span class="s1">)</span><span class="s5">, </span><span class="s4">&quot;Collection was loaded during event handling.&quot;</span>
            <span class="s1">state._get_pending_mutation(self.key).remove(value)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">TYPE_CHECKING:</span>
                <span class="s3">assert </span><span class="s1">isinstance(collection</span><span class="s5">, </span><span class="s1">CollectionAdapter)</span>
            <span class="s1">collection.remove_with_event(value</span><span class="s5">, </span><span class="s1">initiator)</span>

    <span class="s3">def </span><span class="s1">pop(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">value: Any</span><span class="s5">,</span>
        <span class="s1">initiator: Optional[AttributeEventToken]</span><span class="s5">,</span>
        <span class="s1">passive: PassiveFlag = PASSIVE_OFF</span><span class="s5">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s0"># TODO: better solution here would be to add</span>
            <span class="s0"># a &quot;popper&quot; role to collections.py to complement</span>
            <span class="s0"># &quot;remover&quot;.</span>
            <span class="s1">self.remove(state</span><span class="s5">, </span><span class="s1">dict_</span><span class="s5">, </span><span class="s1">value</span><span class="s5">, </span><span class="s1">initiator</span><span class="s5">, </span><span class="s1">passive=passive)</span>
        <span class="s3">except </span><span class="s1">(ValueError</span><span class="s5">, </span><span class="s1">KeyError</span><span class="s5">, </span><span class="s1">IndexError):</span>
            <span class="s3">pass</span>

    <span class="s3">def </span><span class="s1">set(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">value: Any</span><span class="s5">,</span>
        <span class="s1">initiator: Optional[AttributeEventToken] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">passive: PassiveFlag = PassiveFlag.PASSIVE_OFF</span><span class="s5">,</span>
        <span class="s1">check_old: Any = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">pop: bool = </span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">_adapt: bool = </span><span class="s3">True</span><span class="s5">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">iterable = orig_iterable = value</span>
        <span class="s1">new_keys = </span><span class="s3">None</span>

        <span class="s0"># pulling a new collection first so that an adaptation exception does</span>
        <span class="s0"># not trigger a lazy load of the old collection.</span>
        <span class="s1">new_collection</span><span class="s5">, </span><span class="s1">user_data = self._initialize_collection(state)</span>
        <span class="s3">if </span><span class="s1">_adapt:</span>
            <span class="s3">if </span><span class="s1">new_collection._converter </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">iterable = new_collection._converter(iterable)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">setting_type = util.duck_type_collection(iterable)</span>
                <span class="s1">receiving_type = self._duck_typed_as</span>

                <span class="s3">if </span><span class="s1">setting_type </span><span class="s3">is not </span><span class="s1">receiving_type:</span>
                    <span class="s1">given = (</span>
                        <span class="s1">iterable </span><span class="s3">is None</span>
                        <span class="s3">and </span><span class="s4">&quot;None&quot;</span>
                        <span class="s3">or </span><span class="s1">iterable.__class__.__name__</span>
                    <span class="s1">)</span>
                    <span class="s1">wanted = self._duck_typed_as.__name__</span>
                    <span class="s3">raise </span><span class="s1">TypeError(</span>
                        <span class="s4">&quot;Incompatible collection type: %s is not %s-like&quot;</span>
                        <span class="s1">% (given</span><span class="s5">, </span><span class="s1">wanted)</span>
                    <span class="s1">)</span>

                <span class="s0"># If the object is an adapted collection, return the (iterable)</span>
                <span class="s0"># adapter.</span>
                <span class="s3">if </span><span class="s1">hasattr(iterable</span><span class="s5">, </span><span class="s4">&quot;_sa_iterator&quot;</span><span class="s1">):</span>
                    <span class="s1">iterable = iterable._sa_iterator()</span>
                <span class="s3">elif </span><span class="s1">setting_type </span><span class="s3">is </span><span class="s1">dict:</span>
                    <span class="s1">new_keys = list(iterable)</span>
                    <span class="s1">iterable = iterable.values()</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">iterable = iter(iterable)</span>
        <span class="s3">elif </span><span class="s1">util.duck_type_collection(iterable) </span><span class="s3">is </span><span class="s1">dict:</span>
            <span class="s1">new_keys = list(value)</span>

        <span class="s1">new_values = list(iterable)</span>

        <span class="s1">evt = self._bulk_replace_token</span>

        <span class="s1">self.dispatch.bulk_replace(state</span><span class="s5">, </span><span class="s1">new_values</span><span class="s5">, </span><span class="s1">evt</span><span class="s5">, </span><span class="s1">keys=new_keys)</span>

        <span class="s0"># propagate NO_RAISE in passive through to the get() for the</span>
        <span class="s0"># existing object (ticket #8862)</span>
        <span class="s1">old = self.get(</span>
            <span class="s1">state</span><span class="s5">,</span>
            <span class="s1">dict_</span><span class="s5">,</span>
            <span class="s1">passive=PASSIVE_ONLY_PERSISTENT ^ (passive &amp; PassiveFlag.NO_RAISE)</span><span class="s5">,</span>
        <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">old </span><span class="s3">is </span><span class="s1">PASSIVE_NO_RESULT:</span>
            <span class="s1">old = self._default_value(state</span><span class="s5">, </span><span class="s1">dict_)</span>
        <span class="s3">elif </span><span class="s1">old </span><span class="s3">is </span><span class="s1">orig_iterable:</span>
            <span class="s0"># ignore re-assignment of the current collection, as happens</span>
            <span class="s0"># implicitly with in-place operators (foo.collection |= other)</span>
            <span class="s3">return</span>

        <span class="s0"># place a copy of &quot;old&quot; in state.committed_state</span>
        <span class="s1">state._modified_event(dict_</span><span class="s5">, </span><span class="s1">self</span><span class="s5">, </span><span class="s1">old</span><span class="s5">, </span><span class="s3">True</span><span class="s1">)</span>

        <span class="s1">old_collection = old._sa_adapter</span>

        <span class="s1">dict_[self.key] = user_data</span>

        <span class="s1">collections.bulk_replace(</span>
            <span class="s1">new_values</span><span class="s5">, </span><span class="s1">old_collection</span><span class="s5">, </span><span class="s1">new_collection</span><span class="s5">, </span><span class="s1">initiator=evt</span>
        <span class="s1">)</span>

        <span class="s1">self._dispose_previous_collection(state</span><span class="s5">, </span><span class="s1">old</span><span class="s5">, </span><span class="s1">old_collection</span><span class="s5">, </span><span class="s3">True</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_dispose_previous_collection(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">collection: _AdaptedCollectionProtocol</span><span class="s5">,</span>
        <span class="s1">adapter: CollectionAdapter</span><span class="s5">,</span>
        <span class="s1">fire_event: bool</span><span class="s5">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">del </span><span class="s1">collection._sa_adapter</span>

        <span class="s0"># discarding old collection make sure it is not referenced in empty</span>
        <span class="s0"># collections.</span>
        <span class="s1">state._empty_collections.pop(self.key</span><span class="s5">, </span><span class="s3">None</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">fire_event:</span>
            <span class="s1">self.dispatch.dispose_collection(state</span><span class="s5">, </span><span class="s1">collection</span><span class="s5">, </span><span class="s1">adapter)</span>

    <span class="s3">def </span><span class="s1">_invalidate_collection(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">collection: _AdaptedCollectionProtocol</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">adapter = getattr(collection</span><span class="s5">, </span><span class="s4">&quot;_sa_adapter&quot;</span><span class="s1">)</span>
        <span class="s1">adapter.invalidated = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">set_committed_value(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">state: InstanceState[Any]</span><span class="s5">, </span><span class="s1">dict_: _InstanceDict</span><span class="s5">, </span><span class="s1">value: Any</span>
    <span class="s1">) -&gt; _AdaptedCollectionProtocol:</span>
        <span class="s2">&quot;&quot;&quot;Set an attribute value on the given instance and 'commit' it.&quot;&quot;&quot;</span>

        <span class="s1">collection</span><span class="s5">, </span><span class="s1">user_data = self._initialize_collection(state)</span>

        <span class="s3">if </span><span class="s1">value:</span>
            <span class="s1">collection.append_multiple_without_event(value)</span>

        <span class="s1">state.dict[self.key] = user_data</span>

        <span class="s1">state._commit(dict_</span><span class="s5">, </span><span class="s1">[self.key])</span>

        <span class="s3">if </span><span class="s1">self.key </span><span class="s3">in </span><span class="s1">state._pending_mutations:</span>
            <span class="s0"># pending items exist.  issue a modified event,</span>
            <span class="s0"># add/remove new items.</span>
            <span class="s1">state._modified_event(dict_</span><span class="s5">, </span><span class="s1">self</span><span class="s5">, </span><span class="s1">user_data</span><span class="s5">, </span><span class="s3">True</span><span class="s1">)</span>

            <span class="s1">pending = state._pending_mutations.pop(self.key)</span>
            <span class="s1">added = pending.added_items</span>
            <span class="s1">removed = pending.deleted_items</span>
            <span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">added:</span>
                <span class="s1">collection.append_without_event(item)</span>
            <span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">removed:</span>
                <span class="s1">collection.remove_without_event(item)</span>

        <span class="s3">return </span><span class="s1">user_data</span>

    <span class="s1">@overload</span>
    <span class="s3">def </span><span class="s1">get_collection(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">user_data: Literal[</span><span class="s3">None</span><span class="s1">] = ...</span><span class="s5">,</span>
        <span class="s1">passive: Literal[PassiveFlag.PASSIVE_OFF] = ...</span><span class="s5">,</span>
    <span class="s1">) -&gt; CollectionAdapter: ...</span>

    <span class="s1">@overload</span>
    <span class="s3">def </span><span class="s1">get_collection(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">user_data: _AdaptedCollectionProtocol = ...</span><span class="s5">,</span>
        <span class="s1">passive: PassiveFlag = ...</span><span class="s5">,</span>
    <span class="s1">) -&gt; CollectionAdapter: ...</span>

    <span class="s1">@overload</span>
    <span class="s3">def </span><span class="s1">get_collection(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">user_data: Optional[_AdaptedCollectionProtocol] = ...</span><span class="s5">,</span>
        <span class="s1">passive: PassiveFlag = PASSIVE_OFF</span><span class="s5">,</span>
    <span class="s1">) -&gt; Union[</span>
        <span class="s1">Literal[LoaderCallableStatus.PASSIVE_NO_RESULT]</span><span class="s5">, </span><span class="s1">CollectionAdapter</span>
    <span class="s1">]: ...</span>

    <span class="s3">def </span><span class="s1">get_collection(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dict_: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">user_data: Optional[_AdaptedCollectionProtocol] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">passive: PassiveFlag = PASSIVE_OFF</span><span class="s5">,</span>
    <span class="s1">) -&gt; Union[</span>
        <span class="s1">Literal[LoaderCallableStatus.PASSIVE_NO_RESULT]</span><span class="s5">, </span><span class="s1">CollectionAdapter</span>
    <span class="s1">]:</span>
        <span class="s2">&quot;&quot;&quot;Retrieve the CollectionAdapter associated with the given state. 
 
        if user_data is None, retrieves it from the state using normal 
        &quot;get()&quot; rules, which will fire lazy callables or return the &quot;empty&quot; 
        collection value. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">user_data </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">fetch_user_data = self.get(state</span><span class="s5">, </span><span class="s1">dict_</span><span class="s5">, </span><span class="s1">passive=passive)</span>
            <span class="s3">if </span><span class="s1">fetch_user_data </span><span class="s3">is </span><span class="s1">LoaderCallableStatus.PASSIVE_NO_RESULT:</span>
                <span class="s3">return </span><span class="s1">fetch_user_data</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">user_data = cast(</span><span class="s4">&quot;_AdaptedCollectionProtocol&quot;</span><span class="s5">, </span><span class="s1">fetch_user_data)</span>

        <span class="s3">return </span><span class="s1">user_data._sa_adapter</span>


<span class="s3">def </span><span class="s1">backref_listeners(</span>
    <span class="s1">attribute: QueryableAttribute[Any]</span><span class="s5">, </span><span class="s1">key: str</span><span class="s5">, </span><span class="s1">uselist: bool</span>
<span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Apply listeners to synchronize a two-way relationship.&quot;&quot;&quot;</span>

    <span class="s0"># use easily recognizable names for stack traces.</span>

    <span class="s0"># in the sections marked &quot;tokens to test for a recursive loop&quot;,</span>
    <span class="s0"># this is somewhat brittle and very performance-sensitive logic</span>
    <span class="s0"># that is specific to how we might arrive at each event.  a marker</span>
    <span class="s0"># that can target us directly to arguments being invoked against</span>
    <span class="s0"># the impl might be simpler, but could interfere with other systems.</span>

    <span class="s1">parent_token = attribute.impl.parent_token</span>
    <span class="s1">parent_impl = attribute.impl</span>

    <span class="s3">def </span><span class="s1">_acceptable_key_err(child_state</span><span class="s5">, </span><span class="s1">initiator</span><span class="s5">, </span><span class="s1">child_impl):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span>
            <span class="s4">&quot;Bidirectional attribute conflict detected: &quot;</span>
            <span class="s4">'Passing object %s to attribute &quot;%s&quot; '</span>
            <span class="s4">'triggers a modify event on attribute &quot;%s&quot; '</span>
            <span class="s4">'via the backref &quot;%s&quot;.'</span>
            <span class="s1">% (</span>
                <span class="s1">state_str(child_state)</span><span class="s5">,</span>
                <span class="s1">initiator.parent_token</span><span class="s5">,</span>
                <span class="s1">child_impl.parent_token</span><span class="s5">,</span>
                <span class="s1">attribute.impl.parent_token</span><span class="s5">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">emit_backref_from_scalar_set_event(</span>
        <span class="s1">state</span><span class="s5">, </span><span class="s1">child</span><span class="s5">, </span><span class="s1">oldchild</span><span class="s5">, </span><span class="s1">initiator</span><span class="s5">, </span><span class="s1">**kw</span>
    <span class="s1">):</span>
        <span class="s3">if </span><span class="s1">oldchild </span><span class="s3">is </span><span class="s1">child:</span>
            <span class="s3">return </span><span class="s1">child</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">oldchild </span><span class="s3">is not None</span>
            <span class="s3">and </span><span class="s1">oldchild </span><span class="s3">is not </span><span class="s1">PASSIVE_NO_RESULT</span>
            <span class="s3">and </span><span class="s1">oldchild </span><span class="s3">is not </span><span class="s1">NO_VALUE</span>
        <span class="s1">):</span>
            <span class="s0"># With lazy=None, there's no guarantee that the full collection is</span>
            <span class="s0"># present when updating via a backref.</span>
            <span class="s1">old_state</span><span class="s5">, </span><span class="s1">old_dict = (</span>
                <span class="s1">instance_state(oldchild)</span><span class="s5">,</span>
                <span class="s1">instance_dict(oldchild)</span><span class="s5">,</span>
            <span class="s1">)</span>
            <span class="s1">impl = old_state.manager[key].impl</span>

            <span class="s0"># tokens to test for a recursive loop.</span>
            <span class="s3">if not </span><span class="s1">impl.collection </span><span class="s3">and not </span><span class="s1">impl.dynamic:</span>
                <span class="s1">check_recursive_token = impl._replace_token</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">check_recursive_token = impl._remove_token</span>

            <span class="s3">if </span><span class="s1">initiator </span><span class="s3">is not </span><span class="s1">check_recursive_token:</span>
                <span class="s1">impl.pop(</span>
                    <span class="s1">old_state</span><span class="s5">,</span>
                    <span class="s1">old_dict</span><span class="s5">,</span>
                    <span class="s1">state.obj()</span><span class="s5">,</span>
                    <span class="s1">parent_impl._append_token</span><span class="s5">,</span>
                    <span class="s1">passive=PASSIVE_NO_FETCH</span><span class="s5">,</span>
                <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">child </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">child_state</span><span class="s5">, </span><span class="s1">child_dict = (</span>
                <span class="s1">instance_state(child)</span><span class="s5">,</span>
                <span class="s1">instance_dict(child)</span><span class="s5">,</span>
            <span class="s1">)</span>
            <span class="s1">child_impl = child_state.manager[key].impl</span>

            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">initiator.parent_token </span><span class="s3">is not </span><span class="s1">parent_token</span>
                <span class="s3">and </span><span class="s1">initiator.parent_token </span><span class="s3">is not </span><span class="s1">child_impl.parent_token</span>
            <span class="s1">):</span>
                <span class="s1">_acceptable_key_err(state</span><span class="s5">, </span><span class="s1">initiator</span><span class="s5">, </span><span class="s1">child_impl)</span>

            <span class="s0"># tokens to test for a recursive loop.</span>
            <span class="s1">check_append_token = child_impl._append_token</span>
            <span class="s1">check_bulk_replace_token = (</span>
                <span class="s1">child_impl._bulk_replace_token</span>
                <span class="s3">if </span><span class="s1">_is_collection_attribute_impl(child_impl)</span>
                <span class="s3">else None</span>
            <span class="s1">)</span>

            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">initiator </span><span class="s3">is not </span><span class="s1">check_append_token</span>
                <span class="s3">and </span><span class="s1">initiator </span><span class="s3">is not </span><span class="s1">check_bulk_replace_token</span>
            <span class="s1">):</span>
                <span class="s1">child_impl.append(</span>
                    <span class="s1">child_state</span><span class="s5">,</span>
                    <span class="s1">child_dict</span><span class="s5">,</span>
                    <span class="s1">state.obj()</span><span class="s5">,</span>
                    <span class="s1">initiator</span><span class="s5">,</span>
                    <span class="s1">passive=PASSIVE_NO_FETCH</span><span class="s5">,</span>
                <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">child</span>

    <span class="s3">def </span><span class="s1">emit_backref_from_collection_append_event(</span>
        <span class="s1">state</span><span class="s5">, </span><span class="s1">child</span><span class="s5">, </span><span class="s1">initiator</span><span class="s5">, </span><span class="s1">**kw</span>
    <span class="s1">):</span>
        <span class="s3">if </span><span class="s1">child </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return</span>

        <span class="s1">child_state</span><span class="s5">, </span><span class="s1">child_dict = instance_state(child)</span><span class="s5">, </span><span class="s1">instance_dict(child)</span>
        <span class="s1">child_impl = child_state.manager[key].impl</span>

        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">initiator.parent_token </span><span class="s3">is not </span><span class="s1">parent_token</span>
            <span class="s3">and </span><span class="s1">initiator.parent_token </span><span class="s3">is not </span><span class="s1">child_impl.parent_token</span>
        <span class="s1">):</span>
            <span class="s1">_acceptable_key_err(state</span><span class="s5">, </span><span class="s1">initiator</span><span class="s5">, </span><span class="s1">child_impl)</span>

        <span class="s0"># tokens to test for a recursive loop.</span>
        <span class="s1">check_append_token = child_impl._append_token</span>
        <span class="s1">check_bulk_replace_token = (</span>
            <span class="s1">child_impl._bulk_replace_token</span>
            <span class="s3">if </span><span class="s1">_is_collection_attribute_impl(child_impl)</span>
            <span class="s3">else None</span>
        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">initiator </span><span class="s3">is not </span><span class="s1">check_append_token</span>
            <span class="s3">and </span><span class="s1">initiator </span><span class="s3">is not </span><span class="s1">check_bulk_replace_token</span>
        <span class="s1">):</span>
            <span class="s1">child_impl.append(</span>
                <span class="s1">child_state</span><span class="s5">,</span>
                <span class="s1">child_dict</span><span class="s5">,</span>
                <span class="s1">state.obj()</span><span class="s5">,</span>
                <span class="s1">initiator</span><span class="s5">,</span>
                <span class="s1">passive=PASSIVE_NO_FETCH</span><span class="s5">,</span>
            <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">child</span>

    <span class="s3">def </span><span class="s1">emit_backref_from_collection_remove_event(</span>
        <span class="s1">state</span><span class="s5">, </span><span class="s1">child</span><span class="s5">, </span><span class="s1">initiator</span><span class="s5">, </span><span class="s1">**kw</span>
    <span class="s1">):</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">child </span><span class="s3">is not None</span>
            <span class="s3">and </span><span class="s1">child </span><span class="s3">is not </span><span class="s1">PASSIVE_NO_RESULT</span>
            <span class="s3">and </span><span class="s1">child </span><span class="s3">is not </span><span class="s1">NO_VALUE</span>
        <span class="s1">):</span>
            <span class="s1">child_state</span><span class="s5">, </span><span class="s1">child_dict = (</span>
                <span class="s1">instance_state(child)</span><span class="s5">,</span>
                <span class="s1">instance_dict(child)</span><span class="s5">,</span>
            <span class="s1">)</span>
            <span class="s1">child_impl = child_state.manager[key].impl</span>

            <span class="s1">check_replace_token: Optional[AttributeEventToken]</span>

            <span class="s0"># tokens to test for a recursive loop.</span>
            <span class="s3">if not </span><span class="s1">child_impl.collection </span><span class="s3">and not </span><span class="s1">child_impl.dynamic:</span>
                <span class="s1">check_remove_token = child_impl._remove_token</span>
                <span class="s1">check_replace_token = child_impl._replace_token</span>
                <span class="s1">check_for_dupes_on_remove = uselist </span><span class="s3">and not </span><span class="s1">parent_impl.dynamic</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">check_remove_token = child_impl._remove_token</span>
                <span class="s1">check_replace_token = (</span>
                    <span class="s1">child_impl._bulk_replace_token</span>
                    <span class="s3">if </span><span class="s1">_is_collection_attribute_impl(child_impl)</span>
                    <span class="s3">else None</span>
                <span class="s1">)</span>
                <span class="s1">check_for_dupes_on_remove = </span><span class="s3">False</span>

            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">initiator </span><span class="s3">is not </span><span class="s1">check_remove_token</span>
                <span class="s3">and </span><span class="s1">initiator </span><span class="s3">is not </span><span class="s1">check_replace_token</span>
            <span class="s1">):</span>
                <span class="s3">if not </span><span class="s1">check_for_dupes_on_remove </span><span class="s3">or not </span><span class="s1">util.has_dupes(</span>
                    <span class="s0"># when this event is called, the item is usually</span>
                    <span class="s0"># present in the list, except for a pop() operation.</span>
                    <span class="s1">state.dict[parent_impl.key]</span><span class="s5">,</span>
                    <span class="s1">child</span><span class="s5">,</span>
                <span class="s1">):</span>
                    <span class="s1">child_impl.pop(</span>
                        <span class="s1">child_state</span><span class="s5">,</span>
                        <span class="s1">child_dict</span><span class="s5">,</span>
                        <span class="s1">state.obj()</span><span class="s5">,</span>
                        <span class="s1">initiator</span><span class="s5">,</span>
                        <span class="s1">passive=PASSIVE_NO_FETCH</span><span class="s5">,</span>
                    <span class="s1">)</span>

    <span class="s3">if </span><span class="s1">uselist:</span>
        <span class="s1">event.listen(</span>
            <span class="s1">attribute</span><span class="s5">,</span>
            <span class="s4">&quot;append&quot;</span><span class="s5">,</span>
            <span class="s1">emit_backref_from_collection_append_event</span><span class="s5">,</span>
            <span class="s1">retval=</span><span class="s3">True</span><span class="s5">,</span>
            <span class="s1">raw=</span><span class="s3">True</span><span class="s5">,</span>
            <span class="s1">include_key=</span><span class="s3">True</span><span class="s5">,</span>
        <span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">event.listen(</span>
            <span class="s1">attribute</span><span class="s5">,</span>
            <span class="s4">&quot;set&quot;</span><span class="s5">,</span>
            <span class="s1">emit_backref_from_scalar_set_event</span><span class="s5">,</span>
            <span class="s1">retval=</span><span class="s3">True</span><span class="s5">,</span>
            <span class="s1">raw=</span><span class="s3">True</span><span class="s5">,</span>
            <span class="s1">include_key=</span><span class="s3">True</span><span class="s5">,</span>
        <span class="s1">)</span>
    <span class="s0"># TODO: need coverage in test/orm/ of remove event</span>
    <span class="s1">event.listen(</span>
        <span class="s1">attribute</span><span class="s5">,</span>
        <span class="s4">&quot;remove&quot;</span><span class="s5">,</span>
        <span class="s1">emit_backref_from_collection_remove_event</span><span class="s5">,</span>
        <span class="s1">retval=</span><span class="s3">True</span><span class="s5">,</span>
        <span class="s1">raw=</span><span class="s3">True</span><span class="s5">,</span>
        <span class="s1">include_key=</span><span class="s3">True</span><span class="s5">,</span>
    <span class="s1">)</span>


<span class="s1">_NO_HISTORY = util.symbol(</span><span class="s4">&quot;NO_HISTORY&quot;</span><span class="s1">)</span>
<span class="s1">_NO_STATE_SYMBOLS = frozenset([id(PASSIVE_NO_RESULT)</span><span class="s5">, </span><span class="s1">id(NO_VALUE)])</span>


<span class="s3">class </span><span class="s1">History(NamedTuple):</span>
    <span class="s2">&quot;&quot;&quot;A 3-tuple of added, unchanged and deleted values, 
    representing the changes which have occurred on an instrumented 
    attribute. 
 
    The easiest way to get a :class:`.History` object for a particular 
    attribute on an object is to use the :func:`_sa.inspect` function:: 
 
        from sqlalchemy import inspect 
 
        hist = inspect(myobject).attrs.myattribute.history 
 
    Each tuple member is an iterable sequence: 
 
    * ``added`` - the collection of items added to the attribute (the first 
      tuple element). 
 
    * ``unchanged`` - the collection of items that have not changed on the 
      attribute (the second tuple element). 
 
    * ``deleted`` - the collection of items that have been removed from the 
      attribute (the third tuple element). 
 
    &quot;&quot;&quot;</span>

    <span class="s1">added: Union[Tuple[()]</span><span class="s5">, </span><span class="s1">List[Any]]</span>
    <span class="s1">unchanged: Union[Tuple[()]</span><span class="s5">, </span><span class="s1">List[Any]]</span>
    <span class="s1">deleted: Union[Tuple[()]</span><span class="s5">, </span><span class="s1">List[Any]]</span>

    <span class="s3">def </span><span class="s1">__bool__(self) -&gt; bool:</span>
        <span class="s3">return </span><span class="s1">self != HISTORY_BLANK</span>

    <span class="s3">def </span><span class="s1">empty(self) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot;Return True if this :class:`.History` has no changes 
        and no existing, unchanged state. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return not </span><span class="s1">bool((self.added </span><span class="s3">or </span><span class="s1">self.deleted) </span><span class="s3">or </span><span class="s1">self.unchanged)</span>

    <span class="s3">def </span><span class="s1">sum(self) -&gt; Sequence[Any]:</span>
        <span class="s2">&quot;&quot;&quot;Return a collection of added + unchanged + deleted.&quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">(</span>
            <span class="s1">(self.added </span><span class="s3">or </span><span class="s1">[]) + (self.unchanged </span><span class="s3">or </span><span class="s1">[]) + (self.deleted </span><span class="s3">or </span><span class="s1">[])</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">non_deleted(self) -&gt; Sequence[Any]:</span>
        <span class="s2">&quot;&quot;&quot;Return a collection of added + unchanged.&quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">(self.added </span><span class="s3">or </span><span class="s1">[]) + (self.unchanged </span><span class="s3">or </span><span class="s1">[])</span>

    <span class="s3">def </span><span class="s1">non_added(self) -&gt; Sequence[Any]:</span>
        <span class="s2">&quot;&quot;&quot;Return a collection of unchanged + deleted.&quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">(self.unchanged </span><span class="s3">or </span><span class="s1">[]) + (self.deleted </span><span class="s3">or </span><span class="s1">[])</span>

    <span class="s3">def </span><span class="s1">has_changes(self) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot;Return True if this :class:`.History` has changes.&quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">bool(self.added </span><span class="s3">or </span><span class="s1">self.deleted)</span>

    <span class="s3">def </span><span class="s1">_merge(self</span><span class="s5">, </span><span class="s1">added: Iterable[Any]</span><span class="s5">, </span><span class="s1">deleted: Iterable[Any]) -&gt; History:</span>
        <span class="s3">return </span><span class="s1">History(</span>
            <span class="s1">list(self.added) + list(added)</span><span class="s5">,</span>
            <span class="s1">self.unchanged</span><span class="s5">,</span>
            <span class="s1">list(self.deleted) + list(deleted)</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">as_state(self) -&gt; History:</span>
        <span class="s3">return </span><span class="s1">History(</span>
            <span class="s1">[</span>
                <span class="s1">(c </span><span class="s3">is not None</span><span class="s1">) </span><span class="s3">and </span><span class="s1">instance_state(c) </span><span class="s3">or None</span>
                <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">self.added</span>
            <span class="s1">]</span><span class="s5">,</span>
            <span class="s1">[</span>
                <span class="s1">(c </span><span class="s3">is not None</span><span class="s1">) </span><span class="s3">and </span><span class="s1">instance_state(c) </span><span class="s3">or None</span>
                <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">self.unchanged</span>
            <span class="s1">]</span><span class="s5">,</span>
            <span class="s1">[</span>
                <span class="s1">(c </span><span class="s3">is not None</span><span class="s1">) </span><span class="s3">and </span><span class="s1">instance_state(c) </span><span class="s3">or None</span>
                <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">self.deleted</span>
            <span class="s1">]</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">from_scalar_attribute(</span>
        <span class="s1">cls</span><span class="s5">,</span>
        <span class="s1">attribute: ScalarAttributeImpl</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">current: Any</span><span class="s5">,</span>
    <span class="s1">) -&gt; History:</span>
        <span class="s1">original = state.committed_state.get(attribute.key</span><span class="s5">, </span><span class="s1">_NO_HISTORY)</span>

        <span class="s1">deleted: Union[Tuple[()]</span><span class="s5">, </span><span class="s1">List[Any]]</span>

        <span class="s3">if </span><span class="s1">original </span><span class="s3">is </span><span class="s1">_NO_HISTORY:</span>
            <span class="s3">if </span><span class="s1">current </span><span class="s3">is </span><span class="s1">NO_VALUE:</span>
                <span class="s3">return </span><span class="s1">cls(()</span><span class="s5">, </span><span class="s1">()</span><span class="s5">, </span><span class="s1">())</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">cls(()</span><span class="s5">, </span><span class="s1">[current]</span><span class="s5">, </span><span class="s1">())</span>
        <span class="s0"># don't let ClauseElement expressions here trip things up</span>
        <span class="s3">elif </span><span class="s1">(</span>
            <span class="s1">current </span><span class="s3">is not </span><span class="s1">NO_VALUE</span>
            <span class="s3">and </span><span class="s1">attribute.is_equal(current</span><span class="s5">, </span><span class="s1">original) </span><span class="s3">is True</span>
        <span class="s1">):</span>
            <span class="s3">return </span><span class="s1">cls(()</span><span class="s5">, </span><span class="s1">[current]</span><span class="s5">, </span><span class="s1">())</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># current convention on native scalars is to not</span>
            <span class="s0"># include information</span>
            <span class="s0"># about missing previous value in &quot;deleted&quot;, but</span>
            <span class="s0"># we do include None, which helps in some primary</span>
            <span class="s0"># key situations</span>
            <span class="s3">if </span><span class="s1">id(original) </span><span class="s3">in </span><span class="s1">_NO_STATE_SYMBOLS:</span>
                <span class="s1">deleted = ()</span>
                <span class="s0"># indicate a &quot;del&quot; operation occurred when we don't have</span>
                <span class="s0"># the previous value as: ([None], (), ())</span>
                <span class="s3">if </span><span class="s1">id(current) </span><span class="s3">in </span><span class="s1">_NO_STATE_SYMBOLS:</span>
                    <span class="s1">current = </span><span class="s3">None</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">deleted = [original]</span>
            <span class="s3">if </span><span class="s1">current </span><span class="s3">is </span><span class="s1">NO_VALUE:</span>
                <span class="s3">return </span><span class="s1">cls(()</span><span class="s5">, </span><span class="s1">()</span><span class="s5">, </span><span class="s1">deleted)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">cls([current]</span><span class="s5">, </span><span class="s1">()</span><span class="s5">, </span><span class="s1">deleted)</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">from_object_attribute(</span>
        <span class="s1">cls</span><span class="s5">,</span>
        <span class="s1">attribute: ScalarObjectAttributeImpl</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">current: Any</span><span class="s5">,</span>
        <span class="s1">original: Any = _NO_HISTORY</span><span class="s5">,</span>
    <span class="s1">) -&gt; History:</span>
        <span class="s1">deleted: Union[Tuple[()]</span><span class="s5">, </span><span class="s1">List[Any]]</span>

        <span class="s3">if </span><span class="s1">original </span><span class="s3">is </span><span class="s1">_NO_HISTORY:</span>
            <span class="s1">original = state.committed_state.get(attribute.key</span><span class="s5">, </span><span class="s1">_NO_HISTORY)</span>

        <span class="s3">if </span><span class="s1">original </span><span class="s3">is </span><span class="s1">_NO_HISTORY:</span>
            <span class="s3">if </span><span class="s1">current </span><span class="s3">is </span><span class="s1">NO_VALUE:</span>
                <span class="s3">return </span><span class="s1">cls(()</span><span class="s5">, </span><span class="s1">()</span><span class="s5">, </span><span class="s1">())</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">cls(()</span><span class="s5">, </span><span class="s1">[current]</span><span class="s5">, </span><span class="s1">())</span>
        <span class="s3">elif </span><span class="s1">current </span><span class="s3">is </span><span class="s1">original </span><span class="s3">and </span><span class="s1">current </span><span class="s3">is not </span><span class="s1">NO_VALUE:</span>
            <span class="s3">return </span><span class="s1">cls(()</span><span class="s5">, </span><span class="s1">[current]</span><span class="s5">, </span><span class="s1">())</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># current convention on related objects is to not</span>
            <span class="s0"># include information</span>
            <span class="s0"># about missing previous value in &quot;deleted&quot;, and</span>
            <span class="s0"># to also not include None - the dependency.py rules</span>
            <span class="s0"># ignore the None in any case.</span>
            <span class="s3">if </span><span class="s1">id(original) </span><span class="s3">in </span><span class="s1">_NO_STATE_SYMBOLS </span><span class="s3">or </span><span class="s1">original </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">deleted = ()</span>
                <span class="s0"># indicate a &quot;del&quot; operation occurred when we don't have</span>
                <span class="s0"># the previous value as: ([None], (), ())</span>
                <span class="s3">if </span><span class="s1">id(current) </span><span class="s3">in </span><span class="s1">_NO_STATE_SYMBOLS:</span>
                    <span class="s1">current = </span><span class="s3">None</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">deleted = [original]</span>
            <span class="s3">if </span><span class="s1">current </span><span class="s3">is </span><span class="s1">NO_VALUE:</span>
                <span class="s3">return </span><span class="s1">cls(()</span><span class="s5">, </span><span class="s1">()</span><span class="s5">, </span><span class="s1">deleted)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">cls([current]</span><span class="s5">, </span><span class="s1">()</span><span class="s5">, </span><span class="s1">deleted)</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">from_collection(</span>
        <span class="s1">cls</span><span class="s5">,</span>
        <span class="s1">attribute: CollectionAttributeImpl</span><span class="s5">,</span>
        <span class="s1">state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">current: Any</span><span class="s5">,</span>
    <span class="s1">) -&gt; History:</span>
        <span class="s1">original = state.committed_state.get(attribute.key</span><span class="s5">, </span><span class="s1">_NO_HISTORY)</span>
        <span class="s3">if </span><span class="s1">current </span><span class="s3">is </span><span class="s1">NO_VALUE:</span>
            <span class="s3">return </span><span class="s1">cls(()</span><span class="s5">, </span><span class="s1">()</span><span class="s5">, </span><span class="s1">())</span>

        <span class="s1">current = getattr(current</span><span class="s5">, </span><span class="s4">&quot;_sa_adapter&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">original </span><span class="s3">is </span><span class="s1">NO_VALUE:</span>
            <span class="s3">return </span><span class="s1">cls(list(current)</span><span class="s5">, </span><span class="s1">()</span><span class="s5">, </span><span class="s1">())</span>
        <span class="s3">elif </span><span class="s1">original </span><span class="s3">is </span><span class="s1">_NO_HISTORY:</span>
            <span class="s3">return </span><span class="s1">cls(()</span><span class="s5">, </span><span class="s1">list(current)</span><span class="s5">, </span><span class="s1">())</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">current_states = [</span>
                <span class="s1">((c </span><span class="s3">is not None</span><span class="s1">) </span><span class="s3">and </span><span class="s1">instance_state(c) </span><span class="s3">or None</span><span class="s5">, </span><span class="s1">c)</span>
                <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">current</span>
            <span class="s1">]</span>
            <span class="s1">original_states = [</span>
                <span class="s1">((c </span><span class="s3">is not None</span><span class="s1">) </span><span class="s3">and </span><span class="s1">instance_state(c) </span><span class="s3">or None</span><span class="s5">, </span><span class="s1">c)</span>
                <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">original</span>
            <span class="s1">]</span>

            <span class="s1">current_set = dict(current_states)</span>
            <span class="s1">original_set = dict(original_states)</span>

            <span class="s3">return </span><span class="s1">cls(</span>
                <span class="s1">[o </span><span class="s3">for </span><span class="s1">s</span><span class="s5">, </span><span class="s1">o </span><span class="s3">in </span><span class="s1">current_states </span><span class="s3">if </span><span class="s1">s </span><span class="s3">not in </span><span class="s1">original_set]</span><span class="s5">,</span>
                <span class="s1">[o </span><span class="s3">for </span><span class="s1">s</span><span class="s5">, </span><span class="s1">o </span><span class="s3">in </span><span class="s1">current_states </span><span class="s3">if </span><span class="s1">s </span><span class="s3">in </span><span class="s1">original_set]</span><span class="s5">,</span>
                <span class="s1">[o </span><span class="s3">for </span><span class="s1">s</span><span class="s5">, </span><span class="s1">o </span><span class="s3">in </span><span class="s1">original_states </span><span class="s3">if </span><span class="s1">s </span><span class="s3">not in </span><span class="s1">current_set]</span><span class="s5">,</span>
            <span class="s1">)</span>


<span class="s1">HISTORY_BLANK = History(()</span><span class="s5">, </span><span class="s1">()</span><span class="s5">, </span><span class="s1">())</span>


<span class="s3">def </span><span class="s1">get_history(</span>
    <span class="s1">obj: object</span><span class="s5">, </span><span class="s1">key: str</span><span class="s5">, </span><span class="s1">passive: PassiveFlag = PASSIVE_OFF</span>
<span class="s1">) -&gt; History:</span>
    <span class="s2">&quot;&quot;&quot;Return a :class:`.History` record for the given object 
    and attribute key. 
 
    This is the **pre-flush** history for a given attribute, which is 
    reset each time the :class:`.Session` flushes changes to the 
    current database transaction. 
 
    .. note:: 
 
        Prefer to use the :attr:`.AttributeState.history` and 
        :meth:`.AttributeState.load_history` accessors to retrieve the 
        :class:`.History` for instance attributes. 
 
 
    :param obj: an object whose class is instrumented by the 
      attributes package. 
 
    :param key: string attribute name. 
 
    :param passive: indicates loading behavior for the attribute 
       if the value is not already present.   This is a 
       bitflag attribute, which defaults to the symbol 
       :attr:`.PASSIVE_OFF` indicating all necessary SQL 
       should be emitted. 
 
    .. seealso:: 
 
        :attr:`.AttributeState.history` 
 
        :meth:`.AttributeState.load_history` - retrieve history 
        using loader callables if the value is not locally present. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">return </span><span class="s1">get_state_history(instance_state(obj)</span><span class="s5">, </span><span class="s1">key</span><span class="s5">, </span><span class="s1">passive)</span>


<span class="s3">def </span><span class="s1">get_state_history(</span>
    <span class="s1">state: InstanceState[Any]</span><span class="s5">, </span><span class="s1">key: str</span><span class="s5">, </span><span class="s1">passive: PassiveFlag = PASSIVE_OFF</span>
<span class="s1">) -&gt; History:</span>
    <span class="s3">return </span><span class="s1">state.get_history(key</span><span class="s5">, </span><span class="s1">passive)</span>


<span class="s3">def </span><span class="s1">has_parent(</span>
    <span class="s1">cls: Type[_O]</span><span class="s5">, </span><span class="s1">obj: _O</span><span class="s5">, </span><span class="s1">key: str</span><span class="s5">, </span><span class="s1">optimistic: bool = </span><span class="s3">False</span>
<span class="s1">) -&gt; bool:</span>
    <span class="s2">&quot;&quot;&quot;TODO&quot;&quot;&quot;</span>
    <span class="s1">manager = manager_of_class(cls)</span>
    <span class="s1">state = instance_state(obj)</span>
    <span class="s3">return </span><span class="s1">manager.has_parent(state</span><span class="s5">, </span><span class="s1">key</span><span class="s5">, </span><span class="s1">optimistic)</span>


<span class="s3">def </span><span class="s1">register_attribute(</span>
    <span class="s1">class_: Type[_O]</span><span class="s5">,</span>
    <span class="s1">key: str</span><span class="s5">,</span>
    <span class="s1">*</span><span class="s5">,</span>
    <span class="s1">comparator: interfaces.PropComparator[_T]</span><span class="s5">,</span>
    <span class="s1">parententity: _InternalEntityType[_O]</span><span class="s5">,</span>
    <span class="s1">doc: Optional[str] = </span><span class="s3">None</span><span class="s5">,</span>
    <span class="s1">**kw: Any</span><span class="s5">,</span>
<span class="s1">) -&gt; InstrumentedAttribute[_T]:</span>
    <span class="s1">desc = register_descriptor(</span>
        <span class="s1">class_</span><span class="s5">, </span><span class="s1">key</span><span class="s5">, </span><span class="s1">comparator=comparator</span><span class="s5">, </span><span class="s1">parententity=parententity</span><span class="s5">, </span><span class="s1">doc=doc</span>
    <span class="s1">)</span>
    <span class="s1">register_attribute_impl(class_</span><span class="s5">, </span><span class="s1">key</span><span class="s5">, </span><span class="s1">**kw)</span>
    <span class="s3">return </span><span class="s1">desc</span>


<span class="s3">def </span><span class="s1">register_attribute_impl(</span>
    <span class="s1">class_: Type[_O]</span><span class="s5">,</span>
    <span class="s1">key: str</span><span class="s5">,</span>
    <span class="s1">uselist: bool = </span><span class="s3">False</span><span class="s5">,</span>
    <span class="s1">callable_: Optional[_LoaderCallable] = </span><span class="s3">None</span><span class="s5">,</span>
    <span class="s1">useobject: bool = </span><span class="s3">False</span><span class="s5">,</span>
    <span class="s1">impl_class: Optional[Type[AttributeImpl]] = </span><span class="s3">None</span><span class="s5">,</span>
    <span class="s1">backref: Optional[str] = </span><span class="s3">None</span><span class="s5">,</span>
    <span class="s1">**kw: Any</span><span class="s5">,</span>
<span class="s1">) -&gt; QueryableAttribute[Any]:</span>
    <span class="s1">manager = manager_of_class(class_)</span>
    <span class="s3">if </span><span class="s1">uselist:</span>
        <span class="s1">factory = kw.pop(</span><span class="s4">&quot;typecallable&quot;</span><span class="s5">, </span><span class="s3">None</span><span class="s1">)</span>
        <span class="s1">typecallable = manager.instrument_collection_class(</span>
            <span class="s1">key</span><span class="s5">, </span><span class="s1">factory </span><span class="s3">or </span><span class="s1">list</span>
        <span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">typecallable = kw.pop(</span><span class="s4">&quot;typecallable&quot;</span><span class="s5">, </span><span class="s3">None</span><span class="s1">)</span>

    <span class="s1">dispatch = cast(</span>
        <span class="s4">&quot;_Dispatch[QueryableAttribute[Any]]&quot;</span><span class="s5">, </span><span class="s1">manager[key].dispatch</span>
    <span class="s1">)  </span><span class="s0"># noqa: E501</span>

    <span class="s1">impl: AttributeImpl</span>

    <span class="s3">if </span><span class="s1">impl_class:</span>
        <span class="s0"># TODO: this appears to be the WriteOnlyAttributeImpl /</span>
        <span class="s0"># DynamicAttributeImpl constructor which is hardcoded</span>
        <span class="s1">impl = cast(</span><span class="s4">&quot;Type[WriteOnlyAttributeImpl]&quot;</span><span class="s5">, </span><span class="s1">impl_class)(</span>
            <span class="s1">class_</span><span class="s5">, </span><span class="s1">key</span><span class="s5">, </span><span class="s1">dispatch</span><span class="s5">, </span><span class="s1">**kw</span>
        <span class="s1">)</span>
    <span class="s3">elif </span><span class="s1">uselist:</span>
        <span class="s1">impl = CollectionAttributeImpl(</span>
            <span class="s1">class_</span><span class="s5">, </span><span class="s1">key</span><span class="s5">, </span><span class="s1">callable_</span><span class="s5">, </span><span class="s1">dispatch</span><span class="s5">, </span><span class="s1">typecallable=typecallable</span><span class="s5">, </span><span class="s1">**kw</span>
        <span class="s1">)</span>
    <span class="s3">elif </span><span class="s1">useobject:</span>
        <span class="s1">impl = ScalarObjectAttributeImpl(</span>
            <span class="s1">class_</span><span class="s5">, </span><span class="s1">key</span><span class="s5">, </span><span class="s1">callable_</span><span class="s5">, </span><span class="s1">dispatch</span><span class="s5">, </span><span class="s1">**kw</span>
        <span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">impl = ScalarAttributeImpl(class_</span><span class="s5">, </span><span class="s1">key</span><span class="s5">, </span><span class="s1">callable_</span><span class="s5">, </span><span class="s1">dispatch</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s1">manager[key].impl = impl</span>

    <span class="s3">if </span><span class="s1">backref:</span>
        <span class="s1">backref_listeners(manager[key]</span><span class="s5">, </span><span class="s1">backref</span><span class="s5">, </span><span class="s1">uselist)</span>

    <span class="s1">manager.post_configure_attribute(key)</span>
    <span class="s3">return </span><span class="s1">manager[key]</span>


<span class="s3">def </span><span class="s1">register_descriptor(</span>
    <span class="s1">class_: Type[Any]</span><span class="s5">,</span>
    <span class="s1">key: str</span><span class="s5">,</span>
    <span class="s1">*</span><span class="s5">,</span>
    <span class="s1">comparator: interfaces.PropComparator[_T]</span><span class="s5">,</span>
    <span class="s1">parententity: _InternalEntityType[Any]</span><span class="s5">,</span>
    <span class="s1">doc: Optional[str] = </span><span class="s3">None</span><span class="s5">,</span>
<span class="s1">) -&gt; InstrumentedAttribute[_T]:</span>
    <span class="s1">manager = manager_of_class(class_)</span>

    <span class="s1">descriptor = InstrumentedAttribute(</span>
        <span class="s1">class_</span><span class="s5">, </span><span class="s1">key</span><span class="s5">, </span><span class="s1">comparator=comparator</span><span class="s5">, </span><span class="s1">parententity=parententity</span>
    <span class="s1">)</span>

    <span class="s1">descriptor.__doc__ = doc  </span><span class="s0"># type: ignore</span>

    <span class="s1">manager.instrument_attribute(key</span><span class="s5">, </span><span class="s1">descriptor)</span>
    <span class="s3">return </span><span class="s1">descriptor</span>


<span class="s3">def </span><span class="s1">unregister_attribute(class_: Type[Any]</span><span class="s5">, </span><span class="s1">key: str) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">manager_of_class(class_).uninstrument_attribute(key)</span>


<span class="s3">def </span><span class="s1">init_collection(obj: object</span><span class="s5">, </span><span class="s1">key: str) -&gt; CollectionAdapter:</span>
    <span class="s2">&quot;&quot;&quot;Initialize a collection attribute and return the collection adapter. 
 
    This function is used to provide direct access to collection internals 
    for a previously unloaded attribute.  e.g.:: 
 
        collection_adapter = init_collection(someobject, 'elements') 
        for elem in values: 
            collection_adapter.append_without_event(elem) 
 
    For an easier way to do the above, see 
    :func:`~sqlalchemy.orm.attributes.set_committed_value`. 
 
    :param obj: a mapped object 
 
    :param key: string attribute name where the collection is located. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">state = instance_state(obj)</span>
    <span class="s1">dict_ = state.dict</span>
    <span class="s3">return </span><span class="s1">init_state_collection(state</span><span class="s5">, </span><span class="s1">dict_</span><span class="s5">, </span><span class="s1">key)</span>


<span class="s3">def </span><span class="s1">init_state_collection(</span>
    <span class="s1">state: InstanceState[Any]</span><span class="s5">, </span><span class="s1">dict_: _InstanceDict</span><span class="s5">, </span><span class="s1">key: str</span>
<span class="s1">) -&gt; CollectionAdapter:</span>
    <span class="s2">&quot;&quot;&quot;Initialize a collection attribute and return the collection adapter. 
 
    Discards any existing collection which may be there. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">attr = state.manager[key].impl</span>

    <span class="s3">if </span><span class="s1">TYPE_CHECKING:</span>
        <span class="s3">assert </span><span class="s1">isinstance(attr</span><span class="s5">, </span><span class="s1">HasCollectionAdapter)</span>

    <span class="s1">old = dict_.pop(key</span><span class="s5">, </span><span class="s3">None</span><span class="s1">)  </span><span class="s0"># discard old collection</span>
    <span class="s3">if </span><span class="s1">old </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">old_collection = old._sa_adapter</span>
        <span class="s1">attr._dispose_previous_collection(state</span><span class="s5">, </span><span class="s1">old</span><span class="s5">, </span><span class="s1">old_collection</span><span class="s5">, </span><span class="s3">False</span><span class="s1">)</span>

    <span class="s1">user_data = attr._default_value(state</span><span class="s5">, </span><span class="s1">dict_)</span>
    <span class="s1">adapter: CollectionAdapter = attr.get_collection(</span>
        <span class="s1">state</span><span class="s5">, </span><span class="s1">dict_</span><span class="s5">, </span><span class="s1">user_data</span><span class="s5">, </span><span class="s1">passive=PassiveFlag.PASSIVE_NO_FETCH</span>
    <span class="s1">)</span>
    <span class="s1">adapter._reset_empty()</span>

    <span class="s3">return </span><span class="s1">adapter</span>


<span class="s3">def </span><span class="s1">set_committed_value(instance</span><span class="s5">, </span><span class="s1">key</span><span class="s5">, </span><span class="s1">value):</span>
    <span class="s2">&quot;&quot;&quot;Set the value of an attribute with no history events. 
 
    Cancels any previous history present.  The value should be 
    a scalar value for scalar-holding attributes, or 
    an iterable for any collection-holding attribute. 
 
    This is the same underlying method used when a lazy loader 
    fires off and loads additional data from the database. 
    In particular, this method can be used by application code 
    which has loaded additional attributes or collections through 
    separate queries, which can then be attached to an instance 
    as though it were part of its original loaded state. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">state</span><span class="s5">, </span><span class="s1">dict_ = instance_state(instance)</span><span class="s5">, </span><span class="s1">instance_dict(instance)</span>
    <span class="s1">state.manager[key].impl.set_committed_value(state</span><span class="s5">, </span><span class="s1">dict_</span><span class="s5">, </span><span class="s1">value)</span>


<span class="s3">def </span><span class="s1">set_attribute(</span>
    <span class="s1">instance: object</span><span class="s5">,</span>
    <span class="s1">key: str</span><span class="s5">,</span>
    <span class="s1">value: Any</span><span class="s5">,</span>
    <span class="s1">initiator: Optional[AttributeEventToken] = </span><span class="s3">None</span><span class="s5">,</span>
<span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Set the value of an attribute, firing history events. 
 
    This function may be used regardless of instrumentation 
    applied directly to the class, i.e. no descriptors are required. 
    Custom attribute management schemes will need to make usage 
    of this method to establish attribute state as understood 
    by SQLAlchemy. 
 
    :param instance: the object that will be modified 
 
    :param key: string name of the attribute 
 
    :param value: value to assign 
 
    :param initiator: an instance of :class:`.Event` that would have 
     been propagated from a previous event listener.  This argument 
     is used when the :func:`.set_attribute` function is being used within 
     an existing event listening function where an :class:`.Event` object 
     is being supplied; the object may be used to track the origin of the 
     chain of events. 
 
     .. versionadded:: 1.2.3 
 
    &quot;&quot;&quot;</span>
    <span class="s1">state</span><span class="s5">, </span><span class="s1">dict_ = instance_state(instance)</span><span class="s5">, </span><span class="s1">instance_dict(instance)</span>
    <span class="s1">state.manager[key].impl.set(state</span><span class="s5">, </span><span class="s1">dict_</span><span class="s5">, </span><span class="s1">value</span><span class="s5">, </span><span class="s1">initiator)</span>


<span class="s3">def </span><span class="s1">get_attribute(instance: object</span><span class="s5">, </span><span class="s1">key: str) -&gt; Any:</span>
    <span class="s2">&quot;&quot;&quot;Get the value of an attribute, firing any callables required. 
 
    This function may be used regardless of instrumentation 
    applied directly to the class, i.e. no descriptors are required. 
    Custom attribute management schemes will need to make usage 
    of this method to make usage of attribute state as understood 
    by SQLAlchemy. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">state</span><span class="s5">, </span><span class="s1">dict_ = instance_state(instance)</span><span class="s5">, </span><span class="s1">instance_dict(instance)</span>
    <span class="s3">return </span><span class="s1">state.manager[key].impl.get(state</span><span class="s5">, </span><span class="s1">dict_)</span>


<span class="s3">def </span><span class="s1">del_attribute(instance: object</span><span class="s5">, </span><span class="s1">key: str) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Delete the value of an attribute, firing history events. 
 
    This function may be used regardless of instrumentation 
    applied directly to the class, i.e. no descriptors are required. 
    Custom attribute management schemes will need to make usage 
    of this method to establish attribute state as understood 
    by SQLAlchemy. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">state</span><span class="s5">, </span><span class="s1">dict_ = instance_state(instance)</span><span class="s5">, </span><span class="s1">instance_dict(instance)</span>
    <span class="s1">state.manager[key].impl.delete(state</span><span class="s5">, </span><span class="s1">dict_)</span>


<span class="s3">def </span><span class="s1">flag_modified(instance: object</span><span class="s5">, </span><span class="s1">key: str) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Mark an attribute on an instance as 'modified'. 
 
    This sets the 'modified' flag on the instance and 
    establishes an unconditional change event for the given attribute. 
    The attribute must have a value present, else an 
    :class:`.InvalidRequestError` is raised. 
 
    To mark an object &quot;dirty&quot; without referring to any specific attribute 
    so that it is considered within a flush, use the 
    :func:`.attributes.flag_dirty` call. 
 
    .. seealso:: 
 
        :func:`.attributes.flag_dirty` 
 
    &quot;&quot;&quot;</span>
    <span class="s1">state</span><span class="s5">, </span><span class="s1">dict_ = instance_state(instance)</span><span class="s5">, </span><span class="s1">instance_dict(instance)</span>
    <span class="s1">impl = state.manager[key].impl</span>
    <span class="s1">impl.dispatch.modified(state</span><span class="s5">, </span><span class="s1">impl._modified_token)</span>
    <span class="s1">state._modified_event(dict_</span><span class="s5">, </span><span class="s1">impl</span><span class="s5">, </span><span class="s1">NO_VALUE</span><span class="s5">, </span><span class="s1">is_userland=</span><span class="s3">True</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">flag_dirty(instance: object) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Mark an instance as 'dirty' without any specific attribute mentioned. 
 
    This is a special operation that will allow the object to travel through 
    the flush process for interception by events such as 
    :meth:`.SessionEvents.before_flush`.   Note that no SQL will be emitted in 
    the flush process for an object that has no changes, even if marked dirty 
    via this method.  However, a :meth:`.SessionEvents.before_flush` handler 
    will be able to see the object in the :attr:`.Session.dirty` collection and 
    may establish changes on it, which will then be included in the SQL 
    emitted. 
 
    .. versionadded:: 1.2 
 
    .. seealso:: 
 
        :func:`.attributes.flag_modified` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">state</span><span class="s5">, </span><span class="s1">dict_ = instance_state(instance)</span><span class="s5">, </span><span class="s1">instance_dict(instance)</span>
    <span class="s1">state._modified_event(dict_</span><span class="s5">, </span><span class="s3">None</span><span class="s5">, </span><span class="s1">NO_VALUE</span><span class="s5">, </span><span class="s1">is_userland=</span><span class="s3">True</span><span class="s1">)</span>
</pre>
</body>
</html>