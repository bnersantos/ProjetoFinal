<html>
<head>
<title>impl.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5d69bb;}
.s1 { color: #d8d8d8;}
.s2 { color: #717ed3; font-style: italic;}
.s3 { color: #cc8b60;}
.s4 { color: #cc7832;}
.s5 { color: #bbb55b;}
.s6 { color: #96bf7d;}
.s7 { color: #d7539b; font-weight: bold;}
</style>
</head>
<body bgcolor="#1a1a25">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
impl.py</font>
</center></td></tr></table>
<pre><span class="s0"># pool/impl.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>


<span class="s2">&quot;&quot;&quot;Pool implementation classes. 
 
&quot;&quot;&quot;</span>
<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">annotations</span>

<span class="s3">import </span><span class="s1">threading</span>
<span class="s3">import </span><span class="s1">traceback</span>
<span class="s3">import </span><span class="s1">typing</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">cast</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">List</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Optional</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Set</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Type</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Union</span>
<span class="s3">import </span><span class="s1">weakref</span>

<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">_AsyncConnDialect</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">_ConnectionFairy</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">_ConnectionRecord</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">_CreatorFnType</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">_CreatorWRecFnType</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">ConnectionPoolEntry</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">Pool</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">PoolProxiedConnection</span>
<span class="s3">from </span><span class="s1">.. </span><span class="s3">import </span><span class="s1">exc</span>
<span class="s3">from </span><span class="s1">.. </span><span class="s3">import </span><span class="s1">util</span>
<span class="s3">from </span><span class="s1">..util </span><span class="s3">import </span><span class="s1">chop_traceback</span>
<span class="s3">from </span><span class="s1">..util </span><span class="s3">import </span><span class="s1">queue </span><span class="s3">as </span><span class="s1">sqla_queue</span>
<span class="s3">from </span><span class="s1">..util.typing </span><span class="s3">import </span><span class="s1">Literal</span>

<span class="s3">if </span><span class="s1">typing.TYPE_CHECKING:</span>
    <span class="s3">from </span><span class="s1">..engine.interfaces </span><span class="s3">import </span><span class="s1">DBAPIConnection</span>


<span class="s3">class </span><span class="s1">QueuePool(Pool):</span>
    <span class="s2">&quot;&quot;&quot;A :class:`_pool.Pool` 
    that imposes a limit on the number of open connections. 
 
    :class:`.QueuePool` is the default pooling implementation used for 
    all :class:`_engine.Engine` objects other than SQLite with a ``:memory:`` 
    database. 
 
    The :class:`.QueuePool` class **is not compatible** with asyncio and 
    :func:`_asyncio.create_async_engine`.  The 
    :class:`.AsyncAdaptedQueuePool` class is used automatically when 
    using :func:`_asyncio.create_async_engine`, if no other kind of pool 
    is specified. 
 
    .. seealso:: 
 
        :class:`.AsyncAdaptedQueuePool` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_is_asyncio = </span><span class="s3">False  </span><span class="s0"># type: ignore[assignment]</span>

    <span class="s1">_queue_class: Type[sqla_queue.QueueCommon[ConnectionPoolEntry]] = (</span>
        <span class="s1">sqla_queue.Queue</span>
    <span class="s1">)</span>

    <span class="s1">_pool: sqla_queue.QueueCommon[ConnectionPoolEntry]</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">creator: Union[_CreatorFnType</span><span class="s4">, </span><span class="s1">_CreatorWRecFnType]</span><span class="s4">,</span>
        <span class="s1">pool_size: int = </span><span class="s5">5</span><span class="s4">,</span>
        <span class="s1">max_overflow: int = </span><span class="s5">10</span><span class="s4">,</span>
        <span class="s1">timeout: float = </span><span class="s5">30.0</span><span class="s4">,</span>
        <span class="s1">use_lifo: bool = </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">**kw: Any</span><span class="s4">,</span>
    <span class="s1">):</span>
        <span class="s2">r&quot;&quot;&quot; 
        Construct a QueuePool. 
 
        :param creator: a callable function that returns a DB-API 
          connection object, same as that of :paramref:`_pool.Pool.creator`. 
 
        :param pool_size: The size of the pool to be maintained, 
          defaults to 5. This is the largest number of connections that 
          will be kept persistently in the pool. Note that the pool 
          begins with no connections; once this number of connections 
          is requested, that number of connections will remain. 
          ``pool_size`` can be set to 0 to indicate no size limit; to 
          disable pooling, use a :class:`~sqlalchemy.pool.NullPool` 
          instead. 
 
        :param max_overflow: The maximum overflow size of the 
          pool. When the number of checked-out connections reaches the 
          size set in pool_size, additional connections will be 
          returned up to this limit. When those additional connections 
          are returned to the pool, they are disconnected and 
          discarded. It follows then that the total number of 
          simultaneous connections the pool will allow is pool_size + 
          `max_overflow`, and the total number of &quot;sleeping&quot; 
          connections the pool will allow is pool_size. `max_overflow` 
          can be set to -1 to indicate no overflow limit; no limit 
          will be placed on the total number of concurrent 
          connections. Defaults to 10. 
 
        :param timeout: The number of seconds to wait before giving up 
          on returning a connection. Defaults to 30.0. This can be a float 
          but is subject to the limitations of Python time functions which 
          may not be reliable in the tens of milliseconds. 
 
        :param use_lifo: use LIFO (last-in-first-out) when retrieving 
          connections instead of FIFO (first-in-first-out). Using LIFO, a 
          server-side timeout scheme can reduce the number of connections used 
          during non-peak periods of use.   When planning for server-side 
          timeouts, ensure that a recycle or pre-ping strategy is in use to 
          gracefully handle stale connections. 
 
          .. versionadded:: 1.3 
 
          .. seealso:: 
 
            :ref:`pool_use_lifo` 
 
            :ref:`pool_disconnects` 
 
        :param \**kw: Other keyword arguments including 
          :paramref:`_pool.Pool.recycle`, :paramref:`_pool.Pool.echo`, 
          :paramref:`_pool.Pool.reset_on_return` and others are passed to the 
          :class:`_pool.Pool` constructor. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">Pool.__init__(self</span><span class="s4">, </span><span class="s1">creator</span><span class="s4">, </span><span class="s1">**kw)</span>
        <span class="s1">self._pool = self._queue_class(pool_size</span><span class="s4">, </span><span class="s1">use_lifo=use_lifo)</span>
        <span class="s1">self._overflow = </span><span class="s5">0 </span><span class="s1">- pool_size</span>
        <span class="s1">self._max_overflow = -</span><span class="s5">1 </span><span class="s3">if </span><span class="s1">pool_size == </span><span class="s5">0 </span><span class="s3">else </span><span class="s1">max_overflow</span>
        <span class="s1">self._timeout = timeout</span>
        <span class="s1">self._overflow_lock = threading.Lock()</span>

    <span class="s3">def </span><span class="s1">_do_return_conn(self</span><span class="s4">, </span><span class="s1">record: ConnectionPoolEntry) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">self._pool.put(record</span><span class="s4">, </span><span class="s3">False</span><span class="s1">)</span>
        <span class="s3">except </span><span class="s1">sqla_queue.Full:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">record.close()</span>
            <span class="s3">finally</span><span class="s1">:</span>
                <span class="s1">self._dec_overflow()</span>

    <span class="s3">def </span><span class="s1">_do_get(self) -&gt; ConnectionPoolEntry:</span>
        <span class="s1">use_overflow = self._max_overflow &gt; -</span><span class="s5">1</span>

        <span class="s1">wait = use_overflow </span><span class="s3">and </span><span class="s1">self._overflow &gt;= self._max_overflow</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self._pool.get(wait</span><span class="s4">, </span><span class="s1">self._timeout)</span>
        <span class="s3">except </span><span class="s1">sqla_queue.Empty:</span>
            <span class="s0"># don't do things inside of &quot;except Empty&quot;, because when we say</span>
            <span class="s0"># we timed out or can't connect and raise, Python 3 tells</span>
            <span class="s0"># people the real error is queue.Empty which it isn't.</span>
            <span class="s3">pass</span>
        <span class="s3">if </span><span class="s1">use_overflow </span><span class="s3">and </span><span class="s1">self._overflow &gt;= self._max_overflow:</span>
            <span class="s3">if not </span><span class="s1">wait:</span>
                <span class="s3">return </span><span class="s1">self._do_get()</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">exc.TimeoutError(</span>
                    <span class="s6">&quot;QueuePool limit of size %d overflow %d reached, &quot;</span>
                    <span class="s6">&quot;connection timed out, timeout %0.2f&quot;</span>
                    <span class="s1">% (self.size()</span><span class="s4">, </span><span class="s1">self.overflow()</span><span class="s4">, </span><span class="s1">self._timeout)</span><span class="s4">,</span>
                    <span class="s1">code=</span><span class="s6">&quot;3o7r&quot;</span><span class="s4">,</span>
                <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">self._inc_overflow():</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">self._create_connection()</span>
            <span class="s3">except</span><span class="s1">:</span>
                <span class="s3">with </span><span class="s1">util.safe_reraise():</span>
                    <span class="s1">self._dec_overflow()</span>
                <span class="s3">raise</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self._do_get()</span>

    <span class="s3">def </span><span class="s1">_inc_overflow(self) -&gt; bool:</span>
        <span class="s3">if </span><span class="s1">self._max_overflow == -</span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">self._overflow += </span><span class="s5">1</span>
            <span class="s3">return True</span>
        <span class="s3">with </span><span class="s1">self._overflow_lock:</span>
            <span class="s3">if </span><span class="s1">self._overflow &lt; self._max_overflow:</span>
                <span class="s1">self._overflow += </span><span class="s5">1</span>
                <span class="s3">return True</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">_dec_overflow(self) -&gt; Literal[</span><span class="s3">True</span><span class="s1">]:</span>
        <span class="s3">if </span><span class="s1">self._max_overflow == -</span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">self._overflow -= </span><span class="s5">1</span>
            <span class="s3">return True</span>
        <span class="s3">with </span><span class="s1">self._overflow_lock:</span>
            <span class="s1">self._overflow -= </span><span class="s5">1</span>
            <span class="s3">return True</span>

    <span class="s3">def </span><span class="s1">recreate(self) -&gt; QueuePool:</span>
        <span class="s1">self.logger.info(</span><span class="s6">&quot;Pool recreating&quot;</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self.__class__(</span>
            <span class="s1">self._creator</span><span class="s4">,</span>
            <span class="s1">pool_size=self._pool.maxsize</span><span class="s4">,</span>
            <span class="s1">max_overflow=self._max_overflow</span><span class="s4">,</span>
            <span class="s1">pre_ping=self._pre_ping</span><span class="s4">,</span>
            <span class="s1">use_lifo=self._pool.use_lifo</span><span class="s4">,</span>
            <span class="s1">timeout=self._timeout</span><span class="s4">,</span>
            <span class="s1">recycle=self._recycle</span><span class="s4">,</span>
            <span class="s1">echo=self.echo</span><span class="s4">,</span>
            <span class="s1">logging_name=self._orig_logging_name</span><span class="s4">,</span>
            <span class="s1">reset_on_return=self._reset_on_return</span><span class="s4">,</span>
            <span class="s1">_dispatch=self.dispatch</span><span class="s4">,</span>
            <span class="s1">dialect=self._dialect</span><span class="s4">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">dispose(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">conn = self._pool.get(</span><span class="s3">False</span><span class="s1">)</span>
                <span class="s1">conn.close()</span>
            <span class="s3">except </span><span class="s1">sqla_queue.Empty:</span>
                <span class="s3">break</span>

        <span class="s1">self._overflow = </span><span class="s5">0 </span><span class="s1">- self.size()</span>
        <span class="s1">self.logger.info(</span><span class="s6">&quot;Pool disposed. %s&quot;</span><span class="s4">, </span><span class="s1">self.status())</span>

    <span class="s3">def </span><span class="s1">status(self) -&gt; str:</span>
        <span class="s3">return </span><span class="s1">(</span>
            <span class="s6">&quot;Pool size: %d  Connections in pool: %d &quot;</span>
            <span class="s6">&quot;Current Overflow: %d Current Checked out &quot;</span>
            <span class="s6">&quot;connections: %d&quot;</span>
            <span class="s1">% (</span>
                <span class="s1">self.size()</span><span class="s4">,</span>
                <span class="s1">self.checkedin()</span><span class="s4">,</span>
                <span class="s1">self.overflow()</span><span class="s4">,</span>
                <span class="s1">self.checkedout()</span><span class="s4">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">size(self) -&gt; int:</span>
        <span class="s3">return </span><span class="s1">self._pool.maxsize</span>

    <span class="s3">def </span><span class="s1">timeout(self) -&gt; float:</span>
        <span class="s3">return </span><span class="s1">self._timeout</span>

    <span class="s3">def </span><span class="s1">checkedin(self) -&gt; int:</span>
        <span class="s3">return </span><span class="s1">self._pool.qsize()</span>

    <span class="s3">def </span><span class="s1">overflow(self) -&gt; int:</span>
        <span class="s3">return </span><span class="s1">self._overflow </span><span class="s3">if </span><span class="s1">self._pool.maxsize </span><span class="s3">else </span><span class="s5">0</span>

    <span class="s3">def </span><span class="s1">checkedout(self) -&gt; int:</span>
        <span class="s3">return </span><span class="s1">self._pool.maxsize - self._pool.qsize() + self._overflow</span>


<span class="s3">class </span><span class="s1">AsyncAdaptedQueuePool(QueuePool):</span>
    <span class="s2">&quot;&quot;&quot;An asyncio-compatible version of :class:`.QueuePool`. 
 
    This pool is used by default when using :class:`.AsyncEngine` engines that 
    were generated from :func:`_asyncio.create_async_engine`.   It uses an 
    asyncio-compatible queue implementation that does not use 
    ``threading.Lock``. 
 
    The arguments and operation of :class:`.AsyncAdaptedQueuePool` are 
    otherwise identical to that of :class:`.QueuePool`. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_is_asyncio = </span><span class="s3">True  </span><span class="s0"># type: ignore[assignment]</span>
    <span class="s1">_queue_class: Type[sqla_queue.QueueCommon[ConnectionPoolEntry]] = (</span>
        <span class="s1">sqla_queue.AsyncAdaptedQueue</span>
    <span class="s1">)</span>

    <span class="s1">_dialect = _AsyncConnDialect()</span>


<span class="s3">class </span><span class="s1">FallbackAsyncAdaptedQueuePool(AsyncAdaptedQueuePool):</span>
    <span class="s1">_queue_class = sqla_queue.FallbackAsyncAdaptedQueue</span>


<span class="s3">class </span><span class="s1">NullPool(Pool):</span>
    <span class="s2">&quot;&quot;&quot;A Pool which does not pool connections. 
 
    Instead it literally opens and closes the underlying DB-API connection 
    per each connection open/close. 
 
    Reconnect-related functions such as ``recycle`` and connection 
    invalidation are not supported by this Pool implementation, since 
    no connections are held persistently. 
 
    The :class:`.NullPool` class **is compatible** with asyncio and 
    :func:`_asyncio.create_async_engine`. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">status(self) -&gt; str:</span>
        <span class="s3">return </span><span class="s6">&quot;NullPool&quot;</span>

    <span class="s3">def </span><span class="s1">_do_return_conn(self</span><span class="s4">, </span><span class="s1">record: ConnectionPoolEntry) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">record.close()</span>

    <span class="s3">def </span><span class="s1">_do_get(self) -&gt; ConnectionPoolEntry:</span>
        <span class="s3">return </span><span class="s1">self._create_connection()</span>

    <span class="s3">def </span><span class="s1">recreate(self) -&gt; NullPool:</span>
        <span class="s1">self.logger.info(</span><span class="s6">&quot;Pool recreating&quot;</span><span class="s1">)</span>

        <span class="s3">return </span><span class="s1">self.__class__(</span>
            <span class="s1">self._creator</span><span class="s4">,</span>
            <span class="s1">recycle=self._recycle</span><span class="s4">,</span>
            <span class="s1">echo=self.echo</span><span class="s4">,</span>
            <span class="s1">logging_name=self._orig_logging_name</span><span class="s4">,</span>
            <span class="s1">reset_on_return=self._reset_on_return</span><span class="s4">,</span>
            <span class="s1">pre_ping=self._pre_ping</span><span class="s4">,</span>
            <span class="s1">_dispatch=self.dispatch</span><span class="s4">,</span>
            <span class="s1">dialect=self._dialect</span><span class="s4">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">dispose(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">SingletonThreadPool(Pool):</span>
    <span class="s2">&quot;&quot;&quot;A Pool that maintains one connection per thread. 
 
    Maintains one connection per each thread, never moving a connection to a 
    thread other than the one which it was created in. 
 
    .. warning::  the :class:`.SingletonThreadPool` will call ``.close()`` 
       on arbitrary connections that exist beyond the size setting of 
       ``pool_size``, e.g. if more unique **thread identities** 
       than what ``pool_size`` states are used.   This cleanup is 
       non-deterministic and not sensitive to whether or not the connections 
       linked to those thread identities are currently in use. 
 
       :class:`.SingletonThreadPool` may be improved in a future release, 
       however in its current status it is generally used only for test 
       scenarios using a SQLite ``:memory:`` database and is not recommended 
       for production use. 
 
    The :class:`.SingletonThreadPool` class **is not compatible** with asyncio 
    and :func:`_asyncio.create_async_engine`. 
 
 
    Options are the same as those of :class:`_pool.Pool`, as well as: 
 
    :param pool_size: The number of threads in which to maintain connections 
        at once.  Defaults to five. 
 
    :class:`.SingletonThreadPool` is used by the SQLite dialect 
    automatically when a memory-based database is used. 
    See :ref:`sqlite_toplevel`. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_is_asyncio = </span><span class="s3">False  </span><span class="s0"># type: ignore[assignment]</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">creator: Union[_CreatorFnType</span><span class="s4">, </span><span class="s1">_CreatorWRecFnType]</span><span class="s4">,</span>
        <span class="s1">pool_size: int = </span><span class="s5">5</span><span class="s4">,</span>
        <span class="s1">**kw: Any</span><span class="s4">,</span>
    <span class="s1">):</span>
        <span class="s1">Pool.__init__(self</span><span class="s4">, </span><span class="s1">creator</span><span class="s4">, </span><span class="s1">**kw)</span>
        <span class="s1">self._conn = threading.local()</span>
        <span class="s1">self._fairy = threading.local()</span>
        <span class="s1">self._all_conns: Set[ConnectionPoolEntry] = set()</span>
        <span class="s1">self.size = pool_size</span>

    <span class="s3">def </span><span class="s1">recreate(self) -&gt; SingletonThreadPool:</span>
        <span class="s1">self.logger.info(</span><span class="s6">&quot;Pool recreating&quot;</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self.__class__(</span>
            <span class="s1">self._creator</span><span class="s4">,</span>
            <span class="s1">pool_size=self.size</span><span class="s4">,</span>
            <span class="s1">recycle=self._recycle</span><span class="s4">,</span>
            <span class="s1">echo=self.echo</span><span class="s4">,</span>
            <span class="s1">pre_ping=self._pre_ping</span><span class="s4">,</span>
            <span class="s1">logging_name=self._orig_logging_name</span><span class="s4">,</span>
            <span class="s1">reset_on_return=self._reset_on_return</span><span class="s4">,</span>
            <span class="s1">_dispatch=self.dispatch</span><span class="s4">,</span>
            <span class="s1">dialect=self._dialect</span><span class="s4">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">dispose(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Dispose of this pool.&quot;&quot;&quot;</span>

        <span class="s3">for </span><span class="s1">conn </span><span class="s3">in </span><span class="s1">self._all_conns:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">conn.close()</span>
            <span class="s3">except </span><span class="s1">Exception:</span>
                <span class="s0"># pysqlite won't even let you close a conn from a thread</span>
                <span class="s0"># that didn't create it</span>
                <span class="s3">pass</span>

        <span class="s1">self._all_conns.clear()</span>

    <span class="s3">def </span><span class="s1">_cleanup(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">while </span><span class="s1">len(self._all_conns) &gt;= self.size:</span>
            <span class="s1">c = self._all_conns.pop()</span>
            <span class="s1">c.close()</span>

    <span class="s3">def </span><span class="s1">status(self) -&gt; str:</span>
        <span class="s3">return </span><span class="s6">&quot;SingletonThreadPool id:%d size: %d&quot; </span><span class="s1">% (</span>
            <span class="s1">id(self)</span><span class="s4">,</span>
            <span class="s1">len(self._all_conns)</span><span class="s4">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_do_return_conn(self</span><span class="s4">, </span><span class="s1">record: ConnectionPoolEntry) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">del </span><span class="s1">self._fairy.current</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s3">pass</span>

    <span class="s3">def </span><span class="s1">_do_get(self) -&gt; ConnectionPoolEntry:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">TYPE_CHECKING:</span>
                <span class="s1">c = cast(ConnectionPoolEntry</span><span class="s4">, </span><span class="s1">self._conn.current())</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">c = self._conn.current()</span>
            <span class="s3">if </span><span class="s1">c:</span>
                <span class="s3">return </span><span class="s1">c</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s3">pass</span>
        <span class="s1">c = self._create_connection()</span>
        <span class="s1">self._conn.current = weakref.ref(c)</span>
        <span class="s3">if </span><span class="s1">len(self._all_conns) &gt;= self.size:</span>
            <span class="s1">self._cleanup()</span>
        <span class="s1">self._all_conns.add(c)</span>
        <span class="s3">return </span><span class="s1">c</span>

    <span class="s3">def </span><span class="s1">connect(self) -&gt; PoolProxiedConnection:</span>
        <span class="s0"># vendored from Pool to include the now removed use_threadlocal</span>
        <span class="s0"># behavior</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">rec = cast(_ConnectionFairy</span><span class="s4">, </span><span class="s1">self._fairy.current())</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s3">pass</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">rec </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">rec._checkout_existing()</span>

        <span class="s3">return </span><span class="s1">_ConnectionFairy._checkout(self</span><span class="s4">, </span><span class="s1">self._fairy)</span>


<span class="s3">class </span><span class="s1">StaticPool(Pool):</span>
    <span class="s2">&quot;&quot;&quot;A Pool of exactly one connection, used for all requests. 
 
    Reconnect-related functions such as ``recycle`` and connection 
    invalidation (which is also used to support auto-reconnect) are only 
    partially supported right now and may not yield good results. 
 
    The :class:`.StaticPool` class **is compatible** with asyncio and 
    :func:`_asyncio.create_async_engine`. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">@util.memoized_property</span>
    <span class="s3">def </span><span class="s1">connection(self) -&gt; _ConnectionRecord:</span>
        <span class="s3">return </span><span class="s1">_ConnectionRecord(self)</span>

    <span class="s3">def </span><span class="s1">status(self) -&gt; str:</span>
        <span class="s3">return </span><span class="s6">&quot;StaticPool&quot;</span>

    <span class="s3">def </span><span class="s1">dispose(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s6">&quot;connection&quot; </span><span class="s3">in </span><span class="s1">self.__dict__</span>
            <span class="s3">and </span><span class="s1">self.connection.dbapi_connection </span><span class="s3">is not None</span>
        <span class="s1">):</span>
            <span class="s1">self.connection.close()</span>
            <span class="s3">del </span><span class="s1">self.__dict__[</span><span class="s6">&quot;connection&quot;</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">recreate(self) -&gt; StaticPool:</span>
        <span class="s1">self.logger.info(</span><span class="s6">&quot;Pool recreating&quot;</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self.__class__(</span>
            <span class="s1">creator=self._creator</span><span class="s4">,</span>
            <span class="s1">recycle=self._recycle</span><span class="s4">,</span>
            <span class="s1">reset_on_return=self._reset_on_return</span><span class="s4">,</span>
            <span class="s1">pre_ping=self._pre_ping</span><span class="s4">,</span>
            <span class="s1">echo=self.echo</span><span class="s4">,</span>
            <span class="s1">logging_name=self._orig_logging_name</span><span class="s4">,</span>
            <span class="s1">_dispatch=self.dispatch</span><span class="s4">,</span>
            <span class="s1">dialect=self._dialect</span><span class="s4">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_transfer_from(self</span><span class="s4">, </span><span class="s1">other_static_pool: StaticPool) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s0"># used by the test suite to make a new engine / pool without</span>
        <span class="s0"># losing the state of an existing SQLite :memory: connection</span>
        <span class="s3">def </span><span class="s1">creator(rec: ConnectionPoolEntry) -&gt; DBAPIConnection:</span>
            <span class="s1">conn = other_static_pool.connection.dbapi_connection</span>
            <span class="s3">assert </span><span class="s1">conn </span><span class="s3">is not None</span>
            <span class="s3">return </span><span class="s1">conn</span>

        <span class="s1">self._invoke_creator = creator</span>

    <span class="s3">def </span><span class="s1">_create_connection(self) -&gt; ConnectionPoolEntry:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s3">def </span><span class="s1">_do_return_conn(self</span><span class="s4">, </span><span class="s1">record: ConnectionPoolEntry) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">pass</span>

    <span class="s3">def </span><span class="s1">_do_get(self) -&gt; ConnectionPoolEntry:</span>
        <span class="s1">rec = self.connection</span>
        <span class="s3">if </span><span class="s1">rec._is_hard_or_soft_invalidated():</span>
            <span class="s3">del </span><span class="s1">self.__dict__[</span><span class="s6">&quot;connection&quot;</span><span class="s1">]</span>
            <span class="s1">rec = self.connection</span>

        <span class="s3">return </span><span class="s1">rec</span>


<span class="s3">class </span><span class="s1">AssertionPool(Pool):</span>
    <span class="s2">&quot;&quot;&quot;A :class:`_pool.Pool` that allows at most one checked out connection at 
    any given time. 
 
    This will raise an exception if more than one connection is checked out 
    at a time.  Useful for debugging code that is using more connections 
    than desired. 
 
    The :class:`.AssertionPool` class **is compatible** with asyncio and 
    :func:`_asyncio.create_async_engine`. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_conn: Optional[ConnectionPoolEntry]</span>
    <span class="s1">_checkout_traceback: Optional[List[str]]</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">*args: Any</span><span class="s4">, </span><span class="s1">**kw: Any):</span>
        <span class="s1">self._conn = </span><span class="s3">None</span>
        <span class="s1">self._checked_out = </span><span class="s3">False</span>
        <span class="s1">self._store_traceback = kw.pop(</span><span class="s6">&quot;store_traceback&quot;</span><span class="s4">, </span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">self._checkout_traceback = </span><span class="s3">None</span>
        <span class="s1">Pool.__init__(self</span><span class="s4">, </span><span class="s1">*args</span><span class="s4">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">status(self) -&gt; str:</span>
        <span class="s3">return </span><span class="s6">&quot;AssertionPool&quot;</span>

    <span class="s3">def </span><span class="s1">_do_return_conn(self</span><span class="s4">, </span><span class="s1">record: ConnectionPoolEntry) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">if not </span><span class="s1">self._checked_out:</span>
            <span class="s3">raise </span><span class="s1">AssertionError(</span><span class="s6">&quot;connection is not checked out&quot;</span><span class="s1">)</span>
        <span class="s1">self._checked_out = </span><span class="s3">False</span>
        <span class="s3">assert </span><span class="s1">record </span><span class="s3">is </span><span class="s1">self._conn</span>

    <span class="s3">def </span><span class="s1">dispose(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">self._checked_out = </span><span class="s3">False</span>
        <span class="s3">if </span><span class="s1">self._conn:</span>
            <span class="s1">self._conn.close()</span>

    <span class="s3">def </span><span class="s1">recreate(self) -&gt; AssertionPool:</span>
        <span class="s1">self.logger.info(</span><span class="s6">&quot;Pool recreating&quot;</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self.__class__(</span>
            <span class="s1">self._creator</span><span class="s4">,</span>
            <span class="s1">echo=self.echo</span><span class="s4">,</span>
            <span class="s1">pre_ping=self._pre_ping</span><span class="s4">,</span>
            <span class="s1">recycle=self._recycle</span><span class="s4">,</span>
            <span class="s1">reset_on_return=self._reset_on_return</span><span class="s4">,</span>
            <span class="s1">logging_name=self._orig_logging_name</span><span class="s4">,</span>
            <span class="s1">_dispatch=self.dispatch</span><span class="s4">,</span>
            <span class="s1">dialect=self._dialect</span><span class="s4">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_do_get(self) -&gt; ConnectionPoolEntry:</span>
        <span class="s3">if </span><span class="s1">self._checked_out:</span>
            <span class="s3">if </span><span class="s1">self._checkout_traceback:</span>
                <span class="s1">suffix = </span><span class="s6">&quot; at:</span><span class="s7">\n</span><span class="s6">%s&quot; </span><span class="s1">% </span><span class="s6">&quot;&quot;</span><span class="s1">.join(</span>
                    <span class="s1">chop_traceback(self._checkout_traceback)</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">suffix = </span><span class="s6">&quot;&quot;</span>
            <span class="s3">raise </span><span class="s1">AssertionError(</span><span class="s6">&quot;connection is already checked out&quot; </span><span class="s1">+ suffix)</span>

        <span class="s3">if not </span><span class="s1">self._conn:</span>
            <span class="s1">self._conn = self._create_connection()</span>

        <span class="s1">self._checked_out = </span><span class="s3">True</span>
        <span class="s3">if </span><span class="s1">self._store_traceback:</span>
            <span class="s1">self._checkout_traceback = traceback.format_stack()</span>
        <span class="s3">return </span><span class="s1">self._conn</span>
</pre>
</body>
</html>