<html>
<head>
<title>mapped_collection.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5d69bb;}
.s1 { color: #d8d8d8;}
.s2 { color: #cc8b60;}
.s3 { color: #96bf7d;}
.s4 { color: #cc7832;}
.s5 { color: #717ed3; font-style: italic;}
.s6 { color: #bbb55b;}
.s7 { color: #d7539b; font-weight: bold;}
</style>
</head>
<body bgcolor="#1a1a25">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
mapped_collection.py</font>
</center></td></tr></table>
<pre><span class="s0"># orm/mapped_collection.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">import </span><span class="s1">operator</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Any</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Callable</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Dict</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Generic</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">List</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Optional</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Sequence</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Tuple</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Type</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TypeVar</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Union</span>

<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">base</span>
<span class="s2">from </span><span class="s1">.collections </span><span class="s2">import </span><span class="s1">collection</span>
<span class="s2">from </span><span class="s1">.collections </span><span class="s2">import </span><span class="s1">collection_adapter</span>
<span class="s2">from </span><span class="s1">.. </span><span class="s2">import </span><span class="s1">exc </span><span class="s2">as </span><span class="s1">sa_exc</span>
<span class="s2">from </span><span class="s1">.. </span><span class="s2">import </span><span class="s1">util</span>
<span class="s2">from </span><span class="s1">..sql </span><span class="s2">import </span><span class="s1">coercions</span>
<span class="s2">from </span><span class="s1">..sql </span><span class="s2">import </span><span class="s1">expression</span>
<span class="s2">from </span><span class="s1">..sql </span><span class="s2">import </span><span class="s1">roles</span>
<span class="s2">from </span><span class="s1">..util.langhelpers </span><span class="s2">import </span><span class="s1">Missing</span>
<span class="s2">from </span><span class="s1">..util.langhelpers </span><span class="s2">import </span><span class="s1">MissingOr</span>
<span class="s2">from </span><span class="s1">..util.typing </span><span class="s2">import </span><span class="s1">Literal</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">AttributeEventToken</span>
    <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">Mapper</span>
    <span class="s2">from </span><span class="s1">.collections </span><span class="s2">import </span><span class="s1">CollectionAdapter</span>
    <span class="s2">from </span><span class="s1">..sql.elements </span><span class="s2">import </span><span class="s1">ColumnElement</span>

<span class="s1">_KT = TypeVar(</span><span class="s3">&quot;_KT&quot;</span><span class="s4">, </span><span class="s1">bound=Any)</span>
<span class="s1">_VT = TypeVar(</span><span class="s3">&quot;_VT&quot;</span><span class="s4">, </span><span class="s1">bound=Any)</span>


<span class="s2">class </span><span class="s1">_PlainColumnGetter(Generic[_KT]):</span>
    <span class="s5">&quot;&quot;&quot;Plain column getter, stores collection of Column objects 
    directly. 
 
    Serializes to a :class:`._SerializableColumnGetterV2` 
    which has more expensive __call__() performance 
    and some rare caveats. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = (</span><span class="s3">&quot;cols&quot;</span><span class="s4">, </span><span class="s3">&quot;composite&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">cols: Sequence[ColumnElement[_KT]]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.cols = cols</span>
        <span class="s1">self.composite = len(cols) &gt; </span><span class="s6">1</span>

    <span class="s2">def </span><span class="s1">__reduce__(</span>
        <span class="s1">self</span><span class="s4">,</span>
    <span class="s1">) -&gt; Tuple[</span>
        <span class="s1">Type[_SerializableColumnGetterV2[_KT]]</span><span class="s4">,</span>
        <span class="s1">Tuple[Sequence[Tuple[Optional[str]</span><span class="s4">, </span><span class="s1">Optional[str]]]]</span><span class="s4">,</span>
    <span class="s1">]:</span>
        <span class="s2">return </span><span class="s1">_SerializableColumnGetterV2._reduce_from_cols(self.cols)</span>

    <span class="s2">def </span><span class="s1">_cols(self</span><span class="s4">, </span><span class="s1">mapper: Mapper[_KT]) -&gt; Sequence[ColumnElement[_KT]]:</span>
        <span class="s2">return </span><span class="s1">self.cols</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s4">, </span><span class="s1">value: _KT) -&gt; MissingOr[Union[_KT</span><span class="s4">, </span><span class="s1">Tuple[_KT</span><span class="s4">, </span><span class="s1">...]]]:</span>
        <span class="s1">state = base.instance_state(value)</span>
        <span class="s1">m = base._state_mapper(state)</span>

        <span class="s1">key: List[_KT] = [</span>
            <span class="s1">m._get_state_attr_by_column(state</span><span class="s4">, </span><span class="s1">state.dict</span><span class="s4">, </span><span class="s1">col)</span>
            <span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">self._cols(m)</span>
        <span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self.composite:</span>
            <span class="s2">return </span><span class="s1">tuple(key)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">obj = key[</span><span class="s6">0</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">obj </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">Missing</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">obj</span>


<span class="s2">class </span><span class="s1">_SerializableColumnGetterV2(_PlainColumnGetter[_KT]):</span>
    <span class="s5">&quot;&quot;&quot;Updated serializable getter which deals with 
    multi-table mapped classes. 
 
    Two extremely unusual cases are not supported. 
    Mappings which have tables across multiple metadata 
    objects, or which are mapped to non-Table selectables 
    linked across inheriting mappers may fail to function 
    here. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = (</span><span class="s3">&quot;colkeys&quot;</span><span class="s4">,</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">colkeys: Sequence[Tuple[Optional[str]</span><span class="s4">, </span><span class="s1">Optional[str]]]</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.colkeys = colkeys</span>
        <span class="s1">self.composite = len(colkeys) &gt; </span><span class="s6">1</span>

    <span class="s2">def </span><span class="s1">__reduce__(</span>
        <span class="s1">self</span><span class="s4">,</span>
    <span class="s1">) -&gt; Tuple[</span>
        <span class="s1">Type[_SerializableColumnGetterV2[_KT]]</span><span class="s4">,</span>
        <span class="s1">Tuple[Sequence[Tuple[Optional[str]</span><span class="s4">, </span><span class="s1">Optional[str]]]]</span><span class="s4">,</span>
    <span class="s1">]:</span>
        <span class="s2">return </span><span class="s1">self.__class__</span><span class="s4">, </span><span class="s1">(self.colkeys</span><span class="s4">,</span><span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_reduce_from_cols(cls</span><span class="s4">, </span><span class="s1">cols: Sequence[ColumnElement[_KT]]) -&gt; Tuple[</span>
        <span class="s1">Type[_SerializableColumnGetterV2[_KT]]</span><span class="s4">,</span>
        <span class="s1">Tuple[Sequence[Tuple[Optional[str]</span><span class="s4">, </span><span class="s1">Optional[str]]]]</span><span class="s4">,</span>
    <span class="s1">]:</span>
        <span class="s2">def </span><span class="s1">_table_key(c: ColumnElement[_KT]) -&gt; Optional[str]:</span>
            <span class="s2">if not </span><span class="s1">isinstance(c.table</span><span class="s4">, </span><span class="s1">expression.TableClause):</span>
                <span class="s2">return None</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">c.table.key  </span><span class="s0"># type: ignore</span>

        <span class="s1">colkeys = [(c.key</span><span class="s4">, </span><span class="s1">_table_key(c)) </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">cols]</span>
        <span class="s2">return </span><span class="s1">_SerializableColumnGetterV2</span><span class="s4">, </span><span class="s1">(colkeys</span><span class="s4">,</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_cols(self</span><span class="s4">, </span><span class="s1">mapper: Mapper[_KT]) -&gt; Sequence[ColumnElement[_KT]]:</span>
        <span class="s1">cols: List[ColumnElement[_KT]] = []</span>
        <span class="s1">metadata = getattr(mapper.local_table</span><span class="s4">, </span><span class="s3">&quot;metadata&quot;</span><span class="s4">, </span><span class="s2">None</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">ckey</span><span class="s4">, </span><span class="s1">tkey </span><span class="s2">in </span><span class="s1">self.colkeys:</span>
            <span class="s2">if </span><span class="s1">tkey </span><span class="s2">is None or </span><span class="s1">metadata </span><span class="s2">is None or </span><span class="s1">tkey </span><span class="s2">not in </span><span class="s1">metadata:</span>
                <span class="s1">cols.append(mapper.local_table.c[ckey])  </span><span class="s0"># type: ignore</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">cols.append(metadata.tables[tkey].c[ckey])</span>
        <span class="s2">return </span><span class="s1">cols</span>


<span class="s2">def </span><span class="s1">column_keyed_dict(</span>
    <span class="s1">mapping_spec: Union[Type[_KT]</span><span class="s4">, </span><span class="s1">Callable[[_KT]</span><span class="s4">, </span><span class="s1">_VT]]</span><span class="s4">,</span>
    <span class="s1">*</span><span class="s4">,</span>
    <span class="s1">ignore_unpopulated_attribute: bool = </span><span class="s2">False</span><span class="s4">,</span>
<span class="s1">) -&gt; Type[KeyFuncDict[_KT</span><span class="s4">, </span><span class="s1">_KT]]:</span>
    <span class="s5">&quot;&quot;&quot;A dictionary-based collection type with column-based keying. 
 
    .. versionchanged:: 2.0 Renamed :data:`.column_mapped_collection` to 
       :class:`.column_keyed_dict`. 
 
    Returns a :class:`.KeyFuncDict` factory which will produce new 
    dictionary keys based on the value of a particular :class:`.Column`-mapped 
    attribute on ORM mapped instances to be added to the dictionary. 
 
    .. note:: the value of the target attribute must be assigned with its 
       value at the time that the object is being added to the 
       dictionary collection.   Additionally, changes to the key attribute 
       are **not tracked**, which means the key in the dictionary is not 
       automatically synchronized with the key value on the target object 
       itself.  See :ref:`key_collections_mutations` for further details. 
 
    .. seealso:: 
 
        :ref:`orm_dictionary_collection` - background on use 
 
    :param mapping_spec: a :class:`_schema.Column` object that is expected 
     to be mapped by the target mapper to a particular attribute on the 
     mapped class, the value of which on a particular instance is to be used 
     as the key for a new dictionary entry for that instance. 
    :param ignore_unpopulated_attribute:  if True, and the mapped attribute 
     indicated by the given :class:`_schema.Column` target attribute 
     on an object is not populated at all, the operation will be silently 
     skipped.  By default, an error is raised. 
 
     .. versionadded:: 2.0 an error is raised by default if the attribute 
        being used for the dictionary key is determined that it was never 
        populated with any value.  The 
        :paramref:`_orm.column_keyed_dict.ignore_unpopulated_attribute` 
        parameter may be set which will instead indicate that this condition 
        should be ignored, and the append operation silently skipped. 
        This is in contrast to the behavior of the 1.x series which would 
        erroneously populate the value in the dictionary with an arbitrary key 
        value of ``None``. 
 
 
    &quot;&quot;&quot;</span>
    <span class="s1">cols = [</span>
        <span class="s1">coercions.expect(roles.ColumnArgumentRole</span><span class="s4">, </span><span class="s1">q</span><span class="s4">, </span><span class="s1">argname=</span><span class="s3">&quot;mapping_spec&quot;</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">q </span><span class="s2">in </span><span class="s1">util.to_list(mapping_spec)</span>
    <span class="s1">]</span>
    <span class="s1">keyfunc = _PlainColumnGetter(cols)</span>
    <span class="s2">return </span><span class="s1">_mapped_collection_cls(</span>
        <span class="s1">keyfunc</span><span class="s4">,</span>
        <span class="s1">ignore_unpopulated_attribute=ignore_unpopulated_attribute</span><span class="s4">,</span>
    <span class="s1">)</span>


<span class="s2">class </span><span class="s1">_AttrGetter:</span>
    <span class="s1">__slots__ = (</span><span class="s3">&quot;attr_name&quot;</span><span class="s4">, </span><span class="s3">&quot;getter&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">attr_name: str):</span>
        <span class="s1">self.attr_name = attr_name</span>
        <span class="s1">self.getter = operator.attrgetter(attr_name)</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s4">, </span><span class="s1">mapped_object: Any) -&gt; Any:</span>
        <span class="s1">obj = self.getter(mapped_object)</span>
        <span class="s2">if </span><span class="s1">obj </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">state = base.instance_state(mapped_object)</span>
            <span class="s1">mp = state.mapper</span>
            <span class="s2">if </span><span class="s1">self.attr_name </span><span class="s2">in </span><span class="s1">mp.attrs:</span>
                <span class="s1">dict_ = state.dict</span>
                <span class="s1">obj = dict_.get(self.attr_name</span><span class="s4">, </span><span class="s1">base.NO_VALUE)</span>
                <span class="s2">if </span><span class="s1">obj </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">Missing</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">Missing</span>

        <span class="s2">return </span><span class="s1">obj</span>

    <span class="s2">def </span><span class="s1">__reduce__(self) -&gt; Tuple[Type[_AttrGetter]</span><span class="s4">, </span><span class="s1">Tuple[str]]:</span>
        <span class="s2">return </span><span class="s1">_AttrGetter</span><span class="s4">, </span><span class="s1">(self.attr_name</span><span class="s4">,</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">attribute_keyed_dict(</span>
    <span class="s1">attr_name: str</span><span class="s4">, </span><span class="s1">*</span><span class="s4">, </span><span class="s1">ignore_unpopulated_attribute: bool = </span><span class="s2">False</span>
<span class="s1">) -&gt; Type[KeyFuncDict[Any</span><span class="s4">, </span><span class="s1">Any]]:</span>
    <span class="s5">&quot;&quot;&quot;A dictionary-based collection type with attribute-based keying. 
 
    .. versionchanged:: 2.0 Renamed :data:`.attribute_mapped_collection` to 
       :func:`.attribute_keyed_dict`. 
 
    Returns a :class:`.KeyFuncDict` factory which will produce new 
    dictionary keys based on the value of a particular named attribute on 
    ORM mapped instances to be added to the dictionary. 
 
    .. note:: the value of the target attribute must be assigned with its 
       value at the time that the object is being added to the 
       dictionary collection.   Additionally, changes to the key attribute 
       are **not tracked**, which means the key in the dictionary is not 
       automatically synchronized with the key value on the target object 
       itself.  See :ref:`key_collections_mutations` for further details. 
 
    .. seealso:: 
 
        :ref:`orm_dictionary_collection` - background on use 
 
    :param attr_name: string name of an ORM-mapped attribute 
     on the mapped class, the value of which on a particular instance 
     is to be used as the key for a new dictionary entry for that instance. 
    :param ignore_unpopulated_attribute:  if True, and the target attribute 
     on an object is not populated at all, the operation will be silently 
     skipped.  By default, an error is raised. 
 
     .. versionadded:: 2.0 an error is raised by default if the attribute 
        being used for the dictionary key is determined that it was never 
        populated with any value.  The 
        :paramref:`_orm.attribute_keyed_dict.ignore_unpopulated_attribute` 
        parameter may be set which will instead indicate that this condition 
        should be ignored, and the append operation silently skipped. 
        This is in contrast to the behavior of the 1.x series which would 
        erroneously populate the value in the dictionary with an arbitrary key 
        value of ``None``. 
 
 
    &quot;&quot;&quot;</span>

    <span class="s2">return </span><span class="s1">_mapped_collection_cls(</span>
        <span class="s1">_AttrGetter(attr_name)</span><span class="s4">,</span>
        <span class="s1">ignore_unpopulated_attribute=ignore_unpopulated_attribute</span><span class="s4">,</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">keyfunc_mapping(</span>
    <span class="s1">keyfunc: Callable[[Any]</span><span class="s4">, </span><span class="s1">Any]</span><span class="s4">,</span>
    <span class="s1">*</span><span class="s4">,</span>
    <span class="s1">ignore_unpopulated_attribute: bool = </span><span class="s2">False</span><span class="s4">,</span>
<span class="s1">) -&gt; Type[KeyFuncDict[_KT</span><span class="s4">, </span><span class="s1">Any]]:</span>
    <span class="s5">&quot;&quot;&quot;A dictionary-based collection type with arbitrary keying. 
 
    .. versionchanged:: 2.0 Renamed :data:`.mapped_collection` to 
       :func:`.keyfunc_mapping`. 
 
    Returns a :class:`.KeyFuncDict` factory with a keying function 
    generated from keyfunc, a callable that takes an entity and returns a 
    key value. 
 
    .. note:: the given keyfunc is called only once at the time that the 
       target object is being added to the collection.   Changes to the 
       effective value returned by the function are not tracked. 
 
 
    .. seealso:: 
 
        :ref:`orm_dictionary_collection` - background on use 
 
    :param keyfunc: a callable that will be passed the ORM-mapped instance 
     which should then generate a new key to use in the dictionary. 
     If the value returned is :attr:`.LoaderCallableStatus.NO_VALUE`, an error 
     is raised. 
    :param ignore_unpopulated_attribute:  if True, and the callable returns 
     :attr:`.LoaderCallableStatus.NO_VALUE` for a particular instance, the 
     operation will be silently skipped.  By default, an error is raised. 
 
     .. versionadded:: 2.0 an error is raised by default if the callable 
        being used for the dictionary key returns 
        :attr:`.LoaderCallableStatus.NO_VALUE`, which in an ORM attribute 
        context indicates an attribute that was never populated with any value. 
        The :paramref:`_orm.mapped_collection.ignore_unpopulated_attribute` 
        parameter may be set which will instead indicate that this condition 
        should be ignored, and the append operation silently skipped. This is 
        in contrast to the behavior of the 1.x series which would erroneously 
        populate the value in the dictionary with an arbitrary key value of 
        ``None``. 
 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_mapped_collection_cls(</span>
        <span class="s1">keyfunc</span><span class="s4">, </span><span class="s1">ignore_unpopulated_attribute=ignore_unpopulated_attribute</span>
    <span class="s1">)</span>


<span class="s2">class </span><span class="s1">KeyFuncDict(Dict[_KT</span><span class="s4">, </span><span class="s1">_VT]):</span>
    <span class="s5">&quot;&quot;&quot;Base for ORM mapped dictionary classes. 
 
    Extends the ``dict`` type with additional methods needed by SQLAlchemy ORM 
    collection classes. Use of :class:`_orm.KeyFuncDict` is most directly 
    by using the :func:`.attribute_keyed_dict` or 
    :func:`.column_keyed_dict` class factories. 
    :class:`_orm.KeyFuncDict` may also serve as the base for user-defined 
    custom dictionary classes. 
 
    .. versionchanged:: 2.0 Renamed :class:`.MappedCollection` to 
       :class:`.KeyFuncDict`. 
 
    .. seealso:: 
 
        :func:`_orm.attribute_keyed_dict` 
 
        :func:`_orm.column_keyed_dict` 
 
        :ref:`orm_dictionary_collection` 
 
        :ref:`orm_custom_collection` 
 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">keyfunc: Callable[[Any]</span><span class="s4">, </span><span class="s1">Any]</span><span class="s4">,</span>
        <span class="s1">*dict_args: Any</span><span class="s4">,</span>
        <span class="s1">ignore_unpopulated_attribute: bool = </span><span class="s2">False</span><span class="s4">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Create a new collection with keying provided by keyfunc. 
 
        keyfunc may be any callable that takes an object and returns an object 
        for use as a dictionary key. 
 
        The keyfunc will be called every time the ORM needs to add a member by 
        value-only (such as when loading instances from the database) or 
        remove a member.  The usual cautions about dictionary keying apply- 
        ``keyfunc(object)`` should return the same output for the life of the 
        collection.  Keying based on mutable properties can result in 
        unreachable instances &quot;lost&quot; in the collection. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.keyfunc = keyfunc</span>
        <span class="s1">self.ignore_unpopulated_attribute = ignore_unpopulated_attribute</span>
        <span class="s1">super().__init__(*dict_args)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_unreduce(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">keyfunc: Callable[[Any]</span><span class="s4">, </span><span class="s1">Any]</span><span class="s4">,</span>
        <span class="s1">values: Dict[_KT</span><span class="s4">, </span><span class="s1">_KT]</span><span class="s4">,</span>
        <span class="s1">adapter: Optional[CollectionAdapter] = </span><span class="s2">None</span><span class="s4">,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;KeyFuncDict[_KT, _KT]&quot;</span><span class="s1">:</span>
        <span class="s1">mp: KeyFuncDict[_KT</span><span class="s4">, </span><span class="s1">_KT] = KeyFuncDict(keyfunc)</span>
        <span class="s1">mp.update(values)</span>
        <span class="s0"># note that the adapter sets itself up onto this collection</span>
        <span class="s0"># when its `__setstate__` method is called</span>
        <span class="s2">return </span><span class="s1">mp</span>

    <span class="s2">def </span><span class="s1">__reduce__(</span>
        <span class="s1">self</span><span class="s4">,</span>
    <span class="s1">) -&gt; Tuple[</span>
        <span class="s1">Callable[[_KT</span><span class="s4">, </span><span class="s1">_KT]</span><span class="s4">, </span><span class="s1">KeyFuncDict[_KT</span><span class="s4">, </span><span class="s1">_KT]]</span><span class="s4">,</span>
        <span class="s1">Tuple[Any</span><span class="s4">, </span><span class="s1">Union[Dict[_KT</span><span class="s4">, </span><span class="s1">_KT]</span><span class="s4">, </span><span class="s1">Dict[_KT</span><span class="s4">, </span><span class="s1">_KT]]</span><span class="s4">, </span><span class="s1">CollectionAdapter]</span><span class="s4">,</span>
    <span class="s1">]:</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">KeyFuncDict._unreduce</span><span class="s4">,</span>
            <span class="s1">(</span>
                <span class="s1">self.keyfunc</span><span class="s4">,</span>
                <span class="s1">dict(self)</span><span class="s4">,</span>
                <span class="s1">collection_adapter(self)</span><span class="s4">,</span>
            <span class="s1">)</span><span class="s4">,</span>
        <span class="s1">)</span>

    <span class="s1">@util.preload_module(</span><span class="s3">&quot;sqlalchemy.orm.attributes&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">_raise_for_unpopulated(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">value: _KT</span><span class="s4">,</span>
        <span class="s1">initiator: Union[AttributeEventToken</span><span class="s4">, </span><span class="s1">Literal[</span><span class="s2">None</span><span class="s4">, </span><span class="s2">False</span><span class="s1">]] = </span><span class="s2">None</span><span class="s4">,</span>
        <span class="s1">*</span><span class="s4">,</span>
        <span class="s1">warn_only: bool</span><span class="s4">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">mapper = base.instance_state(value).mapper</span>

        <span class="s1">attributes = util.preloaded.orm_attributes</span>

        <span class="s2">if not </span><span class="s1">isinstance(initiator</span><span class="s4">, </span><span class="s1">attributes.AttributeEventToken):</span>
            <span class="s1">relationship = </span><span class="s3">&quot;unknown relationship&quot;</span>
        <span class="s2">elif </span><span class="s1">initiator.key </span><span class="s2">in </span><span class="s1">mapper.attrs:</span>
            <span class="s1">relationship = </span><span class="s3">f&quot;</span><span class="s7">{</span><span class="s1">mapper.attrs[initiator.key]</span><span class="s7">}</span><span class="s3">&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">relationship = initiator.key</span>

        <span class="s2">if </span><span class="s1">warn_only:</span>
            <span class="s1">util.warn(</span>
                <span class="s3">f&quot;Attribute keyed dictionary value for &quot;</span>
                <span class="s3">f&quot;attribute '</span><span class="s7">{</span><span class="s1">relationship</span><span class="s7">}</span><span class="s3">' was None; this will raise &quot;</span>
                <span class="s3">&quot;in a future release. &quot;</span>
                <span class="s3">f&quot;To skip this assignment entirely, &quot;</span>
                <span class="s3">f'Set the &quot;ignore_unpopulated_attribute=True&quot; '</span>
                <span class="s3">f&quot;parameter on the mapped collection factory.&quot;</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">sa_exc.InvalidRequestError(</span>
                <span class="s3">&quot;In event triggered from population of &quot;</span>
                <span class="s3">f&quot;attribute '</span><span class="s7">{</span><span class="s1">relationship</span><span class="s7">}</span><span class="s3">' &quot;</span>
                <span class="s3">&quot;(potentially from a backref), &quot;</span>
                <span class="s3">f&quot;can't populate value in KeyFuncDict; &quot;</span>
                <span class="s3">&quot;dictionary key &quot;</span>
                <span class="s3">f&quot;derived from </span><span class="s7">{</span><span class="s1">base.instance_str(value)</span><span class="s7">} </span><span class="s3">is not &quot;</span>
                <span class="s3">f&quot;populated. Ensure appropriate state is set up on &quot;</span>
                <span class="s3">f&quot;the </span><span class="s7">{</span><span class="s1">base.instance_str(value)</span><span class="s7">} </span><span class="s3">object &quot;</span>
                <span class="s3">f&quot;before assigning to the </span><span class="s7">{</span><span class="s1">relationship</span><span class="s7">} </span><span class="s3">attribute. &quot;</span>
                <span class="s3">f&quot;To skip this assignment entirely, &quot;</span>
                <span class="s3">f'Set the &quot;ignore_unpopulated_attribute=True&quot; '</span>
                <span class="s3">f&quot;parameter on the mapped collection factory.&quot;</span>
            <span class="s1">)</span>

    <span class="s1">@collection.appender  </span><span class="s0"># type: ignore[misc]</span>
    <span class="s1">@collection.internally_instrumented  </span><span class="s0"># type: ignore[misc]</span>
    <span class="s2">def </span><span class="s1">set(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">value: _KT</span><span class="s4">,</span>
        <span class="s1">_sa_initiator: Union[AttributeEventToken</span><span class="s4">, </span><span class="s1">Literal[</span><span class="s2">None</span><span class="s4">, </span><span class="s2">False</span><span class="s1">]] = </span><span class="s2">None</span><span class="s4">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Add an item by value, consulting the keyfunc for the key.&quot;&quot;&quot;</span>

        <span class="s1">key = self.keyfunc(value)</span>

        <span class="s2">if </span><span class="s1">key </span><span class="s2">is </span><span class="s1">base.NO_VALUE:</span>
            <span class="s2">if not </span><span class="s1">self.ignore_unpopulated_attribute:</span>
                <span class="s1">self._raise_for_unpopulated(</span>
                    <span class="s1">value</span><span class="s4">, </span><span class="s1">_sa_initiator</span><span class="s4">, </span><span class="s1">warn_only=</span><span class="s2">False</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return</span>
        <span class="s2">elif </span><span class="s1">key </span><span class="s2">is </span><span class="s1">Missing:</span>
            <span class="s2">if not </span><span class="s1">self.ignore_unpopulated_attribute:</span>
                <span class="s1">self._raise_for_unpopulated(</span>
                    <span class="s1">value</span><span class="s4">, </span><span class="s1">_sa_initiator</span><span class="s4">, </span><span class="s1">warn_only=</span><span class="s2">True</span>
                <span class="s1">)</span>
                <span class="s1">key = </span><span class="s2">None</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return</span>

        <span class="s1">self.__setitem__(key</span><span class="s4">, </span><span class="s1">value</span><span class="s4">, </span><span class="s1">_sa_initiator)  </span><span class="s0"># type: ignore[call-arg]</span>

    <span class="s1">@collection.remover  </span><span class="s0"># type: ignore[misc]</span>
    <span class="s1">@collection.internally_instrumented  </span><span class="s0"># type: ignore[misc]</span>
    <span class="s2">def </span><span class="s1">remove(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">value: _KT</span><span class="s4">,</span>
        <span class="s1">_sa_initiator: Union[AttributeEventToken</span><span class="s4">, </span><span class="s1">Literal[</span><span class="s2">None</span><span class="s4">, </span><span class="s2">False</span><span class="s1">]] = </span><span class="s2">None</span><span class="s4">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Remove an item by value, consulting the keyfunc for the key.&quot;&quot;&quot;</span>

        <span class="s1">key = self.keyfunc(value)</span>

        <span class="s2">if </span><span class="s1">key </span><span class="s2">is </span><span class="s1">base.NO_VALUE:</span>
            <span class="s2">if not </span><span class="s1">self.ignore_unpopulated_attribute:</span>
                <span class="s1">self._raise_for_unpopulated(</span>
                    <span class="s1">value</span><span class="s4">, </span><span class="s1">_sa_initiator</span><span class="s4">, </span><span class="s1">warn_only=</span><span class="s2">False</span>
                <span class="s1">)</span>
            <span class="s2">return</span>
        <span class="s2">elif </span><span class="s1">key </span><span class="s2">is </span><span class="s1">Missing:</span>
            <span class="s2">if not </span><span class="s1">self.ignore_unpopulated_attribute:</span>
                <span class="s1">self._raise_for_unpopulated(</span>
                    <span class="s1">value</span><span class="s4">, </span><span class="s1">_sa_initiator</span><span class="s4">, </span><span class="s1">warn_only=</span><span class="s2">True</span>
                <span class="s1">)</span>
                <span class="s1">key = </span><span class="s2">None</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return</span>

        <span class="s0"># Let self[key] raise if key is not in this collection</span>
        <span class="s0"># testlib.pragma exempt:__ne__</span>
        <span class="s2">if </span><span class="s1">self[key] != value:</span>
            <span class="s2">raise </span><span class="s1">sa_exc.InvalidRequestError(</span>
                <span class="s3">&quot;Can not remove '%s': collection holds '%s' for key '%s'. &quot;</span>
                <span class="s3">&quot;Possible cause: is the KeyFuncDict key function &quot;</span>
                <span class="s3">&quot;based on mutable properties or properties that only obtain &quot;</span>
                <span class="s3">&quot;values after flush?&quot; </span><span class="s1">% (value</span><span class="s4">, </span><span class="s1">self[key]</span><span class="s4">, </span><span class="s1">key)</span>
            <span class="s1">)</span>
        <span class="s1">self.__delitem__(key</span><span class="s4">, </span><span class="s1">_sa_initiator)  </span><span class="s0"># type: ignore[call-arg]</span>


<span class="s2">def </span><span class="s1">_mapped_collection_cls(</span>
    <span class="s1">keyfunc: Callable[[Any]</span><span class="s4">, </span><span class="s1">Any]</span><span class="s4">, </span><span class="s1">ignore_unpopulated_attribute: bool</span>
<span class="s1">) -&gt; Type[KeyFuncDict[_KT</span><span class="s4">, </span><span class="s1">_KT]]:</span>
    <span class="s2">class </span><span class="s1">_MKeyfuncMapped(KeyFuncDict[_KT</span><span class="s4">, </span><span class="s1">_KT]):</span>
        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">*dict_args: Any) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
            <span class="s1">super().__init__(</span>
                <span class="s1">keyfunc</span><span class="s4">,</span>
                <span class="s1">*dict_args</span><span class="s4">,</span>
                <span class="s1">ignore_unpopulated_attribute=ignore_unpopulated_attribute</span><span class="s4">,</span>
            <span class="s1">)</span>

    <span class="s2">return </span><span class="s1">_MKeyfuncMapped</span>


<span class="s1">MappedCollection = KeyFuncDict</span>
<span class="s3">&quot;&quot;&quot;A synonym for :class:`.KeyFuncDict`. 
 
.. versionchanged:: 2.0 Renamed :class:`.MappedCollection` to 
   :class:`.KeyFuncDict`. 
 
&quot;&quot;&quot;</span>

<span class="s1">mapped_collection = keyfunc_mapping</span>
<span class="s3">&quot;&quot;&quot;A synonym for :func:`_orm.keyfunc_mapping`. 
 
.. versionchanged:: 2.0 Renamed :data:`.mapped_collection` to 
   :func:`_orm.keyfunc_mapping` 
 
&quot;&quot;&quot;</span>

<span class="s1">attribute_mapped_collection = attribute_keyed_dict</span>
<span class="s3">&quot;&quot;&quot;A synonym for :func:`_orm.attribute_keyed_dict`. 
 
.. versionchanged:: 2.0 Renamed :data:`.attribute_mapped_collection` to 
   :func:`_orm.attribute_keyed_dict` 
 
&quot;&quot;&quot;</span>

<span class="s1">column_mapped_collection = column_keyed_dict</span>
<span class="s3">&quot;&quot;&quot;A synonym for :func:`_orm.column_keyed_dict. 
 
.. versionchanged:: 2.0 Renamed :func:`.column_mapped_collection` to 
   :func:`_orm.column_keyed_dict` 
 
&quot;&quot;&quot;</span>
</pre>
</body>
</html>