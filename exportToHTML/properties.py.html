<html>
<head>
<title>properties.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5d69bb;}
.s1 { color: #d8d8d8;}
.s2 { color: #717ed3; font-style: italic;}
.s3 { color: #cc8b60;}
.s4 { color: #96bf7d;}
.s5 { color: #cc7832;}
.s6 { color: #bbb55b;}
.s7 { color: #d7539b; font-weight: bold;}
</style>
</head>
<body bgcolor="#1a1a25">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
properties.py</font>
</center></td></tr></table>
<pre><span class="s0"># orm/properties.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>

<span class="s2">&quot;&quot;&quot;MapperProperty implementations. 
 
This is a private module which defines the behavior of individual ORM- 
mapped attributes. 
 
&quot;&quot;&quot;</span>

<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">annotations</span>

<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">cast</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Dict</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">List</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Optional</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Sequence</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Set</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Tuple</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Type</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TypeVar</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Union</span>

<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">attributes</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">strategy_options</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">_DeclarativeMapped</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">class_mapper</span>
<span class="s3">from </span><span class="s1">.descriptor_props </span><span class="s3">import </span><span class="s1">CompositeProperty</span>
<span class="s3">from </span><span class="s1">.descriptor_props </span><span class="s3">import </span><span class="s1">ConcreteInheritedProperty</span>
<span class="s3">from </span><span class="s1">.descriptor_props </span><span class="s3">import </span><span class="s1">SynonymProperty</span>
<span class="s3">from </span><span class="s1">.interfaces </span><span class="s3">import </span><span class="s1">_AttributeOptions</span>
<span class="s3">from </span><span class="s1">.interfaces </span><span class="s3">import </span><span class="s1">_DEFAULT_ATTRIBUTE_OPTIONS</span>
<span class="s3">from </span><span class="s1">.interfaces </span><span class="s3">import </span><span class="s1">_IntrospectsAnnotations</span>
<span class="s3">from </span><span class="s1">.interfaces </span><span class="s3">import </span><span class="s1">_MapsColumns</span>
<span class="s3">from </span><span class="s1">.interfaces </span><span class="s3">import </span><span class="s1">MapperProperty</span>
<span class="s3">from </span><span class="s1">.interfaces </span><span class="s3">import </span><span class="s1">PropComparator</span>
<span class="s3">from </span><span class="s1">.interfaces </span><span class="s3">import </span><span class="s1">StrategizedProperty</span>
<span class="s3">from </span><span class="s1">.relationships </span><span class="s3">import </span><span class="s1">RelationshipProperty</span>
<span class="s3">from </span><span class="s1">.util </span><span class="s3">import </span><span class="s1">de_stringify_annotation</span>
<span class="s3">from </span><span class="s1">.util </span><span class="s3">import </span><span class="s1">de_stringify_union_elements</span>
<span class="s3">from </span><span class="s1">.. </span><span class="s3">import </span><span class="s1">exc </span><span class="s3">as </span><span class="s1">sa_exc</span>
<span class="s3">from </span><span class="s1">.. </span><span class="s3">import </span><span class="s1">ForeignKey</span>
<span class="s3">from </span><span class="s1">.. </span><span class="s3">import </span><span class="s1">log</span>
<span class="s3">from </span><span class="s1">.. </span><span class="s3">import </span><span class="s1">util</span>
<span class="s3">from </span><span class="s1">..sql </span><span class="s3">import </span><span class="s1">coercions</span>
<span class="s3">from </span><span class="s1">..sql </span><span class="s3">import </span><span class="s1">roles</span>
<span class="s3">from </span><span class="s1">..sql.base </span><span class="s3">import </span><span class="s1">_NoArg</span>
<span class="s3">from </span><span class="s1">..sql.schema </span><span class="s3">import </span><span class="s1">Column</span>
<span class="s3">from </span><span class="s1">..sql.schema </span><span class="s3">import </span><span class="s1">SchemaConst</span>
<span class="s3">from </span><span class="s1">..sql.type_api </span><span class="s3">import </span><span class="s1">TypeEngine</span>
<span class="s3">from </span><span class="s1">..util.typing </span><span class="s3">import </span><span class="s1">de_optionalize_union_types</span>
<span class="s3">from </span><span class="s1">..util.typing </span><span class="s3">import </span><span class="s1">is_fwd_ref</span>
<span class="s3">from </span><span class="s1">..util.typing </span><span class="s3">import </span><span class="s1">is_optional_union</span>
<span class="s3">from </span><span class="s1">..util.typing </span><span class="s3">import </span><span class="s1">is_pep593</span>
<span class="s3">from </span><span class="s1">..util.typing </span><span class="s3">import </span><span class="s1">is_pep695</span>
<span class="s3">from </span><span class="s1">..util.typing </span><span class="s3">import </span><span class="s1">is_union</span>
<span class="s3">from </span><span class="s1">..util.typing </span><span class="s3">import </span><span class="s1">Self</span>
<span class="s3">from </span><span class="s1">..util.typing </span><span class="s3">import </span><span class="s1">typing_get_args</span>

<span class="s3">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s3">from </span><span class="s1">._typing </span><span class="s3">import </span><span class="s1">_IdentityKeyType</span>
    <span class="s3">from </span><span class="s1">._typing </span><span class="s3">import </span><span class="s1">_InstanceDict</span>
    <span class="s3">from </span><span class="s1">._typing </span><span class="s3">import </span><span class="s1">_ORMColumnExprArgument</span>
    <span class="s3">from </span><span class="s1">._typing </span><span class="s3">import </span><span class="s1">_RegistryType</span>
    <span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">Mapped</span>
    <span class="s3">from </span><span class="s1">.decl_base </span><span class="s3">import </span><span class="s1">_ClassScanMapperConfig</span>
    <span class="s3">from </span><span class="s1">.mapper </span><span class="s3">import </span><span class="s1">Mapper</span>
    <span class="s3">from </span><span class="s1">.session </span><span class="s3">import </span><span class="s1">Session</span>
    <span class="s3">from </span><span class="s1">.state </span><span class="s3">import </span><span class="s1">_InstallLoaderCallableProto</span>
    <span class="s3">from </span><span class="s1">.state </span><span class="s3">import </span><span class="s1">InstanceState</span>
    <span class="s3">from </span><span class="s1">..sql._typing </span><span class="s3">import </span><span class="s1">_InfoType</span>
    <span class="s3">from </span><span class="s1">..sql.elements </span><span class="s3">import </span><span class="s1">ColumnElement</span>
    <span class="s3">from </span><span class="s1">..sql.elements </span><span class="s3">import </span><span class="s1">NamedColumn</span>
    <span class="s3">from </span><span class="s1">..sql.operators </span><span class="s3">import </span><span class="s1">OperatorType</span>
    <span class="s3">from </span><span class="s1">..util.typing </span><span class="s3">import </span><span class="s1">_AnnotationScanType</span>
    <span class="s3">from </span><span class="s1">..util.typing </span><span class="s3">import </span><span class="s1">RODescriptorReference</span>

<span class="s1">_T = TypeVar(</span><span class="s4">&quot;_T&quot;</span><span class="s5">, </span><span class="s1">bound=Any)</span>
<span class="s1">_PT = TypeVar(</span><span class="s4">&quot;_PT&quot;</span><span class="s5">, </span><span class="s1">bound=Any)</span>
<span class="s1">_NC = TypeVar(</span><span class="s4">&quot;_NC&quot;</span><span class="s5">, </span><span class="s1">bound=</span><span class="s4">&quot;NamedColumn[Any]&quot;</span><span class="s1">)</span>

<span class="s1">__all__ = [</span>
    <span class="s4">&quot;ColumnProperty&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;CompositeProperty&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;ConcreteInheritedProperty&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;RelationshipProperty&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;SynonymProperty&quot;</span><span class="s5">,</span>
<span class="s1">]</span>


<span class="s1">@log.class_logger</span>
<span class="s3">class </span><span class="s1">ColumnProperty(</span>
    <span class="s1">_MapsColumns[_T]</span><span class="s5">,</span>
    <span class="s1">StrategizedProperty[_T]</span><span class="s5">,</span>
    <span class="s1">_IntrospectsAnnotations</span><span class="s5">,</span>
    <span class="s1">log.Identified</span><span class="s5">,</span>
<span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Describes an object attribute that corresponds to a table column 
    or other column expression. 
 
    Public constructor is the :func:`_orm.column_property` function. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">strategy_wildcard_key = strategy_options._COLUMN_TOKEN</span>
    <span class="s1">inherit_cache = </span><span class="s3">True</span>
    <span class="s4">&quot;&quot;&quot;:meta private:&quot;&quot;&quot;</span>

    <span class="s1">_links_to_entity = </span><span class="s3">False</span>

    <span class="s1">columns: List[NamedColumn[Any]]</span>

    <span class="s1">_is_polymorphic_discriminator: bool</span>

    <span class="s1">_mapped_by_synonym: Optional[str]</span>

    <span class="s1">comparator_factory: Type[PropComparator[_T]]</span>

    <span class="s1">__slots__ = (</span>
        <span class="s4">&quot;columns&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;group&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;deferred&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;instrument&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;comparator_factory&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;active_history&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;expire_on_flush&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;_creation_order&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;_is_polymorphic_discriminator&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;_mapped_by_synonym&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;_deferred_column_loader&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;_raise_column_loader&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;_renders_in_subqueries&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;raiseload&quot;</span><span class="s5">,</span>
    <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">column: _ORMColumnExprArgument[_T]</span><span class="s5">,</span>
        <span class="s1">*additional_columns: _ORMColumnExprArgument[Any]</span><span class="s5">,</span>
        <span class="s1">attribute_options: Optional[_AttributeOptions] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">group: Optional[str] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">deferred: bool = </span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">raiseload: bool = </span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">comparator_factory: Optional[Type[PropComparator[_T]]] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">active_history: bool = </span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">expire_on_flush: bool = </span><span class="s3">True</span><span class="s5">,</span>
        <span class="s1">info: Optional[_InfoType] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">doc: Optional[str] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">_instrument: bool = </span><span class="s3">True</span><span class="s5">,</span>
        <span class="s1">_assume_readonly_dc_attributes: bool = </span><span class="s3">False</span><span class="s5">,</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">attribute_options=attribute_options</span><span class="s5">,</span>
            <span class="s1">_assume_readonly_dc_attributes=_assume_readonly_dc_attributes</span><span class="s5">,</span>
        <span class="s1">)</span>
        <span class="s1">columns = (column</span><span class="s5">,</span><span class="s1">) + additional_columns</span>
        <span class="s1">self.columns = [</span>
            <span class="s1">coercions.expect(roles.LabeledColumnExprRole</span><span class="s5">, </span><span class="s1">c) </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">columns</span>
        <span class="s1">]</span>
        <span class="s1">self.group = group</span>
        <span class="s1">self.deferred = deferred</span>
        <span class="s1">self.raiseload = raiseload</span>
        <span class="s1">self.instrument = _instrument</span>
        <span class="s1">self.comparator_factory = (</span>
            <span class="s1">comparator_factory</span>
            <span class="s3">if </span><span class="s1">comparator_factory </span><span class="s3">is not None</span>
            <span class="s3">else </span><span class="s1">self.__class__.Comparator</span>
        <span class="s1">)</span>
        <span class="s1">self.active_history = active_history</span>
        <span class="s1">self.expire_on_flush = expire_on_flush</span>

        <span class="s3">if </span><span class="s1">info </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.info.update(info)</span>

        <span class="s3">if </span><span class="s1">doc </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.doc = doc</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">reversed(self.columns):</span>
                <span class="s1">doc = getattr(col</span><span class="s5">, </span><span class="s4">&quot;doc&quot;</span><span class="s5">, </span><span class="s3">None</span><span class="s1">)</span>
                <span class="s3">if </span><span class="s1">doc </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">self.doc = doc</span>
                    <span class="s3">break</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self.doc = </span><span class="s3">None</span>

        <span class="s1">util.set_creation_order(self)</span>

        <span class="s1">self.strategy_key = (</span>
            <span class="s1">(</span><span class="s4">&quot;deferred&quot;</span><span class="s5">, </span><span class="s1">self.deferred)</span><span class="s5">,</span>
            <span class="s1">(</span><span class="s4">&quot;instrument&quot;</span><span class="s5">, </span><span class="s1">self.instrument)</span><span class="s5">,</span>
        <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">self.raiseload:</span>
            <span class="s1">self.strategy_key += ((</span><span class="s4">&quot;raiseload&quot;</span><span class="s5">, </span><span class="s3">True</span><span class="s1">)</span><span class="s5">,</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">declarative_scan(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">decl_scan: _ClassScanMapperConfig</span><span class="s5">,</span>
        <span class="s1">registry: _RegistryType</span><span class="s5">,</span>
        <span class="s1">cls: Type[Any]</span><span class="s5">,</span>
        <span class="s1">originating_module: Optional[str]</span><span class="s5">,</span>
        <span class="s1">key: str</span><span class="s5">,</span>
        <span class="s1">mapped_container: Optional[Type[Mapped[Any]]]</span><span class="s5">,</span>
        <span class="s1">annotation: Optional[_AnnotationScanType]</span><span class="s5">,</span>
        <span class="s1">extracted_mapped_annotation: Optional[_AnnotationScanType]</span><span class="s5">,</span>
        <span class="s1">is_dataclass_field: bool</span><span class="s5">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">column = self.columns[</span><span class="s6">0</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">column.key </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">column.key = key</span>
        <span class="s3">if </span><span class="s1">column.name </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">column.name = key</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">mapper_property_to_assign(self) -&gt; Optional[MapperProperty[_T]]:</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">columns_to_assign(self) -&gt; List[Tuple[Column[Any]</span><span class="s5">, </span><span class="s1">int]]:</span>
        <span class="s0"># mypy doesn't care about the isinstance here</span>
        <span class="s3">return </span><span class="s1">[</span>
            <span class="s1">(c</span><span class="s5">, </span><span class="s6">0</span><span class="s1">)  </span><span class="s0"># type: ignore</span>
            <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">self.columns</span>
            <span class="s3">if </span><span class="s1">isinstance(c</span><span class="s5">, </span><span class="s1">Column) </span><span class="s3">and </span><span class="s1">c.table </span><span class="s3">is None</span>
        <span class="s1">]</span>

    <span class="s3">def </span><span class="s1">_memoized_attr__renders_in_subqueries(self) -&gt; bool:</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s4">&quot;query_expression&quot;</span><span class="s5">, </span><span class="s3">True</span><span class="s1">) </span><span class="s3">in </span><span class="s1">self.strategy_key:</span>
            <span class="s3">return </span><span class="s1">self.strategy._have_default_expression  </span><span class="s0"># type: ignore</span>

        <span class="s3">return </span><span class="s1">(</span><span class="s4">&quot;deferred&quot;</span><span class="s5">, </span><span class="s3">True</span><span class="s1">) </span><span class="s3">not in </span><span class="s1">self.strategy_key </span><span class="s3">or </span><span class="s1">(</span>
            <span class="s1">self </span><span class="s3">not in </span><span class="s1">self.parent._readonly_props  </span><span class="s0"># type: ignore</span>
        <span class="s1">)</span>

    <span class="s1">@util.preload_module(</span><span class="s4">&quot;sqlalchemy.orm.state&quot;</span><span class="s5">, </span><span class="s4">&quot;sqlalchemy.orm.strategies&quot;</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">_memoized_attr__deferred_column_loader(</span>
        <span class="s1">self</span><span class="s5">,</span>
    <span class="s1">) -&gt; _InstallLoaderCallableProto[Any]:</span>
        <span class="s1">state = util.preloaded.orm_state</span>
        <span class="s1">strategies = util.preloaded.orm_strategies</span>
        <span class="s3">return </span><span class="s1">state.InstanceState._instance_level_callable_processor(</span>
            <span class="s1">self.parent.class_manager</span><span class="s5">,</span>
            <span class="s1">strategies.LoadDeferredColumns(self.key)</span><span class="s5">,</span>
            <span class="s1">self.key</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s1">@util.preload_module(</span><span class="s4">&quot;sqlalchemy.orm.state&quot;</span><span class="s5">, </span><span class="s4">&quot;sqlalchemy.orm.strategies&quot;</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">_memoized_attr__raise_column_loader(</span>
        <span class="s1">self</span><span class="s5">,</span>
    <span class="s1">) -&gt; _InstallLoaderCallableProto[Any]:</span>
        <span class="s1">state = util.preloaded.orm_state</span>
        <span class="s1">strategies = util.preloaded.orm_strategies</span>
        <span class="s3">return </span><span class="s1">state.InstanceState._instance_level_callable_processor(</span>
            <span class="s1">self.parent.class_manager</span><span class="s5">,</span>
            <span class="s1">strategies.LoadDeferredColumns(self.key</span><span class="s5">, </span><span class="s3">True</span><span class="s1">)</span><span class="s5">,</span>
            <span class="s1">self.key</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__clause_element__(self) -&gt; roles.ColumnsClauseRole:</span>
        <span class="s2">&quot;&quot;&quot;Allow the ColumnProperty to work in expression before it is turned 
        into an instrumented attribute. 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">self.expression</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">expression(self) -&gt; roles.ColumnsClauseRole:</span>
        <span class="s2">&quot;&quot;&quot;Return the primary column or expression for this ColumnProperty. 
 
        E.g.:: 
 
 
            class File(Base): 
                # ... 
 
                name = Column(String(64)) 
                extension = Column(String(8)) 
                filename = column_property(name + '.' + extension) 
                path = column_property('C:/' + filename.expression) 
 
        .. seealso:: 
 
            :ref:`mapper_column_property_sql_expressions_composed` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.columns[</span><span class="s6">0</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">instrument_class(self</span><span class="s5">, </span><span class="s1">mapper: Mapper[Any]) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">if not </span><span class="s1">self.instrument:</span>
            <span class="s3">return</span>

        <span class="s1">attributes.register_descriptor(</span>
            <span class="s1">mapper.class_</span><span class="s5">,</span>
            <span class="s1">self.key</span><span class="s5">,</span>
            <span class="s1">comparator=self.comparator_factory(self</span><span class="s5">, </span><span class="s1">mapper)</span><span class="s5">,</span>
            <span class="s1">parententity=mapper</span><span class="s5">,</span>
            <span class="s1">doc=self.doc</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">do_init(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">super().do_init()</span>

        <span class="s3">if </span><span class="s1">len(self.columns) &gt; </span><span class="s6">1 </span><span class="s3">and </span><span class="s1">set(self.parent.primary_key).issuperset(</span>
            <span class="s1">self.columns</span>
        <span class="s1">):</span>
            <span class="s1">util.warn(</span>
                <span class="s1">(</span>
                    <span class="s4">&quot;On mapper %s, primary key column '%s' is being combined &quot;</span>
                    <span class="s4">&quot;with distinct primary key column '%s' in attribute '%s'. &quot;</span>
                    <span class="s4">&quot;Use explicit properties to give each column its own &quot;</span>
                    <span class="s4">&quot;mapped attribute name.&quot;</span>
                <span class="s1">)</span>
                <span class="s1">% (self.parent</span><span class="s5">, </span><span class="s1">self.columns[</span><span class="s6">1</span><span class="s1">]</span><span class="s5">, </span><span class="s1">self.columns[</span><span class="s6">0</span><span class="s1">]</span><span class="s5">, </span><span class="s1">self.key)</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">copy(self) -&gt; ColumnProperty[_T]:</span>
        <span class="s3">return </span><span class="s1">ColumnProperty(</span>
            <span class="s1">*self.columns</span><span class="s5">,</span>
            <span class="s1">deferred=self.deferred</span><span class="s5">,</span>
            <span class="s1">group=self.group</span><span class="s5">,</span>
            <span class="s1">active_history=self.active_history</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">merge(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">session: Session</span><span class="s5">,</span>
        <span class="s1">source_state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">source_dict: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">dest_state: InstanceState[Any]</span><span class="s5">,</span>
        <span class="s1">dest_dict: _InstanceDict</span><span class="s5">,</span>
        <span class="s1">load: bool</span><span class="s5">,</span>
        <span class="s1">_recursive: Dict[Any</span><span class="s5">, </span><span class="s1">object]</span><span class="s5">,</span>
        <span class="s1">_resolve_conflict_map: Dict[_IdentityKeyType[Any]</span><span class="s5">, </span><span class="s1">object]</span><span class="s5">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s3">if not </span><span class="s1">self.instrument:</span>
            <span class="s3">return</span>
        <span class="s3">elif </span><span class="s1">self.key </span><span class="s3">in </span><span class="s1">source_dict:</span>
            <span class="s1">value = source_dict[self.key]</span>

            <span class="s3">if not </span><span class="s1">load:</span>
                <span class="s1">dest_dict[self.key] = value</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">impl = dest_state.get_impl(self.key)</span>
                <span class="s1">impl.set(dest_state</span><span class="s5">, </span><span class="s1">dest_dict</span><span class="s5">, </span><span class="s1">value</span><span class="s5">, </span><span class="s3">None</span><span class="s1">)</span>
        <span class="s3">elif </span><span class="s1">dest_state.has_identity </span><span class="s3">and </span><span class="s1">self.key </span><span class="s3">not in </span><span class="s1">dest_dict:</span>
            <span class="s1">dest_state._expire_attributes(</span>
                <span class="s1">dest_dict</span><span class="s5">, </span><span class="s1">[self.key]</span><span class="s5">, </span><span class="s1">no_loader=</span><span class="s3">True</span>
            <span class="s1">)</span>

    <span class="s3">class </span><span class="s1">Comparator(util.MemoizedSlots</span><span class="s5">, </span><span class="s1">PropComparator[_PT]):</span>
        <span class="s2">&quot;&quot;&quot;Produce boolean, comparison, and other operators for 
        :class:`.ColumnProperty` attributes. 
 
        See the documentation for :class:`.PropComparator` for a brief 
        overview. 
 
        .. seealso:: 
 
            :class:`.PropComparator` 
 
            :class:`.ColumnOperators` 
 
            :ref:`types_operators` 
 
            :attr:`.TypeEngine.comparator_factory` 
 
        &quot;&quot;&quot;</span>

        <span class="s3">if not </span><span class="s1">TYPE_CHECKING:</span>
            <span class="s0"># prevent pylance from being clever about slots</span>
            <span class="s1">__slots__ = </span><span class="s4">&quot;__clause_element__&quot;</span><span class="s5">, </span><span class="s4">&quot;info&quot;</span><span class="s5">, </span><span class="s4">&quot;expressions&quot;</span>

        <span class="s1">prop: RODescriptorReference[ColumnProperty[_PT]]</span>

        <span class="s1">expressions: Sequence[NamedColumn[Any]]</span>
        <span class="s4">&quot;&quot;&quot;The full sequence of columns referenced by this 
         attribute, adjusted for any aliasing in progress. 
 
        .. versionadded:: 1.3.17 
 
        .. seealso:: 
 
           :ref:`maptojoin` - usage example 
        &quot;&quot;&quot;</span>

        <span class="s3">def </span><span class="s1">_orm_annotate_column(self</span><span class="s5">, </span><span class="s1">column: _NC) -&gt; _NC:</span>
            <span class="s2">&quot;&quot;&quot;annotate and possibly adapt a column to be returned 
            as the mapped-attribute exposed version of the column. 
 
            The column in this context needs to act as much like the 
            column in an ORM mapped context as possible, so includes 
            annotations to give hints to various ORM functions as to 
            the source entity of this column.   It also adapts it 
            to the mapper's with_polymorphic selectable if one is 
            present. 
 
            &quot;&quot;&quot;</span>

            <span class="s1">pe = self._parententity</span>
            <span class="s1">annotations: Dict[str</span><span class="s5">, </span><span class="s1">Any] = {</span>
                <span class="s4">&quot;entity_namespace&quot;</span><span class="s1">: pe</span><span class="s5">,</span>
                <span class="s4">&quot;parententity&quot;</span><span class="s1">: pe</span><span class="s5">,</span>
                <span class="s4">&quot;parentmapper&quot;</span><span class="s1">: pe</span><span class="s5">,</span>
                <span class="s4">&quot;proxy_key&quot;</span><span class="s1">: self.prop.key</span><span class="s5">,</span>
            <span class="s1">}</span>

            <span class="s1">col = column</span>

            <span class="s0"># for a mapper with polymorphic_on and an adapter, return</span>
            <span class="s0"># the column against the polymorphic selectable.</span>
            <span class="s0"># see also orm.util._orm_downgrade_polymorphic_columns</span>
            <span class="s0"># for the reverse operation.</span>
            <span class="s3">if </span><span class="s1">self._parentmapper._polymorphic_adapter:</span>
                <span class="s1">mapper_local_col = col</span>
                <span class="s1">col = self._parentmapper._polymorphic_adapter.traverse(col)</span>

                <span class="s0"># this is a clue to the ORM Query etc. that this column</span>
                <span class="s0"># was adapted to the mapper's polymorphic_adapter.  the</span>
                <span class="s0"># ORM uses this hint to know which column its adapting.</span>
                <span class="s1">annotations[</span><span class="s4">&quot;adapt_column&quot;</span><span class="s1">] = mapper_local_col</span>

            <span class="s3">return </span><span class="s1">col._annotate(annotations)._set_propagate_attrs(</span>
                <span class="s1">{</span><span class="s4">&quot;compile_state_plugin&quot;</span><span class="s1">: </span><span class="s4">&quot;orm&quot;</span><span class="s5">, </span><span class="s4">&quot;plugin_subject&quot;</span><span class="s1">: pe}</span>
            <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">TYPE_CHECKING:</span>

            <span class="s3">def </span><span class="s1">__clause_element__(self) -&gt; NamedColumn[_PT]: ...</span>

        <span class="s3">def </span><span class="s1">_memoized_method___clause_element__(</span>
            <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">) -&gt; NamedColumn[_PT]:</span>
            <span class="s3">if </span><span class="s1">self.adapter:</span>
                <span class="s3">return </span><span class="s1">self.adapter(self.prop.columns[</span><span class="s6">0</span><span class="s1">]</span><span class="s5">, </span><span class="s1">self.prop.key)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">self._orm_annotate_column(self.prop.columns[</span><span class="s6">0</span><span class="s1">])</span>

        <span class="s3">def </span><span class="s1">_memoized_attr_info(self) -&gt; _InfoType:</span>
            <span class="s2">&quot;&quot;&quot;The .info dictionary for this attribute.&quot;&quot;&quot;</span>

            <span class="s1">ce = self.__clause_element__()</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">ce.info  </span><span class="s0"># type: ignore</span>
            <span class="s3">except </span><span class="s1">AttributeError:</span>
                <span class="s3">return </span><span class="s1">self.prop.info</span>

        <span class="s3">def </span><span class="s1">_memoized_attr_expressions(self) -&gt; Sequence[NamedColumn[Any]]:</span>
            <span class="s2">&quot;&quot;&quot;The full sequence of columns referenced by this 
            attribute, adjusted for any aliasing in progress. 
 
            .. versionadded:: 1.3.17 
 
            &quot;&quot;&quot;</span>
            <span class="s3">if </span><span class="s1">self.adapter:</span>
                <span class="s3">return </span><span class="s1">[</span>
                    <span class="s1">self.adapter(col</span><span class="s5">, </span><span class="s1">self.prop.key)</span>
                    <span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">self.prop.columns</span>
                <span class="s1">]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">[</span>
                    <span class="s1">self._orm_annotate_column(col) </span><span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">self.prop.columns</span>
                <span class="s1">]</span>

        <span class="s3">def </span><span class="s1">_fallback_getattr(self</span><span class="s5">, </span><span class="s1">key: str) -&gt; Any:</span>
            <span class="s2">&quot;&quot;&quot;proxy attribute access down to the mapped column. 
 
            this allows user-defined comparison methods to be accessed. 
            &quot;&quot;&quot;</span>
            <span class="s3">return </span><span class="s1">getattr(self.__clause_element__()</span><span class="s5">, </span><span class="s1">key)</span>

        <span class="s3">def </span><span class="s1">operate(</span>
            <span class="s1">self</span><span class="s5">, </span><span class="s1">op: OperatorType</span><span class="s5">, </span><span class="s1">*other: Any</span><span class="s5">, </span><span class="s1">**kwargs: Any</span>
        <span class="s1">) -&gt; ColumnElement[Any]:</span>
            <span class="s3">return </span><span class="s1">op(self.__clause_element__()</span><span class="s5">, </span><span class="s1">*other</span><span class="s5">, </span><span class="s1">**kwargs)  </span><span class="s0"># type: ignore[no-any-return]  # noqa: E501</span>

        <span class="s3">def </span><span class="s1">reverse_operate(</span>
            <span class="s1">self</span><span class="s5">, </span><span class="s1">op: OperatorType</span><span class="s5">, </span><span class="s1">other: Any</span><span class="s5">, </span><span class="s1">**kwargs: Any</span>
        <span class="s1">) -&gt; ColumnElement[Any]:</span>
            <span class="s1">col = self.__clause_element__()</span>
            <span class="s3">return </span><span class="s1">op(col._bind_param(op</span><span class="s5">, </span><span class="s1">other)</span><span class="s5">, </span><span class="s1">col</span><span class="s5">, </span><span class="s1">**kwargs)  </span><span class="s0"># type: ignore[no-any-return]  # noqa: E501</span>

    <span class="s3">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s3">if not </span><span class="s1">self.parent </span><span class="s3">or not </span><span class="s1">self.key:</span>
            <span class="s3">return </span><span class="s1">object.__repr__(self)</span>
        <span class="s3">return </span><span class="s1">str(self.parent.class_.__name__) + </span><span class="s4">&quot;.&quot; </span><span class="s1">+ self.key</span>


<span class="s3">class </span><span class="s1">MappedSQLExpression(ColumnProperty[_T]</span><span class="s5">, </span><span class="s1">_DeclarativeMapped[_T]):</span>
    <span class="s2">&quot;&quot;&quot;Declarative front-end for the :class:`.ColumnProperty` class. 
 
    Public constructor is the :func:`_orm.column_property` function. 
 
    .. versionchanged:: 2.0 Added :class:`_orm.MappedSQLExpression` as 
       a Declarative compatible subclass for :class:`_orm.ColumnProperty`. 
 
    .. seealso:: 
 
        :class:`.MappedColumn` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">inherit_cache = </span><span class="s3">True</span>
    <span class="s4">&quot;&quot;&quot;:meta private:&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">MappedColumn(</span>
    <span class="s1">_IntrospectsAnnotations</span><span class="s5">,</span>
    <span class="s1">_MapsColumns[_T]</span><span class="s5">,</span>
    <span class="s1">_DeclarativeMapped[_T]</span><span class="s5">,</span>
<span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Maps a single :class:`_schema.Column` on a class. 
 
    :class:`_orm.MappedColumn` is a specialization of the 
    :class:`_orm.ColumnProperty` class and is oriented towards declarative 
    configuration. 
 
    To construct :class:`_orm.MappedColumn` objects, use the 
    :func:`_orm.mapped_column` constructor function. 
 
    .. versionadded:: 2.0 
 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = (</span>
        <span class="s4">&quot;column&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;_creation_order&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;_sort_order&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;foreign_keys&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;_has_nullable&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;_has_insert_default&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;deferred&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;deferred_group&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;deferred_raiseload&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;active_history&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;_attribute_options&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;_has_dataclass_arguments&quot;</span><span class="s5">,</span>
        <span class="s4">&quot;_use_existing_column&quot;</span><span class="s5">,</span>
    <span class="s1">)</span>

    <span class="s1">deferred: Union[_NoArg</span><span class="s5">, </span><span class="s1">bool]</span>
    <span class="s1">deferred_raiseload: bool</span>
    <span class="s1">deferred_group: Optional[str]</span>

    <span class="s1">column: Column[_T]</span>
    <span class="s1">foreign_keys: Optional[Set[ForeignKey]]</span>
    <span class="s1">_attribute_options: _AttributeOptions</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s5">, </span><span class="s1">*arg: Any</span><span class="s5">, </span><span class="s1">**kw: Any):</span>
        <span class="s1">self._attribute_options = attr_opts = kw.pop(</span>
            <span class="s4">&quot;attribute_options&quot;</span><span class="s5">, </span><span class="s1">_DEFAULT_ATTRIBUTE_OPTIONS</span>
        <span class="s1">)</span>

        <span class="s1">self._use_existing_column = kw.pop(</span><span class="s4">&quot;use_existing_column&quot;</span><span class="s5">, </span><span class="s3">False</span><span class="s1">)</span>

        <span class="s1">self._has_dataclass_arguments = (</span>
            <span class="s1">attr_opts </span><span class="s3">is not None</span>
            <span class="s3">and </span><span class="s1">attr_opts != _DEFAULT_ATTRIBUTE_OPTIONS</span>
            <span class="s3">and </span><span class="s1">any(</span>
                <span class="s1">attr_opts[i] </span><span class="s3">is not </span><span class="s1">_NoArg.NO_ARG</span>
                <span class="s3">for </span><span class="s1">i</span><span class="s5">, </span><span class="s1">attr </span><span class="s3">in </span><span class="s1">enumerate(attr_opts._fields)</span>
                <span class="s3">if </span><span class="s1">attr != </span><span class="s4">&quot;dataclasses_default&quot;</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s1">insert_default = kw.pop(</span><span class="s4">&quot;insert_default&quot;</span><span class="s5">, </span><span class="s1">_NoArg.NO_ARG)</span>
        <span class="s1">self._has_insert_default = insert_default </span><span class="s3">is not </span><span class="s1">_NoArg.NO_ARG</span>

        <span class="s3">if </span><span class="s1">self._has_insert_default:</span>
            <span class="s1">kw[</span><span class="s4">&quot;default&quot;</span><span class="s1">] = insert_default</span>
        <span class="s3">elif </span><span class="s1">attr_opts.dataclasses_default </span><span class="s3">is not </span><span class="s1">_NoArg.NO_ARG:</span>
            <span class="s1">kw[</span><span class="s4">&quot;default&quot;</span><span class="s1">] = attr_opts.dataclasses_default</span>

        <span class="s1">self.deferred_group = kw.pop(</span><span class="s4">&quot;deferred_group&quot;</span><span class="s5">, </span><span class="s3">None</span><span class="s1">)</span>
        <span class="s1">self.deferred_raiseload = kw.pop(</span><span class="s4">&quot;deferred_raiseload&quot;</span><span class="s5">, </span><span class="s3">None</span><span class="s1">)</span>
        <span class="s1">self.deferred = kw.pop(</span><span class="s4">&quot;deferred&quot;</span><span class="s5">, </span><span class="s1">_NoArg.NO_ARG)</span>
        <span class="s1">self.active_history = kw.pop(</span><span class="s4">&quot;active_history&quot;</span><span class="s5">, </span><span class="s3">False</span><span class="s1">)</span>

        <span class="s1">self._sort_order = kw.pop(</span><span class="s4">&quot;sort_order&quot;</span><span class="s5">, </span><span class="s1">_NoArg.NO_ARG)</span>
        <span class="s1">self.column = cast(</span><span class="s4">&quot;Column[_T]&quot;</span><span class="s5">, </span><span class="s1">Column(*arg</span><span class="s5">, </span><span class="s1">**kw))</span>
        <span class="s1">self.foreign_keys = self.column.foreign_keys</span>
        <span class="s1">self._has_nullable = </span><span class="s4">&quot;nullable&quot; </span><span class="s3">in </span><span class="s1">kw </span><span class="s3">and </span><span class="s1">kw.get(</span><span class="s4">&quot;nullable&quot;</span><span class="s1">) </span><span class="s3">not in </span><span class="s1">(</span>
            <span class="s3">None</span><span class="s5">,</span>
            <span class="s1">SchemaConst.NULL_UNSPECIFIED</span><span class="s5">,</span>
        <span class="s1">)</span>
        <span class="s1">util.set_creation_order(self)</span>

    <span class="s3">def </span><span class="s1">_copy(self</span><span class="s5">, </span><span class="s1">**kw: Any) -&gt; Self:</span>
        <span class="s1">new = self.__class__.__new__(self.__class__)</span>
        <span class="s1">new.column = self.column._copy(**kw)</span>
        <span class="s1">new.deferred = self.deferred</span>
        <span class="s1">new.deferred_group = self.deferred_group</span>
        <span class="s1">new.deferred_raiseload = self.deferred_raiseload</span>
        <span class="s1">new.foreign_keys = new.column.foreign_keys</span>
        <span class="s1">new.active_history = self.active_history</span>
        <span class="s1">new._has_nullable = self._has_nullable</span>
        <span class="s1">new._attribute_options = self._attribute_options</span>
        <span class="s1">new._has_insert_default = self._has_insert_default</span>
        <span class="s1">new._has_dataclass_arguments = self._has_dataclass_arguments</span>
        <span class="s1">new._use_existing_column = self._use_existing_column</span>
        <span class="s1">new._sort_order = self._sort_order</span>
        <span class="s1">util.set_creation_order(new)</span>
        <span class="s3">return </span><span class="s1">new</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">name(self) -&gt; str:</span>
        <span class="s3">return </span><span class="s1">self.column.name</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">mapper_property_to_assign(self) -&gt; Optional[MapperProperty[_T]]:</span>
        <span class="s1">effective_deferred = self.deferred</span>
        <span class="s3">if </span><span class="s1">effective_deferred </span><span class="s3">is </span><span class="s1">_NoArg.NO_ARG:</span>
            <span class="s1">effective_deferred = bool(</span>
                <span class="s1">self.deferred_group </span><span class="s3">or </span><span class="s1">self.deferred_raiseload</span>
            <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">effective_deferred </span><span class="s3">or </span><span class="s1">self.active_history:</span>
            <span class="s3">return </span><span class="s1">ColumnProperty(</span>
                <span class="s1">self.column</span><span class="s5">,</span>
                <span class="s1">deferred=effective_deferred</span><span class="s5">,</span>
                <span class="s1">group=self.deferred_group</span><span class="s5">,</span>
                <span class="s1">raiseload=self.deferred_raiseload</span><span class="s5">,</span>
                <span class="s1">attribute_options=self._attribute_options</span><span class="s5">,</span>
                <span class="s1">active_history=self.active_history</span><span class="s5">,</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return None</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">columns_to_assign(self) -&gt; List[Tuple[Column[Any]</span><span class="s5">, </span><span class="s1">int]]:</span>
        <span class="s3">return </span><span class="s1">[</span>
            <span class="s1">(</span>
                <span class="s1">self.column</span><span class="s5">,</span>
                <span class="s1">(</span>
                    <span class="s1">self._sort_order</span>
                    <span class="s3">if </span><span class="s1">self._sort_order </span><span class="s3">is not </span><span class="s1">_NoArg.NO_ARG</span>
                    <span class="s3">else </span><span class="s6">0</span>
                <span class="s1">)</span><span class="s5">,</span>
            <span class="s1">)</span>
        <span class="s1">]</span>

    <span class="s3">def </span><span class="s1">__clause_element__(self) -&gt; Column[_T]:</span>
        <span class="s3">return </span><span class="s1">self.column</span>

    <span class="s3">def </span><span class="s1">operate(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">op: OperatorType</span><span class="s5">, </span><span class="s1">*other: Any</span><span class="s5">, </span><span class="s1">**kwargs: Any</span>
    <span class="s1">) -&gt; ColumnElement[Any]:</span>
        <span class="s3">return </span><span class="s1">op(self.__clause_element__()</span><span class="s5">, </span><span class="s1">*other</span><span class="s5">, </span><span class="s1">**kwargs)  </span><span class="s0"># type: ignore[no-any-return]  # noqa: E501</span>

    <span class="s3">def </span><span class="s1">reverse_operate(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">op: OperatorType</span><span class="s5">, </span><span class="s1">other: Any</span><span class="s5">, </span><span class="s1">**kwargs: Any</span>
    <span class="s1">) -&gt; ColumnElement[Any]:</span>
        <span class="s1">col = self.__clause_element__()</span>
        <span class="s3">return </span><span class="s1">op(col._bind_param(op</span><span class="s5">, </span><span class="s1">other)</span><span class="s5">, </span><span class="s1">col</span><span class="s5">, </span><span class="s1">**kwargs)  </span><span class="s0"># type: ignore[no-any-return]  # noqa: E501</span>

    <span class="s3">def </span><span class="s1">found_in_pep593_annotated(self) -&gt; Any:</span>
        <span class="s0"># return a blank mapped_column().  This mapped_column()'s</span>
        <span class="s0"># Column will be merged into it in _init_column_for_annotation().</span>
        <span class="s3">return </span><span class="s1">MappedColumn()</span>

    <span class="s3">def </span><span class="s1">declarative_scan(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">decl_scan: _ClassScanMapperConfig</span><span class="s5">,</span>
        <span class="s1">registry: _RegistryType</span><span class="s5">,</span>
        <span class="s1">cls: Type[Any]</span><span class="s5">,</span>
        <span class="s1">originating_module: Optional[str]</span><span class="s5">,</span>
        <span class="s1">key: str</span><span class="s5">,</span>
        <span class="s1">mapped_container: Optional[Type[Mapped[Any]]]</span><span class="s5">,</span>
        <span class="s1">annotation: Optional[_AnnotationScanType]</span><span class="s5">,</span>
        <span class="s1">extracted_mapped_annotation: Optional[_AnnotationScanType]</span><span class="s5">,</span>
        <span class="s1">is_dataclass_field: bool</span><span class="s5">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">column = self.column</span>

        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">self._use_existing_column</span>
            <span class="s3">and </span><span class="s1">decl_scan.inherits</span>
            <span class="s3">and </span><span class="s1">decl_scan.single</span>
        <span class="s1">):</span>
            <span class="s3">if </span><span class="s1">decl_scan.is_deferred:</span>
                <span class="s3">raise </span><span class="s1">sa_exc.ArgumentError(</span>
                    <span class="s4">&quot;Can't use use_existing_column with deferred mappers&quot;</span>
                <span class="s1">)</span>
            <span class="s1">supercls_mapper = class_mapper(decl_scan.inherits</span><span class="s5">, </span><span class="s3">False</span><span class="s1">)</span>

            <span class="s1">colname = column.name </span><span class="s3">if </span><span class="s1">column.name </span><span class="s3">is not None else </span><span class="s1">key</span>
            <span class="s1">column = self.column = supercls_mapper.local_table.c.get(  </span><span class="s0"># type: ignore[assignment] # noqa: E501</span>
                <span class="s1">colname</span><span class="s5">, </span><span class="s1">column</span>
            <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">column.key </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">column.key = key</span>
        <span class="s3">if </span><span class="s1">column.name </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">column.name = key</span>

        <span class="s1">sqltype = column.type</span>

        <span class="s3">if </span><span class="s1">extracted_mapped_annotation </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">sqltype._isnull </span><span class="s3">and not </span><span class="s1">self.column.foreign_keys:</span>
                <span class="s1">self._raise_for_required(key</span><span class="s5">, </span><span class="s1">cls)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return</span>

        <span class="s1">self._init_column_for_annotation(</span>
            <span class="s1">cls</span><span class="s5">,</span>
            <span class="s1">registry</span><span class="s5">,</span>
            <span class="s1">extracted_mapped_annotation</span><span class="s5">,</span>
            <span class="s1">originating_module</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s1">@util.preload_module(</span><span class="s4">&quot;sqlalchemy.orm.decl_base&quot;</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">declarative_scan_for_composite(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">registry: _RegistryType</span><span class="s5">,</span>
        <span class="s1">cls: Type[Any]</span><span class="s5">,</span>
        <span class="s1">originating_module: Optional[str]</span><span class="s5">,</span>
        <span class="s1">key: str</span><span class="s5">,</span>
        <span class="s1">param_name: str</span><span class="s5">,</span>
        <span class="s1">param_annotation: _AnnotationScanType</span><span class="s5">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">decl_base = util.preloaded.orm_decl_base</span>
        <span class="s1">decl_base._undefer_column_name(param_name</span><span class="s5">, </span><span class="s1">self.column)</span>
        <span class="s1">self._init_column_for_annotation(</span>
            <span class="s1">cls</span><span class="s5">, </span><span class="s1">registry</span><span class="s5">, </span><span class="s1">param_annotation</span><span class="s5">, </span><span class="s1">originating_module</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_init_column_for_annotation(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">cls: Type[Any]</span><span class="s5">,</span>
        <span class="s1">registry: _RegistryType</span><span class="s5">,</span>
        <span class="s1">argument: _AnnotationScanType</span><span class="s5">,</span>
        <span class="s1">originating_module: Optional[str]</span><span class="s5">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">sqltype = self.column.type</span>

        <span class="s3">if </span><span class="s1">isinstance(argument</span><span class="s5">, </span><span class="s1">str) </span><span class="s3">or </span><span class="s1">is_fwd_ref(</span>
            <span class="s1">argument</span><span class="s5">, </span><span class="s1">check_generic=</span><span class="s3">True</span>
        <span class="s1">):</span>
            <span class="s3">assert </span><span class="s1">originating_module </span><span class="s3">is not None</span>
            <span class="s1">argument = de_stringify_annotation(</span>
                <span class="s1">cls</span><span class="s5">, </span><span class="s1">argument</span><span class="s5">, </span><span class="s1">originating_module</span><span class="s5">, </span><span class="s1">include_generic=</span><span class="s3">True</span>
            <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">is_union(argument):</span>
            <span class="s3">assert </span><span class="s1">originating_module </span><span class="s3">is not None</span>
            <span class="s1">argument = de_stringify_union_elements(</span>
                <span class="s1">cls</span><span class="s5">, </span><span class="s1">argument</span><span class="s5">, </span><span class="s1">originating_module</span>
            <span class="s1">)</span>

        <span class="s1">nullable = is_optional_union(argument)</span>

        <span class="s3">if not </span><span class="s1">self._has_nullable:</span>
            <span class="s1">self.column.nullable = nullable</span>

        <span class="s1">our_type = de_optionalize_union_types(argument)</span>

        <span class="s1">use_args_from = </span><span class="s3">None</span>

        <span class="s1">our_original_type = our_type</span>

        <span class="s3">if </span><span class="s1">is_pep695(our_type):</span>
            <span class="s1">our_type = our_type.__value__</span>

        <span class="s3">if </span><span class="s1">is_pep593(our_type):</span>
            <span class="s1">our_type_is_pep593 = </span><span class="s3">True</span>

            <span class="s1">pep_593_components = typing_get_args(our_type)</span>
            <span class="s1">raw_pep_593_type = pep_593_components[</span><span class="s6">0</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">is_optional_union(raw_pep_593_type):</span>
                <span class="s1">raw_pep_593_type = de_optionalize_union_types(raw_pep_593_type)</span>

                <span class="s1">nullable = </span><span class="s3">True</span>
                <span class="s3">if not </span><span class="s1">self._has_nullable:</span>
                    <span class="s1">self.column.nullable = nullable</span>
            <span class="s3">for </span><span class="s1">elem </span><span class="s3">in </span><span class="s1">pep_593_components[</span><span class="s6">1</span><span class="s1">:]:</span>
                <span class="s3">if </span><span class="s1">isinstance(elem</span><span class="s5">, </span><span class="s1">MappedColumn):</span>
                    <span class="s1">use_args_from = elem</span>
                    <span class="s3">break</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">our_type_is_pep593 = </span><span class="s3">False</span>
            <span class="s1">raw_pep_593_type = </span><span class="s3">None</span>

        <span class="s3">if </span><span class="s1">use_args_from </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">(</span>
                <span class="s3">not </span><span class="s1">self._has_insert_default</span>
                <span class="s3">and </span><span class="s1">use_args_from.column.default </span><span class="s3">is not None</span>
            <span class="s1">):</span>
                <span class="s1">self.column.default = </span><span class="s3">None</span>

            <span class="s1">use_args_from.column._merge(self.column)</span>
            <span class="s1">sqltype = self.column.type</span>

            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">use_args_from.deferred </span><span class="s3">is not </span><span class="s1">_NoArg.NO_ARG</span>
                <span class="s3">and </span><span class="s1">self.deferred </span><span class="s3">is </span><span class="s1">_NoArg.NO_ARG</span>
            <span class="s1">):</span>
                <span class="s1">self.deferred = use_args_from.deferred</span>

            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">use_args_from.deferred_group </span><span class="s3">is not None</span>
                <span class="s3">and </span><span class="s1">self.deferred_group </span><span class="s3">is None</span>
            <span class="s1">):</span>
                <span class="s1">self.deferred_group = use_args_from.deferred_group</span>

            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">use_args_from.deferred_raiseload </span><span class="s3">is not None</span>
                <span class="s3">and </span><span class="s1">self.deferred_raiseload </span><span class="s3">is None</span>
            <span class="s1">):</span>
                <span class="s1">self.deferred_raiseload = use_args_from.deferred_raiseload</span>

            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">use_args_from._use_existing_column</span>
                <span class="s3">and not </span><span class="s1">self._use_existing_column</span>
            <span class="s1">):</span>
                <span class="s1">self._use_existing_column = </span><span class="s3">True</span>

            <span class="s3">if </span><span class="s1">use_args_from.active_history:</span>
                <span class="s1">self.active_history = use_args_from.active_history</span>

            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">use_args_from._sort_order </span><span class="s3">is not None</span>
                <span class="s3">and </span><span class="s1">self._sort_order </span><span class="s3">is </span><span class="s1">_NoArg.NO_ARG</span>
            <span class="s1">):</span>
                <span class="s1">self._sort_order = use_args_from._sort_order</span>

            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">use_args_from.column.key </span><span class="s3">is not None</span>
                <span class="s3">or </span><span class="s1">use_args_from.column.name </span><span class="s3">is not None</span>
            <span class="s1">):</span>
                <span class="s1">util.warn_deprecated(</span>
                    <span class="s4">&quot;Can't use the 'key' or 'name' arguments in &quot;</span>
                    <span class="s4">&quot;Annotated with mapped_column(); this will be ignored&quot;</span><span class="s5">,</span>
                    <span class="s4">&quot;2.0.22&quot;</span><span class="s5">,</span>
                <span class="s1">)</span>

            <span class="s3">if </span><span class="s1">use_args_from._has_dataclass_arguments:</span>
                <span class="s3">for </span><span class="s1">idx</span><span class="s5">, </span><span class="s1">arg </span><span class="s3">in </span><span class="s1">enumerate(</span>
                    <span class="s1">use_args_from._attribute_options._fields</span>
                <span class="s1">):</span>
                    <span class="s3">if </span><span class="s1">(</span>
                        <span class="s1">use_args_from._attribute_options[idx]</span>
                        <span class="s3">is not </span><span class="s1">_NoArg.NO_ARG</span>
                    <span class="s1">):</span>
                        <span class="s1">arg = arg.replace(</span><span class="s4">&quot;dataclasses_&quot;</span><span class="s5">, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
                        <span class="s1">util.warn_deprecated(</span>
                            <span class="s4">f&quot;Argument '</span><span class="s7">{</span><span class="s1">arg</span><span class="s7">}</span><span class="s4">' is a dataclass argument and &quot;</span>
                            <span class="s4">&quot;cannot be specified within a mapped_column() &quot;</span>
                            <span class="s4">&quot;bundled inside of an Annotated object&quot;</span><span class="s5">,</span>
                            <span class="s4">&quot;2.0.22&quot;</span><span class="s5">,</span>
                        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">sqltype._isnull </span><span class="s3">and not </span><span class="s1">self.column.foreign_keys:</span>
            <span class="s1">new_sqltype = </span><span class="s3">None</span>

            <span class="s3">if </span><span class="s1">our_type_is_pep593:</span>
                <span class="s1">checks = [our_original_type</span><span class="s5">, </span><span class="s1">raw_pep_593_type]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">checks = [our_original_type]</span>

            <span class="s3">for </span><span class="s1">check_type </span><span class="s3">in </span><span class="s1">checks:</span>
                <span class="s1">new_sqltype = registry._resolve_type(check_type)</span>
                <span class="s3">if </span><span class="s1">new_sqltype </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s3">break</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">isinstance(our_type</span><span class="s5">, </span><span class="s1">TypeEngine) </span><span class="s3">or </span><span class="s1">(</span>
                    <span class="s1">isinstance(our_type</span><span class="s5">, </span><span class="s1">type)</span>
                    <span class="s3">and </span><span class="s1">issubclass(our_type</span><span class="s5">, </span><span class="s1">TypeEngine)</span>
                <span class="s1">):</span>
                    <span class="s3">raise </span><span class="s1">sa_exc.ArgumentError(</span>
                        <span class="s4">f&quot;The type provided inside the </span><span class="s7">{</span><span class="s1">self.column.key</span><span class="s7">!r} </span><span class="s4">&quot;</span>
                        <span class="s4">&quot;attribute Mapped annotation is the SQLAlchemy type &quot;</span>
                        <span class="s4">f&quot;</span><span class="s7">{</span><span class="s1">our_type</span><span class="s7">}</span><span class="s4">. Expected a Python type instead&quot;</span>
                    <span class="s1">)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">raise </span><span class="s1">sa_exc.ArgumentError(</span>
                        <span class="s4">&quot;Could not locate SQLAlchemy Core type for Python &quot;</span>
                        <span class="s4">f&quot;type </span><span class="s7">{</span><span class="s1">our_type</span><span class="s7">} </span><span class="s4">inside the </span><span class="s7">{</span><span class="s1">self.column.key</span><span class="s7">!r} </span><span class="s4">&quot;</span>
                        <span class="s4">&quot;attribute Mapped annotation&quot;</span>
                    <span class="s1">)</span>

            <span class="s1">self.column._set_type(new_sqltype)</span>
</pre>
</body>
</html>