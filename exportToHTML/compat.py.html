<html>
<head>
<title>compat.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5d69bb;}
.s1 { color: #d8d8d8;}
.s2 { color: #717ed3; font-style: italic;}
.s3 { color: #cc8b60;}
.s4 { color: #bbb55b;}
.s5 { color: #cc7832;}
.s6 { color: #96bf7d;}
.s7 { color: #d7539b; font-weight: bold;}
</style>
</head>
<body bgcolor="#1a1a25">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
compat.py</font>
</center></td></tr></table>
<pre><span class="s0"># util/compat.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>
<span class="s0"># mypy: allow-untyped-defs, allow-untyped-calls</span>

<span class="s2">&quot;&quot;&quot;Handle Python version/platform incompatibilities.&quot;&quot;&quot;</span>

<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">annotations</span>

<span class="s3">import </span><span class="s1">base64</span>
<span class="s3">import </span><span class="s1">dataclasses</span>
<span class="s3">import </span><span class="s1">hashlib</span>
<span class="s3">import </span><span class="s1">inspect</span>
<span class="s3">import </span><span class="s1">operator</span>
<span class="s3">import </span><span class="s1">platform</span>
<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">typing</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Callable</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Dict</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Iterable</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">List</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Mapping</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Optional</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Sequence</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Set</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Tuple</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Type</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TypeVar</span>


<span class="s1">py313 = sys.version_info &gt;= (</span><span class="s4">3</span><span class="s5">, </span><span class="s4">13</span><span class="s1">)</span>
<span class="s1">py312 = sys.version_info &gt;= (</span><span class="s4">3</span><span class="s5">, </span><span class="s4">12</span><span class="s1">)</span>
<span class="s1">py311 = sys.version_info &gt;= (</span><span class="s4">3</span><span class="s5">, </span><span class="s4">11</span><span class="s1">)</span>
<span class="s1">py310 = sys.version_info &gt;= (</span><span class="s4">3</span><span class="s5">, </span><span class="s4">10</span><span class="s1">)</span>
<span class="s1">py39 = sys.version_info &gt;= (</span><span class="s4">3</span><span class="s5">, </span><span class="s4">9</span><span class="s1">)</span>
<span class="s1">py38 = sys.version_info &gt;= (</span><span class="s4">3</span><span class="s5">, </span><span class="s4">8</span><span class="s1">)</span>
<span class="s1">pypy = platform.python_implementation() == </span><span class="s6">&quot;PyPy&quot;</span>
<span class="s1">cpython = platform.python_implementation() == </span><span class="s6">&quot;CPython&quot;</span>

<span class="s1">win32 = sys.platform.startswith(</span><span class="s6">&quot;win&quot;</span><span class="s1">)</span>
<span class="s1">osx = sys.platform.startswith(</span><span class="s6">&quot;darwin&quot;</span><span class="s1">)</span>
<span class="s1">arm = </span><span class="s6">&quot;aarch&quot; </span><span class="s3">in </span><span class="s1">platform.machine().lower()</span>
<span class="s1">is64bit = sys.maxsize &gt; </span><span class="s4">2</span><span class="s1">**</span><span class="s4">32</span>

<span class="s1">has_refcount_gc = bool(cpython)</span>

<span class="s1">dottedgetter = operator.attrgetter</span>

<span class="s1">_T_co = TypeVar(</span><span class="s6">&quot;_T_co&quot;</span><span class="s5">, </span><span class="s1">covariant=</span><span class="s3">True</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">FullArgSpec(typing.NamedTuple):</span>
    <span class="s1">args: List[str]</span>
    <span class="s1">varargs: Optional[str]</span>
    <span class="s1">varkw: Optional[str]</span>
    <span class="s1">defaults: Optional[Tuple[Any</span><span class="s5">, </span><span class="s1">...]]</span>
    <span class="s1">kwonlyargs: List[str]</span>
    <span class="s1">kwonlydefaults: Optional[Dict[str</span><span class="s5">, </span><span class="s1">Any]]</span>
    <span class="s1">annotations: Dict[str</span><span class="s5">, </span><span class="s1">Any]</span>


<span class="s3">def </span><span class="s1">inspect_getfullargspec(func: Callable[...</span><span class="s5">, </span><span class="s1">Any]) -&gt; FullArgSpec:</span>
    <span class="s2">&quot;&quot;&quot;Fully vendored version of getfullargspec from Python 3.3.&quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">inspect.ismethod(func):</span>
        <span class="s1">func = func.__func__</span>
    <span class="s3">if not </span><span class="s1">inspect.isfunction(func):</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s6">f&quot;</span><span class="s7">{</span><span class="s1">func</span><span class="s7">!r} </span><span class="s6">is not a Python function&quot;</span><span class="s1">)</span>

    <span class="s1">co = func.__code__</span>
    <span class="s3">if not </span><span class="s1">inspect.iscode(co):</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s6">f&quot;</span><span class="s7">{</span><span class="s1">co</span><span class="s7">!r} </span><span class="s6">is not a code object&quot;</span><span class="s1">)</span>

    <span class="s1">nargs = co.co_argcount</span>
    <span class="s1">names = co.co_varnames</span>
    <span class="s1">nkwargs = co.co_kwonlyargcount</span>
    <span class="s1">args = list(names[:nargs])</span>
    <span class="s1">kwonlyargs = list(names[nargs : nargs + nkwargs])</span>

    <span class="s1">nargs += nkwargs</span>
    <span class="s1">varargs = </span><span class="s3">None</span>
    <span class="s3">if </span><span class="s1">co.co_flags &amp; inspect.CO_VARARGS:</span>
        <span class="s1">varargs = co.co_varnames[nargs]</span>
        <span class="s1">nargs = nargs + </span><span class="s4">1</span>
    <span class="s1">varkw = </span><span class="s3">None</span>
    <span class="s3">if </span><span class="s1">co.co_flags &amp; inspect.CO_VARKEYWORDS:</span>
        <span class="s1">varkw = co.co_varnames[nargs]</span>

    <span class="s3">return </span><span class="s1">FullArgSpec(</span>
        <span class="s1">args</span><span class="s5">,</span>
        <span class="s1">varargs</span><span class="s5">,</span>
        <span class="s1">varkw</span><span class="s5">,</span>
        <span class="s1">func.__defaults__</span><span class="s5">,</span>
        <span class="s1">kwonlyargs</span><span class="s5">,</span>
        <span class="s1">func.__kwdefaults__</span><span class="s5">,</span>
        <span class="s1">func.__annotations__</span><span class="s5">,</span>
    <span class="s1">)</span>


<span class="s3">if </span><span class="s1">py39:</span>
    <span class="s0"># python stubs don't have a public type for this. not worth</span>
    <span class="s0"># making a protocol</span>
    <span class="s3">def </span><span class="s1">md5_not_for_security() -&gt; Any:</span>
        <span class="s3">return </span><span class="s1">hashlib.md5(usedforsecurity=</span><span class="s3">False</span><span class="s1">)</span>

<span class="s3">else</span><span class="s1">:</span>

    <span class="s3">def </span><span class="s1">md5_not_for_security() -&gt; Any:</span>
        <span class="s3">return </span><span class="s1">hashlib.md5()</span>


<span class="s3">if </span><span class="s1">typing.TYPE_CHECKING </span><span class="s3">or </span><span class="s1">py38:</span>
    <span class="s3">from </span><span class="s1">importlib </span><span class="s3">import </span><span class="s1">metadata </span><span class="s3">as </span><span class="s1">importlib_metadata</span>
<span class="s3">else</span><span class="s1">:</span>
    <span class="s3">import </span><span class="s1">importlib_metadata  </span><span class="s0"># noqa</span>


<span class="s3">if </span><span class="s1">typing.TYPE_CHECKING </span><span class="s3">or </span><span class="s1">py39:</span>
    <span class="s0"># pep 584 dict union</span>
    <span class="s1">dict_union = operator.or_  </span><span class="s0"># noqa</span>
<span class="s3">else</span><span class="s1">:</span>

    <span class="s3">def </span><span class="s1">dict_union(a: dict</span><span class="s5">, </span><span class="s1">b: dict) -&gt; dict:</span>
        <span class="s1">a = a.copy()</span>
        <span class="s1">a.update(b)</span>
        <span class="s3">return </span><span class="s1">a</span>


<span class="s3">if </span><span class="s1">py310:</span>
    <span class="s1">anext_ = anext</span>
<span class="s3">else</span><span class="s1">:</span>
    <span class="s1">_NOT_PROVIDED = object()</span>
    <span class="s3">from </span><span class="s1">collections.abc </span><span class="s3">import </span><span class="s1">AsyncIterator</span>

    <span class="s3">async def </span><span class="s1">anext_(async_iterator</span><span class="s5">, </span><span class="s1">default=_NOT_PROVIDED):</span>
        <span class="s2">&quot;&quot;&quot;vendored from https://github.com/python/cpython/pull/8895&quot;&quot;&quot;</span>

        <span class="s3">if not </span><span class="s1">isinstance(async_iterator</span><span class="s5">, </span><span class="s1">AsyncIterator):</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span>
                <span class="s6">f&quot;anext expected an AsyncIterator, got </span><span class="s7">{</span><span class="s1">type(async_iterator)</span><span class="s7">}</span><span class="s6">&quot;</span>
            <span class="s1">)</span>
        <span class="s1">anxt = type(async_iterator).__anext__</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return await </span><span class="s1">anxt(async_iterator)</span>
        <span class="s3">except </span><span class="s1">StopAsyncIteration:</span>
            <span class="s3">if </span><span class="s1">default </span><span class="s3">is </span><span class="s1">_NOT_PROVIDED:</span>
                <span class="s3">raise</span>
            <span class="s3">return </span><span class="s1">default</span>


<span class="s3">def </span><span class="s1">importlib_metadata_get(group):</span>
    <span class="s1">ep = importlib_metadata.entry_points()</span>
    <span class="s3">if </span><span class="s1">typing.TYPE_CHECKING </span><span class="s3">or </span><span class="s1">hasattr(ep</span><span class="s5">, </span><span class="s6">&quot;select&quot;</span><span class="s1">):</span>
        <span class="s3">return </span><span class="s1">ep.select(group=group)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">ep.get(group</span><span class="s5">, </span><span class="s1">())</span>


<span class="s3">def </span><span class="s1">b(s):</span>
    <span class="s3">return </span><span class="s1">s.encode(</span><span class="s6">&quot;latin-1&quot;</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">b64decode(x: str) -&gt; bytes:</span>
    <span class="s3">return </span><span class="s1">base64.b64decode(x.encode(</span><span class="s6">&quot;ascii&quot;</span><span class="s1">))</span>


<span class="s3">def </span><span class="s1">b64encode(x: bytes) -&gt; str:</span>
    <span class="s3">return </span><span class="s1">base64.b64encode(x).decode(</span><span class="s6">&quot;ascii&quot;</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">decode_backslashreplace(text: bytes</span><span class="s5">, </span><span class="s1">encoding: str) -&gt; str:</span>
    <span class="s3">return </span><span class="s1">text.decode(encoding</span><span class="s5">, </span><span class="s1">errors=</span><span class="s6">&quot;backslashreplace&quot;</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">cmp(a</span><span class="s5">, </span><span class="s1">b):</span>
    <span class="s3">return </span><span class="s1">(a &gt; b) - (a &lt; b)</span>


<span class="s3">def </span><span class="s1">_formatannotation(annotation</span><span class="s5">, </span><span class="s1">base_module=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;vendored from python 3.7&quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">isinstance(annotation</span><span class="s5">, </span><span class="s1">str):</span>
        <span class="s3">return </span><span class="s1">annotation</span>

    <span class="s3">if </span><span class="s1">getattr(annotation</span><span class="s5">, </span><span class="s6">&quot;__module__&quot;</span><span class="s5">, </span><span class="s3">None</span><span class="s1">) == </span><span class="s6">&quot;typing&quot;</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">repr(annotation).replace(</span><span class="s6">&quot;typing.&quot;</span><span class="s5">, </span><span class="s6">&quot;&quot;</span><span class="s1">).replace(</span><span class="s6">&quot;~&quot;</span><span class="s5">, </span><span class="s6">&quot;&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">isinstance(annotation</span><span class="s5">, </span><span class="s1">type):</span>
        <span class="s3">if </span><span class="s1">annotation.__module__ </span><span class="s3">in </span><span class="s1">(</span><span class="s6">&quot;builtins&quot;</span><span class="s5">, </span><span class="s1">base_module):</span>
            <span class="s3">return </span><span class="s1">repr(annotation.__qualname__)</span>
        <span class="s3">return </span><span class="s1">annotation.__module__ + </span><span class="s6">&quot;.&quot; </span><span class="s1">+ annotation.__qualname__</span>
    <span class="s3">elif </span><span class="s1">isinstance(annotation</span><span class="s5">, </span><span class="s1">typing.TypeVar):</span>
        <span class="s3">return </span><span class="s1">repr(annotation).replace(</span><span class="s6">&quot;~&quot;</span><span class="s5">, </span><span class="s6">&quot;&quot;</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">repr(annotation).replace(</span><span class="s6">&quot;~&quot;</span><span class="s5">, </span><span class="s6">&quot;&quot;</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">inspect_formatargspec(</span>
    <span class="s1">args: List[str]</span><span class="s5">,</span>
    <span class="s1">varargs: Optional[str] = </span><span class="s3">None</span><span class="s5">,</span>
    <span class="s1">varkw: Optional[str] = </span><span class="s3">None</span><span class="s5">,</span>
    <span class="s1">defaults: Optional[Sequence[Any]] = </span><span class="s3">None</span><span class="s5">,</span>
    <span class="s1">kwonlyargs: Optional[Sequence[str]] = ()</span><span class="s5">,</span>
    <span class="s1">kwonlydefaults: Optional[Mapping[str</span><span class="s5">, </span><span class="s1">Any]] = {}</span><span class="s5">,</span>
    <span class="s1">annotations: Mapping[str</span><span class="s5">, </span><span class="s1">Any] = {}</span><span class="s5">,</span>
    <span class="s1">formatarg: Callable[[str]</span><span class="s5">, </span><span class="s1">str] = str</span><span class="s5">,</span>
    <span class="s1">formatvarargs: Callable[[str]</span><span class="s5">, </span><span class="s1">str] = </span><span class="s3">lambda </span><span class="s1">name: </span><span class="s6">&quot;*&quot; </span><span class="s1">+ name</span><span class="s5">,</span>
    <span class="s1">formatvarkw: Callable[[str]</span><span class="s5">, </span><span class="s1">str] = </span><span class="s3">lambda </span><span class="s1">name: </span><span class="s6">&quot;**&quot; </span><span class="s1">+ name</span><span class="s5">,</span>
    <span class="s1">formatvalue: Callable[[Any]</span><span class="s5">, </span><span class="s1">str] = </span><span class="s3">lambda </span><span class="s1">value: </span><span class="s6">&quot;=&quot; </span><span class="s1">+ repr(value)</span><span class="s5">,</span>
    <span class="s1">formatreturns: Callable[[Any]</span><span class="s5">, </span><span class="s1">str] = </span><span class="s3">lambda </span><span class="s1">text: </span><span class="s6">&quot; -&gt; &quot; </span><span class="s1">+ str(text)</span><span class="s5">,</span>
    <span class="s1">formatannotation: Callable[[Any]</span><span class="s5">, </span><span class="s1">str] = _formatannotation</span><span class="s5">,</span>
<span class="s1">) -&gt; str:</span>
    <span class="s2">&quot;&quot;&quot;Copy formatargspec from python 3.7 standard library. 
 
    Python 3 has deprecated formatargspec and requested that Signature 
    be used instead, however this requires a full reimplementation 
    of formatargspec() in terms of creating Parameter objects and such. 
    Instead of introducing all the object-creation overhead and having 
    to reinvent from scratch, just copy their compatibility routine. 
 
    Ultimately we would need to rewrite our &quot;decorator&quot; routine completely 
    which is not really worth it right now, until all Python 2.x support 
    is dropped. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">kwonlydefaults = kwonlydefaults </span><span class="s3">or </span><span class="s1">{}</span>
    <span class="s1">annotations = annotations </span><span class="s3">or </span><span class="s1">{}</span>

    <span class="s3">def </span><span class="s1">formatargandannotation(arg):</span>
        <span class="s1">result = formatarg(arg)</span>
        <span class="s3">if </span><span class="s1">arg </span><span class="s3">in </span><span class="s1">annotations:</span>
            <span class="s1">result += </span><span class="s6">&quot;: &quot; </span><span class="s1">+ formatannotation(annotations[arg])</span>
        <span class="s3">return </span><span class="s1">result</span>

    <span class="s1">specs = []</span>
    <span class="s3">if </span><span class="s1">defaults:</span>
        <span class="s1">firstdefault = len(args) - len(defaults)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">firstdefault = -</span><span class="s4">1</span>

    <span class="s3">for </span><span class="s1">i</span><span class="s5">, </span><span class="s1">arg </span><span class="s3">in </span><span class="s1">enumerate(args):</span>
        <span class="s1">spec = formatargandannotation(arg)</span>
        <span class="s3">if </span><span class="s1">defaults </span><span class="s3">and </span><span class="s1">i &gt;= firstdefault:</span>
            <span class="s1">spec = spec + formatvalue(defaults[i - firstdefault])</span>
        <span class="s1">specs.append(spec)</span>

    <span class="s3">if </span><span class="s1">varargs </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">specs.append(formatvarargs(formatargandannotation(varargs)))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">kwonlyargs:</span>
            <span class="s1">specs.append(</span><span class="s6">&quot;*&quot;</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">kwonlyargs:</span>
        <span class="s3">for </span><span class="s1">kwonlyarg </span><span class="s3">in </span><span class="s1">kwonlyargs:</span>
            <span class="s1">spec = formatargandannotation(kwonlyarg)</span>
            <span class="s3">if </span><span class="s1">kwonlydefaults </span><span class="s3">and </span><span class="s1">kwonlyarg </span><span class="s3">in </span><span class="s1">kwonlydefaults:</span>
                <span class="s1">spec += formatvalue(kwonlydefaults[kwonlyarg])</span>
            <span class="s1">specs.append(spec)</span>

    <span class="s3">if </span><span class="s1">varkw </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">specs.append(formatvarkw(formatargandannotation(varkw)))</span>

    <span class="s1">result = </span><span class="s6">&quot;(&quot; </span><span class="s1">+ </span><span class="s6">&quot;, &quot;</span><span class="s1">.join(specs) + </span><span class="s6">&quot;)&quot;</span>
    <span class="s3">if </span><span class="s6">&quot;return&quot; </span><span class="s3">in </span><span class="s1">annotations:</span>
        <span class="s1">result += formatreturns(formatannotation(annotations[</span><span class="s6">&quot;return&quot;</span><span class="s1">]))</span>
    <span class="s3">return </span><span class="s1">result</span>


<span class="s3">def </span><span class="s1">dataclass_fields(cls: Type[Any]) -&gt; Iterable[dataclasses.Field[Any]]:</span>
    <span class="s2">&quot;&quot;&quot;Return a sequence of all dataclasses.Field objects associated 
    with a class as an already processed dataclass. 
 
    The class must **already be a dataclass** for Field objects to be returned. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">dataclasses.is_dataclass(cls):</span>
        <span class="s3">return </span><span class="s1">dataclasses.fields(cls)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">[]</span>


<span class="s3">def </span><span class="s1">local_dataclass_fields(cls: Type[Any]) -&gt; Iterable[dataclasses.Field[Any]]:</span>
    <span class="s2">&quot;&quot;&quot;Return a sequence of all dataclasses.Field objects associated with 
    an already processed dataclass, excluding those that originate from a 
    superclass. 
 
    The class must **already be a dataclass** for Field objects to be returned. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">dataclasses.is_dataclass(cls):</span>
        <span class="s1">super_fields: Set[dataclasses.Field[Any]] = set()</span>
        <span class="s3">for </span><span class="s1">sup </span><span class="s3">in </span><span class="s1">cls.__bases__:</span>
            <span class="s1">super_fields.update(dataclass_fields(sup))</span>
        <span class="s3">return </span><span class="s1">[f </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">dataclasses.fields(cls) </span><span class="s3">if </span><span class="s1">f </span><span class="s3">not in </span><span class="s1">super_fields]</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">[]</span>
</pre>
</body>
</html>