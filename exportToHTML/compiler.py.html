<html>
<head>
<title>compiler.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5d69bb;}
.s1 { color: #d8d8d8;}
.s2 { color: #717ed3; font-style: italic;}
.s3 { color: #cc8b60;}
.s4 { color: #96bf7d;}
.s5 { color: #cc7832;}
.s6 { color: #bbb55b;}
.s7 { color: #d7539b; font-weight: bold;}
</style>
</head>
<body bgcolor="#1a1a25">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
compiler.py</font>
</center></td></tr></table>
<pre><span class="s0"># sql/compiler.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>
<span class="s0"># mypy: allow-untyped-defs, allow-untyped-calls</span>

<span class="s2">&quot;&quot;&quot;Base SQL and DDL compiler implementations. 
 
Classes provided include: 
 
:class:`.compiler.SQLCompiler` - renders SQL 
strings 
 
:class:`.compiler.DDLCompiler` - renders DDL 
(data definition language) strings 
 
:class:`.compiler.GenericTypeCompiler` - renders 
type specification strings. 
 
To generate user-defined SQL strings, see 
:doc:`/ext/compiler`. 
 
&quot;&quot;&quot;</span>
<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">annotations</span>

<span class="s3">import </span><span class="s1">collections</span>
<span class="s3">import </span><span class="s1">collections.abc </span><span class="s3">as </span><span class="s1">collections_abc</span>
<span class="s3">import </span><span class="s1">contextlib</span>
<span class="s3">from </span><span class="s1">enum </span><span class="s3">import </span><span class="s1">IntEnum</span>
<span class="s3">import </span><span class="s1">functools</span>
<span class="s3">import </span><span class="s1">itertools</span>
<span class="s3">import </span><span class="s1">operator</span>
<span class="s3">import </span><span class="s1">re</span>
<span class="s3">from </span><span class="s1">time </span><span class="s3">import </span><span class="s1">perf_counter</span>
<span class="s3">import </span><span class="s1">typing</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Callable</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">cast</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">ClassVar</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Dict</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">FrozenSet</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Iterable</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Iterator</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">List</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Mapping</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">MutableMapping</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">NamedTuple</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">NoReturn</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Optional</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Pattern</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Sequence</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Set</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Tuple</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Type</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Union</span>

<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">base</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">coercions</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">crud</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">elements</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">functions</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">operators</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">roles</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">schema</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">selectable</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">sqltypes</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">util </span><span class="s3">as </span><span class="s1">sql_util</span>
<span class="s3">from </span><span class="s1">._typing </span><span class="s3">import </span><span class="s1">is_column_element</span>
<span class="s3">from </span><span class="s1">._typing </span><span class="s3">import </span><span class="s1">is_dml</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">_de_clone</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">_from_objects</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">_NONE_NAME</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">_SentinelDefaultCharacterization</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">Executable</span>
<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">NO_ARG</span>
<span class="s3">from </span><span class="s1">.elements </span><span class="s3">import </span><span class="s1">ClauseElement</span>
<span class="s3">from </span><span class="s1">.elements </span><span class="s3">import </span><span class="s1">quoted_name</span>
<span class="s3">from </span><span class="s1">.schema </span><span class="s3">import </span><span class="s1">Column</span>
<span class="s3">from </span><span class="s1">.sqltypes </span><span class="s3">import </span><span class="s1">TupleType</span>
<span class="s3">from </span><span class="s1">.type_api </span><span class="s3">import </span><span class="s1">TypeEngine</span>
<span class="s3">from </span><span class="s1">.visitors </span><span class="s3">import </span><span class="s1">prefix_anon_map</span>
<span class="s3">from </span><span class="s1">.visitors </span><span class="s3">import </span><span class="s1">Visitable</span>
<span class="s3">from </span><span class="s1">.. </span><span class="s3">import </span><span class="s1">exc</span>
<span class="s3">from </span><span class="s1">.. </span><span class="s3">import </span><span class="s1">util</span>
<span class="s3">from </span><span class="s1">..util </span><span class="s3">import </span><span class="s1">FastIntFlag</span>
<span class="s3">from </span><span class="s1">..util.typing </span><span class="s3">import </span><span class="s1">Literal</span>
<span class="s3">from </span><span class="s1">..util.typing </span><span class="s3">import </span><span class="s1">Protocol</span>
<span class="s3">from </span><span class="s1">..util.typing </span><span class="s3">import </span><span class="s1">TypedDict</span>

<span class="s3">if </span><span class="s1">typing.TYPE_CHECKING:</span>
    <span class="s3">from </span><span class="s1">.annotation </span><span class="s3">import </span><span class="s1">_AnnotationDict</span>
    <span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">_AmbiguousTableNameMap</span>
    <span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">CompileState</span>
    <span class="s3">from </span><span class="s1">.cache_key </span><span class="s3">import </span><span class="s1">CacheKey</span>
    <span class="s3">from </span><span class="s1">.ddl </span><span class="s3">import </span><span class="s1">ExecutableDDLElement</span>
    <span class="s3">from </span><span class="s1">.dml </span><span class="s3">import </span><span class="s1">Insert</span>
    <span class="s3">from </span><span class="s1">.dml </span><span class="s3">import </span><span class="s1">UpdateBase</span>
    <span class="s3">from </span><span class="s1">.dml </span><span class="s3">import </span><span class="s1">ValuesBase</span>
    <span class="s3">from </span><span class="s1">.elements </span><span class="s3">import </span><span class="s1">_truncated_label</span>
    <span class="s3">from </span><span class="s1">.elements </span><span class="s3">import </span><span class="s1">BindParameter</span>
    <span class="s3">from </span><span class="s1">.elements </span><span class="s3">import </span><span class="s1">ColumnClause</span>
    <span class="s3">from </span><span class="s1">.elements </span><span class="s3">import </span><span class="s1">ColumnElement</span>
    <span class="s3">from </span><span class="s1">.elements </span><span class="s3">import </span><span class="s1">Label</span>
    <span class="s3">from </span><span class="s1">.functions </span><span class="s3">import </span><span class="s1">Function</span>
    <span class="s3">from </span><span class="s1">.schema </span><span class="s3">import </span><span class="s1">Table</span>
    <span class="s3">from </span><span class="s1">.selectable </span><span class="s3">import </span><span class="s1">AliasedReturnsRows</span>
    <span class="s3">from </span><span class="s1">.selectable </span><span class="s3">import </span><span class="s1">CompoundSelectState</span>
    <span class="s3">from </span><span class="s1">.selectable </span><span class="s3">import </span><span class="s1">CTE</span>
    <span class="s3">from </span><span class="s1">.selectable </span><span class="s3">import </span><span class="s1">FromClause</span>
    <span class="s3">from </span><span class="s1">.selectable </span><span class="s3">import </span><span class="s1">NamedFromClause</span>
    <span class="s3">from </span><span class="s1">.selectable </span><span class="s3">import </span><span class="s1">ReturnsRows</span>
    <span class="s3">from </span><span class="s1">.selectable </span><span class="s3">import </span><span class="s1">Select</span>
    <span class="s3">from </span><span class="s1">.selectable </span><span class="s3">import </span><span class="s1">SelectState</span>
    <span class="s3">from </span><span class="s1">.type_api </span><span class="s3">import </span><span class="s1">_BindProcessorType</span>
    <span class="s3">from </span><span class="s1">..engine.cursor </span><span class="s3">import </span><span class="s1">CursorResultMetaData</span>
    <span class="s3">from </span><span class="s1">..engine.interfaces </span><span class="s3">import </span><span class="s1">_CoreSingleExecuteParams</span>
    <span class="s3">from </span><span class="s1">..engine.interfaces </span><span class="s3">import </span><span class="s1">_DBAPIAnyExecuteParams</span>
    <span class="s3">from </span><span class="s1">..engine.interfaces </span><span class="s3">import </span><span class="s1">_DBAPIMultiExecuteParams</span>
    <span class="s3">from </span><span class="s1">..engine.interfaces </span><span class="s3">import </span><span class="s1">_DBAPISingleExecuteParams</span>
    <span class="s3">from </span><span class="s1">..engine.interfaces </span><span class="s3">import </span><span class="s1">_ExecuteOptions</span>
    <span class="s3">from </span><span class="s1">..engine.interfaces </span><span class="s3">import </span><span class="s1">_GenericSetInputSizesType</span>
    <span class="s3">from </span><span class="s1">..engine.interfaces </span><span class="s3">import </span><span class="s1">_MutableCoreSingleExecuteParams</span>
    <span class="s3">from </span><span class="s1">..engine.interfaces </span><span class="s3">import </span><span class="s1">Dialect</span>
    <span class="s3">from </span><span class="s1">..engine.interfaces </span><span class="s3">import </span><span class="s1">SchemaTranslateMapType</span>

<span class="s1">_FromHintsType = Dict[</span><span class="s4">&quot;FromClause&quot;</span><span class="s5">, </span><span class="s1">str]</span>

<span class="s1">RESERVED_WORDS = {</span>
    <span class="s4">&quot;all&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;analyse&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;analyze&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;and&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;any&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;array&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;as&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;asc&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;asymmetric&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;authorization&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;between&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;binary&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;both&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;case&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;cast&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;check&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;collate&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;column&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;constraint&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;create&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;cross&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;current_date&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;current_role&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;current_time&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;current_timestamp&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;current_user&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;default&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;deferrable&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;desc&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;distinct&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;do&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;else&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;end&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;except&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;false&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;for&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;foreign&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;freeze&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;from&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;full&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;grant&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;group&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;having&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;ilike&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;in&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;initially&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;inner&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;intersect&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;into&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;is&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;isnull&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;join&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;leading&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;left&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;like&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;limit&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;localtime&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;localtimestamp&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;natural&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;new&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;not&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;notnull&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;null&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;off&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;offset&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;old&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;on&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;only&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;or&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;order&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;outer&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;overlaps&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;placing&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;primary&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;references&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;right&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;select&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;session_user&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;set&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;similar&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;some&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;symmetric&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;table&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;then&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;to&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;trailing&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;true&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;union&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;unique&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;user&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;using&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;verbose&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;when&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;where&quot;</span><span class="s5">,</span>
<span class="s1">}</span>

<span class="s1">LEGAL_CHARACTERS = re.compile(</span><span class="s4">r&quot;^[A-Z0-9_$]+$&quot;</span><span class="s5">, </span><span class="s1">re.I)</span>
<span class="s1">LEGAL_CHARACTERS_PLUS_SPACE = re.compile(</span><span class="s4">r&quot;^[A-Z0-9_ $]+$&quot;</span><span class="s5">, </span><span class="s1">re.I)</span>
<span class="s1">ILLEGAL_INITIAL_CHARACTERS = {str(x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">range(</span><span class="s6">0</span><span class="s5">, </span><span class="s6">10</span><span class="s1">)}.union([</span><span class="s4">&quot;$&quot;</span><span class="s1">])</span>

<span class="s1">FK_ON_DELETE = re.compile(</span>
    <span class="s4">r&quot;^(?:RESTRICT|CASCADE|SET NULL|NO ACTION|SET DEFAULT)$&quot;</span><span class="s5">, </span><span class="s1">re.I</span>
<span class="s1">)</span>
<span class="s1">FK_ON_UPDATE = re.compile(</span>
    <span class="s4">r&quot;^(?:RESTRICT|CASCADE|SET NULL|NO ACTION|SET DEFAULT)$&quot;</span><span class="s5">, </span><span class="s1">re.I</span>
<span class="s1">)</span>
<span class="s1">FK_INITIALLY = re.compile(</span><span class="s4">r&quot;^(?:DEFERRED|IMMEDIATE)$&quot;</span><span class="s5">, </span><span class="s1">re.I)</span>
<span class="s1">BIND_PARAMS = re.compile(</span><span class="s4">r&quot;(?&lt;![:\w\$\x5c]):([\w\$]+)(?![:\w\$])&quot;</span><span class="s5">, </span><span class="s1">re.UNICODE)</span>
<span class="s1">BIND_PARAMS_ESC = re.compile(</span><span class="s4">r&quot;\x5c(:[\w\$]*)(?![:\w\$])&quot;</span><span class="s5">, </span><span class="s1">re.UNICODE)</span>

<span class="s1">_pyformat_template = </span><span class="s4">&quot;%%(%(name)s)s&quot;</span>
<span class="s1">BIND_TEMPLATES = {</span>
    <span class="s4">&quot;pyformat&quot;</span><span class="s1">: _pyformat_template</span><span class="s5">,</span>
    <span class="s4">&quot;qmark&quot;</span><span class="s1">: </span><span class="s4">&quot;?&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;format&quot;</span><span class="s1">: </span><span class="s4">&quot;%%s&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;numeric&quot;</span><span class="s1">: </span><span class="s4">&quot;:[_POSITION]&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;numeric_dollar&quot;</span><span class="s1">: </span><span class="s4">&quot;$[_POSITION]&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;named&quot;</span><span class="s1">: </span><span class="s4">&quot;:%(name)s&quot;</span><span class="s5">,</span>
<span class="s1">}</span>


<span class="s1">OPERATORS = {</span>
    <span class="s0"># binary</span>
    <span class="s1">operators.and_: </span><span class="s4">&quot; AND &quot;</span><span class="s5">,</span>
    <span class="s1">operators.or_: </span><span class="s4">&quot; OR &quot;</span><span class="s5">,</span>
    <span class="s1">operators.add: </span><span class="s4">&quot; + &quot;</span><span class="s5">,</span>
    <span class="s1">operators.mul: </span><span class="s4">&quot; * &quot;</span><span class="s5">,</span>
    <span class="s1">operators.sub: </span><span class="s4">&quot; - &quot;</span><span class="s5">,</span>
    <span class="s1">operators.mod: </span><span class="s4">&quot; % &quot;</span><span class="s5">,</span>
    <span class="s1">operators.neg: </span><span class="s4">&quot;-&quot;</span><span class="s5">,</span>
    <span class="s1">operators.lt: </span><span class="s4">&quot; &lt; &quot;</span><span class="s5">,</span>
    <span class="s1">operators.le: </span><span class="s4">&quot; &lt;= &quot;</span><span class="s5">,</span>
    <span class="s1">operators.ne: </span><span class="s4">&quot; != &quot;</span><span class="s5">,</span>
    <span class="s1">operators.gt: </span><span class="s4">&quot; &gt; &quot;</span><span class="s5">,</span>
    <span class="s1">operators.ge: </span><span class="s4">&quot; &gt;= &quot;</span><span class="s5">,</span>
    <span class="s1">operators.eq: </span><span class="s4">&quot; = &quot;</span><span class="s5">,</span>
    <span class="s1">operators.is_distinct_from: </span><span class="s4">&quot; IS DISTINCT FROM &quot;</span><span class="s5">,</span>
    <span class="s1">operators.is_not_distinct_from: </span><span class="s4">&quot; IS NOT DISTINCT FROM &quot;</span><span class="s5">,</span>
    <span class="s1">operators.concat_op: </span><span class="s4">&quot; || &quot;</span><span class="s5">,</span>
    <span class="s1">operators.match_op: </span><span class="s4">&quot; MATCH &quot;</span><span class="s5">,</span>
    <span class="s1">operators.not_match_op: </span><span class="s4">&quot; NOT MATCH &quot;</span><span class="s5">,</span>
    <span class="s1">operators.in_op: </span><span class="s4">&quot; IN &quot;</span><span class="s5">,</span>
    <span class="s1">operators.not_in_op: </span><span class="s4">&quot; NOT IN &quot;</span><span class="s5">,</span>
    <span class="s1">operators.comma_op: </span><span class="s4">&quot;, &quot;</span><span class="s5">,</span>
    <span class="s1">operators.from_: </span><span class="s4">&quot; FROM &quot;</span><span class="s5">,</span>
    <span class="s1">operators.as_: </span><span class="s4">&quot; AS &quot;</span><span class="s5">,</span>
    <span class="s1">operators.is_: </span><span class="s4">&quot; IS &quot;</span><span class="s5">,</span>
    <span class="s1">operators.is_not: </span><span class="s4">&quot; IS NOT &quot;</span><span class="s5">,</span>
    <span class="s1">operators.collate: </span><span class="s4">&quot; COLLATE &quot;</span><span class="s5">,</span>
    <span class="s0"># unary</span>
    <span class="s1">operators.exists: </span><span class="s4">&quot;EXISTS &quot;</span><span class="s5">,</span>
    <span class="s1">operators.distinct_op: </span><span class="s4">&quot;DISTINCT &quot;</span><span class="s5">,</span>
    <span class="s1">operators.inv: </span><span class="s4">&quot;NOT &quot;</span><span class="s5">,</span>
    <span class="s1">operators.any_op: </span><span class="s4">&quot;ANY &quot;</span><span class="s5">,</span>
    <span class="s1">operators.all_op: </span><span class="s4">&quot;ALL &quot;</span><span class="s5">,</span>
    <span class="s0"># modifiers</span>
    <span class="s1">operators.desc_op: </span><span class="s4">&quot; DESC&quot;</span><span class="s5">,</span>
    <span class="s1">operators.asc_op: </span><span class="s4">&quot; ASC&quot;</span><span class="s5">,</span>
    <span class="s1">operators.nulls_first_op: </span><span class="s4">&quot; NULLS FIRST&quot;</span><span class="s5">,</span>
    <span class="s1">operators.nulls_last_op: </span><span class="s4">&quot; NULLS LAST&quot;</span><span class="s5">,</span>
    <span class="s0"># bitwise</span>
    <span class="s1">operators.bitwise_xor_op: </span><span class="s4">&quot; ^ &quot;</span><span class="s5">,</span>
    <span class="s1">operators.bitwise_or_op: </span><span class="s4">&quot; | &quot;</span><span class="s5">,</span>
    <span class="s1">operators.bitwise_and_op: </span><span class="s4">&quot; &amp; &quot;</span><span class="s5">,</span>
    <span class="s1">operators.bitwise_not_op: </span><span class="s4">&quot;~&quot;</span><span class="s5">,</span>
    <span class="s1">operators.bitwise_lshift_op: </span><span class="s4">&quot; &lt;&lt; &quot;</span><span class="s5">,</span>
    <span class="s1">operators.bitwise_rshift_op: </span><span class="s4">&quot; &gt;&gt; &quot;</span><span class="s5">,</span>
<span class="s1">}</span>

<span class="s1">FUNCTIONS: Dict[Type[Function[Any]]</span><span class="s5">, </span><span class="s1">str] = {</span>
    <span class="s1">functions.coalesce: </span><span class="s4">&quot;coalesce&quot;</span><span class="s5">,</span>
    <span class="s1">functions.current_date: </span><span class="s4">&quot;CURRENT_DATE&quot;</span><span class="s5">,</span>
    <span class="s1">functions.current_time: </span><span class="s4">&quot;CURRENT_TIME&quot;</span><span class="s5">,</span>
    <span class="s1">functions.current_timestamp: </span><span class="s4">&quot;CURRENT_TIMESTAMP&quot;</span><span class="s5">,</span>
    <span class="s1">functions.current_user: </span><span class="s4">&quot;CURRENT_USER&quot;</span><span class="s5">,</span>
    <span class="s1">functions.localtime: </span><span class="s4">&quot;LOCALTIME&quot;</span><span class="s5">,</span>
    <span class="s1">functions.localtimestamp: </span><span class="s4">&quot;LOCALTIMESTAMP&quot;</span><span class="s5">,</span>
    <span class="s1">functions.random: </span><span class="s4">&quot;random&quot;</span><span class="s5">,</span>
    <span class="s1">functions.sysdate: </span><span class="s4">&quot;sysdate&quot;</span><span class="s5">,</span>
    <span class="s1">functions.session_user: </span><span class="s4">&quot;SESSION_USER&quot;</span><span class="s5">,</span>
    <span class="s1">functions.user: </span><span class="s4">&quot;USER&quot;</span><span class="s5">,</span>
    <span class="s1">functions.cube: </span><span class="s4">&quot;CUBE&quot;</span><span class="s5">,</span>
    <span class="s1">functions.rollup: </span><span class="s4">&quot;ROLLUP&quot;</span><span class="s5">,</span>
    <span class="s1">functions.grouping_sets: </span><span class="s4">&quot;GROUPING SETS&quot;</span><span class="s5">,</span>
<span class="s1">}</span>


<span class="s1">EXTRACT_MAP = {</span>
    <span class="s4">&quot;month&quot;</span><span class="s1">: </span><span class="s4">&quot;month&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;day&quot;</span><span class="s1">: </span><span class="s4">&quot;day&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;year&quot;</span><span class="s1">: </span><span class="s4">&quot;year&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;second&quot;</span><span class="s1">: </span><span class="s4">&quot;second&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;hour&quot;</span><span class="s1">: </span><span class="s4">&quot;hour&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;doy&quot;</span><span class="s1">: </span><span class="s4">&quot;doy&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;minute&quot;</span><span class="s1">: </span><span class="s4">&quot;minute&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;quarter&quot;</span><span class="s1">: </span><span class="s4">&quot;quarter&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;dow&quot;</span><span class="s1">: </span><span class="s4">&quot;dow&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;week&quot;</span><span class="s1">: </span><span class="s4">&quot;week&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;epoch&quot;</span><span class="s1">: </span><span class="s4">&quot;epoch&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;milliseconds&quot;</span><span class="s1">: </span><span class="s4">&quot;milliseconds&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;microseconds&quot;</span><span class="s1">: </span><span class="s4">&quot;microseconds&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;timezone_hour&quot;</span><span class="s1">: </span><span class="s4">&quot;timezone_hour&quot;</span><span class="s5">,</span>
    <span class="s4">&quot;timezone_minute&quot;</span><span class="s1">: </span><span class="s4">&quot;timezone_minute&quot;</span><span class="s5">,</span>
<span class="s1">}</span>

<span class="s1">COMPOUND_KEYWORDS = {</span>
    <span class="s1">selectable._CompoundSelectKeyword.UNION: </span><span class="s4">&quot;UNION&quot;</span><span class="s5">,</span>
    <span class="s1">selectable._CompoundSelectKeyword.UNION_ALL: </span><span class="s4">&quot;UNION ALL&quot;</span><span class="s5">,</span>
    <span class="s1">selectable._CompoundSelectKeyword.EXCEPT: </span><span class="s4">&quot;EXCEPT&quot;</span><span class="s5">,</span>
    <span class="s1">selectable._CompoundSelectKeyword.EXCEPT_ALL: </span><span class="s4">&quot;EXCEPT ALL&quot;</span><span class="s5">,</span>
    <span class="s1">selectable._CompoundSelectKeyword.INTERSECT: </span><span class="s4">&quot;INTERSECT&quot;</span><span class="s5">,</span>
    <span class="s1">selectable._CompoundSelectKeyword.INTERSECT_ALL: </span><span class="s4">&quot;INTERSECT ALL&quot;</span><span class="s5">,</span>
<span class="s1">}</span>


<span class="s3">class </span><span class="s1">ResultColumnsEntry(NamedTuple):</span>
    <span class="s2">&quot;&quot;&quot;Tracks a column expression that is expected to be represented 
    in the result rows for this statement. 
 
    This normally refers to the columns clause of a SELECT statement 
    but may also refer to a RETURNING clause, as well as for dialect-specific 
    emulations. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">keyname: str</span>
    <span class="s4">&quot;&quot;&quot;string name that's expected in cursor.description&quot;&quot;&quot;</span>

    <span class="s1">name: str</span>
    <span class="s4">&quot;&quot;&quot;column name, may be labeled&quot;&quot;&quot;</span>

    <span class="s1">objects: Tuple[Any</span><span class="s5">, </span><span class="s1">...]</span>
    <span class="s4">&quot;&quot;&quot;sequence of objects that should be able to locate this column 
    in a RowMapping.  This is typically string names and aliases 
    as well as Column objects. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">type: TypeEngine[Any]</span>
    <span class="s4">&quot;&quot;&quot;Datatype to be associated with this column.   This is where 
    the &quot;result processing&quot; logic directly links the compiled statement 
    to the rows that come back from the cursor. 
 
    &quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">_ResultMapAppender(Protocol):</span>
    <span class="s3">def </span><span class="s1">__call__(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">keyname: str</span><span class="s5">,</span>
        <span class="s1">name: str</span><span class="s5">,</span>
        <span class="s1">objects: Sequence[Any]</span><span class="s5">,</span>
        <span class="s1">type_: TypeEngine[Any]</span><span class="s5">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">: ...</span>


<span class="s0"># integer indexes into ResultColumnsEntry used by cursor.py.</span>
<span class="s0"># some profiling showed integer access faster than named tuple</span>
<span class="s1">RM_RENDERED_NAME: Literal[</span><span class="s6">0</span><span class="s1">] = </span><span class="s6">0</span>
<span class="s1">RM_NAME: Literal[</span><span class="s6">1</span><span class="s1">] = </span><span class="s6">1</span>
<span class="s1">RM_OBJECTS: Literal[</span><span class="s6">2</span><span class="s1">] = </span><span class="s6">2</span>
<span class="s1">RM_TYPE: Literal[</span><span class="s6">3</span><span class="s1">] = </span><span class="s6">3</span>


<span class="s3">class </span><span class="s1">_BaseCompilerStackEntry(TypedDict):</span>
    <span class="s1">asfrom_froms: Set[FromClause]</span>
    <span class="s1">correlate_froms: Set[FromClause]</span>
    <span class="s1">selectable: ReturnsRows</span>


<span class="s3">class </span><span class="s1">_CompilerStackEntry(_BaseCompilerStackEntry</span><span class="s5">, </span><span class="s1">total=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s1">compile_state: CompileState</span>
    <span class="s1">need_result_map_for_nested: bool</span>
    <span class="s1">need_result_map_for_compound: bool</span>
    <span class="s1">select_0: ReturnsRows</span>
    <span class="s1">insert_from_select: Select[Any]</span>


<span class="s3">class </span><span class="s1">ExpandedState(NamedTuple):</span>
    <span class="s2">&quot;&quot;&quot;represents state to use when producing &quot;expanded&quot; and 
    &quot;post compile&quot; bound parameters for a statement. 
 
    &quot;expanded&quot; parameters are parameters that are generated at 
    statement execution time to suit a number of parameters passed, the most 
    prominent example being the individual elements inside of an IN expression. 
 
    &quot;post compile&quot; parameters are parameters where the SQL literal value 
    will be rendered into the SQL statement at execution time, rather than 
    being passed as separate parameters to the driver. 
 
    To create an :class:`.ExpandedState` instance, use the 
    :meth:`.SQLCompiler.construct_expanded_state` method on any 
    :class:`.SQLCompiler` instance. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">statement: str</span>
    <span class="s4">&quot;&quot;&quot;String SQL statement with parameters fully expanded&quot;&quot;&quot;</span>

    <span class="s1">parameters: _CoreSingleExecuteParams</span>
    <span class="s4">&quot;&quot;&quot;Parameter dictionary with parameters fully expanded. 
 
    For a statement that uses named parameters, this dictionary will map 
    exactly to the names in the statement.  For a statement that uses 
    positional parameters, the :attr:`.ExpandedState.positional_parameters` 
    will yield a tuple with the positional parameter set. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">processors: Mapping[str</span><span class="s5">, </span><span class="s1">_BindProcessorType[Any]]</span>
    <span class="s4">&quot;&quot;&quot;mapping of bound value processors&quot;&quot;&quot;</span>

    <span class="s1">positiontup: Optional[Sequence[str]]</span>
    <span class="s4">&quot;&quot;&quot;Sequence of string names indicating the order of positional 
    parameters&quot;&quot;&quot;</span>

    <span class="s1">parameter_expansion: Mapping[str</span><span class="s5">, </span><span class="s1">List[str]]</span>
    <span class="s4">&quot;&quot;&quot;Mapping representing the intermediary link from original parameter 
    name to list of &quot;expanded&quot; parameter names, for those parameters that 
    were expanded.&quot;&quot;&quot;</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">positional_parameters(self) -&gt; Tuple[Any</span><span class="s5">, </span><span class="s1">...]:</span>
        <span class="s2">&quot;&quot;&quot;Tuple of positional parameters, for statements that were compiled 
        using a positional paramstyle. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.positiontup </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">exc.InvalidRequestError(</span>
                <span class="s4">&quot;statement does not use a positional paramstyle&quot;</span>
            <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">tuple(self.parameters[key] </span><span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self.positiontup)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">additional_parameters(self) -&gt; _CoreSingleExecuteParams:</span>
        <span class="s2">&quot;&quot;&quot;synonym for :attr:`.ExpandedState.parameters`.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.parameters</span>


<span class="s3">class </span><span class="s1">_InsertManyValues(NamedTuple):</span>
    <span class="s2">&quot;&quot;&quot;represents state to use for executing an &quot;insertmanyvalues&quot; statement. 
 
    The primary consumers of this object are the 
    :meth:`.SQLCompiler._deliver_insertmanyvalues_batches` and 
    :meth:`.DefaultDialect._deliver_insertmanyvalues_batches` methods. 
 
    .. versionadded:: 2.0 
 
    &quot;&quot;&quot;</span>

    <span class="s1">is_default_expr: bool</span>
    <span class="s4">&quot;&quot;&quot;if True, the statement is of the form 
    ``INSERT INTO TABLE DEFAULT VALUES``, and can't be rewritten as a &quot;batch&quot; 
 
    &quot;&quot;&quot;</span>

    <span class="s1">single_values_expr: str</span>
    <span class="s4">&quot;&quot;&quot;The rendered &quot;values&quot; clause of the INSERT statement. 
 
    This is typically the parenthesized section e.g. &quot;(?, ?, ?)&quot; or similar. 
    The insertmanyvalues logic uses this string as a search and replace 
    target. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">insert_crud_params: List[crud._CrudParamElementStr]</span>
    <span class="s4">&quot;&quot;&quot;List of Column / bind names etc. used while rewriting the statement&quot;&quot;&quot;</span>

    <span class="s1">num_positional_params_counted: int</span>
    <span class="s4">&quot;&quot;&quot;the number of bound parameters in a single-row statement. 
 
    This count may be larger or smaller than the actual number of columns 
    targeted in the INSERT, as it accommodates for SQL expressions 
    in the values list that may have zero or more parameters embedded 
    within them. 
 
    This count is part of what's used to organize rewritten parameter lists 
    when batching. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">sort_by_parameter_order: bool = </span><span class="s3">False</span>
    <span class="s4">&quot;&quot;&quot;if the deterministic_returnined_order parameter were used on the 
    insert. 
 
    All of the attributes following this will only be used if this is True. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">includes_upsert_behaviors: bool = </span><span class="s3">False</span>
    <span class="s4">&quot;&quot;&quot;if True, we have to accommodate for upsert behaviors. 
 
    This will in some cases downgrade &quot;insertmanyvalues&quot; that requests 
    deterministic ordering. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">sentinel_columns: Optional[Sequence[Column[Any]]] = </span><span class="s3">None</span>
    <span class="s4">&quot;&quot;&quot;List of sentinel columns that were located. 
 
    This list is only here if the INSERT asked for 
    sort_by_parameter_order=True, 
    and dialect-appropriate sentinel columns were located. 
 
    .. versionadded:: 2.0.10 
 
    &quot;&quot;&quot;</span>

    <span class="s1">num_sentinel_columns: int = </span><span class="s6">0</span>
    <span class="s4">&quot;&quot;&quot;how many sentinel columns are in the above list, if any. 
 
    This is the same as 
    ``len(sentinel_columns) if sentinel_columns is not None else 0`` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">sentinel_param_keys: Optional[Sequence[str]] = </span><span class="s3">None</span>
    <span class="s4">&quot;&quot;&quot;parameter str keys in each param dictionary / tuple 
    that would link to the client side &quot;sentinel&quot; values for that row, which 
    we can use to match up parameter sets to result rows. 
 
    This is only present if sentinel_columns is present and the INSERT 
    statement actually refers to client side values for these sentinel 
    columns. 
 
    .. versionadded:: 2.0.10 
 
    .. versionchanged:: 2.0.29 - the sequence is now string dictionary keys 
       only, used against the &quot;compiled parameteters&quot; collection before 
       the parameters were converted by bound parameter processors 
 
    &quot;&quot;&quot;</span>

    <span class="s1">implicit_sentinel: bool = </span><span class="s3">False</span>
    <span class="s4">&quot;&quot;&quot;if True, we have exactly one sentinel column and it uses a server side 
    value, currently has to generate an incrementing integer value. 
 
    The dialect in question would have asserted that it supports receiving 
    these values back and sorting on that value as a means of guaranteeing 
    correlation with the incoming parameter list. 
 
    .. versionadded:: 2.0.10 
 
    &quot;&quot;&quot;</span>

    <span class="s1">embed_values_counter: bool = </span><span class="s3">False</span>
    <span class="s4">&quot;&quot;&quot;Whether to embed an incrementing integer counter in each parameter 
    set within the VALUES clause as parameters are batched over. 
 
    This is only used for a specific INSERT..SELECT..VALUES..RETURNING syntax 
    where a subquery is used to produce value tuples.  Current support 
    includes PostgreSQL, Microsoft SQL Server. 
 
    .. versionadded:: 2.0.10 
 
    &quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">_InsertManyValuesBatch(NamedTuple):</span>
    <span class="s2">&quot;&quot;&quot;represents an individual batch SQL statement for insertmanyvalues. 
 
    This is passed through the 
    :meth:`.SQLCompiler._deliver_insertmanyvalues_batches` and 
    :meth:`.DefaultDialect._deliver_insertmanyvalues_batches` methods out 
    to the :class:`.Connection` within the 
    :meth:`.Connection._exec_insertmany_context` method. 
 
    .. versionadded:: 2.0.10 
 
    &quot;&quot;&quot;</span>

    <span class="s1">replaced_statement: str</span>
    <span class="s1">replaced_parameters: _DBAPIAnyExecuteParams</span>
    <span class="s1">processed_setinputsizes: Optional[_GenericSetInputSizesType]</span>
    <span class="s1">batch: Sequence[_DBAPISingleExecuteParams]</span>
    <span class="s1">sentinel_values: Sequence[Tuple[Any</span><span class="s5">, </span><span class="s1">...]]</span>
    <span class="s1">current_batch_size: int</span>
    <span class="s1">batchnum: int</span>
    <span class="s1">total_batches: int</span>
    <span class="s1">rows_sorted: bool</span>
    <span class="s1">is_downgraded: bool</span>


<span class="s3">class </span><span class="s1">InsertmanyvaluesSentinelOpts(FastIntFlag):</span>
    <span class="s2">&quot;&quot;&quot;bitflag enum indicating styles of PK defaults 
    which can work as implicit sentinel columns 
 
    &quot;&quot;&quot;</span>

    <span class="s1">NOT_SUPPORTED = </span><span class="s6">1</span>
    <span class="s1">AUTOINCREMENT = </span><span class="s6">2</span>
    <span class="s1">IDENTITY = </span><span class="s6">4</span>
    <span class="s1">SEQUENCE = </span><span class="s6">8</span>

    <span class="s1">ANY_AUTOINCREMENT = AUTOINCREMENT | IDENTITY | SEQUENCE</span>
    <span class="s1">_SUPPORTED_OR_NOT = NOT_SUPPORTED | ANY_AUTOINCREMENT</span>

    <span class="s1">USE_INSERT_FROM_SELECT = </span><span class="s6">16</span>
    <span class="s1">RENDER_SELECT_COL_CASTS = </span><span class="s6">64</span>


<span class="s3">class </span><span class="s1">CompilerState(IntEnum):</span>
    <span class="s1">COMPILING = </span><span class="s6">0</span>
    <span class="s4">&quot;&quot;&quot;statement is present, compilation phase in progress&quot;&quot;&quot;</span>

    <span class="s1">STRING_APPLIED = </span><span class="s6">1</span>
    <span class="s4">&quot;&quot;&quot;statement is present, string form of the statement has been applied. 
 
    Additional processors by subclasses may still be pending. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">NO_STATEMENT = </span><span class="s6">2</span>
    <span class="s4">&quot;&quot;&quot;compiler does not have a statement to compile, is used 
    for method access&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">Linting(IntEnum):</span>
    <span class="s2">&quot;&quot;&quot;represent preferences for the 'SQL linting' feature. 
 
    this feature currently includes support for flagging cartesian products 
    in SQL statements. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">NO_LINTING = </span><span class="s6">0</span>
    <span class="s4">&quot;Disable all linting.&quot;</span>

    <span class="s1">COLLECT_CARTESIAN_PRODUCTS = </span><span class="s6">1</span>
    <span class="s4">&quot;&quot;&quot;Collect data on FROMs and cartesian products and gather into 
    'self.from_linter'&quot;&quot;&quot;</span>

    <span class="s1">WARN_LINTING = </span><span class="s6">2</span>
    <span class="s4">&quot;Emit warnings for linters that find problems&quot;</span>

    <span class="s1">FROM_LINTING = COLLECT_CARTESIAN_PRODUCTS | WARN_LINTING</span>
    <span class="s4">&quot;&quot;&quot;Warn for cartesian products; combines COLLECT_CARTESIAN_PRODUCTS 
    and WARN_LINTING&quot;&quot;&quot;</span>


<span class="s1">NO_LINTING</span><span class="s5">, </span><span class="s1">COLLECT_CARTESIAN_PRODUCTS</span><span class="s5">, </span><span class="s1">WARN_LINTING</span><span class="s5">, </span><span class="s1">FROM_LINTING = tuple(</span>
    <span class="s1">Linting</span>
<span class="s1">)</span>


<span class="s3">class </span><span class="s1">FromLinter(collections.namedtuple(</span><span class="s4">&quot;FromLinter&quot;</span><span class="s5">, </span><span class="s1">[</span><span class="s4">&quot;froms&quot;</span><span class="s5">, </span><span class="s4">&quot;edges&quot;</span><span class="s1">])):</span>
    <span class="s2">&quot;&quot;&quot;represents current state for the &quot;cartesian product&quot; detection 
    feature.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">lint(self</span><span class="s5">, </span><span class="s1">start=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">froms = self.froms</span>
        <span class="s3">if not </span><span class="s1">froms:</span>
            <span class="s3">return None</span><span class="s5">, </span><span class="s3">None</span>

        <span class="s1">edges = set(self.edges)</span>
        <span class="s1">the_rest = set(froms)</span>

        <span class="s3">if </span><span class="s1">start </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">start_with = start</span>
            <span class="s1">the_rest.remove(start_with)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">start_with = the_rest.pop()</span>

        <span class="s1">stack = collections.deque([start_with])</span>

        <span class="s3">while </span><span class="s1">stack </span><span class="s3">and </span><span class="s1">the_rest:</span>
            <span class="s1">node = stack.popleft()</span>
            <span class="s1">the_rest.discard(node)</span>

            <span class="s0"># comparison of nodes in edges here is based on hash equality, as</span>
            <span class="s0"># there are &quot;annotated&quot; elements that match the non-annotated ones.</span>
            <span class="s0">#   to remove the need for in-python hash() calls, use native</span>
            <span class="s0"># containment routines (e.g. &quot;node in edge&quot;, &quot;edge.index(node)&quot;)</span>
            <span class="s1">to_remove = {edge </span><span class="s3">for </span><span class="s1">edge </span><span class="s3">in </span><span class="s1">edges </span><span class="s3">if </span><span class="s1">node </span><span class="s3">in </span><span class="s1">edge}</span>

            <span class="s0"># appendleft the node in each edge that is not</span>
            <span class="s0"># the one that matched.</span>
            <span class="s1">stack.extendleft(edge[</span><span class="s3">not </span><span class="s1">edge.index(node)] </span><span class="s3">for </span><span class="s1">edge </span><span class="s3">in </span><span class="s1">to_remove)</span>
            <span class="s1">edges.difference_update(to_remove)</span>

        <span class="s0"># FROMS left over?  boom</span>
        <span class="s3">if </span><span class="s1">the_rest:</span>
            <span class="s3">return </span><span class="s1">the_rest</span><span class="s5">, </span><span class="s1">start_with</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return None</span><span class="s5">, </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">warn(self</span><span class="s5">, </span><span class="s1">stmt_type=</span><span class="s4">&quot;SELECT&quot;</span><span class="s1">):</span>
        <span class="s1">the_rest</span><span class="s5">, </span><span class="s1">start_with = self.lint()</span>

        <span class="s0"># FROMS left over?  boom</span>
        <span class="s3">if </span><span class="s1">the_rest:</span>
            <span class="s1">froms = the_rest</span>
            <span class="s3">if </span><span class="s1">froms:</span>
                <span class="s1">template = (</span>
                    <span class="s4">&quot;{stmt_type} statement has a cartesian product between &quot;</span>
                    <span class="s4">&quot;FROM element(s) {froms} and &quot;</span>
                    <span class="s4">'FROM element &quot;{start}&quot;.  Apply join condition(s) '</span>
                    <span class="s4">&quot;between each element to resolve.&quot;</span>
                <span class="s1">)</span>
                <span class="s1">froms_str = </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
                    <span class="s4">f'&quot;</span><span class="s7">{</span><span class="s1">self.froms[from_]</span><span class="s7">}</span><span class="s4">&quot;' </span><span class="s3">for </span><span class="s1">from_ </span><span class="s3">in </span><span class="s1">froms</span>
                <span class="s1">)</span>
                <span class="s1">message = template.format(</span>
                    <span class="s1">stmt_type=stmt_type</span><span class="s5">,</span>
                    <span class="s1">froms=froms_str</span><span class="s5">,</span>
                    <span class="s1">start=self.froms[start_with]</span><span class="s5">,</span>
                <span class="s1">)</span>

                <span class="s1">util.warn(message)</span>


<span class="s3">class </span><span class="s1">Compiled:</span>
    <span class="s2">&quot;&quot;&quot;Represent a compiled SQL or DDL expression. 
 
    The ``__str__`` method of the ``Compiled`` object should produce 
    the actual text of the statement.  ``Compiled`` objects are 
    specific to their underlying database dialect, and also may 
    or may not be specific to the columns referenced within a 
    particular set of bind parameters.  In no case should the 
    ``Compiled`` object be dependent on the actual values of those 
    bind parameters, even though it may reference those values as 
    defaults. 
    &quot;&quot;&quot;</span>

    <span class="s1">statement: Optional[ClauseElement] = </span><span class="s3">None</span>
    <span class="s4">&quot;The statement to compile.&quot;</span>
    <span class="s1">string: str = </span><span class="s4">&quot;&quot;</span>
    <span class="s4">&quot;The string representation of the ``statement``&quot;</span>

    <span class="s1">state: CompilerState</span>
    <span class="s4">&quot;&quot;&quot;description of the compiler's state&quot;&quot;&quot;</span>

    <span class="s1">is_sql = </span><span class="s3">False</span>
    <span class="s1">is_ddl = </span><span class="s3">False</span>

    <span class="s1">_cached_metadata: Optional[CursorResultMetaData] = </span><span class="s3">None</span>

    <span class="s1">_result_columns: Optional[List[ResultColumnsEntry]] = </span><span class="s3">None</span>

    <span class="s1">schema_translate_map: Optional[SchemaTranslateMapType] = </span><span class="s3">None</span>

    <span class="s1">execution_options: _ExecuteOptions = util.EMPTY_DICT</span>
    <span class="s4">&quot;&quot;&quot; 
    Execution options propagated from the statement.   In some cases, 
    sub-elements of the statement can modify these. 
    &quot;&quot;&quot;</span>

    <span class="s1">preparer: IdentifierPreparer</span>

    <span class="s1">_annotations: _AnnotationDict = util.EMPTY_DICT</span>

    <span class="s1">compile_state: Optional[CompileState] = </span><span class="s3">None</span>
    <span class="s4">&quot;&quot;&quot;Optional :class:`.CompileState` object that maintains additional 
    state used by the compiler. 
 
    Major executable objects such as :class:`_expression.Insert`, 
    :class:`_expression.Update`, :class:`_expression.Delete`, 
    :class:`_expression.Select` will generate this 
    state when compiled in order to calculate additional information about the 
    object.   For the top level object that is to be executed, the state can be 
    stored here where it can also have applicability towards result set 
    processing. 
 
    .. versionadded:: 1.4 
 
    &quot;&quot;&quot;</span>

    <span class="s1">dml_compile_state: Optional[CompileState] = </span><span class="s3">None</span>
    <span class="s4">&quot;&quot;&quot;Optional :class:`.CompileState` assigned at the same point that 
    .isinsert, .isupdate, or .isdelete is assigned. 
 
    This will normally be the same object as .compile_state, with the 
    exception of cases like the :class:`.ORMFromStatementCompileState` 
    object. 
 
    .. versionadded:: 1.4.40 
 
    &quot;&quot;&quot;</span>

    <span class="s1">cache_key: Optional[CacheKey] = </span><span class="s3">None</span>
    <span class="s4">&quot;&quot;&quot;The :class:`.CacheKey` that was generated ahead of creating this 
    :class:`.Compiled` object. 
 
    This is used for routines that need access to the original 
    :class:`.CacheKey` instance generated when the :class:`.Compiled` 
    instance was first cached, typically in order to reconcile 
    the original list of :class:`.BindParameter` objects with a 
    per-statement list that's generated on each call. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_gen_time: float</span>
    <span class="s4">&quot;&quot;&quot;Generation time of this :class:`.Compiled`, used for reporting 
    cache stats.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">dialect: Dialect</span><span class="s5">,</span>
        <span class="s1">statement: Optional[ClauseElement]</span><span class="s5">,</span>
        <span class="s1">schema_translate_map: Optional[SchemaTranslateMapType] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">render_schema_translate: bool = </span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">compile_kwargs: Mapping[str</span><span class="s5">, </span><span class="s1">Any] = util.immutabledict()</span><span class="s5">,</span>
    <span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Construct a new :class:`.Compiled` object. 
 
        :param dialect: :class:`.Dialect` to compile against. 
 
        :param statement: :class:`_expression.ClauseElement` to be compiled. 
 
        :param schema_translate_map: dictionary of schema names to be 
         translated when forming the resultant SQL 
 
         .. seealso:: 
 
            :ref:`schema_translating` 
 
        :param compile_kwargs: additional kwargs that will be 
         passed to the initial call to :meth:`.Compiled.process`. 
 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.dialect = dialect</span>
        <span class="s1">self.preparer = self.dialect.identifier_preparer</span>
        <span class="s3">if </span><span class="s1">schema_translate_map:</span>
            <span class="s1">self.schema_translate_map = schema_translate_map</span>
            <span class="s1">self.preparer = self.preparer._with_schema_translate(</span>
                <span class="s1">schema_translate_map</span>
            <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">statement </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.state = CompilerState.COMPILING</span>
            <span class="s1">self.statement = statement</span>
            <span class="s1">self.can_execute = statement.supports_execution</span>
            <span class="s1">self._annotations = statement._annotations</span>
            <span class="s3">if </span><span class="s1">self.can_execute:</span>
                <span class="s3">if </span><span class="s1">TYPE_CHECKING:</span>
                    <span class="s3">assert </span><span class="s1">isinstance(statement</span><span class="s5">, </span><span class="s1">Executable)</span>
                <span class="s1">self.execution_options = statement._execution_options</span>
            <span class="s1">self.string = self.process(self.statement</span><span class="s5">, </span><span class="s1">**compile_kwargs)</span>

            <span class="s3">if </span><span class="s1">render_schema_translate:</span>
                <span class="s1">self.string = self.preparer._render_schema_translates(</span>
                    <span class="s1">self.string</span><span class="s5">, </span><span class="s1">schema_translate_map</span>
                <span class="s1">)</span>

            <span class="s1">self.state = CompilerState.STRING_APPLIED</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.state = CompilerState.NO_STATEMENT</span>

        <span class="s1">self._gen_time = perf_counter()</span>

    <span class="s3">def </span><span class="s1">__init_subclass__(cls) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
        <span class="s1">cls._init_compiler_cls()</span>
        <span class="s3">return </span><span class="s1">super().__init_subclass__()</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_init_compiler_cls(cls):</span>
        <span class="s3">pass</span>

    <span class="s3">def </span><span class="s1">_execute_on_connection(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">connection</span><span class="s5">, </span><span class="s1">distilled_params</span><span class="s5">, </span><span class="s1">execution_options</span>
    <span class="s1">):</span>
        <span class="s3">if </span><span class="s1">self.can_execute:</span>
            <span class="s3">return </span><span class="s1">connection._execute_compiled(</span>
                <span class="s1">self</span><span class="s5">, </span><span class="s1">distilled_params</span><span class="s5">, </span><span class="s1">execution_options</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">exc.ObjectNotExecutableError(self.statement)</span>

    <span class="s3">def </span><span class="s1">visit_unsupported_compilation(self</span><span class="s5">, </span><span class="s1">element</span><span class="s5">, </span><span class="s1">err</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">raise </span><span class="s1">exc.UnsupportedCompilationError(self</span><span class="s5">, </span><span class="s1">type(element)) </span><span class="s3">from </span><span class="s1">err</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">sql_compiler(self):</span>
        <span class="s2">&quot;&quot;&quot;Return a Compiled that is capable of processing SQL expressions. 
 
        If this compiler is one, it would likely just return 'self'. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s3">def </span><span class="s1">process(self</span><span class="s5">, </span><span class="s1">obj: Visitable</span><span class="s5">, </span><span class="s1">**kwargs: Any) -&gt; str:</span>
        <span class="s3">return </span><span class="s1">obj._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kwargs)</span>

    <span class="s3">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s2">&quot;&quot;&quot;Return the string text of the generated SQL or DDL.&quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">self.state </span><span class="s3">is </span><span class="s1">CompilerState.STRING_APPLIED:</span>
            <span class="s3">return </span><span class="s1">self.string</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">construct_params(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">params: Optional[_CoreSingleExecuteParams] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">extracted_parameters: Optional[Sequence[BindParameter[Any]]] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">escape_names: bool = </span><span class="s3">True</span><span class="s5">,</span>
    <span class="s1">) -&gt; Optional[_MutableCoreSingleExecuteParams]:</span>
        <span class="s2">&quot;&quot;&quot;Return the bind params for this compiled object. 
 
        :param params: a dict of string/object pairs whose values will 
                       override bind values compiled in to the 
                       statement. 
        &quot;&quot;&quot;</span>

        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">params(self):</span>
        <span class="s2">&quot;&quot;&quot;Return the bind params for this compiled object.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.construct_params()</span>


<span class="s3">class </span><span class="s1">TypeCompiler(util.EnsureKWArg):</span>
    <span class="s2">&quot;&quot;&quot;Produces DDL specification for TypeEngine objects.&quot;&quot;&quot;</span>

    <span class="s1">ensure_kwarg = </span><span class="s4">r&quot;visit_\w+&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s5">, </span><span class="s1">dialect: Dialect):</span>
        <span class="s1">self.dialect = dialect</span>

    <span class="s3">def </span><span class="s1">process(self</span><span class="s5">, </span><span class="s1">type_: TypeEngine[Any]</span><span class="s5">, </span><span class="s1">**kw: Any) -&gt; str:</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">type_._variant_mapping</span>
            <span class="s3">and </span><span class="s1">self.dialect.name </span><span class="s3">in </span><span class="s1">type_._variant_mapping</span>
        <span class="s1">):</span>
            <span class="s1">type_ = type_._variant_mapping[self.dialect.name]</span>
        <span class="s3">return </span><span class="s1">type_._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_unsupported_compilation(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">element: Any</span><span class="s5">, </span><span class="s1">err: Exception</span><span class="s5">, </span><span class="s1">**kw: Any</span>
    <span class="s1">) -&gt; NoReturn:</span>
        <span class="s3">raise </span><span class="s1">exc.UnsupportedCompilationError(self</span><span class="s5">, </span><span class="s1">element) </span><span class="s3">from </span><span class="s1">err</span>


<span class="s0"># this was a Visitable, but to allow accurate detection of</span>
<span class="s0"># column elements this is actually a column element</span>
<span class="s3">class </span><span class="s1">_CompileLabel(</span>
    <span class="s1">roles.BinaryElementRole[Any]</span><span class="s5">, </span><span class="s1">elements.CompilerColumnElement</span>
<span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;lightweight label object which acts as an expression.Label.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ = </span><span class="s4">&quot;label&quot;</span>
    <span class="s1">__slots__ = </span><span class="s4">&quot;element&quot;</span><span class="s5">, </span><span class="s4">&quot;name&quot;</span><span class="s5">, </span><span class="s4">&quot;_alt_names&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s5">, </span><span class="s1">col</span><span class="s5">, </span><span class="s1">name</span><span class="s5">, </span><span class="s1">alt_names=()):</span>
        <span class="s1">self.element = col</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self._alt_names = (col</span><span class="s5">,</span><span class="s1">) + alt_names</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">proxy_set(self):</span>
        <span class="s3">return </span><span class="s1">self.element.proxy_set</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">type(self):</span>
        <span class="s3">return </span><span class="s1">self.element.type</span>

    <span class="s3">def </span><span class="s1">self_group(self</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self</span>


<span class="s3">class </span><span class="s1">ilike_case_insensitive(</span>
    <span class="s1">roles.BinaryElementRole[Any]</span><span class="s5">, </span><span class="s1">elements.CompilerColumnElement</span>
<span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;produce a wrapping element for a case-insensitive portion of 
    an ILIKE construct. 
 
    The construct usually renders the ``lower()`` function, but on 
    PostgreSQL will pass silently with the assumption that &quot;ILIKE&quot; 
    is being used. 
 
    .. versionadded:: 2.0 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ = </span><span class="s4">&quot;ilike_case_insensitive_operand&quot;</span>
    <span class="s1">__slots__ = </span><span class="s4">&quot;element&quot;</span><span class="s5">, </span><span class="s4">&quot;comparator&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s5">, </span><span class="s1">element):</span>
        <span class="s1">self.element = element</span>
        <span class="s1">self.comparator = element.comparator</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">proxy_set(self):</span>
        <span class="s3">return </span><span class="s1">self.element.proxy_set</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">type(self):</span>
        <span class="s3">return </span><span class="s1">self.element.type</span>

    <span class="s3">def </span><span class="s1">self_group(self</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_with_binary_element_type(self</span><span class="s5">, </span><span class="s1">type_):</span>
        <span class="s3">return </span><span class="s1">ilike_case_insensitive(</span>
            <span class="s1">self.element._with_binary_element_type(type_)</span>
        <span class="s1">)</span>


<span class="s3">class </span><span class="s1">SQLCompiler(Compiled):</span>
    <span class="s2">&quot;&quot;&quot;Default implementation of :class:`.Compiled`. 
 
    Compiles :class:`_expression.ClauseElement` objects into SQL strings. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">extract_map = EXTRACT_MAP</span>

    <span class="s1">bindname_escape_characters: ClassVar[Mapping[str</span><span class="s5">, </span><span class="s1">str]] = (</span>
        <span class="s1">util.immutabledict(</span>
            <span class="s1">{</span>
                <span class="s4">&quot;%&quot;</span><span class="s1">: </span><span class="s4">&quot;P&quot;</span><span class="s5">,</span>
                <span class="s4">&quot;(&quot;</span><span class="s1">: </span><span class="s4">&quot;A&quot;</span><span class="s5">,</span>
                <span class="s4">&quot;)&quot;</span><span class="s1">: </span><span class="s4">&quot;Z&quot;</span><span class="s5">,</span>
                <span class="s4">&quot;:&quot;</span><span class="s1">: </span><span class="s4">&quot;C&quot;</span><span class="s5">,</span>
                <span class="s4">&quot;.&quot;</span><span class="s1">: </span><span class="s4">&quot;_&quot;</span><span class="s5">,</span>
                <span class="s4">&quot;[&quot;</span><span class="s1">: </span><span class="s4">&quot;_&quot;</span><span class="s5">,</span>
                <span class="s4">&quot;]&quot;</span><span class="s1">: </span><span class="s4">&quot;_&quot;</span><span class="s5">,</span>
                <span class="s4">&quot; &quot;</span><span class="s1">: </span><span class="s4">&quot;_&quot;</span><span class="s5">,</span>
            <span class="s1">}</span>
        <span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s4">&quot;&quot;&quot;A mapping (e.g. dict or similar) containing a lookup of 
    characters keyed to replacement characters which will be applied to all 
    'bind names' used in SQL statements as a form of 'escaping'; the given 
    characters are replaced entirely with the 'replacement' character when 
    rendered in the SQL statement, and a similar translation is performed 
    on the incoming names used in parameter dictionaries passed to methods 
    like :meth:`_engine.Connection.execute`. 
 
    This allows bound parameter names used in :func:`_sql.bindparam` and 
    other constructs to have any arbitrary characters present without any 
    concern for characters that aren't allowed at all on the target database. 
 
    Third party dialects can establish their own dictionary here to replace the 
    default mapping, which will ensure that the particular characters in the 
    mapping will never appear in a bound parameter name. 
 
    The dictionary is evaluated at **class creation time**, so cannot be 
    modified at runtime; it must be present on the class when the class 
    is first declared. 
 
    Note that for dialects that have additional bound parameter rules such 
    as additional restrictions on leading characters, the 
    :meth:`_sql.SQLCompiler.bindparam_string` method may need to be augmented. 
    See the cx_Oracle compiler for an example of this. 
 
    .. versionadded:: 2.0.0rc1 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_bind_translate_re: ClassVar[Pattern[str]]</span>
    <span class="s1">_bind_translate_chars: ClassVar[Mapping[str</span><span class="s5">, </span><span class="s1">str]]</span>

    <span class="s1">is_sql = </span><span class="s3">True</span>

    <span class="s1">compound_keywords = COMPOUND_KEYWORDS</span>

    <span class="s1">isdelete: bool = </span><span class="s3">False</span>
    <span class="s1">isinsert: bool = </span><span class="s3">False</span>
    <span class="s1">isupdate: bool = </span><span class="s3">False</span>
    <span class="s4">&quot;&quot;&quot;class-level defaults which can be set at the instance 
    level to define if this Compiled instance represents 
    INSERT/UPDATE/DELETE 
    &quot;&quot;&quot;</span>

    <span class="s1">postfetch: Optional[List[Column[Any]]]</span>
    <span class="s4">&quot;&quot;&quot;list of columns that can be post-fetched after INSERT or UPDATE to 
    receive server-updated values&quot;&quot;&quot;</span>

    <span class="s1">insert_prefetch: Sequence[Column[Any]] = ()</span>
    <span class="s4">&quot;&quot;&quot;list of columns for which default values should be evaluated before 
    an INSERT takes place&quot;&quot;&quot;</span>

    <span class="s1">update_prefetch: Sequence[Column[Any]] = ()</span>
    <span class="s4">&quot;&quot;&quot;list of columns for which onupdate default values should be evaluated 
    before an UPDATE takes place&quot;&quot;&quot;</span>

    <span class="s1">implicit_returning: Optional[Sequence[ColumnElement[Any]]] = </span><span class="s3">None</span>
    <span class="s4">&quot;&quot;&quot;list of &quot;implicit&quot; returning columns for a toplevel INSERT or UPDATE 
    statement, used to receive newly generated values of columns. 
 
    .. versionadded:: 2.0  ``implicit_returning`` replaces the previous 
       ``returning`` collection, which was not a generalized RETURNING 
       collection and instead was in fact specific to the &quot;implicit returning&quot; 
       feature. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">isplaintext: bool = </span><span class="s3">False</span>

    <span class="s1">binds: Dict[str</span><span class="s5">, </span><span class="s1">BindParameter[Any]]</span>
    <span class="s4">&quot;&quot;&quot;a dictionary of bind parameter keys to BindParameter instances.&quot;&quot;&quot;</span>

    <span class="s1">bind_names: Dict[BindParameter[Any]</span><span class="s5">, </span><span class="s1">str]</span>
    <span class="s4">&quot;&quot;&quot;a dictionary of BindParameter instances to &quot;compiled&quot; names 
    that are actually present in the generated SQL&quot;&quot;&quot;</span>

    <span class="s1">stack: List[_CompilerStackEntry]</span>
    <span class="s4">&quot;&quot;&quot;major statements such as SELECT, INSERT, UPDATE, DELETE are 
    tracked in this stack using an entry format.&quot;&quot;&quot;</span>

    <span class="s1">returning_precedes_values: bool = </span><span class="s3">False</span>
    <span class="s4">&quot;&quot;&quot;set to True classwide to generate RETURNING 
    clauses before the VALUES or WHERE clause (i.e. MSSQL) 
    &quot;&quot;&quot;</span>

    <span class="s1">render_table_with_column_in_update_from: bool = </span><span class="s3">False</span>
    <span class="s4">&quot;&quot;&quot;set to True classwide to indicate the SET clause 
    in a multi-table UPDATE statement should qualify 
    columns with the table name (i.e. MySQL only) 
    &quot;&quot;&quot;</span>

    <span class="s1">ansi_bind_rules: bool = </span><span class="s3">False</span>
    <span class="s4">&quot;&quot;&quot;SQL 92 doesn't allow bind parameters to be used 
    in the columns clause of a SELECT, nor does it allow 
    ambiguous expressions like &quot;? = ?&quot;.  A compiler 
    subclass can set this flag to False if the target 
    driver/DB enforces this 
    &quot;&quot;&quot;</span>

    <span class="s1">bindtemplate: str</span>
    <span class="s4">&quot;&quot;&quot;template to render bound parameters based on paramstyle.&quot;&quot;&quot;</span>

    <span class="s1">compilation_bindtemplate: str</span>
    <span class="s4">&quot;&quot;&quot;template used by compiler to render parameters before positional 
    paramstyle application&quot;&quot;&quot;</span>

    <span class="s1">_numeric_binds_identifier_char: str</span>
    <span class="s4">&quot;&quot;&quot;Character that's used to as the identifier of a numerical bind param. 
    For example if this char is set to ``$``, numerical binds will be rendered 
    in the form ``$1, $2, $3``. 
    &quot;&quot;&quot;</span>

    <span class="s1">_result_columns: List[ResultColumnsEntry]</span>
    <span class="s4">&quot;&quot;&quot;relates label names in the final SQL to a tuple of local 
    column/label name, ColumnElement object (if any) and 
    TypeEngine. CursorResult uses this for type processing and 
    column targeting&quot;&quot;&quot;</span>

    <span class="s1">_textual_ordered_columns: bool = </span><span class="s3">False</span>
    <span class="s4">&quot;&quot;&quot;tell the result object that the column names as rendered are important, 
    but they are also &quot;ordered&quot; vs. what is in the compiled object here. 
 
    As of 1.4.42 this condition is only present when the statement is a 
    TextualSelect, e.g. text(&quot;....&quot;).columns(...), where it is required 
    that the columns are considered positionally and not by name. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_ad_hoc_textual: bool = </span><span class="s3">False</span>
    <span class="s4">&quot;&quot;&quot;tell the result that we encountered text() or '*' constructs in the 
    middle of the result columns, but we also have compiled columns, so 
    if the number of columns in cursor.description does not match how many 
    expressions we have, that means we can't rely on positional at all and 
    should match on name. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_ordered_columns: bool = </span><span class="s3">True</span>
    <span class="s4">&quot;&quot;&quot; 
    if False, means we can't be sure the list of entries 
    in _result_columns is actually the rendered order.  Usually 
    True unless using an unordered TextualSelect. 
    &quot;&quot;&quot;</span>

    <span class="s1">_loose_column_name_matching: bool = </span><span class="s3">False</span>
    <span class="s4">&quot;&quot;&quot;tell the result object that the SQL statement is textual, wants to match 
    up to Column objects, and may be using the ._tq_label in the SELECT rather 
    than the base name. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_numeric_binds: bool = </span><span class="s3">False</span>
    <span class="s4">&quot;&quot;&quot; 
    True if paramstyle is &quot;numeric&quot;.  This paramstyle is trickier than 
    all the others. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_render_postcompile: bool = </span><span class="s3">False</span>
    <span class="s4">&quot;&quot;&quot; 
    whether to render out POSTCOMPILE params during the compile phase. 
 
    This attribute is used only for end-user invocation of stmt.compile(); 
    it's never used for actual statement execution, where instead the 
    dialect internals access and render the internal postcompile structure 
    directly. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_post_compile_expanded_state: Optional[ExpandedState] = </span><span class="s3">None</span>
    <span class="s4">&quot;&quot;&quot;When render_postcompile is used, the ``ExpandedState`` used to create 
    the &quot;expanded&quot; SQL is assigned here, and then used by the ``.params`` 
    accessor and ``.construct_params()`` methods for their return values. 
 
    .. versionadded:: 2.0.0rc1 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_pre_expanded_string: Optional[str] = </span><span class="s3">None</span>
    <span class="s4">&quot;&quot;&quot;Stores the original string SQL before 'post_compile' is applied, 
    for cases where 'post_compile' were used. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_pre_expanded_positiontup: Optional[List[str]] = </span><span class="s3">None</span>

    <span class="s1">_insertmanyvalues: Optional[_InsertManyValues] = </span><span class="s3">None</span>

    <span class="s1">_insert_crud_params: Optional[crud._CrudParamSequence] = </span><span class="s3">None</span>

    <span class="s1">literal_execute_params: FrozenSet[BindParameter[Any]] = frozenset()</span>
    <span class="s4">&quot;&quot;&quot;bindparameter objects that are rendered as literal values at statement 
    execution time. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">post_compile_params: FrozenSet[BindParameter[Any]] = frozenset()</span>
    <span class="s4">&quot;&quot;&quot;bindparameter objects that are rendered as bound parameter placeholders 
    at statement execution time. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">escaped_bind_names: util.immutabledict[str</span><span class="s5">, </span><span class="s1">str] = util.EMPTY_DICT</span>
    <span class="s4">&quot;&quot;&quot;Late escaping of bound parameter names that has to be converted 
    to the original name when looking in the parameter dictionary. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">has_out_parameters = </span><span class="s3">False</span>
    <span class="s4">&quot;&quot;&quot;if True, there are bindparam() objects that have the isoutparam 
    flag set.&quot;&quot;&quot;</span>

    <span class="s1">postfetch_lastrowid = </span><span class="s3">False</span>
    <span class="s4">&quot;&quot;&quot;if True, and this in insert, use cursor.lastrowid to populate 
    result.inserted_primary_key. &quot;&quot;&quot;</span>

    <span class="s1">_cache_key_bind_match: Optional[</span>
        <span class="s1">Tuple[</span>
            <span class="s1">Dict[</span>
                <span class="s1">BindParameter[Any]</span><span class="s5">,</span>
                <span class="s1">List[BindParameter[Any]]</span><span class="s5">,</span>
            <span class="s1">]</span><span class="s5">,</span>
            <span class="s1">Dict[</span>
                <span class="s1">str</span><span class="s5">,</span>
                <span class="s1">BindParameter[Any]</span><span class="s5">,</span>
            <span class="s1">]</span><span class="s5">,</span>
        <span class="s1">]</span>
    <span class="s1">] = </span><span class="s3">None</span>
    <span class="s4">&quot;&quot;&quot;a mapping that will relate the BindParameter object we compile 
    to those that are part of the extracted collection of parameters 
    in the cache key, if we were given a cache key. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">positiontup: Optional[List[str]] = </span><span class="s3">None</span>
    <span class="s4">&quot;&quot;&quot;for a compiled construct that uses a positional paramstyle, will be 
    a sequence of strings, indicating the names of bound parameters in order. 
 
    This is used in order to render bound parameters in their correct order, 
    and is combined with the :attr:`_sql.Compiled.params` dictionary to 
    render parameters. 
 
    This sequence always contains the unescaped name of the parameters. 
 
    .. seealso:: 
 
        :ref:`faq_sql_expression_string` - includes a usage example for 
        debugging use cases. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">_values_bindparam: Optional[List[str]] = </span><span class="s3">None</span>

    <span class="s1">_visited_bindparam: Optional[List[str]] = </span><span class="s3">None</span>

    <span class="s1">inline: bool = </span><span class="s3">False</span>

    <span class="s1">ctes: Optional[MutableMapping[CTE</span><span class="s5">, </span><span class="s1">str]]</span>

    <span class="s0"># Detect same CTE references - Dict[(level, name), cte]</span>
    <span class="s0"># Level is required for supporting nesting</span>
    <span class="s1">ctes_by_level_name: Dict[Tuple[int</span><span class="s5">, </span><span class="s1">str]</span><span class="s5">, </span><span class="s1">CTE]</span>

    <span class="s0"># To retrieve key/level in ctes_by_level_name -</span>
    <span class="s0"># Dict[cte_reference, (level, cte_name, cte_opts)]</span>
    <span class="s1">level_name_by_cte: Dict[CTE</span><span class="s5">, </span><span class="s1">Tuple[int</span><span class="s5">, </span><span class="s1">str</span><span class="s5">, </span><span class="s1">selectable._CTEOpts]]</span>

    <span class="s1">ctes_recursive: bool</span>

    <span class="s1">_post_compile_pattern = re.compile(</span><span class="s4">r&quot;__\[POSTCOMPILE_(\S+?)(~~.+?~~)?\]&quot;</span><span class="s1">)</span>
    <span class="s1">_pyformat_pattern = re.compile(</span><span class="s4">r&quot;%\(([^)]+?)\)s&quot;</span><span class="s1">)</span>
    <span class="s1">_positional_pattern = re.compile(</span>
        <span class="s4">f&quot;</span><span class="s7">{</span><span class="s1">_pyformat_pattern.pattern</span><span class="s7">}</span><span class="s4">|</span><span class="s7">{</span><span class="s1">_post_compile_pattern.pattern</span><span class="s7">}</span><span class="s4">&quot;</span>
    <span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_init_compiler_cls(cls):</span>
        <span class="s1">cls._init_bind_translate()</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">_init_bind_translate(cls):</span>
        <span class="s1">reg = re.escape(</span><span class="s4">&quot;&quot;</span><span class="s1">.join(cls.bindname_escape_characters))</span>
        <span class="s1">cls._bind_translate_re = re.compile(</span><span class="s4">f&quot;[</span><span class="s7">{</span><span class="s1">reg</span><span class="s7">}</span><span class="s4">]&quot;</span><span class="s1">)</span>
        <span class="s1">cls._bind_translate_chars = cls.bindname_escape_characters</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">dialect: Dialect</span><span class="s5">,</span>
        <span class="s1">statement: Optional[ClauseElement]</span><span class="s5">,</span>
        <span class="s1">cache_key: Optional[CacheKey] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">column_keys: Optional[Sequence[str]] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">for_executemany: bool = </span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">linting: Linting = NO_LINTING</span><span class="s5">,</span>
        <span class="s1">_supporting_against: Optional[SQLCompiler] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">**kwargs: Any</span><span class="s5">,</span>
    <span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Construct a new :class:`.SQLCompiler` object. 
 
        :param dialect: :class:`.Dialect` to be used 
 
        :param statement: :class:`_expression.ClauseElement` to be compiled 
 
        :param column_keys:  a list of column names to be compiled into an 
         INSERT or UPDATE statement. 
 
        :param for_executemany: whether INSERT / UPDATE statements should 
         expect that they are to be invoked in an &quot;executemany&quot; style, 
         which may impact how the statement will be expected to return the 
         values of defaults and autoincrement / sequences and similar. 
         Depending on the backend and driver in use, support for retrieving 
         these values may be disabled which means SQL expressions may 
         be rendered inline, RETURNING may not be rendered, etc. 
 
        :param kwargs: additional keyword arguments to be consumed by the 
         superclass. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.column_keys = column_keys</span>

        <span class="s1">self.cache_key = cache_key</span>

        <span class="s3">if </span><span class="s1">cache_key:</span>
            <span class="s1">cksm = {b.key: b </span><span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">cache_key[</span><span class="s6">1</span><span class="s1">]}</span>
            <span class="s1">ckbm = {b: [b] </span><span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">cache_key[</span><span class="s6">1</span><span class="s1">]}</span>
            <span class="s1">self._cache_key_bind_match = (ckbm</span><span class="s5">, </span><span class="s1">cksm)</span>

        <span class="s0"># compile INSERT/UPDATE defaults/sequences to expect executemany</span>
        <span class="s0"># style execution, which may mean no pre-execute of defaults,</span>
        <span class="s0"># or no RETURNING</span>
        <span class="s1">self.for_executemany = for_executemany</span>

        <span class="s1">self.linting = linting</span>

        <span class="s0"># a dictionary of bind parameter keys to BindParameter</span>
        <span class="s0"># instances.</span>
        <span class="s1">self.binds = {}</span>

        <span class="s0"># a dictionary of BindParameter instances to &quot;compiled&quot; names</span>
        <span class="s0"># that are actually present in the generated SQL</span>
        <span class="s1">self.bind_names = util.column_dict()</span>

        <span class="s0"># stack which keeps track of nested SELECT statements</span>
        <span class="s1">self.stack = []</span>

        <span class="s1">self._result_columns = []</span>

        <span class="s0"># true if the paramstyle is positional</span>
        <span class="s1">self.positional = dialect.positional</span>
        <span class="s3">if </span><span class="s1">self.positional:</span>
            <span class="s1">self._numeric_binds = nb = dialect.paramstyle.startswith(</span><span class="s4">&quot;numeric&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">nb:</span>
                <span class="s1">self._numeric_binds_identifier_char = (</span>
                    <span class="s4">&quot;$&quot; </span><span class="s3">if </span><span class="s1">dialect.paramstyle == </span><span class="s4">&quot;numeric_dollar&quot; </span><span class="s3">else </span><span class="s4">&quot;:&quot;</span>
                <span class="s1">)</span>

            <span class="s1">self.compilation_bindtemplate = _pyformat_template</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.compilation_bindtemplate = BIND_TEMPLATES[dialect.paramstyle]</span>

        <span class="s1">self.ctes = </span><span class="s3">None</span>

        <span class="s1">self.label_length = (</span>
            <span class="s1">dialect.label_length </span><span class="s3">or </span><span class="s1">dialect.max_identifier_length</span>
        <span class="s1">)</span>

        <span class="s0"># a map which tracks &quot;anonymous&quot; identifiers that are created on</span>
        <span class="s0"># the fly here</span>
        <span class="s1">self.anon_map = prefix_anon_map()</span>

        <span class="s0"># a map which tracks &quot;truncated&quot; names based on</span>
        <span class="s0"># dialect.label_length or dialect.max_identifier_length</span>
        <span class="s1">self.truncated_names: Dict[Tuple[str</span><span class="s5">, </span><span class="s1">str]</span><span class="s5">, </span><span class="s1">str] = {}</span>
        <span class="s1">self._truncated_counters: Dict[str</span><span class="s5">, </span><span class="s1">int] = {}</span>

        <span class="s1">Compiled.__init__(self</span><span class="s5">, </span><span class="s1">dialect</span><span class="s5">, </span><span class="s1">statement</span><span class="s5">, </span><span class="s1">**kwargs)</span>

        <span class="s3">if </span><span class="s1">self.isinsert </span><span class="s3">or </span><span class="s1">self.isupdate </span><span class="s3">or </span><span class="s1">self.isdelete:</span>
            <span class="s3">if </span><span class="s1">TYPE_CHECKING:</span>
                <span class="s3">assert </span><span class="s1">isinstance(statement</span><span class="s5">, </span><span class="s1">UpdateBase)</span>

            <span class="s3">if </span><span class="s1">self.isinsert </span><span class="s3">or </span><span class="s1">self.isupdate:</span>
                <span class="s3">if </span><span class="s1">TYPE_CHECKING:</span>
                    <span class="s3">assert </span><span class="s1">isinstance(statement</span><span class="s5">, </span><span class="s1">ValuesBase)</span>
                <span class="s3">if </span><span class="s1">statement._inline:</span>
                    <span class="s1">self.inline = </span><span class="s3">True</span>
                <span class="s3">elif </span><span class="s1">self.for_executemany </span><span class="s3">and </span><span class="s1">(</span>
                    <span class="s3">not </span><span class="s1">self.isinsert</span>
                    <span class="s3">or </span><span class="s1">(</span>
                        <span class="s1">self.dialect.insert_executemany_returning</span>
                        <span class="s3">and </span><span class="s1">statement._return_defaults</span>
                    <span class="s1">)</span>
                <span class="s1">):</span>
                    <span class="s1">self.inline = </span><span class="s3">True</span>

        <span class="s1">self.bindtemplate = BIND_TEMPLATES[dialect.paramstyle]</span>

        <span class="s3">if </span><span class="s1">_supporting_against:</span>
            <span class="s1">self.__dict__.update(</span>
                <span class="s1">{</span>
                    <span class="s1">k: v</span>
                    <span class="s3">for </span><span class="s1">k</span><span class="s5">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">_supporting_against.__dict__.items()</span>
                    <span class="s3">if </span><span class="s1">k</span>
                    <span class="s3">not in </span><span class="s1">{</span>
                        <span class="s4">&quot;state&quot;</span><span class="s5">,</span>
                        <span class="s4">&quot;dialect&quot;</span><span class="s5">,</span>
                        <span class="s4">&quot;preparer&quot;</span><span class="s5">,</span>
                        <span class="s4">&quot;positional&quot;</span><span class="s5">,</span>
                        <span class="s4">&quot;_numeric_binds&quot;</span><span class="s5">,</span>
                        <span class="s4">&quot;compilation_bindtemplate&quot;</span><span class="s5">,</span>
                        <span class="s4">&quot;bindtemplate&quot;</span><span class="s5">,</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">self.state </span><span class="s3">is </span><span class="s1">CompilerState.STRING_APPLIED:</span>
            <span class="s3">if </span><span class="s1">self.positional:</span>
                <span class="s3">if </span><span class="s1">self._numeric_binds:</span>
                    <span class="s1">self._process_numeric()</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">self._process_positional()</span>

            <span class="s3">if </span><span class="s1">self._render_postcompile:</span>
                <span class="s1">parameters = self.construct_params(</span>
                    <span class="s1">escape_names=</span><span class="s3">False</span><span class="s5">,</span>
                    <span class="s1">_no_postcompile=</span><span class="s3">True</span><span class="s5">,</span>
                <span class="s1">)</span>

                <span class="s1">self._process_parameters_for_postcompile(</span>
                    <span class="s1">parameters</span><span class="s5">, </span><span class="s1">_populate_self=</span><span class="s3">True</span>
                <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">insert_single_values_expr(self) -&gt; Optional[str]:</span>
        <span class="s2">&quot;&quot;&quot;When an INSERT is compiled with a single set of parameters inside 
        a VALUES expression, the string is assigned here, where it can be 
        used for insert batching schemes to rewrite the VALUES expression. 
 
        .. versionadded:: 1.3.8 
 
        .. versionchanged:: 2.0 This collection is no longer used by 
           SQLAlchemy's built-in dialects, in favor of the currently 
           internal ``_insertmanyvalues`` collection that is used only by 
           :class:`.SQLCompiler`. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self._insertmanyvalues </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self._insertmanyvalues.single_values_expr</span>

    <span class="s1">@util.ro_memoized_property</span>
    <span class="s3">def </span><span class="s1">effective_returning(self) -&gt; Optional[Sequence[ColumnElement[Any]]]:</span>
        <span class="s2">&quot;&quot;&quot;The effective &quot;returning&quot; columns for INSERT, UPDATE or DELETE. 
 
        This is either the so-called &quot;implicit returning&quot; columns which are 
        calculated by the compiler on the fly, or those present based on what's 
        present in ``self.statement._returning`` (expanded into individual 
        columns using the ``._all_selected_columns`` attribute) i.e. those set 
        explicitly using the :meth:`.UpdateBase.returning` method. 
 
        .. versionadded:: 2.0 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.implicit_returning:</span>
            <span class="s3">return </span><span class="s1">self.implicit_returning</span>
        <span class="s3">elif </span><span class="s1">self.statement </span><span class="s3">is not None and </span><span class="s1">is_dml(self.statement):</span>
            <span class="s3">return </span><span class="s1">[</span>
                <span class="s1">c</span>
                <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">self.statement._all_selected_columns</span>
                <span class="s3">if </span><span class="s1">is_column_element(c)</span>
            <span class="s1">]</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return None</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">returning(self):</span>
        <span class="s2">&quot;&quot;&quot;backwards compatibility; returns the 
        effective_returning collection. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.effective_returning</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">current_executable(self):</span>
        <span class="s2">&quot;&quot;&quot;Return the current 'executable' that is being compiled. 
 
        This is currently the :class:`_sql.Select`, :class:`_sql.Insert`, 
        :class:`_sql.Update`, :class:`_sql.Delete`, 
        :class:`_sql.CompoundSelect` object that is being compiled. 
        Specifically it's assigned to the ``self.stack`` list of elements. 
 
        When a statement like the above is being compiled, it normally 
        is also assigned to the ``.statement`` attribute of the 
        :class:`_sql.Compiler` object.   However, all SQL constructs are 
        ultimately nestable, and this attribute should never be consulted 
        by a ``visit_`` method, as it is not guaranteed to be assigned 
        nor guaranteed to correspond to the current statement being compiled. 
 
        .. versionadded:: 1.3.21 
 
            For compatibility with previous versions, use the following 
            recipe:: 
 
                statement = getattr(self, &quot;current_executable&quot;, False) 
                if statement is False: 
                    statement = self.stack[-1][&quot;selectable&quot;] 
 
            For versions 1.4 and above, ensure only .current_executable 
            is used; the format of &quot;self.stack&quot; may change. 
 
 
        &quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.stack[-</span><span class="s6">1</span><span class="s1">][</span><span class="s4">&quot;selectable&quot;</span><span class="s1">]</span>
        <span class="s3">except </span><span class="s1">IndexError </span><span class="s3">as </span><span class="s1">ie:</span>
            <span class="s3">raise </span><span class="s1">IndexError(</span><span class="s4">&quot;Compiler does not have a stack entry&quot;</span><span class="s1">) </span><span class="s3">from </span><span class="s1">ie</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">prefetch(self):</span>
        <span class="s3">return </span><span class="s1">list(self.insert_prefetch) + list(self.update_prefetch)</span>

    <span class="s1">@util.memoized_property</span>
    <span class="s3">def </span><span class="s1">_global_attributes(self) -&gt; Dict[Any</span><span class="s5">, </span><span class="s1">Any]:</span>
        <span class="s3">return </span><span class="s1">{}</span>

    <span class="s1">@util.memoized_instancemethod</span>
    <span class="s3">def </span><span class="s1">_init_cte_state(self) -&gt; MutableMapping[CTE</span><span class="s5">, </span><span class="s1">str]:</span>
        <span class="s2">&quot;&quot;&quot;Initialize collections related to CTEs only if 
        a CTE is located, to save on the overhead of 
        these collections otherwise. 
 
        &quot;&quot;&quot;</span>
        <span class="s0"># collect CTEs to tack on top of a SELECT</span>
        <span class="s0"># To store the query to print - Dict[cte, text_query]</span>
        <span class="s1">ctes: MutableMapping[CTE</span><span class="s5">, </span><span class="s1">str] = util.OrderedDict()</span>
        <span class="s1">self.ctes = ctes</span>

        <span class="s0"># Detect same CTE references - Dict[(level, name), cte]</span>
        <span class="s0"># Level is required for supporting nesting</span>
        <span class="s1">self.ctes_by_level_name = {}</span>

        <span class="s0"># To retrieve key/level in ctes_by_level_name -</span>
        <span class="s0"># Dict[cte_reference, (level, cte_name, cte_opts)]</span>
        <span class="s1">self.level_name_by_cte = {}</span>

        <span class="s1">self.ctes_recursive = </span><span class="s3">False</span>

        <span class="s3">return </span><span class="s1">ctes</span>

    <span class="s1">@contextlib.contextmanager</span>
    <span class="s3">def </span><span class="s1">_nested_result(self):</span>
        <span class="s2">&quot;&quot;&quot;special API to support the use case of 'nested result sets'&quot;&quot;&quot;</span>
        <span class="s1">result_columns</span><span class="s5">, </span><span class="s1">ordered_columns = (</span>
            <span class="s1">self._result_columns</span><span class="s5">,</span>
            <span class="s1">self._ordered_columns</span><span class="s5">,</span>
        <span class="s1">)</span>
        <span class="s1">self._result_columns</span><span class="s5">, </span><span class="s1">self._ordered_columns = []</span><span class="s5">, </span><span class="s3">False</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">self.stack:</span>
                <span class="s1">entry = self.stack[-</span><span class="s6">1</span><span class="s1">]</span>
                <span class="s1">entry[</span><span class="s4">&quot;need_result_map_for_nested&quot;</span><span class="s1">] = </span><span class="s3">True</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">entry = </span><span class="s3">None</span>
            <span class="s3">yield </span><span class="s1">self._result_columns</span><span class="s5">, </span><span class="s1">self._ordered_columns</span>
        <span class="s3">finally</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">entry:</span>
                <span class="s1">entry.pop(</span><span class="s4">&quot;need_result_map_for_nested&quot;</span><span class="s1">)</span>
            <span class="s1">self._result_columns</span><span class="s5">, </span><span class="s1">self._ordered_columns = (</span>
                <span class="s1">result_columns</span><span class="s5">,</span>
                <span class="s1">ordered_columns</span><span class="s5">,</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_process_positional(self):</span>
        <span class="s3">assert not </span><span class="s1">self.positiontup</span>
        <span class="s3">assert </span><span class="s1">self.state </span><span class="s3">is </span><span class="s1">CompilerState.STRING_APPLIED</span>
        <span class="s3">assert not </span><span class="s1">self._numeric_binds</span>

        <span class="s3">if </span><span class="s1">self.dialect.paramstyle == </span><span class="s4">&quot;format&quot;</span><span class="s1">:</span>
            <span class="s1">placeholder = </span><span class="s4">&quot;%s&quot;</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">assert </span><span class="s1">self.dialect.paramstyle == </span><span class="s4">&quot;qmark&quot;</span>
            <span class="s1">placeholder = </span><span class="s4">&quot;?&quot;</span>

        <span class="s1">positions = []</span>

        <span class="s3">def </span><span class="s1">find_position(m: re.Match[str]) -&gt; str:</span>
            <span class="s1">normal_bind = m.group(</span><span class="s6">1</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">normal_bind:</span>
                <span class="s1">positions.append(normal_bind)</span>
                <span class="s3">return </span><span class="s1">placeholder</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># this a post-compile bind</span>
                <span class="s1">positions.append(m.group(</span><span class="s6">2</span><span class="s1">))</span>
                <span class="s3">return </span><span class="s1">m.group(</span><span class="s6">0</span><span class="s1">)</span>

        <span class="s1">self.string = re.sub(</span>
            <span class="s1">self._positional_pattern</span><span class="s5">, </span><span class="s1">find_position</span><span class="s5">, </span><span class="s1">self.string</span>
        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">self.escaped_bind_names:</span>
            <span class="s1">reverse_escape = {v: k </span><span class="s3">for </span><span class="s1">k</span><span class="s5">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">self.escaped_bind_names.items()}</span>
            <span class="s3">assert </span><span class="s1">len(self.escaped_bind_names) == len(reverse_escape)</span>
            <span class="s1">self.positiontup = [</span>
                <span class="s1">reverse_escape.get(name</span><span class="s5">, </span><span class="s1">name) </span><span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">positions</span>
            <span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.positiontup = positions</span>

        <span class="s3">if </span><span class="s1">self._insertmanyvalues:</span>
            <span class="s1">positions = []</span>

            <span class="s1">single_values_expr = re.sub(</span>
                <span class="s1">self._positional_pattern</span><span class="s5">,</span>
                <span class="s1">find_position</span><span class="s5">,</span>
                <span class="s1">self._insertmanyvalues.single_values_expr</span><span class="s5">,</span>
            <span class="s1">)</span>
            <span class="s1">insert_crud_params = [</span>
                <span class="s1">(</span>
                    <span class="s1">v[</span><span class="s6">0</span><span class="s1">]</span><span class="s5">,</span>
                    <span class="s1">v[</span><span class="s6">1</span><span class="s1">]</span><span class="s5">,</span>
                    <span class="s1">re.sub(self._positional_pattern</span><span class="s5">, </span><span class="s1">find_position</span><span class="s5">, </span><span class="s1">v[</span><span class="s6">2</span><span class="s1">])</span><span class="s5">,</span>
                    <span class="s1">v[</span><span class="s6">3</span><span class="s1">]</span><span class="s5">,</span>
                <span class="s1">)</span>
                <span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">self._insertmanyvalues.insert_crud_params</span>
            <span class="s1">]</span>

            <span class="s1">self._insertmanyvalues = self._insertmanyvalues._replace(</span>
                <span class="s1">single_values_expr=single_values_expr</span><span class="s5">,</span>
                <span class="s1">insert_crud_params=insert_crud_params</span><span class="s5">,</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_process_numeric(self):</span>
        <span class="s3">assert </span><span class="s1">self._numeric_binds</span>
        <span class="s3">assert </span><span class="s1">self.state </span><span class="s3">is </span><span class="s1">CompilerState.STRING_APPLIED</span>

        <span class="s1">num = </span><span class="s6">1</span>
        <span class="s1">param_pos: Dict[str</span><span class="s5">, </span><span class="s1">str] = {}</span>
        <span class="s1">order: Iterable[str]</span>
        <span class="s3">if </span><span class="s1">self._insertmanyvalues </span><span class="s3">and </span><span class="s1">self._values_bindparam </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s0"># bindparams that are not in values are always placed first.</span>
            <span class="s0"># this avoids the need of changing them when using executemany</span>
            <span class="s0"># values () ()</span>
            <span class="s1">order = itertools.chain(</span>
                <span class="s1">(</span>
                    <span class="s1">name</span>
                    <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">self.bind_names.values()</span>
                    <span class="s3">if </span><span class="s1">name </span><span class="s3">not in </span><span class="s1">self._values_bindparam</span>
                <span class="s1">)</span><span class="s5">,</span>
                <span class="s1">self.bind_names.values()</span><span class="s5">,</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">order = self.bind_names.values()</span>

        <span class="s3">for </span><span class="s1">bind_name </span><span class="s3">in </span><span class="s1">order:</span>
            <span class="s3">if </span><span class="s1">bind_name </span><span class="s3">in </span><span class="s1">param_pos:</span>
                <span class="s3">continue</span>
            <span class="s1">bind = self.binds[bind_name]</span>
            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">bind </span><span class="s3">in </span><span class="s1">self.post_compile_params</span>
                <span class="s3">or </span><span class="s1">bind </span><span class="s3">in </span><span class="s1">self.literal_execute_params</span>
            <span class="s1">):</span>
                <span class="s0"># set to None to just mark the in positiontup, it will not</span>
                <span class="s0"># be replaced below.</span>
                <span class="s1">param_pos[bind_name] = </span><span class="s3">None  </span><span class="s0"># type: ignore</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">ph = </span><span class="s4">f&quot;</span><span class="s7">{</span><span class="s1">self._numeric_binds_identifier_char</span><span class="s7">}{</span><span class="s1">num</span><span class="s7">}</span><span class="s4">&quot;</span>
                <span class="s1">num += </span><span class="s6">1</span>
                <span class="s1">param_pos[bind_name] = ph</span>

        <span class="s1">self.next_numeric_pos = num</span>

        <span class="s1">self.positiontup = list(param_pos)</span>
        <span class="s3">if </span><span class="s1">self.escaped_bind_names:</span>
            <span class="s1">len_before = len(param_pos)</span>
            <span class="s1">param_pos = {</span>
                <span class="s1">self.escaped_bind_names.get(name</span><span class="s5">, </span><span class="s1">name): pos</span>
                <span class="s3">for </span><span class="s1">name</span><span class="s5">, </span><span class="s1">pos </span><span class="s3">in </span><span class="s1">param_pos.items()</span>
            <span class="s1">}</span>
            <span class="s3">assert </span><span class="s1">len(param_pos) == len_before</span>

        <span class="s0"># Can't use format here since % chars are not escaped.</span>
        <span class="s1">self.string = self._pyformat_pattern.sub(</span>
            <span class="s3">lambda </span><span class="s1">m: param_pos[m.group(</span><span class="s6">1</span><span class="s1">)]</span><span class="s5">, </span><span class="s1">self.string</span>
        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">self._insertmanyvalues:</span>
            <span class="s1">single_values_expr = (</span>
                <span class="s0"># format is ok here since single_values_expr includes only</span>
                <span class="s0"># place-holders</span>
                <span class="s1">self._insertmanyvalues.single_values_expr</span>
                <span class="s1">% param_pos</span>
            <span class="s1">)</span>
            <span class="s1">insert_crud_params = [</span>
                <span class="s1">(v[</span><span class="s6">0</span><span class="s1">]</span><span class="s5">, </span><span class="s1">v[</span><span class="s6">1</span><span class="s1">]</span><span class="s5">, </span><span class="s4">&quot;%s&quot;</span><span class="s5">, </span><span class="s1">v[</span><span class="s6">3</span><span class="s1">])</span>
                <span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">self._insertmanyvalues.insert_crud_params</span>
            <span class="s1">]</span>

            <span class="s1">self._insertmanyvalues = self._insertmanyvalues._replace(</span>
                <span class="s0"># This has the numbers (:1, :2)</span>
                <span class="s1">single_values_expr=single_values_expr</span><span class="s5">,</span>
                <span class="s0"># The single binds are instead %s so they can be formatted</span>
                <span class="s1">insert_crud_params=insert_crud_params</span><span class="s5">,</span>
            <span class="s1">)</span>

    <span class="s1">@util.memoized_property</span>
    <span class="s3">def </span><span class="s1">_bind_processors(</span>
        <span class="s1">self</span><span class="s5">,</span>
    <span class="s1">) -&gt; MutableMapping[</span>
        <span class="s1">str</span><span class="s5">, </span><span class="s1">Union[_BindProcessorType[Any]</span><span class="s5">, </span><span class="s1">Sequence[_BindProcessorType[Any]]]</span>
    <span class="s1">]:</span>
        <span class="s0"># mypy is not able to see the two value types as the above Union,</span>
        <span class="s0"># it just sees &quot;object&quot;.  don't know how to resolve</span>
        <span class="s3">return </span><span class="s1">{</span>
            <span class="s1">key: value  </span><span class="s0"># type: ignore</span>
            <span class="s3">for </span><span class="s1">key</span><span class="s5">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">(</span>
                <span class="s1">(</span>
                    <span class="s1">self.bind_names[bindparam]</span><span class="s5">,</span>
                    <span class="s1">(</span>
                        <span class="s1">bindparam.type._cached_bind_processor(self.dialect)</span>
                        <span class="s3">if not </span><span class="s1">bindparam.type._is_tuple_type</span>
                        <span class="s3">else </span><span class="s1">tuple(</span>
                            <span class="s1">elem_type._cached_bind_processor(self.dialect)</span>
                            <span class="s3">for </span><span class="s1">elem_type </span><span class="s3">in </span><span class="s1">cast(</span>
                                <span class="s1">TupleType</span><span class="s5">, </span><span class="s1">bindparam.type</span>
                            <span class="s1">).types</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span><span class="s5">,</span>
                <span class="s1">)</span>
                <span class="s3">for </span><span class="s1">bindparam </span><span class="s3">in </span><span class="s1">self.bind_names</span>
            <span class="s1">)</span>
            <span class="s3">if </span><span class="s1">value </span><span class="s3">is not None</span>
        <span class="s1">}</span>

    <span class="s3">def </span><span class="s1">is_subquery(self):</span>
        <span class="s3">return </span><span class="s1">len(self.stack) &gt; </span><span class="s6">1</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">sql_compiler(self):</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">construct_expanded_state(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">params: Optional[_CoreSingleExecuteParams] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">escape_names: bool = </span><span class="s3">True</span><span class="s5">,</span>
    <span class="s1">) -&gt; ExpandedState:</span>
        <span class="s2">&quot;&quot;&quot;Return a new :class:`.ExpandedState` for a given parameter set. 
 
        For queries that use &quot;expanding&quot; or other late-rendered parameters, 
        this method will provide for both the finalized SQL string as well 
        as the parameters that would be used for a particular parameter set. 
 
        .. versionadded:: 2.0.0rc1 
 
        &quot;&quot;&quot;</span>
        <span class="s1">parameters = self.construct_params(</span>
            <span class="s1">params</span><span class="s5">,</span>
            <span class="s1">escape_names=escape_names</span><span class="s5">,</span>
            <span class="s1">_no_postcompile=</span><span class="s3">True</span><span class="s5">,</span>
        <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self._process_parameters_for_postcompile(</span>
            <span class="s1">parameters</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">construct_params(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">params: Optional[_CoreSingleExecuteParams] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">extracted_parameters: Optional[Sequence[BindParameter[Any]]] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">escape_names: bool = </span><span class="s3">True</span><span class="s5">,</span>
        <span class="s1">_group_number: Optional[int] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">_check: bool = </span><span class="s3">True</span><span class="s5">,</span>
        <span class="s1">_no_postcompile: bool = </span><span class="s3">False</span><span class="s5">,</span>
    <span class="s1">) -&gt; _MutableCoreSingleExecuteParams:</span>
        <span class="s2">&quot;&quot;&quot;return a dictionary of bind parameter keys and values&quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">self._render_postcompile </span><span class="s3">and not </span><span class="s1">_no_postcompile:</span>
            <span class="s3">assert </span><span class="s1">self._post_compile_expanded_state </span><span class="s3">is not None</span>
            <span class="s3">if not </span><span class="s1">params:</span>
                <span class="s3">return </span><span class="s1">dict(self._post_compile_expanded_state.parameters)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">exc.InvalidRequestError(</span>
                    <span class="s4">&quot;can't construct new parameters when render_postcompile &quot;</span>
                    <span class="s4">&quot;is used; the statement is hard-linked to the original &quot;</span>
                    <span class="s4">&quot;parameters.  Use construct_expanded_state to generate a &quot;</span>
                    <span class="s4">&quot;new statement and parameters.&quot;</span>
                <span class="s1">)</span>

        <span class="s1">has_escaped_names = escape_names </span><span class="s3">and </span><span class="s1">bool(self.escaped_bind_names)</span>

        <span class="s3">if </span><span class="s1">extracted_parameters:</span>
            <span class="s0"># related the bound parameters collected in the original cache key</span>
            <span class="s0"># to those collected in the incoming cache key.  They will not have</span>
            <span class="s0"># matching names but they will line up positionally in the same</span>
            <span class="s0"># way.   The parameters present in self.bind_names may be clones of</span>
            <span class="s0"># these original cache key params in the case of DML but the .key</span>
            <span class="s0"># will be guaranteed to match.</span>
            <span class="s3">if </span><span class="s1">self.cache_key </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
                    <span class="s4">&quot;This compiled object has no original cache key; &quot;</span>
                    <span class="s4">&quot;can't pass extracted_parameters to construct_params&quot;</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">orig_extracted = self.cache_key[</span><span class="s6">1</span><span class="s1">]</span>

            <span class="s1">ckbm_tuple = self._cache_key_bind_match</span>
            <span class="s3">assert </span><span class="s1">ckbm_tuple </span><span class="s3">is not None</span>
            <span class="s1">ckbm</span><span class="s5">, </span><span class="s1">_ = ckbm_tuple</span>
            <span class="s1">resolved_extracted = {</span>
                <span class="s1">bind: extracted</span>
                <span class="s3">for </span><span class="s1">b</span><span class="s5">, </span><span class="s1">extracted </span><span class="s3">in </span><span class="s1">zip(orig_extracted</span><span class="s5">, </span><span class="s1">extracted_parameters)</span>
                <span class="s3">for </span><span class="s1">bind </span><span class="s3">in </span><span class="s1">ckbm[b]</span>
            <span class="s1">}</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">resolved_extracted = </span><span class="s3">None</span>

        <span class="s3">if </span><span class="s1">params:</span>
            <span class="s1">pd = {}</span>
            <span class="s3">for </span><span class="s1">bindparam</span><span class="s5">, </span><span class="s1">name </span><span class="s3">in </span><span class="s1">self.bind_names.items():</span>
                <span class="s1">escaped_name = (</span>
                    <span class="s1">self.escaped_bind_names.get(name</span><span class="s5">, </span><span class="s1">name)</span>
                    <span class="s3">if </span><span class="s1">has_escaped_names</span>
                    <span class="s3">else </span><span class="s1">name</span>
                <span class="s1">)</span>

                <span class="s3">if </span><span class="s1">bindparam.key </span><span class="s3">in </span><span class="s1">params:</span>
                    <span class="s1">pd[escaped_name] = params[bindparam.key]</span>
                <span class="s3">elif </span><span class="s1">name </span><span class="s3">in </span><span class="s1">params:</span>
                    <span class="s1">pd[escaped_name] = params[name]</span>

                <span class="s3">elif </span><span class="s1">_check </span><span class="s3">and </span><span class="s1">bindparam.required:</span>
                    <span class="s3">if </span><span class="s1">_group_number:</span>
                        <span class="s3">raise </span><span class="s1">exc.InvalidRequestError(</span>
                            <span class="s4">&quot;A value is required for bind parameter %r, &quot;</span>
                            <span class="s4">&quot;in parameter group %d&quot;</span>
                            <span class="s1">% (bindparam.key</span><span class="s5">, </span><span class="s1">_group_number)</span><span class="s5">,</span>
                            <span class="s1">code=</span><span class="s4">&quot;cd3x&quot;</span><span class="s5">,</span>
                        <span class="s1">)</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s3">raise </span><span class="s1">exc.InvalidRequestError(</span>
                            <span class="s4">&quot;A value is required for bind parameter %r&quot;</span>
                            <span class="s1">% bindparam.key</span><span class="s5">,</span>
                            <span class="s1">code=</span><span class="s4">&quot;cd3x&quot;</span><span class="s5">,</span>
                        <span class="s1">)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">if </span><span class="s1">resolved_extracted:</span>
                        <span class="s1">value_param = resolved_extracted.get(</span>
                            <span class="s1">bindparam</span><span class="s5">, </span><span class="s1">bindparam</span>
                        <span class="s1">)</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">value_param = bindparam</span>

                    <span class="s3">if </span><span class="s1">bindparam.callable:</span>
                        <span class="s1">pd[escaped_name] = value_param.effective_value</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">pd[escaped_name] = value_param.value</span>
            <span class="s3">return </span><span class="s1">pd</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">pd = {}</span>
            <span class="s3">for </span><span class="s1">bindparam</span><span class="s5">, </span><span class="s1">name </span><span class="s3">in </span><span class="s1">self.bind_names.items():</span>
                <span class="s1">escaped_name = (</span>
                    <span class="s1">self.escaped_bind_names.get(name</span><span class="s5">, </span><span class="s1">name)</span>
                    <span class="s3">if </span><span class="s1">has_escaped_names</span>
                    <span class="s3">else </span><span class="s1">name</span>
                <span class="s1">)</span>

                <span class="s3">if </span><span class="s1">_check </span><span class="s3">and </span><span class="s1">bindparam.required:</span>
                    <span class="s3">if </span><span class="s1">_group_number:</span>
                        <span class="s3">raise </span><span class="s1">exc.InvalidRequestError(</span>
                            <span class="s4">&quot;A value is required for bind parameter %r, &quot;</span>
                            <span class="s4">&quot;in parameter group %d&quot;</span>
                            <span class="s1">% (bindparam.key</span><span class="s5">, </span><span class="s1">_group_number)</span><span class="s5">,</span>
                            <span class="s1">code=</span><span class="s4">&quot;cd3x&quot;</span><span class="s5">,</span>
                        <span class="s1">)</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s3">raise </span><span class="s1">exc.InvalidRequestError(</span>
                            <span class="s4">&quot;A value is required for bind parameter %r&quot;</span>
                            <span class="s1">% bindparam.key</span><span class="s5">,</span>
                            <span class="s1">code=</span><span class="s4">&quot;cd3x&quot;</span><span class="s5">,</span>
                        <span class="s1">)</span>

                <span class="s3">if </span><span class="s1">resolved_extracted:</span>
                    <span class="s1">value_param = resolved_extracted.get(bindparam</span><span class="s5">, </span><span class="s1">bindparam)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">value_param = bindparam</span>

                <span class="s3">if </span><span class="s1">bindparam.callable:</span>
                    <span class="s1">pd[escaped_name] = value_param.effective_value</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">pd[escaped_name] = value_param.value</span>

            <span class="s3">return </span><span class="s1">pd</span>

    <span class="s1">@util.memoized_instancemethod</span>
    <span class="s3">def </span><span class="s1">_get_set_input_sizes_lookup(self):</span>
        <span class="s1">dialect = self.dialect</span>

        <span class="s1">include_types = dialect.include_set_input_sizes</span>
        <span class="s1">exclude_types = dialect.exclude_set_input_sizes</span>

        <span class="s1">dbapi = dialect.dbapi</span>

        <span class="s3">def </span><span class="s1">lookup_type(typ):</span>
            <span class="s1">dbtype = typ._unwrapped_dialect_impl(dialect).get_dbapi_type(dbapi)</span>

            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">dbtype </span><span class="s3">is not None</span>
                <span class="s3">and </span><span class="s1">(exclude_types </span><span class="s3">is None or </span><span class="s1">dbtype </span><span class="s3">not in </span><span class="s1">exclude_types)</span>
                <span class="s3">and </span><span class="s1">(include_types </span><span class="s3">is None or </span><span class="s1">dbtype </span><span class="s3">in </span><span class="s1">include_types)</span>
            <span class="s1">):</span>
                <span class="s3">return </span><span class="s1">dbtype</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return None</span>

        <span class="s1">inputsizes = {}</span>

        <span class="s1">literal_execute_params = self.literal_execute_params</span>

        <span class="s3">for </span><span class="s1">bindparam </span><span class="s3">in </span><span class="s1">self.bind_names:</span>
            <span class="s3">if </span><span class="s1">bindparam </span><span class="s3">in </span><span class="s1">literal_execute_params:</span>
                <span class="s3">continue</span>

            <span class="s3">if </span><span class="s1">bindparam.type._is_tuple_type:</span>
                <span class="s1">inputsizes[bindparam] = [</span>
                    <span class="s1">lookup_type(typ)</span>
                    <span class="s3">for </span><span class="s1">typ </span><span class="s3">in </span><span class="s1">cast(TupleType</span><span class="s5">, </span><span class="s1">bindparam.type).types</span>
                <span class="s1">]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">inputsizes[bindparam] = lookup_type(bindparam.type)</span>

        <span class="s3">return </span><span class="s1">inputsizes</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">params(self):</span>
        <span class="s2">&quot;&quot;&quot;Return the bind param dictionary embedded into this 
        compiled object, for those values that are present. 
 
        .. seealso:: 
 
            :ref:`faq_sql_expression_string` - includes a usage example for 
            debugging use cases. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.construct_params(_check=</span><span class="s3">False</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_process_parameters_for_postcompile(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">parameters: _MutableCoreSingleExecuteParams</span><span class="s5">,</span>
        <span class="s1">_populate_self: bool = </span><span class="s3">False</span><span class="s5">,</span>
    <span class="s1">) -&gt; ExpandedState:</span>
        <span class="s2">&quot;&quot;&quot;handle special post compile parameters. 
 
        These include: 
 
        * &quot;expanding&quot; parameters -typically IN tuples that are rendered 
          on a per-parameter basis for an otherwise fixed SQL statement string. 
 
        * literal_binds compiled with the literal_execute flag.  Used for 
          things like SQL Server &quot;TOP N&quot; where the driver does not accommodate 
          N as a bound parameter. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">expanded_parameters = {}</span>
        <span class="s1">new_positiontup: Optional[List[str]]</span>

        <span class="s1">pre_expanded_string = self._pre_expanded_string</span>
        <span class="s3">if </span><span class="s1">pre_expanded_string </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">pre_expanded_string = self.string</span>

        <span class="s3">if </span><span class="s1">self.positional:</span>
            <span class="s1">new_positiontup = []</span>

            <span class="s1">pre_expanded_positiontup = self._pre_expanded_positiontup</span>
            <span class="s3">if </span><span class="s1">pre_expanded_positiontup </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">pre_expanded_positiontup = self.positiontup</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">new_positiontup = pre_expanded_positiontup = </span><span class="s3">None</span>

        <span class="s1">processors = self._bind_processors</span>
        <span class="s1">single_processors = cast(</span>
            <span class="s4">&quot;Mapping[str, _BindProcessorType[Any]]&quot;</span><span class="s5">, </span><span class="s1">processors</span>
        <span class="s1">)</span>
        <span class="s1">tuple_processors = cast(</span>
            <span class="s4">&quot;Mapping[str, Sequence[_BindProcessorType[Any]]]&quot;</span><span class="s5">, </span><span class="s1">processors</span>
        <span class="s1">)</span>

        <span class="s1">new_processors: Dict[str</span><span class="s5">, </span><span class="s1">_BindProcessorType[Any]] = {}</span>

        <span class="s1">replacement_expressions: Dict[str</span><span class="s5">, </span><span class="s1">Any] = {}</span>
        <span class="s1">to_update_sets: Dict[str</span><span class="s5">, </span><span class="s1">Any] = {}</span>

        <span class="s0"># notes:</span>
        <span class="s0"># *unescaped* parameter names in:</span>
        <span class="s0"># self.bind_names, self.binds, self._bind_processors, self.positiontup</span>
        <span class="s0">#</span>
        <span class="s0"># *escaped* parameter names in:</span>
        <span class="s0"># construct_params(), replacement_expressions</span>

        <span class="s1">numeric_positiontup: Optional[List[str]] = </span><span class="s3">None</span>

        <span class="s3">if </span><span class="s1">self.positional </span><span class="s3">and </span><span class="s1">pre_expanded_positiontup </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">names: Iterable[str] = pre_expanded_positiontup</span>
            <span class="s3">if </span><span class="s1">self._numeric_binds:</span>
                <span class="s1">numeric_positiontup = []</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">names = self.bind_names.values()</span>

        <span class="s1">ebn = self.escaped_bind_names</span>
        <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">names:</span>
            <span class="s1">escaped_name = ebn.get(name</span><span class="s5">, </span><span class="s1">name) </span><span class="s3">if </span><span class="s1">ebn </span><span class="s3">else </span><span class="s1">name</span>
            <span class="s1">parameter = self.binds[name]</span>

            <span class="s3">if </span><span class="s1">parameter </span><span class="s3">in </span><span class="s1">self.literal_execute_params:</span>
                <span class="s3">if </span><span class="s1">escaped_name </span><span class="s3">not in </span><span class="s1">replacement_expressions:</span>
                    <span class="s1">replacement_expressions[escaped_name] = (</span>
                        <span class="s1">self.render_literal_bindparam(</span>
                            <span class="s1">parameter</span><span class="s5">,</span>
                            <span class="s1">render_literal_value=parameters.pop(escaped_name)</span><span class="s5">,</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>
                <span class="s3">continue</span>

            <span class="s3">if </span><span class="s1">parameter </span><span class="s3">in </span><span class="s1">self.post_compile_params:</span>
                <span class="s3">if </span><span class="s1">escaped_name </span><span class="s3">in </span><span class="s1">replacement_expressions:</span>
                    <span class="s1">to_update = to_update_sets[escaped_name]</span>
                    <span class="s1">values = </span><span class="s3">None</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s0"># we are removing the parameter from parameters</span>
                    <span class="s0"># because it is a list value, which is not expected by</span>
                    <span class="s0"># TypeEngine objects that would otherwise be asked to</span>
                    <span class="s0"># process it. the single name is being replaced with</span>
                    <span class="s0"># individual numbered parameters for each value in the</span>
                    <span class="s0"># param.</span>
                    <span class="s0">#</span>
                    <span class="s0"># note we are also inserting *escaped* parameter names</span>
                    <span class="s0"># into the given dictionary.   default dialect will</span>
                    <span class="s0"># use these param names directly as they will not be</span>
                    <span class="s0"># in the escaped_bind_names dictionary.</span>
                    <span class="s1">values = parameters.pop(name)</span>

                    <span class="s1">leep_res = self._literal_execute_expanding_parameter(</span>
                        <span class="s1">escaped_name</span><span class="s5">, </span><span class="s1">parameter</span><span class="s5">, </span><span class="s1">values</span>
                    <span class="s1">)</span>
                    <span class="s1">(to_update</span><span class="s5">, </span><span class="s1">replacement_expr) = leep_res</span>

                    <span class="s1">to_update_sets[escaped_name] = to_update</span>
                    <span class="s1">replacement_expressions[escaped_name] = replacement_expr</span>

                <span class="s3">if not </span><span class="s1">parameter.literal_execute:</span>
                    <span class="s1">parameters.update(to_update)</span>
                    <span class="s3">if </span><span class="s1">parameter.type._is_tuple_type:</span>
                        <span class="s3">assert </span><span class="s1">values </span><span class="s3">is not None</span>
                        <span class="s1">new_processors.update(</span>
                            <span class="s1">(</span>
                                <span class="s4">&quot;%s_%s_%s&quot; </span><span class="s1">% (name</span><span class="s5">, </span><span class="s1">i</span><span class="s5">, </span><span class="s1">j)</span><span class="s5">,</span>
                                <span class="s1">tuple_processors[name][j - </span><span class="s6">1</span><span class="s1">]</span><span class="s5">,</span>
                            <span class="s1">)</span>
                            <span class="s3">for </span><span class="s1">i</span><span class="s5">, </span><span class="s1">tuple_element </span><span class="s3">in </span><span class="s1">enumerate(values</span><span class="s5">, </span><span class="s6">1</span><span class="s1">)</span>
                            <span class="s3">for </span><span class="s1">j</span><span class="s5">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">enumerate(tuple_element</span><span class="s5">, </span><span class="s6">1</span><span class="s1">)</span>
                            <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">tuple_processors</span>
                            <span class="s3">and </span><span class="s1">tuple_processors[name][j - </span><span class="s6">1</span><span class="s1">] </span><span class="s3">is not None</span>
                        <span class="s1">)</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">new_processors.update(</span>
                            <span class="s1">(key</span><span class="s5">, </span><span class="s1">single_processors[name])</span>
                            <span class="s3">for </span><span class="s1">key</span><span class="s5">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">to_update</span>
                            <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">single_processors</span>
                        <span class="s1">)</span>
                    <span class="s3">if </span><span class="s1">numeric_positiontup </span><span class="s3">is not None</span><span class="s1">:</span>
                        <span class="s1">numeric_positiontup.extend(</span>
                            <span class="s1">name </span><span class="s3">for </span><span class="s1">name</span><span class="s5">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">to_update</span>
                        <span class="s1">)</span>
                    <span class="s3">elif </span><span class="s1">new_positiontup </span><span class="s3">is not None</span><span class="s1">:</span>
                        <span class="s0"># to_update has escaped names, but that's ok since</span>
                        <span class="s0"># these are new names, that aren't in the</span>
                        <span class="s0"># escaped_bind_names dict.</span>
                        <span class="s1">new_positiontup.extend(name </span><span class="s3">for </span><span class="s1">name</span><span class="s5">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">to_update)</span>
                    <span class="s1">expanded_parameters[name] = [</span>
                        <span class="s1">expand_key </span><span class="s3">for </span><span class="s1">expand_key</span><span class="s5">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">to_update</span>
                    <span class="s1">]</span>
            <span class="s3">elif </span><span class="s1">new_positiontup </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">new_positiontup.append(name)</span>

        <span class="s3">def </span><span class="s1">process_expanding(m):</span>
            <span class="s1">key = m.group(</span><span class="s6">1</span><span class="s1">)</span>
            <span class="s1">expr = replacement_expressions[key]</span>

            <span class="s0"># if POSTCOMPILE included a bind_expression, render that</span>
            <span class="s0"># around each element</span>
            <span class="s3">if </span><span class="s1">m.group(</span><span class="s6">2</span><span class="s1">):</span>
                <span class="s1">tok = m.group(</span><span class="s6">2</span><span class="s1">).split(</span><span class="s4">&quot;~~&quot;</span><span class="s1">)</span>
                <span class="s1">be_left</span><span class="s5">, </span><span class="s1">be_right = tok[</span><span class="s6">1</span><span class="s1">]</span><span class="s5">, </span><span class="s1">tok[</span><span class="s6">3</span><span class="s1">]</span>
                <span class="s1">expr = </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
                    <span class="s4">&quot;%s%s%s&quot; </span><span class="s1">% (be_left</span><span class="s5">, </span><span class="s1">exp</span><span class="s5">, </span><span class="s1">be_right)</span>
                    <span class="s3">for </span><span class="s1">exp </span><span class="s3">in </span><span class="s1">expr.split(</span><span class="s4">&quot;, &quot;</span><span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s3">return </span><span class="s1">expr</span>

        <span class="s1">statement = re.sub(</span>
            <span class="s1">self._post_compile_pattern</span><span class="s5">, </span><span class="s1">process_expanding</span><span class="s5">, </span><span class="s1">pre_expanded_string</span>
        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">numeric_positiontup </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">assert </span><span class="s1">new_positiontup </span><span class="s3">is not None</span>
            <span class="s1">param_pos = {</span>
                <span class="s1">key: </span><span class="s4">f&quot;</span><span class="s7">{</span><span class="s1">self._numeric_binds_identifier_char</span><span class="s7">}{</span><span class="s1">num</span><span class="s7">}</span><span class="s4">&quot;</span>
                <span class="s3">for </span><span class="s1">num</span><span class="s5">, </span><span class="s1">key </span><span class="s3">in </span><span class="s1">enumerate(</span>
                    <span class="s1">numeric_positiontup</span><span class="s5">, </span><span class="s1">self.next_numeric_pos</span>
                <span class="s1">)</span>
            <span class="s1">}</span>
            <span class="s0"># Can't use format here since % chars are not escaped.</span>
            <span class="s1">statement = self._pyformat_pattern.sub(</span>
                <span class="s3">lambda </span><span class="s1">m: param_pos[m.group(</span><span class="s6">1</span><span class="s1">)]</span><span class="s5">, </span><span class="s1">statement</span>
            <span class="s1">)</span>
            <span class="s1">new_positiontup.extend(numeric_positiontup)</span>

        <span class="s1">expanded_state = ExpandedState(</span>
            <span class="s1">statement</span><span class="s5">,</span>
            <span class="s1">parameters</span><span class="s5">,</span>
            <span class="s1">new_processors</span><span class="s5">,</span>
            <span class="s1">new_positiontup</span><span class="s5">,</span>
            <span class="s1">expanded_parameters</span><span class="s5">,</span>
        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">_populate_self:</span>
            <span class="s0"># this is for the &quot;render_postcompile&quot; flag, which is not</span>
            <span class="s0"># otherwise used internally and is for end-user debugging and</span>
            <span class="s0"># special use cases.</span>
            <span class="s1">self._pre_expanded_string = pre_expanded_string</span>
            <span class="s1">self._pre_expanded_positiontup = pre_expanded_positiontup</span>
            <span class="s1">self.string = expanded_state.statement</span>
            <span class="s1">self.positiontup = (</span>
                <span class="s1">list(expanded_state.positiontup </span><span class="s3">or </span><span class="s1">())</span>
                <span class="s3">if </span><span class="s1">self.positional</span>
                <span class="s3">else None</span>
            <span class="s1">)</span>
            <span class="s1">self._post_compile_expanded_state = expanded_state</span>

        <span class="s3">return </span><span class="s1">expanded_state</span>

    <span class="s1">@util.preload_module(</span><span class="s4">&quot;sqlalchemy.engine.cursor&quot;</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">_create_result_map(self):</span>
        <span class="s2">&quot;&quot;&quot;utility method used for unit tests only.&quot;&quot;&quot;</span>
        <span class="s1">cursor = util.preloaded.engine_cursor</span>
        <span class="s3">return </span><span class="s1">cursor.CursorResultMetaData._create_description_match_map(</span>
            <span class="s1">self._result_columns</span>
        <span class="s1">)</span>

    <span class="s0"># assigned by crud.py for insert/update statements</span>
    <span class="s1">_get_bind_name_for_col: _BindNameForColProtocol</span>

    <span class="s1">@util.memoized_property</span>
    <span class="s3">def </span><span class="s1">_within_exec_param_key_getter(self) -&gt; Callable[[Any]</span><span class="s5">, </span><span class="s1">str]:</span>
        <span class="s1">getter = self._get_bind_name_for_col</span>
        <span class="s3">return </span><span class="s1">getter</span>

    <span class="s1">@util.memoized_property</span>
    <span class="s1">@util.preload_module(</span><span class="s4">&quot;sqlalchemy.engine.result&quot;</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">_inserted_primary_key_from_lastrowid_getter(self):</span>
        <span class="s1">result = util.preloaded.engine_result</span>

        <span class="s1">param_key_getter = self._within_exec_param_key_getter</span>

        <span class="s3">assert </span><span class="s1">self.compile_state </span><span class="s3">is not None</span>
        <span class="s1">statement = self.compile_state.statement</span>

        <span class="s3">if </span><span class="s1">TYPE_CHECKING:</span>
            <span class="s3">assert </span><span class="s1">isinstance(statement</span><span class="s5">, </span><span class="s1">Insert)</span>

        <span class="s1">table = statement.table</span>

        <span class="s1">getters = [</span>
            <span class="s1">(operator.methodcaller(</span><span class="s4">&quot;get&quot;</span><span class="s5">, </span><span class="s1">param_key_getter(col)</span><span class="s5">, </span><span class="s3">None</span><span class="s1">)</span><span class="s5">, </span><span class="s1">col)</span>
            <span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">table.primary_key</span>
        <span class="s1">]</span>

        <span class="s1">autoinc_getter = </span><span class="s3">None</span>
        <span class="s1">autoinc_col = table._autoincrement_column</span>
        <span class="s3">if </span><span class="s1">autoinc_col </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s0"># apply type post processors to the lastrowid</span>
            <span class="s1">lastrowid_processor = autoinc_col.type._cached_result_processor(</span>
                <span class="s1">self.dialect</span><span class="s5">, </span><span class="s3">None</span>
            <span class="s1">)</span>
            <span class="s1">autoinc_key = param_key_getter(autoinc_col)</span>

            <span class="s0"># if a bind value is present for the autoincrement column</span>
            <span class="s0"># in the parameters, we need to do the logic dictated by</span>
            <span class="s0"># #7998; honor a non-None user-passed parameter over lastrowid.</span>
            <span class="s0"># previously in the 1.4 series we weren't fetching lastrowid</span>
            <span class="s0"># at all if the key were present in the parameters</span>
            <span class="s3">if </span><span class="s1">autoinc_key </span><span class="s3">in </span><span class="s1">self.binds:</span>

                <span class="s3">def </span><span class="s1">_autoinc_getter(lastrowid</span><span class="s5">, </span><span class="s1">parameters):</span>
                    <span class="s1">param_value = parameters.get(autoinc_key</span><span class="s5">, </span><span class="s1">lastrowid)</span>
                    <span class="s3">if </span><span class="s1">param_value </span><span class="s3">is not None</span><span class="s1">:</span>
                        <span class="s0"># they supplied non-None parameter, use that.</span>
                        <span class="s0"># SQLite at least is observed to return the wrong</span>
                        <span class="s0"># cursor.lastrowid for INSERT..ON CONFLICT so it</span>
                        <span class="s0"># can't be used in all cases</span>
                        <span class="s3">return </span><span class="s1">param_value</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s0"># use lastrowid</span>
                        <span class="s3">return </span><span class="s1">lastrowid</span>

                <span class="s0"># work around mypy https://github.com/python/mypy/issues/14027</span>
                <span class="s1">autoinc_getter = _autoinc_getter</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">lastrowid_processor = </span><span class="s3">None</span>

        <span class="s1">row_fn = result.result_tuple([col.key </span><span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">table.primary_key])</span>

        <span class="s3">def </span><span class="s1">get(lastrowid</span><span class="s5">, </span><span class="s1">parameters):</span>
            <span class="s2">&quot;&quot;&quot;given cursor.lastrowid value and the parameters used for INSERT, 
            return a &quot;row&quot; that represents the primary key, either by 
            using the &quot;lastrowid&quot; or by extracting values from the parameters 
            that were sent along with the INSERT. 
 
            &quot;&quot;&quot;</span>
            <span class="s3">if </span><span class="s1">lastrowid_processor </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">lastrowid = lastrowid_processor(lastrowid)</span>

            <span class="s3">if </span><span class="s1">lastrowid </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">row_fn(getter(parameters) </span><span class="s3">for </span><span class="s1">getter</span><span class="s5">, </span><span class="s1">col </span><span class="s3">in </span><span class="s1">getters)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">row_fn(</span>
                    <span class="s1">(</span>
                        <span class="s1">(</span>
                            <span class="s1">autoinc_getter(lastrowid</span><span class="s5">, </span><span class="s1">parameters)</span>
                            <span class="s3">if </span><span class="s1">autoinc_getter </span><span class="s3">is not None</span>
                            <span class="s3">else </span><span class="s1">lastrowid</span>
                        <span class="s1">)</span>
                        <span class="s3">if </span><span class="s1">col </span><span class="s3">is </span><span class="s1">autoinc_col</span>
                        <span class="s3">else </span><span class="s1">getter(parameters)</span>
                    <span class="s1">)</span>
                    <span class="s3">for </span><span class="s1">getter</span><span class="s5">, </span><span class="s1">col </span><span class="s3">in </span><span class="s1">getters</span>
                <span class="s1">)</span>

        <span class="s3">return </span><span class="s1">get</span>

    <span class="s1">@util.memoized_property</span>
    <span class="s1">@util.preload_module(</span><span class="s4">&quot;sqlalchemy.engine.result&quot;</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">_inserted_primary_key_from_returning_getter(self):</span>
        <span class="s3">if </span><span class="s1">typing.TYPE_CHECKING:</span>
            <span class="s3">from </span><span class="s1">..engine </span><span class="s3">import </span><span class="s1">result</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">result = util.preloaded.engine_result</span>

        <span class="s3">assert </span><span class="s1">self.compile_state </span><span class="s3">is not None</span>
        <span class="s1">statement = self.compile_state.statement</span>

        <span class="s3">if </span><span class="s1">TYPE_CHECKING:</span>
            <span class="s3">assert </span><span class="s1">isinstance(statement</span><span class="s5">, </span><span class="s1">Insert)</span>

        <span class="s1">param_key_getter = self._within_exec_param_key_getter</span>
        <span class="s1">table = statement.table</span>

        <span class="s1">returning = self.implicit_returning</span>
        <span class="s3">assert </span><span class="s1">returning </span><span class="s3">is not None</span>
        <span class="s1">ret = {col: idx </span><span class="s3">for </span><span class="s1">idx</span><span class="s5">, </span><span class="s1">col </span><span class="s3">in </span><span class="s1">enumerate(returning)}</span>

        <span class="s1">getters = cast(</span>
            <span class="s4">&quot;List[Tuple[Callable[[Any], Any], bool]]&quot;</span><span class="s5">,</span>
            <span class="s1">[</span>
                <span class="s1">(</span>
                    <span class="s1">(operator.itemgetter(ret[col])</span><span class="s5">, </span><span class="s3">True</span><span class="s1">)</span>
                    <span class="s3">if </span><span class="s1">col </span><span class="s3">in </span><span class="s1">ret</span>
                    <span class="s3">else </span><span class="s1">(</span>
                        <span class="s1">operator.methodcaller(</span>
                            <span class="s4">&quot;get&quot;</span><span class="s5">, </span><span class="s1">param_key_getter(col)</span><span class="s5">, </span><span class="s3">None</span>
                        <span class="s1">)</span><span class="s5">,</span>
                        <span class="s3">False</span><span class="s5">,</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
                <span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">table.primary_key</span>
            <span class="s1">]</span><span class="s5">,</span>
        <span class="s1">)</span>

        <span class="s1">row_fn = result.result_tuple([col.key </span><span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">table.primary_key])</span>

        <span class="s3">def </span><span class="s1">get(row</span><span class="s5">, </span><span class="s1">parameters):</span>
            <span class="s3">return </span><span class="s1">row_fn(</span>
                <span class="s1">getter(row) </span><span class="s3">if </span><span class="s1">use_row </span><span class="s3">else </span><span class="s1">getter(parameters)</span>
                <span class="s3">for </span><span class="s1">getter</span><span class="s5">, </span><span class="s1">use_row </span><span class="s3">in </span><span class="s1">getters</span>
            <span class="s1">)</span>

        <span class="s3">return </span><span class="s1">get</span>

    <span class="s3">def </span><span class="s1">default_from(self):</span>
        <span class="s2">&quot;&quot;&quot;Called when a SELECT statement has no froms, and no FROM clause is 
        to be appended. 
 
        Gives Oracle a chance to tack on a ``FROM DUAL`` to the string output. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s4">&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">visit_override_binds(self</span><span class="s5">, </span><span class="s1">override_binds</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s2">&quot;&quot;&quot;SQL compile the nested element of an _OverrideBinds with 
        bindparams swapped out. 
 
        The _OverrideBinds is not normally expected to be compiled; it 
        is meant to be used when an already cached statement is to be used, 
        the compilation was already performed, and only the bound params should 
        be swapped in at execution time. 
 
        However, there are test cases that exericise this object, and 
        additionally the ORM subquery loader is known to feed in expressions 
        which include this construct into new queries (discovered in #11173), 
        so it has to do the right thing at compile time as well. 
 
        &quot;&quot;&quot;</span>

        <span class="s0"># get SQL text first</span>
        <span class="s1">sqltext = override_binds.element._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kw)</span>

        <span class="s0"># for a test compile that is not for caching, change binds after the</span>
        <span class="s0"># fact.  note that we don't try to</span>
        <span class="s0"># swap the bindparam as we compile, because our element may be</span>
        <span class="s0"># elsewhere in the statement already (e.g. a subquery or perhaps a</span>
        <span class="s0"># CTE) and was already visited / compiled. See</span>
        <span class="s0"># test_relationship_criteria.py -&gt;</span>
        <span class="s0">#    test_selectinload_local_criteria_subquery</span>
        <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">override_binds.translate:</span>
            <span class="s3">if </span><span class="s1">k </span><span class="s3">not in </span><span class="s1">self.binds:</span>
                <span class="s3">continue</span>
            <span class="s1">bp = self.binds[k]</span>

            <span class="s0"># so this would work, just change the value of bp in place.</span>
            <span class="s0"># but we dont want to mutate things outside.</span>
            <span class="s0"># bp.value = override_binds.translate[bp.key]</span>
            <span class="s0"># continue</span>

            <span class="s0"># instead, need to replace bp with new_bp or otherwise accommodate</span>
            <span class="s0"># in all internal collections</span>
            <span class="s1">new_bp = bp._with_value(</span>
                <span class="s1">override_binds.translate[bp.key]</span><span class="s5">,</span>
                <span class="s1">maintain_key=</span><span class="s3">True</span><span class="s5">,</span>
                <span class="s1">required=</span><span class="s3">False</span><span class="s5">,</span>
            <span class="s1">)</span>

            <span class="s1">name = self.bind_names[bp]</span>
            <span class="s1">self.binds[k] = self.binds[name] = new_bp</span>
            <span class="s1">self.bind_names[new_bp] = name</span>
            <span class="s1">self.bind_names.pop(bp</span><span class="s5">, </span><span class="s3">None</span><span class="s1">)</span>

            <span class="s3">if </span><span class="s1">bp </span><span class="s3">in </span><span class="s1">self.post_compile_params:</span>
                <span class="s1">self.post_compile_params |= {new_bp}</span>
            <span class="s3">if </span><span class="s1">bp </span><span class="s3">in </span><span class="s1">self.literal_execute_params:</span>
                <span class="s1">self.literal_execute_params |= {new_bp}</span>

            <span class="s1">ckbm_tuple = self._cache_key_bind_match</span>
            <span class="s3">if </span><span class="s1">ckbm_tuple:</span>
                <span class="s1">ckbm</span><span class="s5">, </span><span class="s1">cksm = ckbm_tuple</span>
                <span class="s3">for </span><span class="s1">bp </span><span class="s3">in </span><span class="s1">bp._cloned_set:</span>
                    <span class="s3">if </span><span class="s1">bp.key </span><span class="s3">in </span><span class="s1">cksm:</span>
                        <span class="s1">cb = cksm[bp.key]</span>
                        <span class="s1">ckbm[cb].append(new_bp)</span>

        <span class="s3">return </span><span class="s1">sqltext</span>

    <span class="s3">def </span><span class="s1">visit_grouping(self</span><span class="s5">, </span><span class="s1">grouping</span><span class="s5">, </span><span class="s1">asfrom=</span><span class="s3">False</span><span class="s5">, </span><span class="s1">**kwargs):</span>
        <span class="s3">return </span><span class="s4">&quot;(&quot; </span><span class="s1">+ grouping.element._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kwargs) + </span><span class="s4">&quot;)&quot;</span>

    <span class="s3">def </span><span class="s1">visit_select_statement_grouping(self</span><span class="s5">, </span><span class="s1">grouping</span><span class="s5">, </span><span class="s1">**kwargs):</span>
        <span class="s3">return </span><span class="s4">&quot;(&quot; </span><span class="s1">+ grouping.element._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kwargs) + </span><span class="s4">&quot;)&quot;</span>

    <span class="s3">def </span><span class="s1">visit_label_reference(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">element</span><span class="s5">, </span><span class="s1">within_columns_clause=</span><span class="s3">False</span><span class="s5">, </span><span class="s1">**kwargs</span>
    <span class="s1">):</span>
        <span class="s3">if </span><span class="s1">self.stack </span><span class="s3">and </span><span class="s1">self.dialect.supports_simple_order_by_label:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">compile_state = cast(</span>
                    <span class="s4">&quot;Union[SelectState, CompoundSelectState]&quot;</span><span class="s5">,</span>
                    <span class="s1">self.stack[-</span><span class="s6">1</span><span class="s1">][</span><span class="s4">&quot;compile_state&quot;</span><span class="s1">]</span><span class="s5">,</span>
                <span class="s1">)</span>
            <span class="s3">except </span><span class="s1">KeyError </span><span class="s3">as </span><span class="s1">ke:</span>
                <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
                    <span class="s4">&quot;Can't resolve label reference for ORDER BY / &quot;</span>
                    <span class="s4">&quot;GROUP BY / DISTINCT etc.&quot;</span>
                <span class="s1">) </span><span class="s3">from </span><span class="s1">ke</span>

            <span class="s1">(</span>
                <span class="s1">with_cols</span><span class="s5">,</span>
                <span class="s1">only_froms</span><span class="s5">,</span>
                <span class="s1">only_cols</span><span class="s5">,</span>
            <span class="s1">) = compile_state._label_resolve_dict</span>
            <span class="s3">if </span><span class="s1">within_columns_clause:</span>
                <span class="s1">resolve_dict = only_froms</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">resolve_dict = only_cols</span>

            <span class="s0"># this can be None in the case that a _label_reference()</span>
            <span class="s0"># were subject to a replacement operation, in which case</span>
            <span class="s0"># the replacement of the Label element may have changed</span>
            <span class="s0"># to something else like a ColumnClause expression.</span>
            <span class="s1">order_by_elem = element.element._order_by_label_element</span>

            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">order_by_elem </span><span class="s3">is not None</span>
                <span class="s3">and </span><span class="s1">order_by_elem.name </span><span class="s3">in </span><span class="s1">resolve_dict</span>
                <span class="s3">and </span><span class="s1">order_by_elem.shares_lineage(</span>
                    <span class="s1">resolve_dict[order_by_elem.name]</span>
                <span class="s1">)</span>
            <span class="s1">):</span>
                <span class="s1">kwargs[</span><span class="s4">&quot;render_label_as_label&quot;</span><span class="s1">] = (</span>
                    <span class="s1">element.element._order_by_label_element</span>
                <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self.process(</span>
            <span class="s1">element.element</span><span class="s5">,</span>
            <span class="s1">within_columns_clause=within_columns_clause</span><span class="s5">,</span>
            <span class="s1">**kwargs</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_textual_label_reference(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">element</span><span class="s5">, </span><span class="s1">within_columns_clause=</span><span class="s3">False</span><span class="s5">, </span><span class="s1">**kwargs</span>
    <span class="s1">):</span>
        <span class="s3">if not </span><span class="s1">self.stack:</span>
            <span class="s0"># compiling the element outside of the context of a SELECT</span>
            <span class="s3">return </span><span class="s1">self.process(element._text_clause)</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">compile_state = cast(</span>
                <span class="s4">&quot;Union[SelectState, CompoundSelectState]&quot;</span><span class="s5">,</span>
                <span class="s1">self.stack[-</span><span class="s6">1</span><span class="s1">][</span><span class="s4">&quot;compile_state&quot;</span><span class="s1">]</span><span class="s5">,</span>
            <span class="s1">)</span>
        <span class="s3">except </span><span class="s1">KeyError </span><span class="s3">as </span><span class="s1">ke:</span>
            <span class="s1">coercions._no_text_coercion(</span>
                <span class="s1">element.element</span><span class="s5">,</span>
                <span class="s1">extra=(</span>
                    <span class="s4">&quot;Can't resolve label reference for ORDER BY / &quot;</span>
                    <span class="s4">&quot;GROUP BY / DISTINCT etc.&quot;</span>
                <span class="s1">)</span><span class="s5">,</span>
                <span class="s1">exc_cls=exc.CompileError</span><span class="s5">,</span>
                <span class="s1">err=ke</span><span class="s5">,</span>
            <span class="s1">)</span>

        <span class="s1">with_cols</span><span class="s5">, </span><span class="s1">only_froms</span><span class="s5">, </span><span class="s1">only_cols = compile_state._label_resolve_dict</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">within_columns_clause:</span>
                <span class="s1">col = only_froms[element.element]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">col = with_cols[element.element]</span>
        <span class="s3">except </span><span class="s1">KeyError </span><span class="s3">as </span><span class="s1">err:</span>
            <span class="s1">coercions._no_text_coercion(</span>
                <span class="s1">element.element</span><span class="s5">,</span>
                <span class="s1">extra=(</span>
                    <span class="s4">&quot;Can't resolve label reference for ORDER BY / &quot;</span>
                    <span class="s4">&quot;GROUP BY / DISTINCT etc.&quot;</span>
                <span class="s1">)</span><span class="s5">,</span>
                <span class="s1">exc_cls=exc.CompileError</span><span class="s5">,</span>
                <span class="s1">err=err</span><span class="s5">,</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">kwargs[</span><span class="s4">&quot;render_label_as_label&quot;</span><span class="s1">] = col</span>
            <span class="s3">return </span><span class="s1">self.process(</span>
                <span class="s1">col</span><span class="s5">, </span><span class="s1">within_columns_clause=within_columns_clause</span><span class="s5">, </span><span class="s1">**kwargs</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_label(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">label</span><span class="s5">,</span>
        <span class="s1">add_to_result_map=</span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">within_label_clause=</span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">within_columns_clause=</span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">render_label_as_label=</span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">result_map_targets=()</span><span class="s5">,</span>
        <span class="s1">**kw</span><span class="s5">,</span>
    <span class="s1">):</span>
        <span class="s0"># only render labels within the columns clause</span>
        <span class="s0"># or ORDER BY clause of a select.  dialect-specific compilers</span>
        <span class="s0"># can modify this behavior.</span>
        <span class="s1">render_label_with_as = (</span>
            <span class="s1">within_columns_clause </span><span class="s3">and not </span><span class="s1">within_label_clause</span>
        <span class="s1">)</span>
        <span class="s1">render_label_only = render_label_as_label </span><span class="s3">is </span><span class="s1">label</span>

        <span class="s3">if </span><span class="s1">render_label_only </span><span class="s3">or </span><span class="s1">render_label_with_as:</span>
            <span class="s3">if </span><span class="s1">isinstance(label.name</span><span class="s5">, </span><span class="s1">elements._truncated_label):</span>
                <span class="s1">labelname = self._truncated_identifier(</span><span class="s4">&quot;colident&quot;</span><span class="s5">, </span><span class="s1">label.name)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">labelname = label.name</span>

        <span class="s3">if </span><span class="s1">render_label_with_as:</span>
            <span class="s3">if </span><span class="s1">add_to_result_map </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">add_to_result_map(</span>
                    <span class="s1">labelname</span><span class="s5">,</span>
                    <span class="s1">label.name</span><span class="s5">,</span>
                    <span class="s1">(label</span><span class="s5">, </span><span class="s1">labelname) + label._alt_names + result_map_targets</span><span class="s5">,</span>
                    <span class="s1">label.type</span><span class="s5">,</span>
                <span class="s1">)</span>
            <span class="s3">return </span><span class="s1">(</span>
                <span class="s1">label.element._compiler_dispatch(</span>
                    <span class="s1">self</span><span class="s5">,</span>
                    <span class="s1">within_columns_clause=</span><span class="s3">True</span><span class="s5">,</span>
                    <span class="s1">within_label_clause=</span><span class="s3">True</span><span class="s5">,</span>
                    <span class="s1">**kw</span><span class="s5">,</span>
                <span class="s1">)</span>
                <span class="s1">+ OPERATORS[operators.as_]</span>
                <span class="s1">+ self.preparer.format_label(label</span><span class="s5">, </span><span class="s1">labelname)</span>
            <span class="s1">)</span>
        <span class="s3">elif </span><span class="s1">render_label_only:</span>
            <span class="s3">return </span><span class="s1">self.preparer.format_label(label</span><span class="s5">, </span><span class="s1">labelname)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">label.element._compiler_dispatch(</span>
                <span class="s1">self</span><span class="s5">, </span><span class="s1">within_columns_clause=</span><span class="s3">False</span><span class="s5">, </span><span class="s1">**kw</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_fallback_column_name(self</span><span class="s5">, </span><span class="s1">column):</span>
        <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
            <span class="s4">&quot;Cannot compile Column object until its 'name' is assigned.&quot;</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_lambda_element(self</span><span class="s5">, </span><span class="s1">element</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">sql_element = element._resolved</span>
        <span class="s3">return </span><span class="s1">self.process(sql_element</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_column(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">column: ColumnClause[Any]</span><span class="s5">,</span>
        <span class="s1">add_to_result_map: Optional[_ResultMapAppender] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">include_table: bool = </span><span class="s3">True</span><span class="s5">,</span>
        <span class="s1">result_map_targets: Tuple[Any</span><span class="s5">, </span><span class="s1">...] = ()</span><span class="s5">,</span>
        <span class="s1">ambiguous_table_name_map: Optional[_AmbiguousTableNameMap] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">**kwargs: Any</span><span class="s5">,</span>
    <span class="s1">) -&gt; str:</span>
        <span class="s1">name = orig_name = column.name</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">name = self._fallback_column_name(column)</span>

        <span class="s1">is_literal = column.is_literal</span>
        <span class="s3">if not </span><span class="s1">is_literal </span><span class="s3">and </span><span class="s1">isinstance(name</span><span class="s5">, </span><span class="s1">elements._truncated_label):</span>
            <span class="s1">name = self._truncated_identifier(</span><span class="s4">&quot;colident&quot;</span><span class="s5">, </span><span class="s1">name)</span>

        <span class="s3">if </span><span class="s1">add_to_result_map </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">targets = (column</span><span class="s5">, </span><span class="s1">name</span><span class="s5">, </span><span class="s1">column.key) + result_map_targets</span>
            <span class="s3">if </span><span class="s1">column._tq_label:</span>
                <span class="s1">targets += (column._tq_label</span><span class="s5">,</span><span class="s1">)</span>

            <span class="s1">add_to_result_map(name</span><span class="s5">, </span><span class="s1">orig_name</span><span class="s5">, </span><span class="s1">targets</span><span class="s5">, </span><span class="s1">column.type)</span>

        <span class="s3">if </span><span class="s1">is_literal:</span>
            <span class="s0"># note we are not currently accommodating for</span>
            <span class="s0"># literal_column(quoted_name('ident', True)) here</span>
            <span class="s1">name = self.escape_literal_column(name)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">name = self.preparer.quote(name)</span>
        <span class="s1">table = column.table</span>
        <span class="s3">if </span><span class="s1">table </span><span class="s3">is None or not </span><span class="s1">include_table </span><span class="s3">or not </span><span class="s1">table.named_with_column:</span>
            <span class="s3">return </span><span class="s1">name</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">effective_schema = self.preparer.schema_for_object(table)</span>

            <span class="s3">if </span><span class="s1">effective_schema:</span>
                <span class="s1">schema_prefix = (</span>
                    <span class="s1">self.preparer.quote_schema(effective_schema) + </span><span class="s4">&quot;.&quot;</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">schema_prefix = </span><span class="s4">&quot;&quot;</span>

            <span class="s3">if </span><span class="s1">TYPE_CHECKING:</span>
                <span class="s3">assert </span><span class="s1">isinstance(table</span><span class="s5">, </span><span class="s1">NamedFromClause)</span>
            <span class="s1">tablename = table.name</span>

            <span class="s3">if </span><span class="s1">(</span>
                <span class="s3">not </span><span class="s1">effective_schema</span>
                <span class="s3">and </span><span class="s1">ambiguous_table_name_map</span>
                <span class="s3">and </span><span class="s1">tablename </span><span class="s3">in </span><span class="s1">ambiguous_table_name_map</span>
            <span class="s1">):</span>
                <span class="s1">tablename = ambiguous_table_name_map[tablename]</span>

            <span class="s3">if </span><span class="s1">isinstance(tablename</span><span class="s5">, </span><span class="s1">elements._truncated_label):</span>
                <span class="s1">tablename = self._truncated_identifier(</span><span class="s4">&quot;alias&quot;</span><span class="s5">, </span><span class="s1">tablename)</span>

            <span class="s3">return </span><span class="s1">schema_prefix + self.preparer.quote(tablename) + </span><span class="s4">&quot;.&quot; </span><span class="s1">+ name</span>

    <span class="s3">def </span><span class="s1">visit_collation(self</span><span class="s5">, </span><span class="s1">element</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self.preparer.format_collation(element.collation)</span>

    <span class="s3">def </span><span class="s1">visit_fromclause(self</span><span class="s5">, </span><span class="s1">fromclause</span><span class="s5">, </span><span class="s1">**kwargs):</span>
        <span class="s3">return </span><span class="s1">fromclause.name</span>

    <span class="s3">def </span><span class="s1">visit_index(self</span><span class="s5">, </span><span class="s1">index</span><span class="s5">, </span><span class="s1">**kwargs):</span>
        <span class="s3">return </span><span class="s1">index.name</span>

    <span class="s3">def </span><span class="s1">visit_typeclause(self</span><span class="s5">, </span><span class="s1">typeclause</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">kw[</span><span class="s4">&quot;type_expression&quot;</span><span class="s1">] = typeclause</span>
        <span class="s1">kw[</span><span class="s4">&quot;identifier_preparer&quot;</span><span class="s1">] = self.preparer</span>
        <span class="s3">return </span><span class="s1">self.dialect.type_compiler_instance.process(</span>
            <span class="s1">typeclause.type</span><span class="s5">, </span><span class="s1">**kw</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">post_process_text(self</span><span class="s5">, </span><span class="s1">text):</span>
        <span class="s3">if </span><span class="s1">self.preparer._double_percents:</span>
            <span class="s1">text = text.replace(</span><span class="s4">&quot;%&quot;</span><span class="s5">, </span><span class="s4">&quot;%%&quot;</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">escape_literal_column(self</span><span class="s5">, </span><span class="s1">text):</span>
        <span class="s3">if </span><span class="s1">self.preparer._double_percents:</span>
            <span class="s1">text = text.replace(</span><span class="s4">&quot;%&quot;</span><span class="s5">, </span><span class="s4">&quot;%%&quot;</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">visit_textclause(self</span><span class="s5">, </span><span class="s1">textclause</span><span class="s5">, </span><span class="s1">add_to_result_map=</span><span class="s3">None</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">def </span><span class="s1">do_bindparam(m):</span>
            <span class="s1">name = m.group(</span><span class="s6">1</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">textclause._bindparams:</span>
                <span class="s3">return </span><span class="s1">self.process(textclause._bindparams[name]</span><span class="s5">, </span><span class="s1">**kw)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">self.bindparam_string(name</span><span class="s5">, </span><span class="s1">**kw)</span>

        <span class="s3">if not </span><span class="s1">self.stack:</span>
            <span class="s1">self.isplaintext = </span><span class="s3">True</span>

        <span class="s3">if </span><span class="s1">add_to_result_map:</span>
            <span class="s0"># text() object is present in the columns clause of a</span>
            <span class="s0"># select().   Add a no-name entry to the result map so that</span>
            <span class="s0"># row[text()] produces a result</span>
            <span class="s1">add_to_result_map(</span><span class="s3">None</span><span class="s5">, </span><span class="s3">None</span><span class="s5">, </span><span class="s1">(textclause</span><span class="s5">,</span><span class="s1">)</span><span class="s5">, </span><span class="s1">sqltypes.NULLTYPE)</span>

        <span class="s0"># un-escape any \:params</span>
        <span class="s3">return </span><span class="s1">BIND_PARAMS_ESC.sub(</span>
            <span class="s3">lambda </span><span class="s1">m: m.group(</span><span class="s6">1</span><span class="s1">)</span><span class="s5">,</span>
            <span class="s1">BIND_PARAMS.sub(</span>
                <span class="s1">do_bindparam</span><span class="s5">, </span><span class="s1">self.post_process_text(textclause.text)</span>
            <span class="s1">)</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_textual_select(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">taf</span><span class="s5">, </span><span class="s1">compound_index=</span><span class="s3">None</span><span class="s5">, </span><span class="s1">asfrom=</span><span class="s3">False</span><span class="s5">, </span><span class="s1">**kw</span>
    <span class="s1">):</span>
        <span class="s1">toplevel = </span><span class="s3">not </span><span class="s1">self.stack</span>
        <span class="s1">entry = self._default_stack_entry </span><span class="s3">if </span><span class="s1">toplevel </span><span class="s3">else </span><span class="s1">self.stack[-</span><span class="s6">1</span><span class="s1">]</span>

        <span class="s1">new_entry: _CompilerStackEntry = {</span>
            <span class="s4">&quot;correlate_froms&quot;</span><span class="s1">: set()</span><span class="s5">,</span>
            <span class="s4">&quot;asfrom_froms&quot;</span><span class="s1">: set()</span><span class="s5">,</span>
            <span class="s4">&quot;selectable&quot;</span><span class="s1">: taf</span><span class="s5">,</span>
        <span class="s1">}</span>
        <span class="s1">self.stack.append(new_entry)</span>

        <span class="s3">if </span><span class="s1">taf._independent_ctes:</span>
            <span class="s1">self._dispatch_independent_ctes(taf</span><span class="s5">, </span><span class="s1">kw)</span>

        <span class="s1">populate_result_map = (</span>
            <span class="s1">toplevel</span>
            <span class="s3">or </span><span class="s1">(</span>
                <span class="s1">compound_index == </span><span class="s6">0</span>
                <span class="s3">and </span><span class="s1">entry.get(</span><span class="s4">&quot;need_result_map_for_compound&quot;</span><span class="s5">, </span><span class="s3">False</span><span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s3">or </span><span class="s1">entry.get(</span><span class="s4">&quot;need_result_map_for_nested&quot;</span><span class="s5">, </span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">populate_result_map:</span>
            <span class="s1">self._ordered_columns = self._textual_ordered_columns = (</span>
                <span class="s1">taf.positional</span>
            <span class="s1">)</span>

            <span class="s0"># enable looser result column matching when the SQL text links to</span>
            <span class="s0"># Column objects by name only</span>
            <span class="s1">self._loose_column_name_matching = </span><span class="s3">not </span><span class="s1">taf.positional </span><span class="s3">and </span><span class="s1">bool(</span>
                <span class="s1">taf.column_args</span>
            <span class="s1">)</span>

            <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">taf.column_args:</span>
                <span class="s1">self.process(</span>
                    <span class="s1">c</span><span class="s5">,</span>
                    <span class="s1">within_columns_clause=</span><span class="s3">True</span><span class="s5">,</span>
                    <span class="s1">add_to_result_map=self._add_to_result_map</span><span class="s5">,</span>
                <span class="s1">)</span>

        <span class="s1">text = self.process(taf.element</span><span class="s5">, </span><span class="s1">**kw)</span>
        <span class="s3">if </span><span class="s1">self.ctes:</span>
            <span class="s1">nesting_level = len(self.stack) </span><span class="s3">if not </span><span class="s1">toplevel </span><span class="s3">else None</span>
            <span class="s1">text = self._render_cte_clause(nesting_level=nesting_level) + text</span>

        <span class="s1">self.stack.pop(-</span><span class="s6">1</span><span class="s1">)</span>

        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">visit_null(self</span><span class="s5">, </span><span class="s1">expr</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;NULL&quot;</span>

    <span class="s3">def </span><span class="s1">visit_true(self</span><span class="s5">, </span><span class="s1">expr</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">if </span><span class="s1">self.dialect.supports_native_boolean:</span>
            <span class="s3">return </span><span class="s4">&quot;true&quot;</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">&quot;1&quot;</span>

    <span class="s3">def </span><span class="s1">visit_false(self</span><span class="s5">, </span><span class="s1">expr</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">if </span><span class="s1">self.dialect.supports_native_boolean:</span>
            <span class="s3">return </span><span class="s4">&quot;false&quot;</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">&quot;0&quot;</span>

    <span class="s3">def </span><span class="s1">_generate_delimited_list(self</span><span class="s5">, </span><span class="s1">elements</span><span class="s5">, </span><span class="s1">separator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">separator.join(</span>
            <span class="s1">s</span>
            <span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">(c._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kw) </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">elements)</span>
            <span class="s3">if </span><span class="s1">s</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_generate_delimited_and_list(self</span><span class="s5">, </span><span class="s1">clauses</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">lcc</span><span class="s5">, </span><span class="s1">clauses = elements.BooleanClauseList._process_clauses_for_boolean(</span>
            <span class="s1">operators.and_</span><span class="s5">,</span>
            <span class="s1">elements.True_._singleton</span><span class="s5">,</span>
            <span class="s1">elements.False_._singleton</span><span class="s5">,</span>
            <span class="s1">clauses</span><span class="s5">,</span>
        <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">lcc == </span><span class="s6">1</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">clauses[</span><span class="s6">0</span><span class="s1">]._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kw)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">separator = OPERATORS[operators.and_]</span>
            <span class="s3">return </span><span class="s1">separator.join(</span>
                <span class="s1">s</span>
                <span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">(c._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kw) </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">clauses)</span>
                <span class="s3">if </span><span class="s1">s</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_tuple(self</span><span class="s5">, </span><span class="s1">clauselist</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;(%s)&quot; </span><span class="s1">% self.visit_clauselist(clauselist</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_clauselist(self</span><span class="s5">, </span><span class="s1">clauselist</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">sep = clauselist.operator</span>
        <span class="s3">if </span><span class="s1">sep </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">sep = </span><span class="s4">&quot; &quot;</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">sep = OPERATORS[clauselist.operator]</span>

        <span class="s3">return </span><span class="s1">self._generate_delimited_list(clauselist.clauses</span><span class="s5">, </span><span class="s1">sep</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_expression_clauselist(self</span><span class="s5">, </span><span class="s1">clauselist</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">operator_ = clauselist.operator</span>

        <span class="s1">disp = self._get_operator_dispatch(</span>
            <span class="s1">operator_</span><span class="s5">, </span><span class="s4">&quot;expression_clauselist&quot;</span><span class="s5">, </span><span class="s3">None</span>
        <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">disp:</span>
            <span class="s3">return </span><span class="s1">disp(clauselist</span><span class="s5">, </span><span class="s1">operator_</span><span class="s5">, </span><span class="s1">**kw)</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">opstring = OPERATORS[operator_]</span>
        <span class="s3">except </span><span class="s1">KeyError </span><span class="s3">as </span><span class="s1">err:</span>
            <span class="s3">raise </span><span class="s1">exc.UnsupportedCompilationError(self</span><span class="s5">, </span><span class="s1">operator_) </span><span class="s3">from </span><span class="s1">err</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">kw[</span><span class="s4">&quot;_in_operator_expression&quot;</span><span class="s1">] = </span><span class="s3">True</span>
            <span class="s3">return </span><span class="s1">self._generate_delimited_list(</span>
                <span class="s1">clauselist.clauses</span><span class="s5">, </span><span class="s1">opstring</span><span class="s5">, </span><span class="s1">**kw</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_case(self</span><span class="s5">, </span><span class="s1">clause</span><span class="s5">, </span><span class="s1">**kwargs):</span>
        <span class="s1">x = </span><span class="s4">&quot;CASE &quot;</span>
        <span class="s3">if </span><span class="s1">clause.value </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">x += clause.value._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kwargs) + </span><span class="s4">&quot; &quot;</span>
        <span class="s3">for </span><span class="s1">cond</span><span class="s5">, </span><span class="s1">result </span><span class="s3">in </span><span class="s1">clause.whens:</span>
            <span class="s1">x += (</span>
                <span class="s4">&quot;WHEN &quot;</span>
                <span class="s1">+ cond._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kwargs)</span>
                <span class="s1">+ </span><span class="s4">&quot; THEN &quot;</span>
                <span class="s1">+ result._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kwargs)</span>
                <span class="s1">+ </span><span class="s4">&quot; &quot;</span>
            <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">clause.else_ </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">x += (</span>
                <span class="s4">&quot;ELSE &quot; </span><span class="s1">+ clause.else_._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kwargs) + </span><span class="s4">&quot; &quot;</span>
            <span class="s1">)</span>
        <span class="s1">x += </span><span class="s4">&quot;END&quot;</span>
        <span class="s3">return </span><span class="s1">x</span>

    <span class="s3">def </span><span class="s1">visit_type_coerce(self</span><span class="s5">, </span><span class="s1">type_coerce</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">type_coerce.typed_expression._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_cast(self</span><span class="s5">, </span><span class="s1">cast</span><span class="s5">, </span><span class="s1">**kwargs):</span>
        <span class="s1">type_clause = cast.typeclause._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kwargs)</span>
        <span class="s1">match = re.match(</span><span class="s4">&quot;(.*)( COLLATE .*)&quot;</span><span class="s5">, </span><span class="s1">type_clause)</span>
        <span class="s3">return </span><span class="s4">&quot;CAST(%s AS %s)%s&quot; </span><span class="s1">% (</span>
            <span class="s1">cast.clause._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kwargs)</span><span class="s5">,</span>
            <span class="s1">match.group(</span><span class="s6">1</span><span class="s1">) </span><span class="s3">if </span><span class="s1">match </span><span class="s3">else </span><span class="s1">type_clause</span><span class="s5">,</span>
            <span class="s1">match.group(</span><span class="s6">2</span><span class="s1">) </span><span class="s3">if </span><span class="s1">match </span><span class="s3">else </span><span class="s4">&quot;&quot;</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_format_frame_clause(self</span><span class="s5">, </span><span class="s1">range_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;%s AND %s&quot; </span><span class="s1">% (</span>
            <span class="s1">(</span>
                <span class="s4">&quot;UNBOUNDED PRECEDING&quot;</span>
                <span class="s3">if </span><span class="s1">range_[</span><span class="s6">0</span><span class="s1">] </span><span class="s3">is </span><span class="s1">elements.RANGE_UNBOUNDED</span>
                <span class="s3">else </span><span class="s1">(</span>
                    <span class="s4">&quot;CURRENT ROW&quot;</span>
                    <span class="s3">if </span><span class="s1">range_[</span><span class="s6">0</span><span class="s1">] </span><span class="s3">is </span><span class="s1">elements.RANGE_CURRENT</span>
                    <span class="s3">else </span><span class="s1">(</span>
                        <span class="s4">&quot;%s PRECEDING&quot;</span>
                        <span class="s1">% (</span>
                            <span class="s1">self.process(</span>
                                <span class="s1">elements.literal(abs(range_[</span><span class="s6">0</span><span class="s1">]))</span><span class="s5">, </span><span class="s1">**kw</span>
                            <span class="s1">)</span><span class="s5">,</span>
                        <span class="s1">)</span>
                        <span class="s3">if </span><span class="s1">range_[</span><span class="s6">0</span><span class="s1">] &lt; </span><span class="s6">0</span>
                        <span class="s3">else </span><span class="s4">&quot;%s FOLLOWING&quot;</span>
                        <span class="s1">% (self.process(elements.literal(range_[</span><span class="s6">0</span><span class="s1">])</span><span class="s5">, </span><span class="s1">**kw)</span><span class="s5">,</span><span class="s1">)</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s1">)</span><span class="s5">,</span>
            <span class="s1">(</span>
                <span class="s4">&quot;UNBOUNDED FOLLOWING&quot;</span>
                <span class="s3">if </span><span class="s1">range_[</span><span class="s6">1</span><span class="s1">] </span><span class="s3">is </span><span class="s1">elements.RANGE_UNBOUNDED</span>
                <span class="s3">else </span><span class="s1">(</span>
                    <span class="s4">&quot;CURRENT ROW&quot;</span>
                    <span class="s3">if </span><span class="s1">range_[</span><span class="s6">1</span><span class="s1">] </span><span class="s3">is </span><span class="s1">elements.RANGE_CURRENT</span>
                    <span class="s3">else </span><span class="s1">(</span>
                        <span class="s4">&quot;%s PRECEDING&quot;</span>
                        <span class="s1">% (</span>
                            <span class="s1">self.process(</span>
                                <span class="s1">elements.literal(abs(range_[</span><span class="s6">1</span><span class="s1">]))</span><span class="s5">, </span><span class="s1">**kw</span>
                            <span class="s1">)</span><span class="s5">,</span>
                        <span class="s1">)</span>
                        <span class="s3">if </span><span class="s1">range_[</span><span class="s6">1</span><span class="s1">] &lt; </span><span class="s6">0</span>
                        <span class="s3">else </span><span class="s4">&quot;%s FOLLOWING&quot;</span>
                        <span class="s1">% (self.process(elements.literal(range_[</span><span class="s6">1</span><span class="s1">])</span><span class="s5">, </span><span class="s1">**kw)</span><span class="s5">,</span><span class="s1">)</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s1">)</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_over(self</span><span class="s5">, </span><span class="s1">over</span><span class="s5">, </span><span class="s1">**kwargs):</span>
        <span class="s1">text = over.element._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kwargs)</span>
        <span class="s3">if </span><span class="s1">over.range_:</span>
            <span class="s1">range_ = </span><span class="s4">&quot;RANGE BETWEEN %s&quot; </span><span class="s1">% self._format_frame_clause(</span>
                <span class="s1">over.range_</span><span class="s5">, </span><span class="s1">**kwargs</span>
            <span class="s1">)</span>
        <span class="s3">elif </span><span class="s1">over.rows:</span>
            <span class="s1">range_ = </span><span class="s4">&quot;ROWS BETWEEN %s&quot; </span><span class="s1">% self._format_frame_clause(</span>
                <span class="s1">over.rows</span><span class="s5">, </span><span class="s1">**kwargs</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">range_ = </span><span class="s3">None</span>

        <span class="s3">return </span><span class="s4">&quot;%s OVER (%s)&quot; </span><span class="s1">% (</span>
            <span class="s1">text</span><span class="s5">,</span>
            <span class="s4">&quot; &quot;</span><span class="s1">.join(</span>
                <span class="s1">[</span>
                    <span class="s4">&quot;%s BY %s&quot;</span>
                    <span class="s1">% (word</span><span class="s5">, </span><span class="s1">clause._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kwargs))</span>
                    <span class="s3">for </span><span class="s1">word</span><span class="s5">, </span><span class="s1">clause </span><span class="s3">in </span><span class="s1">(</span>
                        <span class="s1">(</span><span class="s4">&quot;PARTITION&quot;</span><span class="s5">, </span><span class="s1">over.partition_by)</span><span class="s5">,</span>
                        <span class="s1">(</span><span class="s4">&quot;ORDER&quot;</span><span class="s5">, </span><span class="s1">over.order_by)</span><span class="s5">,</span>
                    <span class="s1">)</span>
                    <span class="s3">if </span><span class="s1">clause </span><span class="s3">is not None and </span><span class="s1">len(clause)</span>
                <span class="s1">]</span>
                <span class="s1">+ ([range_] </span><span class="s3">if </span><span class="s1">range_ </span><span class="s3">else </span><span class="s1">[])</span>
            <span class="s1">)</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_withingroup(self</span><span class="s5">, </span><span class="s1">withingroup</span><span class="s5">, </span><span class="s1">**kwargs):</span>
        <span class="s3">return </span><span class="s4">&quot;%s WITHIN GROUP (ORDER BY %s)&quot; </span><span class="s1">% (</span>
            <span class="s1">withingroup.element._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kwargs)</span><span class="s5">,</span>
            <span class="s1">withingroup.order_by._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kwargs)</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_funcfilter(self</span><span class="s5">, </span><span class="s1">funcfilter</span><span class="s5">, </span><span class="s1">**kwargs):</span>
        <span class="s3">return </span><span class="s4">&quot;%s FILTER (WHERE %s)&quot; </span><span class="s1">% (</span>
            <span class="s1">funcfilter.func._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kwargs)</span><span class="s5">,</span>
            <span class="s1">funcfilter.criterion._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kwargs)</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_extract(self</span><span class="s5">, </span><span class="s1">extract</span><span class="s5">, </span><span class="s1">**kwargs):</span>
        <span class="s1">field = self.extract_map.get(extract.field</span><span class="s5">, </span><span class="s1">extract.field)</span>
        <span class="s3">return </span><span class="s4">&quot;EXTRACT(%s FROM %s)&quot; </span><span class="s1">% (</span>
            <span class="s1">field</span><span class="s5">,</span>
            <span class="s1">extract.expr._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kwargs)</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_scalar_function_column(self</span><span class="s5">, </span><span class="s1">element</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">compiled_fn = self.visit_function(element.fn</span><span class="s5">, </span><span class="s1">**kw)</span>
        <span class="s1">compiled_col = self.visit_column(element</span><span class="s5">, </span><span class="s1">**kw)</span>
        <span class="s3">return </span><span class="s4">&quot;(%s).%s&quot; </span><span class="s1">% (compiled_fn</span><span class="s5">, </span><span class="s1">compiled_col)</span>

    <span class="s3">def </span><span class="s1">visit_function(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">func: Function[Any]</span><span class="s5">,</span>
        <span class="s1">add_to_result_map: Optional[_ResultMapAppender] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">**kwargs: Any</span><span class="s5">,</span>
    <span class="s1">) -&gt; str:</span>
        <span class="s3">if </span><span class="s1">add_to_result_map </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">add_to_result_map(func.name</span><span class="s5">, </span><span class="s1">func.name</span><span class="s5">, </span><span class="s1">(func.name</span><span class="s5">,</span><span class="s1">)</span><span class="s5">, </span><span class="s1">func.type)</span>

        <span class="s1">disp = getattr(self</span><span class="s5">, </span><span class="s4">&quot;visit_%s_func&quot; </span><span class="s1">% func.name.lower()</span><span class="s5">, </span><span class="s3">None</span><span class="s1">)</span>

        <span class="s1">text: str</span>

        <span class="s3">if </span><span class="s1">disp:</span>
            <span class="s1">text = disp(func</span><span class="s5">, </span><span class="s1">**kwargs)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">name = FUNCTIONS.get(func._deannotate().__class__</span><span class="s5">, </span><span class="s3">None</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">name:</span>
                <span class="s3">if </span><span class="s1">func._has_args:</span>
                    <span class="s1">name += </span><span class="s4">&quot;%(expr)s&quot;</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">name = func.name</span>
                <span class="s1">name = (</span>
                    <span class="s1">self.preparer.quote(name)</span>
                    <span class="s3">if </span><span class="s1">self.preparer._requires_quotes_illegal_chars(name)</span>
                    <span class="s3">or </span><span class="s1">isinstance(name</span><span class="s5">, </span><span class="s1">elements.quoted_name)</span>
                    <span class="s3">else </span><span class="s1">name</span>
                <span class="s1">)</span>
                <span class="s1">name = name + </span><span class="s4">&quot;%(expr)s&quot;</span>
            <span class="s1">text = </span><span class="s4">&quot;.&quot;</span><span class="s1">.join(</span>
                <span class="s1">[</span>
                    <span class="s1">(</span>
                        <span class="s1">self.preparer.quote(tok)</span>
                        <span class="s3">if </span><span class="s1">self.preparer._requires_quotes_illegal_chars(tok)</span>
                        <span class="s3">or </span><span class="s1">isinstance(name</span><span class="s5">, </span><span class="s1">elements.quoted_name)</span>
                        <span class="s3">else </span><span class="s1">tok</span>
                    <span class="s1">)</span>
                    <span class="s3">for </span><span class="s1">tok </span><span class="s3">in </span><span class="s1">func.packagenames</span>
                <span class="s1">]</span>
                <span class="s1">+ [name]</span>
            <span class="s1">) % {</span><span class="s4">&quot;expr&quot;</span><span class="s1">: self.function_argspec(func</span><span class="s5">, </span><span class="s1">**kwargs)}</span>

        <span class="s3">if </span><span class="s1">func._with_ordinality:</span>
            <span class="s1">text += </span><span class="s4">&quot; WITH ORDINALITY&quot;</span>
        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">visit_next_value_func(self</span><span class="s5">, </span><span class="s1">next_value</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self.visit_sequence(next_value.sequence)</span>

    <span class="s3">def </span><span class="s1">visit_sequence(self</span><span class="s5">, </span><span class="s1">sequence</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span>
            <span class="s4">&quot;Dialect '%s' does not support sequence increments.&quot;</span>
            <span class="s1">% self.dialect.name</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">function_argspec(self</span><span class="s5">, </span><span class="s1">func</span><span class="s5">, </span><span class="s1">**kwargs):</span>
        <span class="s3">return </span><span class="s1">func.clause_expr._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kwargs)</span>

    <span class="s3">def </span><span class="s1">visit_compound_select(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">cs</span><span class="s5">, </span><span class="s1">asfrom=</span><span class="s3">False</span><span class="s5">, </span><span class="s1">compound_index=</span><span class="s3">None</span><span class="s5">, </span><span class="s1">**kwargs</span>
    <span class="s1">):</span>
        <span class="s1">toplevel = </span><span class="s3">not </span><span class="s1">self.stack</span>

        <span class="s1">compile_state = cs._compile_state_factory(cs</span><span class="s5">, </span><span class="s1">self</span><span class="s5">, </span><span class="s1">**kwargs)</span>

        <span class="s3">if </span><span class="s1">toplevel </span><span class="s3">and not </span><span class="s1">self.compile_state:</span>
            <span class="s1">self.compile_state = compile_state</span>

        <span class="s1">compound_stmt = compile_state.statement</span>

        <span class="s1">entry = self._default_stack_entry </span><span class="s3">if </span><span class="s1">toplevel </span><span class="s3">else </span><span class="s1">self.stack[-</span><span class="s6">1</span><span class="s1">]</span>
        <span class="s1">need_result_map = toplevel </span><span class="s3">or </span><span class="s1">(</span>
            <span class="s3">not </span><span class="s1">compound_index</span>
            <span class="s3">and </span><span class="s1">entry.get(</span><span class="s4">&quot;need_result_map_for_compound&quot;</span><span class="s5">, </span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s0"># indicates there is already a CompoundSelect in play</span>
        <span class="s3">if </span><span class="s1">compound_index == </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s1">entry[</span><span class="s4">&quot;select_0&quot;</span><span class="s1">] = cs</span>

        <span class="s1">self.stack.append(</span>
            <span class="s1">{</span>
                <span class="s4">&quot;correlate_froms&quot;</span><span class="s1">: entry[</span><span class="s4">&quot;correlate_froms&quot;</span><span class="s1">]</span><span class="s5">,</span>
                <span class="s4">&quot;asfrom_froms&quot;</span><span class="s1">: entry[</span><span class="s4">&quot;asfrom_froms&quot;</span><span class="s1">]</span><span class="s5">,</span>
                <span class="s4">&quot;selectable&quot;</span><span class="s1">: cs</span><span class="s5">,</span>
                <span class="s4">&quot;compile_state&quot;</span><span class="s1">: compile_state</span><span class="s5">,</span>
                <span class="s4">&quot;need_result_map_for_compound&quot;</span><span class="s1">: need_result_map</span><span class="s5">,</span>
            <span class="s1">}</span>
        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">compound_stmt._independent_ctes:</span>
            <span class="s1">self._dispatch_independent_ctes(compound_stmt</span><span class="s5">, </span><span class="s1">kwargs)</span>

        <span class="s1">keyword = self.compound_keywords[cs.keyword]</span>

        <span class="s1">text = (</span><span class="s4">&quot; &quot; </span><span class="s1">+ keyword + </span><span class="s4">&quot; &quot;</span><span class="s1">).join(</span>
            <span class="s1">(</span>
                <span class="s1">c._compiler_dispatch(</span>
                    <span class="s1">self</span><span class="s5">, </span><span class="s1">asfrom=asfrom</span><span class="s5">, </span><span class="s1">compound_index=i</span><span class="s5">, </span><span class="s1">**kwargs</span>
                <span class="s1">)</span>
                <span class="s3">for </span><span class="s1">i</span><span class="s5">, </span><span class="s1">c </span><span class="s3">in </span><span class="s1">enumerate(cs.selects)</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s1">kwargs[</span><span class="s4">&quot;include_table&quot;</span><span class="s1">] = </span><span class="s3">False</span>
        <span class="s1">text += self.group_by_clause(cs</span><span class="s5">, </span><span class="s1">**dict(asfrom=asfrom</span><span class="s5">, </span><span class="s1">**kwargs))</span>
        <span class="s1">text += self.order_by_clause(cs</span><span class="s5">, </span><span class="s1">**kwargs)</span>
        <span class="s3">if </span><span class="s1">cs._has_row_limiting_clause:</span>
            <span class="s1">text += self._row_limit_clause(cs</span><span class="s5">, </span><span class="s1">**kwargs)</span>

        <span class="s3">if </span><span class="s1">self.ctes:</span>
            <span class="s1">nesting_level = len(self.stack) </span><span class="s3">if not </span><span class="s1">toplevel </span><span class="s3">else None</span>
            <span class="s1">text = (</span>
                <span class="s1">self._render_cte_clause(</span>
                    <span class="s1">nesting_level=nesting_level</span><span class="s5">,</span>
                    <span class="s1">include_following_stack=</span><span class="s3">True</span><span class="s5">,</span>
                <span class="s1">)</span>
                <span class="s1">+ text</span>
            <span class="s1">)</span>

        <span class="s1">self.stack.pop(-</span><span class="s6">1</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">_row_limit_clause(self</span><span class="s5">, </span><span class="s1">cs</span><span class="s5">, </span><span class="s1">**kwargs):</span>
        <span class="s3">if </span><span class="s1">cs._fetch_clause </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.fetch_clause(cs</span><span class="s5">, </span><span class="s1">**kwargs)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.limit_clause(cs</span><span class="s5">, </span><span class="s1">**kwargs)</span>

    <span class="s3">def </span><span class="s1">_get_operator_dispatch(self</span><span class="s5">, </span><span class="s1">operator_</span><span class="s5">, </span><span class="s1">qualifier1</span><span class="s5">, </span><span class="s1">qualifier2):</span>
        <span class="s1">attrname = </span><span class="s4">&quot;visit_%s_%s%s&quot; </span><span class="s1">% (</span>
            <span class="s1">operator_.__name__</span><span class="s5">,</span>
            <span class="s1">qualifier1</span><span class="s5">,</span>
            <span class="s4">&quot;_&quot; </span><span class="s1">+ qualifier2 </span><span class="s3">if </span><span class="s1">qualifier2 </span><span class="s3">else </span><span class="s4">&quot;&quot;</span><span class="s5">,</span>
        <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">getattr(self</span><span class="s5">, </span><span class="s1">attrname</span><span class="s5">, </span><span class="s3">None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_unary(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">unary</span><span class="s5">, </span><span class="s1">add_to_result_map=</span><span class="s3">None</span><span class="s5">, </span><span class="s1">result_map_targets=()</span><span class="s5">, </span><span class="s1">**kw</span>
    <span class="s1">):</span>
        <span class="s3">if </span><span class="s1">add_to_result_map </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">result_map_targets += (unary</span><span class="s5">,</span><span class="s1">)</span>
            <span class="s1">kw[</span><span class="s4">&quot;add_to_result_map&quot;</span><span class="s1">] = add_to_result_map</span>
            <span class="s1">kw[</span><span class="s4">&quot;result_map_targets&quot;</span><span class="s1">] = result_map_targets</span>

        <span class="s3">if </span><span class="s1">unary.operator:</span>
            <span class="s3">if </span><span class="s1">unary.modifier:</span>
                <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
                    <span class="s4">&quot;Unary expression does not support operator &quot;</span>
                    <span class="s4">&quot;and modifier simultaneously&quot;</span>
                <span class="s1">)</span>
            <span class="s1">disp = self._get_operator_dispatch(</span>
                <span class="s1">unary.operator</span><span class="s5">, </span><span class="s4">&quot;unary&quot;</span><span class="s5">, </span><span class="s4">&quot;operator&quot;</span>
            <span class="s1">)</span>
            <span class="s3">if </span><span class="s1">disp:</span>
                <span class="s3">return </span><span class="s1">disp(unary</span><span class="s5">, </span><span class="s1">unary.operator</span><span class="s5">, </span><span class="s1">**kw)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">self._generate_generic_unary_operator(</span>
                    <span class="s1">unary</span><span class="s5">, </span><span class="s1">OPERATORS[unary.operator]</span><span class="s5">, </span><span class="s1">**kw</span>
                <span class="s1">)</span>
        <span class="s3">elif </span><span class="s1">unary.modifier:</span>
            <span class="s1">disp = self._get_operator_dispatch(</span>
                <span class="s1">unary.modifier</span><span class="s5">, </span><span class="s4">&quot;unary&quot;</span><span class="s5">, </span><span class="s4">&quot;modifier&quot;</span>
            <span class="s1">)</span>
            <span class="s3">if </span><span class="s1">disp:</span>
                <span class="s3">return </span><span class="s1">disp(unary</span><span class="s5">, </span><span class="s1">unary.modifier</span><span class="s5">, </span><span class="s1">**kw)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">self._generate_generic_unary_modifier(</span>
                    <span class="s1">unary</span><span class="s5">, </span><span class="s1">OPERATORS[unary.modifier]</span><span class="s5">, </span><span class="s1">**kw</span>
                <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
                <span class="s4">&quot;Unary expression has no operator or modifier&quot;</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_truediv_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">if </span><span class="s1">self.dialect.div_is_floordiv:</span>
            <span class="s3">return </span><span class="s1">(</span>
                <span class="s1">self.process(binary.left</span><span class="s5">, </span><span class="s1">**kw)</span>
                <span class="s1">+ </span><span class="s4">&quot; / &quot;</span>
                <span class="s0"># TODO: would need a fast cast again here,</span>
                <span class="s0"># unless we want to use an implicit cast like &quot;+ 0.0&quot;</span>
                <span class="s1">+ self.process(</span>
                    <span class="s1">elements.Cast(</span>
                        <span class="s1">binary.right</span><span class="s5">,</span>
                        <span class="s1">(</span>
                            <span class="s1">binary.right.type</span>
                            <span class="s3">if </span><span class="s1">binary.right.type._type_affinity</span>
                            <span class="s3">is </span><span class="s1">sqltypes.Numeric</span>
                            <span class="s3">else </span><span class="s1">sqltypes.Numeric()</span>
                        <span class="s1">)</span><span class="s5">,</span>
                    <span class="s1">)</span><span class="s5">,</span>
                    <span class="s1">**kw</span><span class="s5">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">(</span>
                <span class="s1">self.process(binary.left</span><span class="s5">, </span><span class="s1">**kw)</span>
                <span class="s1">+ </span><span class="s4">&quot; / &quot;</span>
                <span class="s1">+ self.process(binary.right</span><span class="s5">, </span><span class="s1">**kw)</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_floordiv_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">self.dialect.div_is_floordiv</span>
            <span class="s3">and </span><span class="s1">binary.right.type._type_affinity </span><span class="s3">is </span><span class="s1">sqltypes.Integer</span>
        <span class="s1">):</span>
            <span class="s3">return </span><span class="s1">(</span>
                <span class="s1">self.process(binary.left</span><span class="s5">, </span><span class="s1">**kw)</span>
                <span class="s1">+ </span><span class="s4">&quot; / &quot;</span>
                <span class="s1">+ self.process(binary.right</span><span class="s5">, </span><span class="s1">**kw)</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">&quot;FLOOR(%s)&quot; </span><span class="s1">% (</span>
                <span class="s1">self.process(binary.left</span><span class="s5">, </span><span class="s1">**kw)</span>
                <span class="s1">+ </span><span class="s4">&quot; / &quot;</span>
                <span class="s1">+ self.process(binary.right</span><span class="s5">, </span><span class="s1">**kw)</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_is_true_unary_operator(self</span><span class="s5">, </span><span class="s1">element</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">element._is_implicitly_boolean</span>
            <span class="s3">or </span><span class="s1">self.dialect.supports_native_boolean</span>
        <span class="s1">):</span>
            <span class="s3">return </span><span class="s1">self.process(element.element</span><span class="s5">, </span><span class="s1">**kw)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">&quot;%s = 1&quot; </span><span class="s1">% self.process(element.element</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_is_false_unary_operator(self</span><span class="s5">, </span><span class="s1">element</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">element._is_implicitly_boolean</span>
            <span class="s3">or </span><span class="s1">self.dialect.supports_native_boolean</span>
        <span class="s1">):</span>
            <span class="s3">return </span><span class="s4">&quot;NOT %s&quot; </span><span class="s1">% self.process(element.element</span><span class="s5">, </span><span class="s1">**kw)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">&quot;%s = 0&quot; </span><span class="s1">% self.process(element.element</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_not_match_op_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;NOT %s&quot; </span><span class="s1">% self.visit_binary(</span>
            <span class="s1">binary</span><span class="s5">, </span><span class="s1">override_operator=operators.match_op</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_not_in_op_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s0"># The brackets are required in the NOT IN operation because the empty</span>
        <span class="s0"># case is handled using the form &quot;(col NOT IN (null) OR 1 = 1)&quot;.</span>
        <span class="s0"># The presence of the OR makes the brackets required.</span>
        <span class="s3">return </span><span class="s4">&quot;(%s)&quot; </span><span class="s1">% self._generate_generic_binary(</span>
            <span class="s1">binary</span><span class="s5">, </span><span class="s1">OPERATORS[operator]</span><span class="s5">, </span><span class="s1">**kw</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_empty_set_op_expr(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">expand_op</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">if </span><span class="s1">expand_op </span><span class="s3">is </span><span class="s1">operators.not_in_op:</span>
            <span class="s3">if </span><span class="s1">len(type_) &gt; </span><span class="s6">1</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s4">&quot;(%s)) OR (1 = 1&quot; </span><span class="s1">% (</span>
                    <span class="s4">&quot;, &quot;</span><span class="s1">.join(</span><span class="s4">&quot;NULL&quot; </span><span class="s3">for </span><span class="s1">element </span><span class="s3">in </span><span class="s1">type_)</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s4">&quot;NULL) OR (1 = 1&quot;</span>
        <span class="s3">elif </span><span class="s1">expand_op </span><span class="s3">is </span><span class="s1">operators.in_op:</span>
            <span class="s3">if </span><span class="s1">len(type_) &gt; </span><span class="s6">1</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s4">&quot;(%s)) AND (1 != 1&quot; </span><span class="s1">% (</span>
                    <span class="s4">&quot;, &quot;</span><span class="s1">.join(</span><span class="s4">&quot;NULL&quot; </span><span class="s3">for </span><span class="s1">element </span><span class="s3">in </span><span class="s1">type_)</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s4">&quot;NULL) AND (1 != 1&quot;</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.visit_empty_set_expr(type_)</span>

    <span class="s3">def </span><span class="s1">visit_empty_set_expr(self</span><span class="s5">, </span><span class="s1">element_types</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span>
            <span class="s4">&quot;Dialect '%s' does not support empty set expression.&quot;</span>
            <span class="s1">% self.dialect.name</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_literal_execute_expanding_parameter_literal_binds(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">parameter</span><span class="s5">, </span><span class="s1">values</span><span class="s5">, </span><span class="s1">bind_expression_template=</span><span class="s3">None</span>
    <span class="s1">):</span>
        <span class="s1">typ_dialect_impl = parameter.type._unwrapped_dialect_impl(self.dialect)</span>

        <span class="s3">if not </span><span class="s1">values:</span>
            <span class="s0"># empty IN expression.  note we don't need to use</span>
            <span class="s0"># bind_expression_template here because there are no</span>
            <span class="s0"># expressions to render.</span>

            <span class="s3">if </span><span class="s1">typ_dialect_impl._is_tuple_type:</span>
                <span class="s1">replacement_expression = (</span>
                    <span class="s4">&quot;VALUES &quot; </span><span class="s3">if </span><span class="s1">self.dialect.tuple_in_values </span><span class="s3">else </span><span class="s4">&quot;&quot;</span>
                <span class="s1">) + self.visit_empty_set_op_expr(</span>
                    <span class="s1">parameter.type.types</span><span class="s5">, </span><span class="s1">parameter.expand_op</span>
                <span class="s1">)</span>

            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">replacement_expression = self.visit_empty_set_op_expr(</span>
                    <span class="s1">[parameter.type]</span><span class="s5">, </span><span class="s1">parameter.expand_op</span>
                <span class="s1">)</span>

        <span class="s3">elif </span><span class="s1">typ_dialect_impl._is_tuple_type </span><span class="s3">or </span><span class="s1">(</span>
            <span class="s1">typ_dialect_impl._isnull</span>
            <span class="s3">and </span><span class="s1">isinstance(values[</span><span class="s6">0</span><span class="s1">]</span><span class="s5">, </span><span class="s1">collections_abc.Sequence)</span>
            <span class="s3">and not </span><span class="s1">isinstance(values[</span><span class="s6">0</span><span class="s1">]</span><span class="s5">, </span><span class="s1">(str</span><span class="s5">, </span><span class="s1">bytes))</span>
        <span class="s1">):</span>
            <span class="s3">if </span><span class="s1">typ_dialect_impl._has_bind_expression:</span>
                <span class="s3">raise </span><span class="s1">NotImplementedError(</span>
                    <span class="s4">&quot;bind_expression() on TupleType not supported with &quot;</span>
                    <span class="s4">&quot;literal_binds&quot;</span>
                <span class="s1">)</span>

            <span class="s1">replacement_expression = (</span>
                <span class="s4">&quot;VALUES &quot; </span><span class="s3">if </span><span class="s1">self.dialect.tuple_in_values </span><span class="s3">else </span><span class="s4">&quot;&quot;</span>
            <span class="s1">) + </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
                <span class="s4">&quot;(%s)&quot;</span>
                <span class="s1">% (</span>
                    <span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
                        <span class="s1">self.render_literal_value(value</span><span class="s5">, </span><span class="s1">param_type)</span>
                        <span class="s3">for </span><span class="s1">value</span><span class="s5">, </span><span class="s1">param_type </span><span class="s3">in </span><span class="s1">zip(</span>
                            <span class="s1">tuple_element</span><span class="s5">, </span><span class="s1">parameter.type.types</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
                <span class="s3">for </span><span class="s1">i</span><span class="s5">, </span><span class="s1">tuple_element </span><span class="s3">in </span><span class="s1">enumerate(values)</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">bind_expression_template:</span>
                <span class="s1">post_compile_pattern = self._post_compile_pattern</span>
                <span class="s1">m = post_compile_pattern.search(bind_expression_template)</span>
                <span class="s3">assert </span><span class="s1">m </span><span class="s3">and </span><span class="s1">m.group(</span>
                    <span class="s6">2</span>
                <span class="s1">)</span><span class="s5">, </span><span class="s4">&quot;unexpected format for expanding parameter&quot;</span>

                <span class="s1">tok = m.group(</span><span class="s6">2</span><span class="s1">).split(</span><span class="s4">&quot;~~&quot;</span><span class="s1">)</span>
                <span class="s1">be_left</span><span class="s5">, </span><span class="s1">be_right = tok[</span><span class="s6">1</span><span class="s1">]</span><span class="s5">, </span><span class="s1">tok[</span><span class="s6">3</span><span class="s1">]</span>
                <span class="s1">replacement_expression = </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
                    <span class="s4">&quot;%s%s%s&quot;</span>
                    <span class="s1">% (</span>
                        <span class="s1">be_left</span><span class="s5">,</span>
                        <span class="s1">self.render_literal_value(value</span><span class="s5">, </span><span class="s1">parameter.type)</span><span class="s5">,</span>
                        <span class="s1">be_right</span><span class="s5">,</span>
                    <span class="s1">)</span>
                    <span class="s3">for </span><span class="s1">value </span><span class="s3">in </span><span class="s1">values</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">replacement_expression = </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
                    <span class="s1">self.render_literal_value(value</span><span class="s5">, </span><span class="s1">parameter.type)</span>
                    <span class="s3">for </span><span class="s1">value </span><span class="s3">in </span><span class="s1">values</span>
                <span class="s1">)</span>

        <span class="s3">return </span><span class="s1">()</span><span class="s5">, </span><span class="s1">replacement_expression</span>

    <span class="s3">def </span><span class="s1">_literal_execute_expanding_parameter(self</span><span class="s5">, </span><span class="s1">name</span><span class="s5">, </span><span class="s1">parameter</span><span class="s5">, </span><span class="s1">values):</span>
        <span class="s3">if </span><span class="s1">parameter.literal_execute:</span>
            <span class="s3">return </span><span class="s1">self._literal_execute_expanding_parameter_literal_binds(</span>
                <span class="s1">parameter</span><span class="s5">, </span><span class="s1">values</span>
            <span class="s1">)</span>

        <span class="s1">dialect = self.dialect</span>
        <span class="s1">typ_dialect_impl = parameter.type._unwrapped_dialect_impl(dialect)</span>

        <span class="s3">if </span><span class="s1">self._numeric_binds:</span>
            <span class="s1">bind_template = self.compilation_bindtemplate</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">bind_template = self.bindtemplate</span>

        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">self.dialect._bind_typing_render_casts</span>
            <span class="s3">and </span><span class="s1">typ_dialect_impl.render_bind_cast</span>
        <span class="s1">):</span>

            <span class="s3">def </span><span class="s1">_render_bindtemplate(name):</span>
                <span class="s3">return </span><span class="s1">self.render_bind_cast(</span>
                    <span class="s1">parameter.type</span><span class="s5">,</span>
                    <span class="s1">typ_dialect_impl</span><span class="s5">,</span>
                    <span class="s1">bind_template % {</span><span class="s4">&quot;name&quot;</span><span class="s1">: name}</span><span class="s5">,</span>
                <span class="s1">)</span>

        <span class="s3">else</span><span class="s1">:</span>

            <span class="s3">def </span><span class="s1">_render_bindtemplate(name):</span>
                <span class="s3">return </span><span class="s1">bind_template % {</span><span class="s4">&quot;name&quot;</span><span class="s1">: name}</span>

        <span class="s3">if not </span><span class="s1">values:</span>
            <span class="s1">to_update = []</span>
            <span class="s3">if </span><span class="s1">typ_dialect_impl._is_tuple_type:</span>
                <span class="s1">replacement_expression = self.visit_empty_set_op_expr(</span>
                    <span class="s1">parameter.type.types</span><span class="s5">, </span><span class="s1">parameter.expand_op</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">replacement_expression = self.visit_empty_set_op_expr(</span>
                    <span class="s1">[parameter.type]</span><span class="s5">, </span><span class="s1">parameter.expand_op</span>
                <span class="s1">)</span>

        <span class="s3">elif </span><span class="s1">typ_dialect_impl._is_tuple_type </span><span class="s3">or </span><span class="s1">(</span>
            <span class="s1">typ_dialect_impl._isnull</span>
            <span class="s3">and </span><span class="s1">isinstance(values[</span><span class="s6">0</span><span class="s1">]</span><span class="s5">, </span><span class="s1">collections_abc.Sequence)</span>
            <span class="s3">and not </span><span class="s1">isinstance(values[</span><span class="s6">0</span><span class="s1">]</span><span class="s5">, </span><span class="s1">(str</span><span class="s5">, </span><span class="s1">bytes))</span>
        <span class="s1">):</span>
            <span class="s3">assert not </span><span class="s1">typ_dialect_impl._is_array</span>
            <span class="s1">to_update = [</span>
                <span class="s1">(</span><span class="s4">&quot;%s_%s_%s&quot; </span><span class="s1">% (name</span><span class="s5">, </span><span class="s1">i</span><span class="s5">, </span><span class="s1">j)</span><span class="s5">, </span><span class="s1">value)</span>
                <span class="s3">for </span><span class="s1">i</span><span class="s5">, </span><span class="s1">tuple_element </span><span class="s3">in </span><span class="s1">enumerate(values</span><span class="s5">, </span><span class="s6">1</span><span class="s1">)</span>
                <span class="s3">for </span><span class="s1">j</span><span class="s5">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">enumerate(tuple_element</span><span class="s5">, </span><span class="s6">1</span><span class="s1">)</span>
            <span class="s1">]</span>

            <span class="s1">replacement_expression = (</span>
                <span class="s4">&quot;VALUES &quot; </span><span class="s3">if </span><span class="s1">dialect.tuple_in_values </span><span class="s3">else </span><span class="s4">&quot;&quot;</span>
            <span class="s1">) + </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
                <span class="s4">&quot;(%s)&quot;</span>
                <span class="s1">% (</span>
                    <span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
                        <span class="s1">_render_bindtemplate(</span>
                            <span class="s1">to_update[i * len(tuple_element) + j][</span><span class="s6">0</span><span class="s1">]</span>
                        <span class="s1">)</span>
                        <span class="s3">for </span><span class="s1">j</span><span class="s5">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">enumerate(tuple_element)</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
                <span class="s3">for </span><span class="s1">i</span><span class="s5">, </span><span class="s1">tuple_element </span><span class="s3">in </span><span class="s1">enumerate(values)</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">to_update = [</span>
                <span class="s1">(</span><span class="s4">&quot;%s_%s&quot; </span><span class="s1">% (name</span><span class="s5">, </span><span class="s1">i)</span><span class="s5">, </span><span class="s1">value)</span>
                <span class="s3">for </span><span class="s1">i</span><span class="s5">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">enumerate(values</span><span class="s5">, </span><span class="s6">1</span><span class="s1">)</span>
            <span class="s1">]</span>
            <span class="s1">replacement_expression = </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
                <span class="s1">_render_bindtemplate(key) </span><span class="s3">for </span><span class="s1">key</span><span class="s5">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">to_update</span>
            <span class="s1">)</span>

        <span class="s3">return </span><span class="s1">to_update</span><span class="s5">, </span><span class="s1">replacement_expression</span>

    <span class="s3">def </span><span class="s1">visit_binary(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">binary</span><span class="s5">,</span>
        <span class="s1">override_operator=</span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">eager_grouping=</span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">from_linter=</span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">lateral_from_linter=</span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">**kw</span><span class="s5">,</span>
    <span class="s1">):</span>
        <span class="s3">if </span><span class="s1">from_linter </span><span class="s3">and </span><span class="s1">operators.is_comparison(binary.operator):</span>
            <span class="s3">if </span><span class="s1">lateral_from_linter </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">enclosing_lateral = kw[</span><span class="s4">&quot;enclosing_lateral&quot;</span><span class="s1">]</span>
                <span class="s1">lateral_from_linter.edges.update(</span>
                    <span class="s1">itertools.product(</span>
                        <span class="s1">_de_clone(</span>
                            <span class="s1">binary.left._from_objects + [enclosing_lateral]</span>
                        <span class="s1">)</span><span class="s5">,</span>
                        <span class="s1">_de_clone(</span>
                            <span class="s1">binary.right._from_objects + [enclosing_lateral]</span>
                        <span class="s1">)</span><span class="s5">,</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">from_linter.edges.update(</span>
                    <span class="s1">itertools.product(</span>
                        <span class="s1">_de_clone(binary.left._from_objects)</span><span class="s5">,</span>
                        <span class="s1">_de_clone(binary.right._from_objects)</span><span class="s5">,</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>

        <span class="s0"># don't allow &quot;? = ?&quot; to render</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">self.ansi_bind_rules</span>
            <span class="s3">and </span><span class="s1">isinstance(binary.left</span><span class="s5">, </span><span class="s1">elements.BindParameter)</span>
            <span class="s3">and </span><span class="s1">isinstance(binary.right</span><span class="s5">, </span><span class="s1">elements.BindParameter)</span>
        <span class="s1">):</span>
            <span class="s1">kw[</span><span class="s4">&quot;literal_execute&quot;</span><span class="s1">] = </span><span class="s3">True</span>

        <span class="s1">operator_ = override_operator </span><span class="s3">or </span><span class="s1">binary.operator</span>
        <span class="s1">disp = self._get_operator_dispatch(operator_</span><span class="s5">, </span><span class="s4">&quot;binary&quot;</span><span class="s5">, </span><span class="s3">None</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">disp:</span>
            <span class="s3">return </span><span class="s1">disp(binary</span><span class="s5">, </span><span class="s1">operator_</span><span class="s5">, </span><span class="s1">**kw)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">opstring = OPERATORS[operator_]</span>
            <span class="s3">except </span><span class="s1">KeyError </span><span class="s3">as </span><span class="s1">err:</span>
                <span class="s3">raise </span><span class="s1">exc.UnsupportedCompilationError(self</span><span class="s5">, </span><span class="s1">operator_) </span><span class="s3">from </span><span class="s1">err</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">self._generate_generic_binary(</span>
                    <span class="s1">binary</span><span class="s5">,</span>
                    <span class="s1">opstring</span><span class="s5">,</span>
                    <span class="s1">from_linter=from_linter</span><span class="s5">,</span>
                    <span class="s1">lateral_from_linter=lateral_from_linter</span><span class="s5">,</span>
                    <span class="s1">**kw</span><span class="s5">,</span>
                <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_function_as_comparison_op_binary(self</span><span class="s5">, </span><span class="s1">element</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self.process(element.sql_function</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_mod_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">if </span><span class="s1">self.preparer._double_percents:</span>
            <span class="s3">return </span><span class="s1">(</span>
                <span class="s1">self.process(binary.left</span><span class="s5">, </span><span class="s1">**kw)</span>
                <span class="s1">+ </span><span class="s4">&quot; %% &quot;</span>
                <span class="s1">+ self.process(binary.right</span><span class="s5">, </span><span class="s1">**kw)</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">(</span>
                <span class="s1">self.process(binary.left</span><span class="s5">, </span><span class="s1">**kw)</span>
                <span class="s1">+ </span><span class="s4">&quot; % &quot;</span>
                <span class="s1">+ self.process(binary.right</span><span class="s5">, </span><span class="s1">**kw)</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_custom_op_binary(self</span><span class="s5">, </span><span class="s1">element</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">kw[</span><span class="s4">&quot;eager_grouping&quot;</span><span class="s1">] = operator.eager_grouping</span>
        <span class="s3">return </span><span class="s1">self._generate_generic_binary(</span>
            <span class="s1">element</span><span class="s5">,</span>
            <span class="s4">&quot; &quot; </span><span class="s1">+ self.escape_literal_column(operator.opstring) + </span><span class="s4">&quot; &quot;</span><span class="s5">,</span>
            <span class="s1">**kw</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_custom_op_unary_operator(self</span><span class="s5">, </span><span class="s1">element</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self._generate_generic_unary_operator(</span>
            <span class="s1">element</span><span class="s5">, </span><span class="s1">self.escape_literal_column(operator.opstring) + </span><span class="s4">&quot; &quot;</span><span class="s5">, </span><span class="s1">**kw</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_custom_op_unary_modifier(self</span><span class="s5">, </span><span class="s1">element</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self._generate_generic_unary_modifier(</span>
            <span class="s1">element</span><span class="s5">, </span><span class="s4">&quot; &quot; </span><span class="s1">+ self.escape_literal_column(operator.opstring)</span><span class="s5">, </span><span class="s1">**kw</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_generate_generic_binary(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">opstring</span><span class="s5">, </span><span class="s1">eager_grouping=</span><span class="s3">False</span><span class="s5">, </span><span class="s1">**kw</span>
    <span class="s1">):</span>
        <span class="s1">_in_operator_expression = kw.get(</span><span class="s4">&quot;_in_operator_expression&quot;</span><span class="s5">, </span><span class="s3">False</span><span class="s1">)</span>

        <span class="s1">kw[</span><span class="s4">&quot;_in_operator_expression&quot;</span><span class="s1">] = </span><span class="s3">True</span>
        <span class="s1">kw[</span><span class="s4">&quot;_binary_op&quot;</span><span class="s1">] = binary.operator</span>
        <span class="s1">text = (</span>
            <span class="s1">binary.left._compiler_dispatch(</span>
                <span class="s1">self</span><span class="s5">, </span><span class="s1">eager_grouping=eager_grouping</span><span class="s5">, </span><span class="s1">**kw</span>
            <span class="s1">)</span>
            <span class="s1">+ opstring</span>
            <span class="s1">+ binary.right._compiler_dispatch(</span>
                <span class="s1">self</span><span class="s5">, </span><span class="s1">eager_grouping=eager_grouping</span><span class="s5">, </span><span class="s1">**kw</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">_in_operator_expression </span><span class="s3">and </span><span class="s1">eager_grouping:</span>
            <span class="s1">text = </span><span class="s4">&quot;(%s)&quot; </span><span class="s1">% text</span>
        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">_generate_generic_unary_operator(self</span><span class="s5">, </span><span class="s1">unary</span><span class="s5">, </span><span class="s1">opstring</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">opstring + unary.element._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">_generate_generic_unary_modifier(self</span><span class="s5">, </span><span class="s1">unary</span><span class="s5">, </span><span class="s1">opstring</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">unary.element._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kw) + opstring</span>

    <span class="s1">@util.memoized_property</span>
    <span class="s3">def </span><span class="s1">_like_percent_literal(self):</span>
        <span class="s3">return </span><span class="s1">elements.literal_column(</span><span class="s4">&quot;'%'&quot;</span><span class="s5">, </span><span class="s1">type_=sqltypes.STRINGTYPE)</span>

    <span class="s3">def </span><span class="s1">visit_ilike_case_insensitive_operand(self</span><span class="s5">, </span><span class="s1">element</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">f&quot;lower(</span><span class="s7">{</span><span class="s1">element.element._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kw)</span><span class="s7">}</span><span class="s4">)&quot;</span>

    <span class="s3">def </span><span class="s1">visit_contains_op_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">binary = binary._clone()</span>
        <span class="s1">percent = self._like_percent_literal</span>
        <span class="s1">binary.right = percent.concat(binary.right).concat(percent)</span>
        <span class="s3">return </span><span class="s1">self.visit_like_op_binary(binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_not_contains_op_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">binary = binary._clone()</span>
        <span class="s1">percent = self._like_percent_literal</span>
        <span class="s1">binary.right = percent.concat(binary.right).concat(percent)</span>
        <span class="s3">return </span><span class="s1">self.visit_not_like_op_binary(binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_icontains_op_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">binary = binary._clone()</span>
        <span class="s1">percent = self._like_percent_literal</span>
        <span class="s1">binary.left = ilike_case_insensitive(binary.left)</span>
        <span class="s1">binary.right = percent.concat(</span>
            <span class="s1">ilike_case_insensitive(binary.right)</span>
        <span class="s1">).concat(percent)</span>
        <span class="s3">return </span><span class="s1">self.visit_ilike_op_binary(binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_not_icontains_op_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">binary = binary._clone()</span>
        <span class="s1">percent = self._like_percent_literal</span>
        <span class="s1">binary.left = ilike_case_insensitive(binary.left)</span>
        <span class="s1">binary.right = percent.concat(</span>
            <span class="s1">ilike_case_insensitive(binary.right)</span>
        <span class="s1">).concat(percent)</span>
        <span class="s3">return </span><span class="s1">self.visit_not_ilike_op_binary(binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_startswith_op_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">binary = binary._clone()</span>
        <span class="s1">percent = self._like_percent_literal</span>
        <span class="s1">binary.right = percent._rconcat(binary.right)</span>
        <span class="s3">return </span><span class="s1">self.visit_like_op_binary(binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_not_startswith_op_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">binary = binary._clone()</span>
        <span class="s1">percent = self._like_percent_literal</span>
        <span class="s1">binary.right = percent._rconcat(binary.right)</span>
        <span class="s3">return </span><span class="s1">self.visit_not_like_op_binary(binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_istartswith_op_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">binary = binary._clone()</span>
        <span class="s1">percent = self._like_percent_literal</span>
        <span class="s1">binary.left = ilike_case_insensitive(binary.left)</span>
        <span class="s1">binary.right = percent._rconcat(ilike_case_insensitive(binary.right))</span>
        <span class="s3">return </span><span class="s1">self.visit_ilike_op_binary(binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_not_istartswith_op_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">binary = binary._clone()</span>
        <span class="s1">percent = self._like_percent_literal</span>
        <span class="s1">binary.left = ilike_case_insensitive(binary.left)</span>
        <span class="s1">binary.right = percent._rconcat(ilike_case_insensitive(binary.right))</span>
        <span class="s3">return </span><span class="s1">self.visit_not_ilike_op_binary(binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_endswith_op_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">binary = binary._clone()</span>
        <span class="s1">percent = self._like_percent_literal</span>
        <span class="s1">binary.right = percent.concat(binary.right)</span>
        <span class="s3">return </span><span class="s1">self.visit_like_op_binary(binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_not_endswith_op_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">binary = binary._clone()</span>
        <span class="s1">percent = self._like_percent_literal</span>
        <span class="s1">binary.right = percent.concat(binary.right)</span>
        <span class="s3">return </span><span class="s1">self.visit_not_like_op_binary(binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_iendswith_op_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">binary = binary._clone()</span>
        <span class="s1">percent = self._like_percent_literal</span>
        <span class="s1">binary.left = ilike_case_insensitive(binary.left)</span>
        <span class="s1">binary.right = percent.concat(ilike_case_insensitive(binary.right))</span>
        <span class="s3">return </span><span class="s1">self.visit_ilike_op_binary(binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_not_iendswith_op_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">binary = binary._clone()</span>
        <span class="s1">percent = self._like_percent_literal</span>
        <span class="s1">binary.left = ilike_case_insensitive(binary.left)</span>
        <span class="s1">binary.right = percent.concat(ilike_case_insensitive(binary.right))</span>
        <span class="s3">return </span><span class="s1">self.visit_not_ilike_op_binary(binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_like_op_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">escape = binary.modifiers.get(</span><span class="s4">&quot;escape&quot;</span><span class="s5">, </span><span class="s3">None</span><span class="s1">)</span>

        <span class="s3">return </span><span class="s4">&quot;%s LIKE %s&quot; </span><span class="s1">% (</span>
            <span class="s1">binary.left._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kw)</span><span class="s5">,</span>
            <span class="s1">binary.right._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kw)</span><span class="s5">,</span>
        <span class="s1">) + (</span>
            <span class="s4">&quot; ESCAPE &quot; </span><span class="s1">+ self.render_literal_value(escape</span><span class="s5">, </span><span class="s1">sqltypes.STRINGTYPE)</span>
            <span class="s3">if </span><span class="s1">escape </span><span class="s3">is not None</span>
            <span class="s3">else </span><span class="s4">&quot;&quot;</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_not_like_op_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">escape = binary.modifiers.get(</span><span class="s4">&quot;escape&quot;</span><span class="s5">, </span><span class="s3">None</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s4">&quot;%s NOT LIKE %s&quot; </span><span class="s1">% (</span>
            <span class="s1">binary.left._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kw)</span><span class="s5">,</span>
            <span class="s1">binary.right._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kw)</span><span class="s5">,</span>
        <span class="s1">) + (</span>
            <span class="s4">&quot; ESCAPE &quot; </span><span class="s1">+ self.render_literal_value(escape</span><span class="s5">, </span><span class="s1">sqltypes.STRINGTYPE)</span>
            <span class="s3">if </span><span class="s1">escape </span><span class="s3">is not None</span>
            <span class="s3">else </span><span class="s4">&quot;&quot;</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_ilike_op_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">if </span><span class="s1">operator </span><span class="s3">is </span><span class="s1">operators.ilike_op:</span>
            <span class="s1">binary = binary._clone()</span>
            <span class="s1">binary.left = ilike_case_insensitive(binary.left)</span>
            <span class="s1">binary.right = ilike_case_insensitive(binary.right)</span>
        <span class="s0"># else we assume ilower() has been applied</span>

        <span class="s3">return </span><span class="s1">self.visit_like_op_binary(binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_not_ilike_op_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">if </span><span class="s1">operator </span><span class="s3">is </span><span class="s1">operators.not_ilike_op:</span>
            <span class="s1">binary = binary._clone()</span>
            <span class="s1">binary.left = ilike_case_insensitive(binary.left)</span>
            <span class="s1">binary.right = ilike_case_insensitive(binary.right)</span>
        <span class="s0"># else we assume ilower() has been applied</span>

        <span class="s3">return </span><span class="s1">self.visit_not_like_op_binary(binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_between_op_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">symmetric = binary.modifiers.get(</span><span class="s4">&quot;symmetric&quot;</span><span class="s5">, </span><span class="s3">False</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self._generate_generic_binary(</span>
            <span class="s1">binary</span><span class="s5">, </span><span class="s4">&quot; BETWEEN SYMMETRIC &quot; </span><span class="s3">if </span><span class="s1">symmetric </span><span class="s3">else </span><span class="s4">&quot; BETWEEN &quot;</span><span class="s5">, </span><span class="s1">**kw</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_not_between_op_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">symmetric = binary.modifiers.get(</span><span class="s4">&quot;symmetric&quot;</span><span class="s5">, </span><span class="s3">False</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self._generate_generic_binary(</span>
            <span class="s1">binary</span><span class="s5">,</span>
            <span class="s4">&quot; NOT BETWEEN SYMMETRIC &quot; </span><span class="s3">if </span><span class="s1">symmetric </span><span class="s3">else </span><span class="s4">&quot; NOT BETWEEN &quot;</span><span class="s5">,</span>
            <span class="s1">**kw</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_regexp_match_op_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
            <span class="s4">&quot;%s dialect does not support regular expressions&quot;</span>
            <span class="s1">% self.dialect.name</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_not_regexp_match_op_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
            <span class="s4">&quot;%s dialect does not support regular expressions&quot;</span>
            <span class="s1">% self.dialect.name</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_regexp_replace_op_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
            <span class="s4">&quot;%s dialect does not support regular expression replacements&quot;</span>
            <span class="s1">% self.dialect.name</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_bindparam(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">bindparam</span><span class="s5">,</span>
        <span class="s1">within_columns_clause=</span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">literal_binds=</span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">skip_bind_expression=</span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">literal_execute=</span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">render_postcompile=</span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">**kwargs</span><span class="s5">,</span>
    <span class="s1">):</span>

        <span class="s3">if not </span><span class="s1">skip_bind_expression:</span>
            <span class="s1">impl = bindparam.type.dialect_impl(self.dialect)</span>
            <span class="s3">if </span><span class="s1">impl._has_bind_expression:</span>
                <span class="s1">bind_expression = impl.bind_expression(bindparam)</span>
                <span class="s1">wrapped = self.process(</span>
                    <span class="s1">bind_expression</span><span class="s5">,</span>
                    <span class="s1">skip_bind_expression=</span><span class="s3">True</span><span class="s5">,</span>
                    <span class="s1">within_columns_clause=within_columns_clause</span><span class="s5">,</span>
                    <span class="s1">literal_binds=literal_binds </span><span class="s3">and not </span><span class="s1">bindparam.expanding</span><span class="s5">,</span>
                    <span class="s1">literal_execute=literal_execute</span><span class="s5">,</span>
                    <span class="s1">render_postcompile=render_postcompile</span><span class="s5">,</span>
                    <span class="s1">**kwargs</span><span class="s5">,</span>
                <span class="s1">)</span>
                <span class="s3">if </span><span class="s1">bindparam.expanding:</span>
                    <span class="s0"># for postcompile w/ expanding, move the &quot;wrapped&quot; part</span>
                    <span class="s0"># of this into the inside</span>

                    <span class="s1">m = re.match(</span>
                        <span class="s4">r&quot;^(.*)\(__\[POSTCOMPILE_(\S+?)\]\)(.*)$&quot;</span><span class="s5">, </span><span class="s1">wrapped</span>
                    <span class="s1">)</span>
                    <span class="s3">assert </span><span class="s1">m</span><span class="s5">, </span><span class="s4">&quot;unexpected format for expanding parameter&quot;</span>
                    <span class="s1">wrapped = </span><span class="s4">&quot;(__[POSTCOMPILE_%s~~%s~~REPL~~%s~~])&quot; </span><span class="s1">% (</span>
                        <span class="s1">m.group(</span><span class="s6">2</span><span class="s1">)</span><span class="s5">,</span>
                        <span class="s1">m.group(</span><span class="s6">1</span><span class="s1">)</span><span class="s5">,</span>
                        <span class="s1">m.group(</span><span class="s6">3</span><span class="s1">)</span><span class="s5">,</span>
                    <span class="s1">)</span>

                    <span class="s3">if </span><span class="s1">literal_binds:</span>
                        <span class="s1">ret = self.render_literal_bindparam(</span>
                            <span class="s1">bindparam</span><span class="s5">,</span>
                            <span class="s1">within_columns_clause=</span><span class="s3">True</span><span class="s5">,</span>
                            <span class="s1">bind_expression_template=wrapped</span><span class="s5">,</span>
                            <span class="s1">**kwargs</span><span class="s5">,</span>
                        <span class="s1">)</span>
                        <span class="s3">return </span><span class="s4">&quot;(%s)&quot; </span><span class="s1">% ret</span>

                <span class="s3">return </span><span class="s1">wrapped</span>

        <span class="s3">if not </span><span class="s1">literal_binds:</span>
            <span class="s1">literal_execute = (</span>
                <span class="s1">literal_execute</span>
                <span class="s3">or </span><span class="s1">bindparam.literal_execute</span>
                <span class="s3">or </span><span class="s1">(within_columns_clause </span><span class="s3">and </span><span class="s1">self.ansi_bind_rules)</span>
            <span class="s1">)</span>
            <span class="s1">post_compile = literal_execute </span><span class="s3">or </span><span class="s1">bindparam.expanding</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">post_compile = </span><span class="s3">False</span>

        <span class="s3">if </span><span class="s1">literal_binds:</span>
            <span class="s1">ret = self.render_literal_bindparam(</span>
                <span class="s1">bindparam</span><span class="s5">, </span><span class="s1">within_columns_clause=</span><span class="s3">True</span><span class="s5">, </span><span class="s1">**kwargs</span>
            <span class="s1">)</span>
            <span class="s3">if </span><span class="s1">bindparam.expanding:</span>
                <span class="s1">ret = </span><span class="s4">&quot;(%s)&quot; </span><span class="s1">% ret</span>
            <span class="s3">return </span><span class="s1">ret</span>

        <span class="s1">name = self._truncate_bindparam(bindparam)</span>

        <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">self.binds:</span>
            <span class="s1">existing = self.binds[name]</span>
            <span class="s3">if </span><span class="s1">existing </span><span class="s3">is not </span><span class="s1">bindparam:</span>
                <span class="s3">if </span><span class="s1">(</span>
                    <span class="s1">(existing.unique </span><span class="s3">or </span><span class="s1">bindparam.unique)</span>
                    <span class="s3">and not </span><span class="s1">existing.proxy_set.intersection(</span>
                        <span class="s1">bindparam.proxy_set</span>
                    <span class="s1">)</span>
                    <span class="s3">and not </span><span class="s1">existing._cloned_set.intersection(</span>
                        <span class="s1">bindparam._cloned_set</span>
                    <span class="s1">)</span>
                <span class="s1">):</span>
                    <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
                        <span class="s4">&quot;Bind parameter '%s' conflicts with &quot;</span>
                        <span class="s4">&quot;unique bind parameter of the same name&quot; </span><span class="s1">% name</span>
                    <span class="s1">)</span>
                <span class="s3">elif </span><span class="s1">existing.expanding != bindparam.expanding:</span>
                    <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
                        <span class="s4">&quot;Can't reuse bound parameter name '%s' in both &quot;</span>
                        <span class="s4">&quot;'expanding' (e.g. within an IN expression) and &quot;</span>
                        <span class="s4">&quot;non-expanding contexts.  If this parameter is to &quot;</span>
                        <span class="s4">&quot;receive a list/array value, set 'expanding=True' on &quot;</span>
                        <span class="s4">&quot;it for expressions that aren't IN, otherwise use &quot;</span>
                        <span class="s4">&quot;a different parameter name.&quot; </span><span class="s1">% (name</span><span class="s5">,</span><span class="s1">)</span>
                    <span class="s1">)</span>
                <span class="s3">elif </span><span class="s1">existing._is_crud </span><span class="s3">or </span><span class="s1">bindparam._is_crud:</span>
                    <span class="s3">if </span><span class="s1">existing._is_crud </span><span class="s3">and </span><span class="s1">bindparam._is_crud:</span>
                        <span class="s0"># TODO: this condition is not well understood.</span>
                        <span class="s0"># see tests in test/sql/test_update.py</span>
                        <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
                            <span class="s4">&quot;Encountered unsupported case when compiling an &quot;</span>
                            <span class="s4">&quot;INSERT or UPDATE statement.  If this is a &quot;</span>
                            <span class="s4">&quot;multi-table &quot;</span>
                            <span class="s4">&quot;UPDATE statement, please provide string-named &quot;</span>
                            <span class="s4">&quot;arguments to the &quot;</span>
                            <span class="s4">&quot;values() method with distinct names; support for &quot;</span>
                            <span class="s4">&quot;multi-table UPDATE statements that &quot;</span>
                            <span class="s4">&quot;target multiple tables for UPDATE is very &quot;</span>
                            <span class="s4">&quot;limited&quot;</span><span class="s5">,</span>
                        <span class="s1">)</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
                            <span class="s4">f&quot;bindparam() name '</span><span class="s7">{</span><span class="s1">bindparam.key</span><span class="s7">}</span><span class="s4">' is reserved &quot;</span>
                            <span class="s4">&quot;for automatic usage in the VALUES or SET &quot;</span>
                            <span class="s4">&quot;clause of this &quot;</span>
                            <span class="s4">&quot;insert/update statement.   Please use a &quot;</span>
                            <span class="s4">&quot;name other than column name when using &quot;</span>
                            <span class="s4">&quot;bindparam() &quot;</span>
                            <span class="s4">&quot;with insert() or update() (for example, &quot;</span>
                            <span class="s4">f&quot;'b_</span><span class="s7">{</span><span class="s1">bindparam.key</span><span class="s7">}</span><span class="s4">').&quot;</span>
                        <span class="s1">)</span>

        <span class="s1">self.binds[bindparam.key] = self.binds[name] = bindparam</span>

        <span class="s0"># if we are given a cache key that we're going to match against,</span>
        <span class="s0"># relate the bindparam here to one that is most likely present</span>
        <span class="s0"># in the &quot;extracted params&quot; portion of the cache key.  this is used</span>
        <span class="s0"># to set up a positional mapping that is used to determine the</span>
        <span class="s0"># correct parameters for a subsequent use of this compiled with</span>
        <span class="s0"># a different set of parameter values.   here, we accommodate for</span>
        <span class="s0"># parameters that may have been cloned both before and after the cache</span>
        <span class="s0"># key was been generated.</span>
        <span class="s1">ckbm_tuple = self._cache_key_bind_match</span>

        <span class="s3">if </span><span class="s1">ckbm_tuple:</span>
            <span class="s1">ckbm</span><span class="s5">, </span><span class="s1">cksm = ckbm_tuple</span>
            <span class="s3">for </span><span class="s1">bp </span><span class="s3">in </span><span class="s1">bindparam._cloned_set:</span>
                <span class="s3">if </span><span class="s1">bp.key </span><span class="s3">in </span><span class="s1">cksm:</span>
                    <span class="s1">cb = cksm[bp.key]</span>
                    <span class="s1">ckbm[cb].append(bindparam)</span>

        <span class="s3">if </span><span class="s1">bindparam.isoutparam:</span>
            <span class="s1">self.has_out_parameters = </span><span class="s3">True</span>

        <span class="s3">if </span><span class="s1">post_compile:</span>
            <span class="s3">if </span><span class="s1">render_postcompile:</span>
                <span class="s1">self._render_postcompile = </span><span class="s3">True</span>

            <span class="s3">if </span><span class="s1">literal_execute:</span>
                <span class="s1">self.literal_execute_params |= {bindparam}</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self.post_compile_params |= {bindparam}</span>

        <span class="s1">ret = self.bindparam_string(</span>
            <span class="s1">name</span><span class="s5">,</span>
            <span class="s1">post_compile=post_compile</span><span class="s5">,</span>
            <span class="s1">expanding=bindparam.expanding</span><span class="s5">,</span>
            <span class="s1">bindparam_type=bindparam.type</span><span class="s5">,</span>
            <span class="s1">**kwargs</span><span class="s5">,</span>
        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">bindparam.expanding:</span>
            <span class="s1">ret = </span><span class="s4">&quot;(%s)&quot; </span><span class="s1">% ret</span>

        <span class="s3">return </span><span class="s1">ret</span>

    <span class="s3">def </span><span class="s1">render_bind_cast(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">dbapi_type</span><span class="s5">, </span><span class="s1">sqltext):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s3">def </span><span class="s1">render_literal_bindparam(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">bindparam</span><span class="s5">,</span>
        <span class="s1">render_literal_value=NO_ARG</span><span class="s5">,</span>
        <span class="s1">bind_expression_template=</span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">**kw</span><span class="s5">,</span>
    <span class="s1">):</span>
        <span class="s3">if </span><span class="s1">render_literal_value </span><span class="s3">is not </span><span class="s1">NO_ARG:</span>
            <span class="s1">value = render_literal_value</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">bindparam.value </span><span class="s3">is None and </span><span class="s1">bindparam.callable </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">op = kw.get(</span><span class="s4">&quot;_binary_op&quot;</span><span class="s5">, </span><span class="s3">None</span><span class="s1">)</span>
                <span class="s3">if </span><span class="s1">op </span><span class="s3">and </span><span class="s1">op </span><span class="s3">not in </span><span class="s1">(operators.is_</span><span class="s5">, </span><span class="s1">operators.is_not):</span>
                    <span class="s1">util.warn_limited(</span>
                        <span class="s4">&quot;Bound parameter '%s' rendering literal NULL in a SQL &quot;</span>
                        <span class="s4">&quot;expression; comparisons to NULL should not use &quot;</span>
                        <span class="s4">&quot;operators outside of 'is' or 'is not'&quot;</span><span class="s5">,</span>
                        <span class="s1">(bindparam.key</span><span class="s5">,</span><span class="s1">)</span><span class="s5">,</span>
                    <span class="s1">)</span>
                <span class="s3">return </span><span class="s1">self.process(sqltypes.NULLTYPE</span><span class="s5">, </span><span class="s1">**kw)</span>
            <span class="s1">value = bindparam.effective_value</span>

        <span class="s3">if </span><span class="s1">bindparam.expanding:</span>
            <span class="s1">leep = self._literal_execute_expanding_parameter_literal_binds</span>
            <span class="s1">to_update</span><span class="s5">, </span><span class="s1">replacement_expr = leep(</span>
                <span class="s1">bindparam</span><span class="s5">,</span>
                <span class="s1">value</span><span class="s5">,</span>
                <span class="s1">bind_expression_template=bind_expression_template</span><span class="s5">,</span>
            <span class="s1">)</span>
            <span class="s3">return </span><span class="s1">replacement_expr</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.render_literal_value(value</span><span class="s5">, </span><span class="s1">bindparam.type)</span>

    <span class="s3">def </span><span class="s1">render_literal_value(self</span><span class="s5">, </span><span class="s1">value</span><span class="s5">, </span><span class="s1">type_):</span>
        <span class="s2">&quot;&quot;&quot;Render the value of a bind parameter as a quoted literal. 
 
        This is used for statement sections that do not accept bind parameters 
        on the target driver/database. 
 
        This should be implemented by subclasses using the quoting services 
        of the DBAPI. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">value </span><span class="s3">is None and not </span><span class="s1">type_.should_evaluate_none:</span>
            <span class="s0"># issue #10535 - handle NULL in the compiler without placing</span>
            <span class="s0"># this onto each type, except for &quot;evaluate None&quot; types</span>
            <span class="s0"># (e.g. JSON)</span>
            <span class="s3">return </span><span class="s1">self.process(elements.Null._instance())</span>

        <span class="s1">processor = type_._cached_literal_processor(self.dialect)</span>
        <span class="s3">if </span><span class="s1">processor:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">processor(value)</span>
            <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">e:</span>
                <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
                    <span class="s4">f&quot;Could not render literal value &quot;</span>
                    <span class="s4">f'&quot;</span><span class="s7">{</span><span class="s1">sql_util._repr_single_value(value)</span><span class="s7">}</span><span class="s4">&quot; '</span>
                    <span class="s4">f&quot;with datatype &quot;</span>
                    <span class="s4">f&quot;</span><span class="s7">{</span><span class="s1">type_</span><span class="s7">}</span><span class="s4">; see parent stack trace for &quot;</span>
                    <span class="s4">&quot;more detail.&quot;</span>
                <span class="s1">) </span><span class="s3">from </span><span class="s1">e</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
                <span class="s4">f&quot;No literal value renderer is available for literal value &quot;</span>
                <span class="s4">f'&quot;</span><span class="s7">{</span><span class="s1">sql_util._repr_single_value(value)</span><span class="s7">}</span><span class="s4">&quot; '</span>
                <span class="s4">f&quot;with datatype </span><span class="s7">{</span><span class="s1">type_</span><span class="s7">}</span><span class="s4">&quot;</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_truncate_bindparam(self</span><span class="s5">, </span><span class="s1">bindparam):</span>
        <span class="s3">if </span><span class="s1">bindparam </span><span class="s3">in </span><span class="s1">self.bind_names:</span>
            <span class="s3">return </span><span class="s1">self.bind_names[bindparam]</span>

        <span class="s1">bind_name = bindparam.key</span>
        <span class="s3">if </span><span class="s1">isinstance(bind_name</span><span class="s5">, </span><span class="s1">elements._truncated_label):</span>
            <span class="s1">bind_name = self._truncated_identifier(</span><span class="s4">&quot;bindparam&quot;</span><span class="s5">, </span><span class="s1">bind_name)</span>

        <span class="s0"># add to bind_names for translation</span>
        <span class="s1">self.bind_names[bindparam] = bind_name</span>

        <span class="s3">return </span><span class="s1">bind_name</span>

    <span class="s3">def </span><span class="s1">_truncated_identifier(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">ident_class: str</span><span class="s5">, </span><span class="s1">name: _truncated_label</span>
    <span class="s1">) -&gt; str:</span>
        <span class="s3">if </span><span class="s1">(ident_class</span><span class="s5">, </span><span class="s1">name) </span><span class="s3">in </span><span class="s1">self.truncated_names:</span>
            <span class="s3">return </span><span class="s1">self.truncated_names[(ident_class</span><span class="s5">, </span><span class="s1">name)]</span>

        <span class="s1">anonname = name.apply_map(self.anon_map)</span>

        <span class="s3">if </span><span class="s1">len(anonname) &gt; self.label_length - </span><span class="s6">6</span><span class="s1">:</span>
            <span class="s1">counter = self._truncated_counters.get(ident_class</span><span class="s5">, </span><span class="s6">1</span><span class="s1">)</span>
            <span class="s1">truncname = (</span>
                <span class="s1">anonname[</span><span class="s6">0 </span><span class="s1">: max(self.label_length - </span><span class="s6">6</span><span class="s5">, </span><span class="s6">0</span><span class="s1">)]</span>
                <span class="s1">+ </span><span class="s4">&quot;_&quot;</span>
                <span class="s1">+ hex(counter)[</span><span class="s6">2</span><span class="s1">:]</span>
            <span class="s1">)</span>
            <span class="s1">self._truncated_counters[ident_class] = counter + </span><span class="s6">1</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">truncname = anonname</span>
        <span class="s1">self.truncated_names[(ident_class</span><span class="s5">, </span><span class="s1">name)] = truncname</span>
        <span class="s3">return </span><span class="s1">truncname</span>

    <span class="s3">def </span><span class="s1">_anonymize(self</span><span class="s5">, </span><span class="s1">name: str) -&gt; str:</span>
        <span class="s3">return </span><span class="s1">name % self.anon_map</span>

    <span class="s3">def </span><span class="s1">bindparam_string(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">name: str</span><span class="s5">,</span>
        <span class="s1">post_compile: bool = </span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">expanding: bool = </span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">escaped_from: Optional[str] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">bindparam_type: Optional[TypeEngine[Any]] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">accumulate_bind_names: Optional[Set[str]] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">visited_bindparam: Optional[List[str]] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">**kw: Any</span><span class="s5">,</span>
    <span class="s1">) -&gt; str:</span>
        <span class="s0"># TODO: accumulate_bind_names is passed by crud.py to gather</span>
        <span class="s0"># names on a per-value basis, visited_bindparam is passed by</span>
        <span class="s0"># visit_insert() to collect all parameters in the statement.</span>
        <span class="s0"># see if this gathering can be simplified somehow</span>
        <span class="s3">if </span><span class="s1">accumulate_bind_names </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">accumulate_bind_names.add(name)</span>
        <span class="s3">if </span><span class="s1">visited_bindparam </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">visited_bindparam.append(name)</span>

        <span class="s3">if not </span><span class="s1">escaped_from:</span>
            <span class="s3">if </span><span class="s1">self._bind_translate_re.search(name):</span>
                <span class="s0"># not quite the translate use case as we want to</span>
                <span class="s0"># also get a quick boolean if we even found</span>
                <span class="s0"># unusual characters in the name</span>
                <span class="s1">new_name = self._bind_translate_re.sub(</span>
                    <span class="s3">lambda </span><span class="s1">m: self._bind_translate_chars[m.group(</span><span class="s6">0</span><span class="s1">)]</span><span class="s5">,</span>
                    <span class="s1">name</span><span class="s5">,</span>
                <span class="s1">)</span>
                <span class="s1">escaped_from = name</span>
                <span class="s1">name = new_name</span>

        <span class="s3">if </span><span class="s1">escaped_from:</span>
            <span class="s1">self.escaped_bind_names = self.escaped_bind_names.union(</span>
                <span class="s1">{escaped_from: name}</span>
            <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">post_compile:</span>
            <span class="s1">ret = </span><span class="s4">&quot;__[POSTCOMPILE_%s]&quot; </span><span class="s1">% name</span>
            <span class="s3">if </span><span class="s1">expanding:</span>
                <span class="s0"># for expanding, bound parameters or literal values will be</span>
                <span class="s0"># rendered per item</span>
                <span class="s3">return </span><span class="s1">ret</span>

            <span class="s0"># otherwise, for non-expanding &quot;literal execute&quot;, apply</span>
            <span class="s0"># bind casts as determined by the datatype</span>
            <span class="s3">if </span><span class="s1">bindparam_type </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">type_impl = bindparam_type._unwrapped_dialect_impl(</span>
                    <span class="s1">self.dialect</span>
                <span class="s1">)</span>
                <span class="s3">if </span><span class="s1">type_impl.render_literal_cast:</span>
                    <span class="s1">ret = self.render_bind_cast(bindparam_type</span><span class="s5">, </span><span class="s1">type_impl</span><span class="s5">, </span><span class="s1">ret)</span>
            <span class="s3">return </span><span class="s1">ret</span>
        <span class="s3">elif </span><span class="s1">self.state </span><span class="s3">is </span><span class="s1">CompilerState.COMPILING:</span>
            <span class="s1">ret = self.compilation_bindtemplate % {</span><span class="s4">&quot;name&quot;</span><span class="s1">: name}</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">ret = self.bindtemplate % {</span><span class="s4">&quot;name&quot;</span><span class="s1">: name}</span>

        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">bindparam_type </span><span class="s3">is not None</span>
            <span class="s3">and </span><span class="s1">self.dialect._bind_typing_render_casts</span>
        <span class="s1">):</span>
            <span class="s1">type_impl = bindparam_type._unwrapped_dialect_impl(self.dialect)</span>
            <span class="s3">if </span><span class="s1">type_impl.render_bind_cast:</span>
                <span class="s1">ret = self.render_bind_cast(bindparam_type</span><span class="s5">, </span><span class="s1">type_impl</span><span class="s5">, </span><span class="s1">ret)</span>

        <span class="s3">return </span><span class="s1">ret</span>

    <span class="s3">def </span><span class="s1">_dispatch_independent_ctes(self</span><span class="s5">, </span><span class="s1">stmt</span><span class="s5">, </span><span class="s1">kw):</span>
        <span class="s1">local_kw = kw.copy()</span>
        <span class="s1">local_kw.pop(</span><span class="s4">&quot;cte_opts&quot;</span><span class="s5">, </span><span class="s3">None</span><span class="s1">)</span>
        <span class="s3">for </span><span class="s1">cte</span><span class="s5">, </span><span class="s1">opt </span><span class="s3">in </span><span class="s1">zip(</span>
            <span class="s1">stmt._independent_ctes</span><span class="s5">, </span><span class="s1">stmt._independent_ctes_opts</span>
        <span class="s1">):</span>
            <span class="s1">cte._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">cte_opts=opt</span><span class="s5">, </span><span class="s1">**local_kw)</span>

    <span class="s3">def </span><span class="s1">visit_cte(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">cte: CTE</span><span class="s5">,</span>
        <span class="s1">asfrom: bool = </span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">ashint: bool = </span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">fromhints: Optional[_FromHintsType] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">visiting_cte: Optional[CTE] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">from_linter: Optional[FromLinter] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">cte_opts: selectable._CTEOpts = selectable._CTEOpts(</span><span class="s3">False</span><span class="s1">)</span><span class="s5">,</span>
        <span class="s1">**kwargs: Any</span><span class="s5">,</span>
    <span class="s1">) -&gt; Optional[str]:</span>
        <span class="s1">self_ctes = self._init_cte_state()</span>
        <span class="s3">assert </span><span class="s1">self_ctes </span><span class="s3">is </span><span class="s1">self.ctes</span>

        <span class="s1">kwargs[</span><span class="s4">&quot;visiting_cte&quot;</span><span class="s1">] = cte</span>

        <span class="s1">cte_name = cte.name</span>

        <span class="s3">if </span><span class="s1">isinstance(cte_name</span><span class="s5">, </span><span class="s1">elements._truncated_label):</span>
            <span class="s1">cte_name = self._truncated_identifier(</span><span class="s4">&quot;alias&quot;</span><span class="s5">, </span><span class="s1">cte_name)</span>

        <span class="s1">is_new_cte = </span><span class="s3">True</span>
        <span class="s1">embedded_in_current_named_cte = </span><span class="s3">False</span>

        <span class="s1">_reference_cte = cte._get_reference_cte()</span>

        <span class="s1">nesting = cte.nesting </span><span class="s3">or </span><span class="s1">cte_opts.nesting</span>

        <span class="s0"># check for CTE already encountered</span>
        <span class="s3">if </span><span class="s1">_reference_cte </span><span class="s3">in </span><span class="s1">self.level_name_by_cte:</span>
            <span class="s1">cte_level</span><span class="s5">, </span><span class="s1">_</span><span class="s5">, </span><span class="s1">existing_cte_opts = self.level_name_by_cte[</span>
                <span class="s1">_reference_cte</span>
            <span class="s1">]</span>
            <span class="s3">assert </span><span class="s1">_ == cte_name</span>

            <span class="s1">cte_level_name = (cte_level</span><span class="s5">, </span><span class="s1">cte_name)</span>
            <span class="s1">existing_cte = self.ctes_by_level_name[cte_level_name]</span>

            <span class="s0"># check if we are receiving it here with a specific</span>
            <span class="s0"># &quot;nest_here&quot; location; if so, move it to this location</span>

            <span class="s3">if </span><span class="s1">cte_opts.nesting:</span>
                <span class="s3">if </span><span class="s1">existing_cte_opts.nesting:</span>
                    <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
                        <span class="s4">&quot;CTE is stated as 'nest_here' in &quot;</span>
                        <span class="s4">&quot;more than one location&quot;</span>
                    <span class="s1">)</span>

                <span class="s1">old_level_name = (cte_level</span><span class="s5">, </span><span class="s1">cte_name)</span>
                <span class="s1">cte_level = len(self.stack) </span><span class="s3">if </span><span class="s1">nesting </span><span class="s3">else </span><span class="s6">1</span>
                <span class="s1">cte_level_name = new_level_name = (cte_level</span><span class="s5">, </span><span class="s1">cte_name)</span>

                <span class="s3">del </span><span class="s1">self.ctes_by_level_name[old_level_name]</span>
                <span class="s1">self.ctes_by_level_name[new_level_name] = existing_cte</span>
                <span class="s1">self.level_name_by_cte[_reference_cte] = new_level_name + (</span>
                    <span class="s1">cte_opts</span><span class="s5">,</span>
                <span class="s1">)</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">cte_level = len(self.stack) </span><span class="s3">if </span><span class="s1">nesting </span><span class="s3">else </span><span class="s6">1</span>
            <span class="s1">cte_level_name = (cte_level</span><span class="s5">, </span><span class="s1">cte_name)</span>

            <span class="s3">if </span><span class="s1">cte_level_name </span><span class="s3">in </span><span class="s1">self.ctes_by_level_name:</span>
                <span class="s1">existing_cte = self.ctes_by_level_name[cte_level_name]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">existing_cte = </span><span class="s3">None</span>

        <span class="s3">if </span><span class="s1">existing_cte </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">embedded_in_current_named_cte = visiting_cte </span><span class="s3">is </span><span class="s1">existing_cte</span>

            <span class="s0"># we've generated a same-named CTE that we are enclosed in,</span>
            <span class="s0"># or this is the same CTE.  just return the name.</span>
            <span class="s3">if </span><span class="s1">cte </span><span class="s3">is </span><span class="s1">existing_cte._restates </span><span class="s3">or </span><span class="s1">cte </span><span class="s3">is </span><span class="s1">existing_cte:</span>
                <span class="s1">is_new_cte = </span><span class="s3">False</span>
            <span class="s3">elif </span><span class="s1">existing_cte </span><span class="s3">is </span><span class="s1">cte._restates:</span>
                <span class="s0"># we've generated a same-named CTE that is</span>
                <span class="s0"># enclosed in us - we take precedence, so</span>
                <span class="s0"># discard the text for the &quot;inner&quot;.</span>
                <span class="s3">del </span><span class="s1">self_ctes[existing_cte]</span>

                <span class="s1">existing_cte_reference_cte = existing_cte._get_reference_cte()</span>

                <span class="s3">assert </span><span class="s1">existing_cte_reference_cte </span><span class="s3">is </span><span class="s1">_reference_cte</span>
                <span class="s3">assert </span><span class="s1">existing_cte_reference_cte </span><span class="s3">is </span><span class="s1">existing_cte</span>

                <span class="s3">del </span><span class="s1">self.level_name_by_cte[existing_cte_reference_cte]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># if the two CTEs are deep-copy identical, consider them</span>
                <span class="s0"># the same, **if** they are clones, that is, they came from</span>
                <span class="s0"># the ORM or other visit method</span>
                <span class="s3">if </span><span class="s1">(</span>
                    <span class="s1">cte._is_clone_of </span><span class="s3">is not None</span>
                    <span class="s3">or </span><span class="s1">existing_cte._is_clone_of </span><span class="s3">is not None</span>
                <span class="s1">) </span><span class="s3">and </span><span class="s1">cte.compare(existing_cte):</span>
                    <span class="s1">is_new_cte = </span><span class="s3">False</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
                        <span class="s4">&quot;Multiple, unrelated CTEs found with &quot;</span>
                        <span class="s4">&quot;the same name: %r&quot; </span><span class="s1">% cte_name</span>
                    <span class="s1">)</span>

        <span class="s3">if not </span><span class="s1">asfrom </span><span class="s3">and not </span><span class="s1">is_new_cte:</span>
            <span class="s3">return None</span>

        <span class="s3">if </span><span class="s1">cte._cte_alias </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">pre_alias_cte = cte._cte_alias</span>
            <span class="s1">cte_pre_alias_name = cte._cte_alias.name</span>
            <span class="s3">if </span><span class="s1">isinstance(cte_pre_alias_name</span><span class="s5">, </span><span class="s1">elements._truncated_label):</span>
                <span class="s1">cte_pre_alias_name = self._truncated_identifier(</span>
                    <span class="s4">&quot;alias&quot;</span><span class="s5">, </span><span class="s1">cte_pre_alias_name</span>
                <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">pre_alias_cte = cte</span>
            <span class="s1">cte_pre_alias_name = </span><span class="s3">None</span>

        <span class="s3">if </span><span class="s1">is_new_cte:</span>
            <span class="s1">self.ctes_by_level_name[cte_level_name] = cte</span>
            <span class="s1">self.level_name_by_cte[_reference_cte] = cte_level_name + (</span>
                <span class="s1">cte_opts</span><span class="s5">,</span>
            <span class="s1">)</span>

            <span class="s3">if </span><span class="s1">pre_alias_cte </span><span class="s3">not in </span><span class="s1">self.ctes:</span>
                <span class="s1">self.visit_cte(pre_alias_cte</span><span class="s5">, </span><span class="s1">**kwargs)</span>

            <span class="s3">if not </span><span class="s1">cte_pre_alias_name </span><span class="s3">and </span><span class="s1">cte </span><span class="s3">not in </span><span class="s1">self_ctes:</span>
                <span class="s3">if </span><span class="s1">cte.recursive:</span>
                    <span class="s1">self.ctes_recursive = </span><span class="s3">True</span>
                <span class="s1">text = self.preparer.format_alias(cte</span><span class="s5">, </span><span class="s1">cte_name)</span>
                <span class="s3">if </span><span class="s1">cte.recursive:</span>
                    <span class="s1">col_source = cte.element</span>

                    <span class="s0"># TODO: can we get at the .columns_plus_names collection</span>
                    <span class="s0"># that is already (or will be?) generated for the SELECT</span>
                    <span class="s0"># rather than calling twice?</span>
                    <span class="s1">recur_cols = [</span>
                        <span class="s0"># TODO: proxy_name is not technically safe,</span>
                        <span class="s0"># see test_cte-&gt;</span>
                        <span class="s0"># test_with_recursive_no_name_currently_buggy.  not</span>
                        <span class="s0"># clear what should be done with such a case</span>
                        <span class="s1">fallback_label_name </span><span class="s3">or </span><span class="s1">proxy_name</span>
                        <span class="s3">for </span><span class="s1">(</span>
                            <span class="s1">_</span><span class="s5">,</span>
                            <span class="s1">proxy_name</span><span class="s5">,</span>
                            <span class="s1">fallback_label_name</span><span class="s5">,</span>
                            <span class="s1">c</span><span class="s5">,</span>
                            <span class="s1">repeated</span><span class="s5">,</span>
                        <span class="s1">) </span><span class="s3">in </span><span class="s1">(col_source._generate_columns_plus_names(</span><span class="s3">True</span><span class="s1">))</span>
                        <span class="s3">if not </span><span class="s1">repeated</span>
                    <span class="s1">]</span>

                    <span class="s1">text += </span><span class="s4">&quot;(%s)&quot; </span><span class="s1">% (</span>
                        <span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
                            <span class="s1">self.preparer.format_label_name(</span>
                                <span class="s1">ident</span><span class="s5">, </span><span class="s1">anon_map=self.anon_map</span>
                            <span class="s1">)</span>
                            <span class="s3">for </span><span class="s1">ident </span><span class="s3">in </span><span class="s1">recur_cols</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>

                <span class="s3">assert </span><span class="s1">kwargs.get(</span><span class="s4">&quot;subquery&quot;</span><span class="s5">, </span><span class="s3">False</span><span class="s1">) </span><span class="s3">is False</span>

                <span class="s3">if not </span><span class="s1">self.stack:</span>
                    <span class="s0"># toplevel, this is a stringify of the</span>
                    <span class="s0"># cte directly.  just compile the inner</span>
                    <span class="s0"># the way alias() does.</span>
                    <span class="s3">return </span><span class="s1">cte.element._compiler_dispatch(</span>
                        <span class="s1">self</span><span class="s5">, </span><span class="s1">asfrom=asfrom</span><span class="s5">, </span><span class="s1">**kwargs</span>
                    <span class="s1">)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">prefixes = self._generate_prefixes(</span>
                        <span class="s1">cte</span><span class="s5">, </span><span class="s1">cte._prefixes</span><span class="s5">, </span><span class="s1">**kwargs</span>
                    <span class="s1">)</span>
                    <span class="s1">inner = cte.element._compiler_dispatch(</span>
                        <span class="s1">self</span><span class="s5">, </span><span class="s1">asfrom=</span><span class="s3">True</span><span class="s5">, </span><span class="s1">**kwargs</span>
                    <span class="s1">)</span>

                    <span class="s1">text += </span><span class="s4">&quot; AS %s</span><span class="s7">\n</span><span class="s4">(%s)&quot; </span><span class="s1">% (prefixes</span><span class="s5">, </span><span class="s1">inner)</span>

                <span class="s3">if </span><span class="s1">cte._suffixes:</span>
                    <span class="s1">text += </span><span class="s4">&quot; &quot; </span><span class="s1">+ self._generate_prefixes(</span>
                        <span class="s1">cte</span><span class="s5">, </span><span class="s1">cte._suffixes</span><span class="s5">, </span><span class="s1">**kwargs</span>
                    <span class="s1">)</span>

                <span class="s1">self_ctes[cte] = text</span>

        <span class="s3">if </span><span class="s1">asfrom:</span>
            <span class="s3">if </span><span class="s1">from_linter:</span>
                <span class="s1">from_linter.froms[cte._de_clone()] = cte_name</span>

            <span class="s3">if not </span><span class="s1">is_new_cte </span><span class="s3">and </span><span class="s1">embedded_in_current_named_cte:</span>
                <span class="s3">return </span><span class="s1">self.preparer.format_alias(cte</span><span class="s5">, </span><span class="s1">cte_name)</span>

            <span class="s3">if </span><span class="s1">cte_pre_alias_name:</span>
                <span class="s1">text = self.preparer.format_alias(cte</span><span class="s5">, </span><span class="s1">cte_pre_alias_name)</span>
                <span class="s3">if </span><span class="s1">self.preparer._requires_quotes(cte_name):</span>
                    <span class="s1">cte_name = self.preparer.quote(cte_name)</span>
                <span class="s1">text += self.get_render_as_alias_suffix(cte_name)</span>
                <span class="s3">return </span><span class="s1">text</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">self.preparer.format_alias(cte</span><span class="s5">, </span><span class="s1">cte_name)</span>

        <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">visit_table_valued_alias(self</span><span class="s5">, </span><span class="s1">element</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">if </span><span class="s1">element.joins_implicitly:</span>
            <span class="s1">kw[</span><span class="s4">&quot;from_linter&quot;</span><span class="s1">] = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">element._is_lateral:</span>
            <span class="s3">return </span><span class="s1">self.visit_lateral(element</span><span class="s5">, </span><span class="s1">**kw)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.visit_alias(element</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_table_valued_column(self</span><span class="s5">, </span><span class="s1">element</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self.visit_column(element</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_alias(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">alias</span><span class="s5">,</span>
        <span class="s1">asfrom=</span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">ashint=</span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">iscrud=</span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">fromhints=</span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">subquery=</span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">lateral=</span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">enclosing_alias=</span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">from_linter=</span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">**kwargs</span><span class="s5">,</span>
    <span class="s1">):</span>
        <span class="s3">if </span><span class="s1">lateral:</span>
            <span class="s3">if </span><span class="s4">&quot;enclosing_lateral&quot; </span><span class="s3">not in </span><span class="s1">kwargs:</span>
                <span class="s0"># if lateral is set and enclosing_lateral is not</span>
                <span class="s0"># present, we assume we are being called directly</span>
                <span class="s0"># from visit_lateral() and we need to set enclosing_lateral.</span>
                <span class="s3">assert </span><span class="s1">alias._is_lateral</span>
                <span class="s1">kwargs[</span><span class="s4">&quot;enclosing_lateral&quot;</span><span class="s1">] = alias</span>

            <span class="s0"># for lateral objects, we track a second from_linter that is...</span>
            <span class="s0"># lateral!  to the level above us.</span>
            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">from_linter</span>
                <span class="s3">and </span><span class="s4">&quot;lateral_from_linter&quot; </span><span class="s3">not in </span><span class="s1">kwargs</span>
                <span class="s3">and </span><span class="s4">&quot;enclosing_lateral&quot; </span><span class="s3">in </span><span class="s1">kwargs</span>
            <span class="s1">):</span>
                <span class="s1">kwargs[</span><span class="s4">&quot;lateral_from_linter&quot;</span><span class="s1">] = from_linter</span>

        <span class="s3">if </span><span class="s1">enclosing_alias </span><span class="s3">is not None and </span><span class="s1">enclosing_alias.element </span><span class="s3">is </span><span class="s1">alias:</span>
            <span class="s1">inner = alias.element._compiler_dispatch(</span>
                <span class="s1">self</span><span class="s5">,</span>
                <span class="s1">asfrom=asfrom</span><span class="s5">,</span>
                <span class="s1">ashint=ashint</span><span class="s5">,</span>
                <span class="s1">iscrud=iscrud</span><span class="s5">,</span>
                <span class="s1">fromhints=fromhints</span><span class="s5">,</span>
                <span class="s1">lateral=lateral</span><span class="s5">,</span>
                <span class="s1">enclosing_alias=alias</span><span class="s5">,</span>
                <span class="s1">**kwargs</span><span class="s5">,</span>
            <span class="s1">)</span>
            <span class="s3">if </span><span class="s1">subquery </span><span class="s3">and </span><span class="s1">(asfrom </span><span class="s3">or </span><span class="s1">lateral):</span>
                <span class="s1">inner = </span><span class="s4">&quot;(%s)&quot; </span><span class="s1">% (inner</span><span class="s5">,</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">inner</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">enclosing_alias = kwargs[</span><span class="s4">&quot;enclosing_alias&quot;</span><span class="s1">] = alias</span>

        <span class="s3">if </span><span class="s1">asfrom </span><span class="s3">or </span><span class="s1">ashint:</span>
            <span class="s3">if </span><span class="s1">isinstance(alias.name</span><span class="s5">, </span><span class="s1">elements._truncated_label):</span>
                <span class="s1">alias_name = self._truncated_identifier(</span><span class="s4">&quot;alias&quot;</span><span class="s5">, </span><span class="s1">alias.name)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">alias_name = alias.name</span>

        <span class="s3">if </span><span class="s1">ashint:</span>
            <span class="s3">return </span><span class="s1">self.preparer.format_alias(alias</span><span class="s5">, </span><span class="s1">alias_name)</span>
        <span class="s3">elif </span><span class="s1">asfrom:</span>
            <span class="s3">if </span><span class="s1">from_linter:</span>
                <span class="s1">from_linter.froms[alias._de_clone()] = alias_name</span>

            <span class="s1">inner = alias.element._compiler_dispatch(</span>
                <span class="s1">self</span><span class="s5">, </span><span class="s1">asfrom=</span><span class="s3">True</span><span class="s5">, </span><span class="s1">lateral=lateral</span><span class="s5">, </span><span class="s1">**kwargs</span>
            <span class="s1">)</span>
            <span class="s3">if </span><span class="s1">subquery:</span>
                <span class="s1">inner = </span><span class="s4">&quot;(%s)&quot; </span><span class="s1">% (inner</span><span class="s5">,</span><span class="s1">)</span>

            <span class="s1">ret = inner + self.get_render_as_alias_suffix(</span>
                <span class="s1">self.preparer.format_alias(alias</span><span class="s5">, </span><span class="s1">alias_name)</span>
            <span class="s1">)</span>

            <span class="s3">if </span><span class="s1">alias._supports_derived_columns </span><span class="s3">and </span><span class="s1">alias._render_derived:</span>
                <span class="s1">ret += </span><span class="s4">&quot;(%s)&quot; </span><span class="s1">% (</span>
                    <span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
                        <span class="s4">&quot;%s%s&quot;</span>
                        <span class="s1">% (</span>
                            <span class="s1">self.preparer.quote(col.name)</span><span class="s5">,</span>
                            <span class="s1">(</span>
                                <span class="s4">&quot; %s&quot;</span>
                                <span class="s1">% self.dialect.type_compiler_instance.process(</span>
                                    <span class="s1">col.type</span><span class="s5">, </span><span class="s1">**kwargs</span>
                                <span class="s1">)</span>
                                <span class="s3">if </span><span class="s1">alias._render_derived_w_types</span>
                                <span class="s3">else </span><span class="s4">&quot;&quot;</span>
                            <span class="s1">)</span><span class="s5">,</span>
                        <span class="s1">)</span>
                        <span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">alias.c</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>

            <span class="s3">if </span><span class="s1">fromhints </span><span class="s3">and </span><span class="s1">alias </span><span class="s3">in </span><span class="s1">fromhints:</span>
                <span class="s1">ret = self.format_from_hint_text(</span>
                    <span class="s1">ret</span><span class="s5">, </span><span class="s1">alias</span><span class="s5">, </span><span class="s1">fromhints[alias]</span><span class="s5">, </span><span class="s1">iscrud</span>
                <span class="s1">)</span>

            <span class="s3">return </span><span class="s1">ret</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># note we cancel the &quot;subquery&quot; flag here as well</span>
            <span class="s3">return </span><span class="s1">alias.element._compiler_dispatch(</span>
                <span class="s1">self</span><span class="s5">, </span><span class="s1">lateral=lateral</span><span class="s5">, </span><span class="s1">**kwargs</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_subquery(self</span><span class="s5">, </span><span class="s1">subquery</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">kw[</span><span class="s4">&quot;subquery&quot;</span><span class="s1">] = </span><span class="s3">True</span>
        <span class="s3">return </span><span class="s1">self.visit_alias(subquery</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_lateral(self</span><span class="s5">, </span><span class="s1">lateral_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">kw[</span><span class="s4">&quot;lateral&quot;</span><span class="s1">] = </span><span class="s3">True</span>
        <span class="s3">return </span><span class="s4">&quot;LATERAL %s&quot; </span><span class="s1">% self.visit_alias(lateral_</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_tablesample(self</span><span class="s5">, </span><span class="s1">tablesample</span><span class="s5">, </span><span class="s1">asfrom=</span><span class="s3">False</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">text = </span><span class="s4">&quot;%s TABLESAMPLE %s&quot; </span><span class="s1">% (</span>
            <span class="s1">self.visit_alias(tablesample</span><span class="s5">, </span><span class="s1">asfrom=</span><span class="s3">True</span><span class="s5">, </span><span class="s1">**kw)</span><span class="s5">,</span>
            <span class="s1">tablesample._get_method()._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kw)</span><span class="s5">,</span>
        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">tablesample.seed </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">text += </span><span class="s4">&quot; REPEATABLE (%s)&quot; </span><span class="s1">% (</span>
                <span class="s1">tablesample.seed._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kw)</span>
            <span class="s1">)</span>

        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">_render_values(self</span><span class="s5">, </span><span class="s1">element</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">kw.setdefault(</span><span class="s4">&quot;literal_binds&quot;</span><span class="s5">, </span><span class="s1">element.literal_binds)</span>
        <span class="s1">tuples = </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
            <span class="s1">self.process(</span>
                <span class="s1">elements.Tuple(</span>
                    <span class="s1">types=element._column_types</span><span class="s5">, </span><span class="s1">*elem</span>
                <span class="s1">).self_group()</span><span class="s5">,</span>
                <span class="s1">**kw</span><span class="s5">,</span>
            <span class="s1">)</span>
            <span class="s3">for </span><span class="s1">chunk </span><span class="s3">in </span><span class="s1">element._data</span>
            <span class="s3">for </span><span class="s1">elem </span><span class="s3">in </span><span class="s1">chunk</span>
        <span class="s1">)</span>
        <span class="s3">return </span><span class="s4">f&quot;VALUES </span><span class="s7">{</span><span class="s1">tuples</span><span class="s7">}</span><span class="s4">&quot;</span>

    <span class="s3">def </span><span class="s1">visit_values(self</span><span class="s5">, </span><span class="s1">element</span><span class="s5">, </span><span class="s1">asfrom=</span><span class="s3">False</span><span class="s5">, </span><span class="s1">from_linter=</span><span class="s3">None</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">v = self._render_values(element</span><span class="s5">, </span><span class="s1">**kw)</span>

        <span class="s3">if </span><span class="s1">element._unnamed:</span>
            <span class="s1">name = </span><span class="s3">None</span>
        <span class="s3">elif </span><span class="s1">isinstance(element.name</span><span class="s5">, </span><span class="s1">elements._truncated_label):</span>
            <span class="s1">name = self._truncated_identifier(</span><span class="s4">&quot;values&quot;</span><span class="s5">, </span><span class="s1">element.name)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">name = element.name</span>

        <span class="s3">if </span><span class="s1">element._is_lateral:</span>
            <span class="s1">lateral = </span><span class="s4">&quot;LATERAL &quot;</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">lateral = </span><span class="s4">&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">asfrom:</span>
            <span class="s3">if </span><span class="s1">from_linter:</span>
                <span class="s1">from_linter.froms[element._de_clone()] = (</span>
                    <span class="s1">name </span><span class="s3">if </span><span class="s1">name </span><span class="s3">is not None else </span><span class="s4">&quot;(unnamed VALUES element)&quot;</span>
                <span class="s1">)</span>

            <span class="s3">if </span><span class="s1">name:</span>
                <span class="s1">kw[</span><span class="s4">&quot;include_table&quot;</span><span class="s1">] = </span><span class="s3">False</span>
                <span class="s1">v = </span><span class="s4">&quot;%s(%s)%s (%s)&quot; </span><span class="s1">% (</span>
                    <span class="s1">lateral</span><span class="s5">,</span>
                    <span class="s1">v</span><span class="s5">,</span>
                    <span class="s1">self.get_render_as_alias_suffix(self.preparer.quote(name))</span><span class="s5">,</span>
                    <span class="s1">(</span>
                        <span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
                            <span class="s1">c._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kw)</span>
                            <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">element.columns</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span><span class="s5">,</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">v = </span><span class="s4">&quot;%s(%s)&quot; </span><span class="s1">% (lateral</span><span class="s5">, </span><span class="s1">v)</span>
        <span class="s3">return </span><span class="s1">v</span>

    <span class="s3">def </span><span class="s1">visit_scalar_values(self</span><span class="s5">, </span><span class="s1">element</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">f&quot;(</span><span class="s7">{</span><span class="s1">self._render_values(element</span><span class="s5">, </span><span class="s1">**kw)</span><span class="s7">}</span><span class="s4">)&quot;</span>

    <span class="s3">def </span><span class="s1">get_render_as_alias_suffix(self</span><span class="s5">, </span><span class="s1">alias_name_text):</span>
        <span class="s3">return </span><span class="s4">&quot; AS &quot; </span><span class="s1">+ alias_name_text</span>

    <span class="s3">def </span><span class="s1">_add_to_result_map(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">keyname: str</span><span class="s5">,</span>
        <span class="s1">name: str</span><span class="s5">,</span>
        <span class="s1">objects: Tuple[Any</span><span class="s5">, </span><span class="s1">...]</span><span class="s5">,</span>
        <span class="s1">type_: TypeEngine[Any]</span><span class="s5">,</span>
    <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>

        <span class="s0"># note objects must be non-empty for cursor.py to handle the</span>
        <span class="s0"># collection properly</span>
        <span class="s3">assert </span><span class="s1">objects</span>

        <span class="s3">if </span><span class="s1">keyname </span><span class="s3">is None or </span><span class="s1">keyname == </span><span class="s4">&quot;*&quot;</span><span class="s1">:</span>
            <span class="s1">self._ordered_columns = </span><span class="s3">False</span>
            <span class="s1">self._ad_hoc_textual = </span><span class="s3">True</span>
        <span class="s3">if </span><span class="s1">type_._is_tuple_type:</span>
            <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
                <span class="s4">&quot;Most backends don't support SELECTing &quot;</span>
                <span class="s4">&quot;from a tuple() object.  If this is an ORM query, &quot;</span>
                <span class="s4">&quot;consider using the Bundle object.&quot;</span>
            <span class="s1">)</span>
        <span class="s1">self._result_columns.append(</span>
            <span class="s1">ResultColumnsEntry(keyname</span><span class="s5">, </span><span class="s1">name</span><span class="s5">, </span><span class="s1">objects</span><span class="s5">, </span><span class="s1">type_)</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_label_returning_column(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">stmt</span><span class="s5">, </span><span class="s1">column</span><span class="s5">, </span><span class="s1">populate_result_map</span><span class="s5">, </span><span class="s1">column_clause_args=</span><span class="s3">None</span><span class="s5">, </span><span class="s1">**kw</span>
    <span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Render a column with necessary labels inside of a RETURNING clause. 
 
        This method is provided for individual dialects in place of calling 
        the _label_select_column method directly, so that the two use cases 
        of RETURNING vs. SELECT can be disambiguated going forward. 
 
        .. versionadded:: 1.4.21 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._label_select_column(</span>
            <span class="s3">None</span><span class="s5">,</span>
            <span class="s1">column</span><span class="s5">,</span>
            <span class="s1">populate_result_map</span><span class="s5">,</span>
            <span class="s3">False</span><span class="s5">,</span>
            <span class="s1">{} </span><span class="s3">if </span><span class="s1">column_clause_args </span><span class="s3">is None else </span><span class="s1">column_clause_args</span><span class="s5">,</span>
            <span class="s1">**kw</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_label_select_column(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">select</span><span class="s5">,</span>
        <span class="s1">column</span><span class="s5">,</span>
        <span class="s1">populate_result_map</span><span class="s5">,</span>
        <span class="s1">asfrom</span><span class="s5">,</span>
        <span class="s1">column_clause_args</span><span class="s5">,</span>
        <span class="s1">name=</span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">proxy_name=</span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">fallback_label_name=</span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">within_columns_clause=</span><span class="s3">True</span><span class="s5">,</span>
        <span class="s1">column_is_repeated=</span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">need_column_expressions=</span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">include_table=</span><span class="s3">True</span><span class="s5">,</span>
    <span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;produce labeled columns present in a select().&quot;&quot;&quot;</span>
        <span class="s1">impl = column.type.dialect_impl(self.dialect)</span>

        <span class="s3">if </span><span class="s1">impl._has_column_expression </span><span class="s3">and </span><span class="s1">(</span>
            <span class="s1">need_column_expressions </span><span class="s3">or </span><span class="s1">populate_result_map</span>
        <span class="s1">):</span>
            <span class="s1">col_expr = impl.column_expression(column)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">col_expr = column</span>

        <span class="s3">if </span><span class="s1">populate_result_map:</span>
            <span class="s0"># pass an &quot;add_to_result_map&quot; callable into the compilation</span>
            <span class="s0"># of embedded columns.  this collects information about the</span>
            <span class="s0"># column as it will be fetched in the result and is coordinated</span>
            <span class="s0"># with cursor.description when the query is executed.</span>
            <span class="s1">add_to_result_map = self._add_to_result_map</span>

            <span class="s0"># if the SELECT statement told us this column is a repeat,</span>
            <span class="s0"># wrap the callable with one that prevents the addition of the</span>
            <span class="s0"># targets</span>
            <span class="s3">if </span><span class="s1">column_is_repeated:</span>
                <span class="s1">_add_to_result_map = add_to_result_map</span>

                <span class="s3">def </span><span class="s1">add_to_result_map(keyname</span><span class="s5">, </span><span class="s1">name</span><span class="s5">, </span><span class="s1">objects</span><span class="s5">, </span><span class="s1">type_):</span>
                    <span class="s1">_add_to_result_map(keyname</span><span class="s5">, </span><span class="s1">name</span><span class="s5">, </span><span class="s1">(keyname</span><span class="s5">,</span><span class="s1">)</span><span class="s5">, </span><span class="s1">type_)</span>

            <span class="s0"># if we redefined col_expr for type expressions, wrap the</span>
            <span class="s0"># callable with one that adds the original column to the targets</span>
            <span class="s3">elif </span><span class="s1">col_expr </span><span class="s3">is not </span><span class="s1">column:</span>
                <span class="s1">_add_to_result_map = add_to_result_map</span>

                <span class="s3">def </span><span class="s1">add_to_result_map(keyname</span><span class="s5">, </span><span class="s1">name</span><span class="s5">, </span><span class="s1">objects</span><span class="s5">, </span><span class="s1">type_):</span>
                    <span class="s1">_add_to_result_map(</span>
                        <span class="s1">keyname</span><span class="s5">, </span><span class="s1">name</span><span class="s5">, </span><span class="s1">(column</span><span class="s5">,</span><span class="s1">) + objects</span><span class="s5">, </span><span class="s1">type_</span>
                    <span class="s1">)</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">add_to_result_map = </span><span class="s3">None</span>

        <span class="s0"># this method is used by some of the dialects for RETURNING,</span>
        <span class="s0"># which has different inputs.  _label_returning_column was added</span>
        <span class="s0"># as the better target for this now however for 1.4 we will keep</span>
        <span class="s0"># _label_select_column directly compatible with this use case.</span>
        <span class="s0"># these assertions right now set up the current expected inputs</span>
        <span class="s3">assert </span><span class="s1">within_columns_clause</span><span class="s5">, </span><span class="s1">(</span>
            <span class="s4">&quot;_label_select_column is only relevant within &quot;</span>
            <span class="s4">&quot;the columns clause of a SELECT or RETURNING&quot;</span>
        <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">isinstance(column</span><span class="s5">, </span><span class="s1">elements.Label):</span>
            <span class="s3">if </span><span class="s1">col_expr </span><span class="s3">is not </span><span class="s1">column:</span>
                <span class="s1">result_expr = _CompileLabel(</span>
                    <span class="s1">col_expr</span><span class="s5">, </span><span class="s1">column.name</span><span class="s5">, </span><span class="s1">alt_names=(column.element</span><span class="s5">,</span><span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">result_expr = col_expr</span>

        <span class="s3">elif </span><span class="s1">name:</span>
            <span class="s0"># here, _columns_plus_names has determined there's an explicit</span>
            <span class="s0"># label name we need to use.  this is the default for</span>
            <span class="s0"># tablenames_plus_columnnames as well as when columns are being</span>
            <span class="s0"># deduplicated on name</span>

            <span class="s3">assert </span><span class="s1">(</span>
                <span class="s1">proxy_name </span><span class="s3">is not None</span>
            <span class="s1">)</span><span class="s5">, </span><span class="s4">&quot;proxy_name is required if 'name' is passed&quot;</span>

            <span class="s1">result_expr = _CompileLabel(</span>
                <span class="s1">col_expr</span><span class="s5">,</span>
                <span class="s1">name</span><span class="s5">,</span>
                <span class="s1">alt_names=(</span>
                    <span class="s1">proxy_name</span><span class="s5">,</span>
                    <span class="s0"># this is a hack to allow legacy result column lookups</span>
                    <span class="s0"># to work as they did before; this goes away in 2.0.</span>
                    <span class="s0"># TODO: this only seems to be tested indirectly</span>
                    <span class="s0"># via test/orm/test_deprecations.py.   should be a</span>
                    <span class="s0"># resultset test for this</span>
                    <span class="s1">column._tq_label</span><span class="s5">,</span>
                <span class="s1">)</span><span class="s5">,</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># determine here whether this column should be rendered in</span>
            <span class="s0"># a labelled context or not, as we were given no required label</span>
            <span class="s0"># name from the caller. Here we apply heuristics based on the kind</span>
            <span class="s0"># of SQL expression involved.</span>

            <span class="s3">if </span><span class="s1">col_expr </span><span class="s3">is not </span><span class="s1">column:</span>
                <span class="s0"># type-specific expression wrapping the given column,</span>
                <span class="s0"># so we render a label</span>
                <span class="s1">render_with_label = </span><span class="s3">True</span>
            <span class="s3">elif </span><span class="s1">isinstance(column</span><span class="s5">, </span><span class="s1">elements.ColumnClause):</span>
                <span class="s0"># table-bound column, we render its name as a label if we are</span>
                <span class="s0"># inside of a subquery only</span>
                <span class="s1">render_with_label = (</span>
                    <span class="s1">asfrom</span>
                    <span class="s3">and not </span><span class="s1">column.is_literal</span>
                    <span class="s3">and </span><span class="s1">column.table </span><span class="s3">is not None</span>
                <span class="s1">)</span>
            <span class="s3">elif </span><span class="s1">isinstance(column</span><span class="s5">, </span><span class="s1">elements.TextClause):</span>
                <span class="s1">render_with_label = </span><span class="s3">False</span>
            <span class="s3">elif </span><span class="s1">isinstance(column</span><span class="s5">, </span><span class="s1">elements.UnaryExpression):</span>
                <span class="s1">render_with_label = column.wraps_column_expression </span><span class="s3">or </span><span class="s1">asfrom</span>
            <span class="s3">elif </span><span class="s1">(</span>
                <span class="s0"># general class of expressions that don't have a SQL-column</span>
                <span class="s0"># addressible name.  includes scalar selects, bind parameters,</span>
                <span class="s0"># SQL functions, others</span>
                <span class="s3">not </span><span class="s1">isinstance(column</span><span class="s5">, </span><span class="s1">elements.NamedColumn)</span>
                <span class="s0"># deeper check that indicates there's no natural &quot;name&quot; to</span>
                <span class="s0"># this element, which accommodates for custom SQL constructs</span>
                <span class="s0"># that might have a &quot;.name&quot; attribute (but aren't SQL</span>
                <span class="s0"># functions) but are not implementing this more recently added</span>
                <span class="s0"># base class.  in theory the &quot;NamedColumn&quot; check should be</span>
                <span class="s0"># enough, however here we seek to maintain legacy behaviors</span>
                <span class="s0"># as well.</span>
                <span class="s3">and </span><span class="s1">column._non_anon_label </span><span class="s3">is None</span>
            <span class="s1">):</span>
                <span class="s1">render_with_label = </span><span class="s3">True</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">render_with_label = </span><span class="s3">False</span>

            <span class="s3">if </span><span class="s1">render_with_label:</span>
                <span class="s3">if not </span><span class="s1">fallback_label_name:</span>
                    <span class="s0"># used by the RETURNING case right now.  we generate it</span>
                    <span class="s0"># here as 3rd party dialects may be referring to</span>
                    <span class="s0"># _label_select_column method directly instead of the</span>
                    <span class="s0"># just-added _label_returning_column method</span>
                    <span class="s3">assert not </span><span class="s1">column_is_repeated</span>
                    <span class="s1">fallback_label_name = column._anon_name_label</span>

                <span class="s1">fallback_label_name = (</span>
                    <span class="s1">elements._truncated_label(fallback_label_name)</span>
                    <span class="s3">if not </span><span class="s1">isinstance(</span>
                        <span class="s1">fallback_label_name</span><span class="s5">, </span><span class="s1">elements._truncated_label</span>
                    <span class="s1">)</span>
                    <span class="s3">else </span><span class="s1">fallback_label_name</span>
                <span class="s1">)</span>

                <span class="s1">result_expr = _CompileLabel(</span>
                    <span class="s1">col_expr</span><span class="s5">, </span><span class="s1">fallback_label_name</span><span class="s5">, </span><span class="s1">alt_names=(proxy_name</span><span class="s5">,</span><span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">result_expr = col_expr</span>

        <span class="s1">column_clause_args.update(</span>
            <span class="s1">within_columns_clause=within_columns_clause</span><span class="s5">,</span>
            <span class="s1">add_to_result_map=add_to_result_map</span><span class="s5">,</span>
            <span class="s1">include_table=include_table</span><span class="s5">,</span>
        <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">result_expr._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**column_clause_args)</span>

    <span class="s3">def </span><span class="s1">format_from_hint_text(self</span><span class="s5">, </span><span class="s1">sqltext</span><span class="s5">, </span><span class="s1">table</span><span class="s5">, </span><span class="s1">hint</span><span class="s5">, </span><span class="s1">iscrud):</span>
        <span class="s1">hinttext = self.get_from_hint_text(table</span><span class="s5">, </span><span class="s1">hint)</span>
        <span class="s3">if </span><span class="s1">hinttext:</span>
            <span class="s1">sqltext += </span><span class="s4">&quot; &quot; </span><span class="s1">+ hinttext</span>
        <span class="s3">return </span><span class="s1">sqltext</span>

    <span class="s3">def </span><span class="s1">get_select_hint_text(self</span><span class="s5">, </span><span class="s1">byfroms):</span>
        <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">get_from_hint_text(self</span><span class="s5">, </span><span class="s1">table</span><span class="s5">, </span><span class="s1">text):</span>
        <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">get_crud_hint_text(self</span><span class="s5">, </span><span class="s1">table</span><span class="s5">, </span><span class="s1">text):</span>
        <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">get_statement_hint_text(self</span><span class="s5">, </span><span class="s1">hint_texts):</span>
        <span class="s3">return </span><span class="s4">&quot; &quot;</span><span class="s1">.join(hint_texts)</span>

    <span class="s1">_default_stack_entry: _CompilerStackEntry</span>

    <span class="s3">if not </span><span class="s1">typing.TYPE_CHECKING:</span>
        <span class="s1">_default_stack_entry = util.immutabledict(</span>
            <span class="s1">[(</span><span class="s4">&quot;correlate_froms&quot;</span><span class="s5">, </span><span class="s1">frozenset())</span><span class="s5">, </span><span class="s1">(</span><span class="s4">&quot;asfrom_froms&quot;</span><span class="s5">, </span><span class="s1">frozenset())]</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_display_froms_for_select(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">select_stmt</span><span class="s5">, </span><span class="s1">asfrom</span><span class="s5">, </span><span class="s1">lateral=</span><span class="s3">False</span><span class="s5">, </span><span class="s1">**kw</span>
    <span class="s1">):</span>
        <span class="s0"># utility method to help external dialects</span>
        <span class="s0"># get the correct from list for a select.</span>
        <span class="s0"># specifically the oracle dialect needs this feature</span>
        <span class="s0"># right now.</span>
        <span class="s1">toplevel = </span><span class="s3">not </span><span class="s1">self.stack</span>
        <span class="s1">entry = self._default_stack_entry </span><span class="s3">if </span><span class="s1">toplevel </span><span class="s3">else </span><span class="s1">self.stack[-</span><span class="s6">1</span><span class="s1">]</span>

        <span class="s1">compile_state = select_stmt._compile_state_factory(select_stmt</span><span class="s5">, </span><span class="s1">self)</span>

        <span class="s1">correlate_froms = entry[</span><span class="s4">&quot;correlate_froms&quot;</span><span class="s1">]</span>
        <span class="s1">asfrom_froms = entry[</span><span class="s4">&quot;asfrom_froms&quot;</span><span class="s1">]</span>

        <span class="s3">if </span><span class="s1">asfrom </span><span class="s3">and not </span><span class="s1">lateral:</span>
            <span class="s1">froms = compile_state._get_display_froms(</span>
                <span class="s1">explicit_correlate_froms=correlate_froms.difference(</span>
                    <span class="s1">asfrom_froms</span>
                <span class="s1">)</span><span class="s5">,</span>
                <span class="s1">implicit_correlate_froms=()</span><span class="s5">,</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">froms = compile_state._get_display_froms(</span>
                <span class="s1">explicit_correlate_froms=correlate_froms</span><span class="s5">,</span>
                <span class="s1">implicit_correlate_froms=asfrom_froms</span><span class="s5">,</span>
            <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">froms</span>

    <span class="s1">translate_select_structure: Any = </span><span class="s3">None</span>
    <span class="s4">&quot;&quot;&quot;if not ``None``, should be a callable which accepts ``(select_stmt, 
    **kw)`` and returns a select object.   this is used for structural changes 
    mostly to accommodate for LIMIT/OFFSET schemes 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">visit_select(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">select_stmt</span><span class="s5">,</span>
        <span class="s1">asfrom=</span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">insert_into=</span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">fromhints=</span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">compound_index=</span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">select_wraps_for=</span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">lateral=</span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">from_linter=</span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">**kwargs</span><span class="s5">,</span>
    <span class="s1">):</span>
        <span class="s3">assert </span><span class="s1">select_wraps_for </span><span class="s3">is None</span><span class="s5">, </span><span class="s1">(</span>
            <span class="s4">&quot;SQLAlchemy 1.4 requires use of &quot;</span>
            <span class="s4">&quot;the translate_select_structure hook for structural &quot;</span>
            <span class="s4">&quot;translations of SELECT objects&quot;</span>
        <span class="s1">)</span>

        <span class="s0"># initial setup of SELECT.  the compile_state_factory may now</span>
        <span class="s0"># be creating a totally different SELECT from the one that was</span>
        <span class="s0"># passed in.  for ORM use this will convert from an ORM-state</span>
        <span class="s0"># SELECT to a regular &quot;Core&quot; SELECT.  other composed operations</span>
        <span class="s0"># such as computation of joins will be performed.</span>

        <span class="s1">kwargs[</span><span class="s4">&quot;within_columns_clause&quot;</span><span class="s1">] = </span><span class="s3">False</span>

        <span class="s1">compile_state = select_stmt._compile_state_factory(</span>
            <span class="s1">select_stmt</span><span class="s5">, </span><span class="s1">self</span><span class="s5">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s4">&quot;ambiguous_table_name_map&quot;</span><span class="s1">] = (</span>
            <span class="s1">compile_state._ambiguous_table_name_map</span>
        <span class="s1">)</span>

        <span class="s1">select_stmt = compile_state.statement</span>

        <span class="s1">toplevel = </span><span class="s3">not </span><span class="s1">self.stack</span>

        <span class="s3">if </span><span class="s1">toplevel </span><span class="s3">and not </span><span class="s1">self.compile_state:</span>
            <span class="s1">self.compile_state = compile_state</span>

        <span class="s1">is_embedded_select = compound_index </span><span class="s3">is not None or </span><span class="s1">insert_into</span>

        <span class="s0"># translate step for Oracle, SQL Server which often need to</span>
        <span class="s0"># restructure the SELECT to allow for LIMIT/OFFSET and possibly</span>
        <span class="s0"># other conditions</span>
        <span class="s3">if </span><span class="s1">self.translate_select_structure:</span>
            <span class="s1">new_select_stmt = self.translate_select_structure(</span>
                <span class="s1">select_stmt</span><span class="s5">, </span><span class="s1">asfrom=asfrom</span><span class="s5">, </span><span class="s1">**kwargs</span>
            <span class="s1">)</span>

            <span class="s0"># if SELECT was restructured, maintain a link to the originals</span>
            <span class="s0"># and assemble a new compile state</span>
            <span class="s3">if </span><span class="s1">new_select_stmt </span><span class="s3">is not </span><span class="s1">select_stmt:</span>
                <span class="s1">compile_state_wraps_for = compile_state</span>
                <span class="s1">select_wraps_for = select_stmt</span>
                <span class="s1">select_stmt = new_select_stmt</span>

                <span class="s1">compile_state = select_stmt._compile_state_factory(</span>
                    <span class="s1">select_stmt</span><span class="s5">, </span><span class="s1">self</span><span class="s5">, </span><span class="s1">**kwargs</span>
                <span class="s1">)</span>
                <span class="s1">select_stmt = compile_state.statement</span>

        <span class="s1">entry = self._default_stack_entry </span><span class="s3">if </span><span class="s1">toplevel </span><span class="s3">else </span><span class="s1">self.stack[-</span><span class="s6">1</span><span class="s1">]</span>

        <span class="s1">populate_result_map = need_column_expressions = (</span>
            <span class="s1">toplevel</span>
            <span class="s3">or </span><span class="s1">entry.get(</span><span class="s4">&quot;need_result_map_for_compound&quot;</span><span class="s5">, </span><span class="s3">False</span><span class="s1">)</span>
            <span class="s3">or </span><span class="s1">entry.get(</span><span class="s4">&quot;need_result_map_for_nested&quot;</span><span class="s5">, </span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s0"># indicates there is a CompoundSelect in play and we are not the</span>
        <span class="s0"># first select</span>
        <span class="s3">if </span><span class="s1">compound_index:</span>
            <span class="s1">populate_result_map = </span><span class="s3">False</span>

        <span class="s0"># this was first proposed as part of #3372; however, it is not</span>
        <span class="s0"># reached in current tests and could possibly be an assertion</span>
        <span class="s0"># instead.</span>
        <span class="s3">if not </span><span class="s1">populate_result_map </span><span class="s3">and </span><span class="s4">&quot;add_to_result_map&quot; </span><span class="s3">in </span><span class="s1">kwargs:</span>
            <span class="s3">del </span><span class="s1">kwargs[</span><span class="s4">&quot;add_to_result_map&quot;</span><span class="s1">]</span>

        <span class="s1">froms = self._setup_select_stack(</span>
            <span class="s1">select_stmt</span><span class="s5">, </span><span class="s1">compile_state</span><span class="s5">, </span><span class="s1">entry</span><span class="s5">, </span><span class="s1">asfrom</span><span class="s5">, </span><span class="s1">lateral</span><span class="s5">, </span><span class="s1">compound_index</span>
        <span class="s1">)</span>

        <span class="s1">column_clause_args = kwargs.copy()</span>
        <span class="s1">column_clause_args.update(</span>
            <span class="s1">{</span><span class="s4">&quot;within_label_clause&quot;</span><span class="s1">: </span><span class="s3">False</span><span class="s5">, </span><span class="s4">&quot;within_columns_clause&quot;</span><span class="s1">: </span><span class="s3">False</span><span class="s1">}</span>
        <span class="s1">)</span>

        <span class="s1">text = </span><span class="s4">&quot;SELECT &quot;  </span><span class="s0"># we're off to a good start !</span>

        <span class="s3">if </span><span class="s1">select_stmt._hints:</span>
            <span class="s1">hint_text</span><span class="s5">, </span><span class="s1">byfrom = self._setup_select_hints(select_stmt)</span>
            <span class="s3">if </span><span class="s1">hint_text:</span>
                <span class="s1">text += hint_text + </span><span class="s4">&quot; &quot;</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">byfrom = </span><span class="s3">None</span>

        <span class="s3">if </span><span class="s1">select_stmt._independent_ctes:</span>
            <span class="s1">self._dispatch_independent_ctes(select_stmt</span><span class="s5">, </span><span class="s1">kwargs)</span>

        <span class="s3">if </span><span class="s1">select_stmt._prefixes:</span>
            <span class="s1">text += self._generate_prefixes(</span>
                <span class="s1">select_stmt</span><span class="s5">, </span><span class="s1">select_stmt._prefixes</span><span class="s5">, </span><span class="s1">**kwargs</span>
            <span class="s1">)</span>

        <span class="s1">text += self.get_select_precolumns(select_stmt</span><span class="s5">, </span><span class="s1">**kwargs)</span>
        <span class="s0"># the actual list of columns to print in the SELECT column list.</span>
        <span class="s1">inner_columns = [</span>
            <span class="s1">c</span>
            <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">[</span>
                <span class="s1">self._label_select_column(</span>
                    <span class="s1">select_stmt</span><span class="s5">,</span>
                    <span class="s1">column</span><span class="s5">,</span>
                    <span class="s1">populate_result_map</span><span class="s5">,</span>
                    <span class="s1">asfrom</span><span class="s5">,</span>
                    <span class="s1">column_clause_args</span><span class="s5">,</span>
                    <span class="s1">name=name</span><span class="s5">,</span>
                    <span class="s1">proxy_name=proxy_name</span><span class="s5">,</span>
                    <span class="s1">fallback_label_name=fallback_label_name</span><span class="s5">,</span>
                    <span class="s1">column_is_repeated=repeated</span><span class="s5">,</span>
                    <span class="s1">need_column_expressions=need_column_expressions</span><span class="s5">,</span>
                <span class="s1">)</span>
                <span class="s3">for </span><span class="s1">(</span>
                    <span class="s1">name</span><span class="s5">,</span>
                    <span class="s1">proxy_name</span><span class="s5">,</span>
                    <span class="s1">fallback_label_name</span><span class="s5">,</span>
                    <span class="s1">column</span><span class="s5">,</span>
                    <span class="s1">repeated</span><span class="s5">,</span>
                <span class="s1">) </span><span class="s3">in </span><span class="s1">compile_state.columns_plus_names</span>
            <span class="s1">]</span>
            <span class="s3">if </span><span class="s1">c </span><span class="s3">is not None</span>
        <span class="s1">]</span>

        <span class="s3">if </span><span class="s1">populate_result_map </span><span class="s3">and </span><span class="s1">select_wraps_for </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s0"># if this select was generated from translate_select,</span>
            <span class="s0"># rewrite the targeted columns in the result map</span>

            <span class="s1">translate = dict(</span>
                <span class="s1">zip(</span>
                    <span class="s1">[</span>
                        <span class="s1">name</span>
                        <span class="s3">for </span><span class="s1">(</span>
                            <span class="s1">key</span><span class="s5">,</span>
                            <span class="s1">proxy_name</span><span class="s5">,</span>
                            <span class="s1">fallback_label_name</span><span class="s5">,</span>
                            <span class="s1">name</span><span class="s5">,</span>
                            <span class="s1">repeated</span><span class="s5">,</span>
                        <span class="s1">) </span><span class="s3">in </span><span class="s1">compile_state.columns_plus_names</span>
                    <span class="s1">]</span><span class="s5">,</span>
                    <span class="s1">[</span>
                        <span class="s1">name</span>
                        <span class="s3">for </span><span class="s1">(</span>
                            <span class="s1">key</span><span class="s5">,</span>
                            <span class="s1">proxy_name</span><span class="s5">,</span>
                            <span class="s1">fallback_label_name</span><span class="s5">,</span>
                            <span class="s1">name</span><span class="s5">,</span>
                            <span class="s1">repeated</span><span class="s5">,</span>
                        <span class="s1">) </span><span class="s3">in </span><span class="s1">compile_state_wraps_for.columns_plus_names</span>
                    <span class="s1">]</span><span class="s5">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

            <span class="s1">self._result_columns = [</span>
                <span class="s1">ResultColumnsEntry(</span>
                    <span class="s1">key</span><span class="s5">, </span><span class="s1">name</span><span class="s5">, </span><span class="s1">tuple(translate.get(o</span><span class="s5">, </span><span class="s1">o) </span><span class="s3">for </span><span class="s1">o </span><span class="s3">in </span><span class="s1">obj)</span><span class="s5">, </span><span class="s1">type_</span>
                <span class="s1">)</span>
                <span class="s3">for </span><span class="s1">key</span><span class="s5">, </span><span class="s1">name</span><span class="s5">, </span><span class="s1">obj</span><span class="s5">, </span><span class="s1">type_ </span><span class="s3">in </span><span class="s1">self._result_columns</span>
            <span class="s1">]</span>

        <span class="s1">text = self._compose_select_body(</span>
            <span class="s1">text</span><span class="s5">,</span>
            <span class="s1">select_stmt</span><span class="s5">,</span>
            <span class="s1">compile_state</span><span class="s5">,</span>
            <span class="s1">inner_columns</span><span class="s5">,</span>
            <span class="s1">froms</span><span class="s5">,</span>
            <span class="s1">byfrom</span><span class="s5">,</span>
            <span class="s1">toplevel</span><span class="s5">,</span>
            <span class="s1">kwargs</span><span class="s5">,</span>
        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">select_stmt._statement_hints:</span>
            <span class="s1">per_dialect = [</span>
                <span class="s1">ht</span>
                <span class="s3">for </span><span class="s1">(dialect_name</span><span class="s5">, </span><span class="s1">ht) </span><span class="s3">in </span><span class="s1">select_stmt._statement_hints</span>
                <span class="s3">if </span><span class="s1">dialect_name </span><span class="s3">in </span><span class="s1">(</span><span class="s4">&quot;*&quot;</span><span class="s5">, </span><span class="s1">self.dialect.name)</span>
            <span class="s1">]</span>
            <span class="s3">if </span><span class="s1">per_dialect:</span>
                <span class="s1">text += </span><span class="s4">&quot; &quot; </span><span class="s1">+ self.get_statement_hint_text(per_dialect)</span>

        <span class="s0"># In compound query, CTEs are shared at the compound level</span>
        <span class="s3">if </span><span class="s1">self.ctes </span><span class="s3">and </span><span class="s1">(</span><span class="s3">not </span><span class="s1">is_embedded_select </span><span class="s3">or </span><span class="s1">toplevel):</span>
            <span class="s1">nesting_level = len(self.stack) </span><span class="s3">if not </span><span class="s1">toplevel </span><span class="s3">else None</span>
            <span class="s1">text = self._render_cte_clause(nesting_level=nesting_level) + text</span>

        <span class="s3">if </span><span class="s1">select_stmt._suffixes:</span>
            <span class="s1">text += </span><span class="s4">&quot; &quot; </span><span class="s1">+ self._generate_prefixes(</span>
                <span class="s1">select_stmt</span><span class="s5">, </span><span class="s1">select_stmt._suffixes</span><span class="s5">, </span><span class="s1">**kwargs</span>
            <span class="s1">)</span>

        <span class="s1">self.stack.pop(-</span><span class="s6">1</span><span class="s1">)</span>

        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">_setup_select_hints(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">select: Select[Any]</span>
    <span class="s1">) -&gt; Tuple[str</span><span class="s5">, </span><span class="s1">_FromHintsType]:</span>
        <span class="s1">byfrom = {</span>
            <span class="s1">from_: hinttext</span>
            <span class="s1">% {</span><span class="s4">&quot;name&quot;</span><span class="s1">: from_._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">ashint=</span><span class="s3">True</span><span class="s1">)}</span>
            <span class="s3">for </span><span class="s1">(from_</span><span class="s5">, </span><span class="s1">dialect)</span><span class="s5">, </span><span class="s1">hinttext </span><span class="s3">in </span><span class="s1">select._hints.items()</span>
            <span class="s3">if </span><span class="s1">dialect </span><span class="s3">in </span><span class="s1">(</span><span class="s4">&quot;*&quot;</span><span class="s5">, </span><span class="s1">self.dialect.name)</span>
        <span class="s1">}</span>
        <span class="s1">hint_text = self.get_select_hint_text(byfrom)</span>
        <span class="s3">return </span><span class="s1">hint_text</span><span class="s5">, </span><span class="s1">byfrom</span>

    <span class="s3">def </span><span class="s1">_setup_select_stack(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">select</span><span class="s5">, </span><span class="s1">compile_state</span><span class="s5">, </span><span class="s1">entry</span><span class="s5">, </span><span class="s1">asfrom</span><span class="s5">, </span><span class="s1">lateral</span><span class="s5">, </span><span class="s1">compound_index</span>
    <span class="s1">):</span>
        <span class="s1">correlate_froms = entry[</span><span class="s4">&quot;correlate_froms&quot;</span><span class="s1">]</span>
        <span class="s1">asfrom_froms = entry[</span><span class="s4">&quot;asfrom_froms&quot;</span><span class="s1">]</span>

        <span class="s3">if </span><span class="s1">compound_index == </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s1">entry[</span><span class="s4">&quot;select_0&quot;</span><span class="s1">] = select</span>
        <span class="s3">elif </span><span class="s1">compound_index:</span>
            <span class="s1">select_0 = entry[</span><span class="s4">&quot;select_0&quot;</span><span class="s1">]</span>
            <span class="s1">numcols = len(select_0._all_selected_columns)</span>

            <span class="s3">if </span><span class="s1">len(compile_state.columns_plus_names) != numcols:</span>
                <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
                    <span class="s4">&quot;All selectables passed to &quot;</span>
                    <span class="s4">&quot;CompoundSelect must have identical numbers of &quot;</span>
                    <span class="s4">&quot;columns; select #%d has %d columns, select &quot;</span>
                    <span class="s4">&quot;#%d has %d&quot;</span>
                    <span class="s1">% (</span>
                        <span class="s6">1</span><span class="s5">,</span>
                        <span class="s1">numcols</span><span class="s5">,</span>
                        <span class="s1">compound_index + </span><span class="s6">1</span><span class="s5">,</span>
                        <span class="s1">len(select._all_selected_columns)</span><span class="s5">,</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">asfrom </span><span class="s3">and not </span><span class="s1">lateral:</span>
            <span class="s1">froms = compile_state._get_display_froms(</span>
                <span class="s1">explicit_correlate_froms=correlate_froms.difference(</span>
                    <span class="s1">asfrom_froms</span>
                <span class="s1">)</span><span class="s5">,</span>
                <span class="s1">implicit_correlate_froms=()</span><span class="s5">,</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">froms = compile_state._get_display_froms(</span>
                <span class="s1">explicit_correlate_froms=correlate_froms</span><span class="s5">,</span>
                <span class="s1">implicit_correlate_froms=asfrom_froms</span><span class="s5">,</span>
            <span class="s1">)</span>

        <span class="s1">new_correlate_froms = set(_from_objects(*froms))</span>
        <span class="s1">all_correlate_froms = new_correlate_froms.union(correlate_froms)</span>

        <span class="s1">new_entry: _CompilerStackEntry = {</span>
            <span class="s4">&quot;asfrom_froms&quot;</span><span class="s1">: new_correlate_froms</span><span class="s5">,</span>
            <span class="s4">&quot;correlate_froms&quot;</span><span class="s1">: all_correlate_froms</span><span class="s5">,</span>
            <span class="s4">&quot;selectable&quot;</span><span class="s1">: select</span><span class="s5">,</span>
            <span class="s4">&quot;compile_state&quot;</span><span class="s1">: compile_state</span><span class="s5">,</span>
        <span class="s1">}</span>
        <span class="s1">self.stack.append(new_entry)</span>

        <span class="s3">return </span><span class="s1">froms</span>

    <span class="s3">def </span><span class="s1">_compose_select_body(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">text</span><span class="s5">,</span>
        <span class="s1">select</span><span class="s5">,</span>
        <span class="s1">compile_state</span><span class="s5">,</span>
        <span class="s1">inner_columns</span><span class="s5">,</span>
        <span class="s1">froms</span><span class="s5">,</span>
        <span class="s1">byfrom</span><span class="s5">,</span>
        <span class="s1">toplevel</span><span class="s5">,</span>
        <span class="s1">kwargs</span><span class="s5">,</span>
    <span class="s1">):</span>
        <span class="s1">text += </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(inner_columns)</span>

        <span class="s3">if </span><span class="s1">self.linting &amp; COLLECT_CARTESIAN_PRODUCTS:</span>
            <span class="s1">from_linter = FromLinter({}</span><span class="s5">, </span><span class="s1">set())</span>
            <span class="s1">warn_linting = self.linting &amp; WARN_LINTING</span>
            <span class="s3">if </span><span class="s1">toplevel:</span>
                <span class="s1">self.from_linter = from_linter</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">from_linter = </span><span class="s3">None</span>
            <span class="s1">warn_linting = </span><span class="s3">False</span>

        <span class="s0"># adjust the whitespace for no inner columns, part of #9440,</span>
        <span class="s0"># so that a no-col SELECT comes out as &quot;SELECT WHERE...&quot; or</span>
        <span class="s0"># &quot;SELECT FROM ...&quot;.</span>
        <span class="s0"># while it would be better to have built the SELECT starting string</span>
        <span class="s0"># without trailing whitespace first, then add whitespace only if inner</span>
        <span class="s0"># cols were present, this breaks compatibility with various custom</span>
        <span class="s0"># compilation schemes that are currently being tested.</span>
        <span class="s3">if not </span><span class="s1">inner_columns:</span>
            <span class="s1">text = text.rstrip()</span>

        <span class="s3">if </span><span class="s1">froms:</span>
            <span class="s1">text += </span><span class="s4">&quot; </span><span class="s7">\n</span><span class="s4">FROM &quot;</span>

            <span class="s3">if </span><span class="s1">select._hints:</span>
                <span class="s1">text += </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
                    <span class="s1">[</span>
                        <span class="s1">f._compiler_dispatch(</span>
                            <span class="s1">self</span><span class="s5">,</span>
                            <span class="s1">asfrom=</span><span class="s3">True</span><span class="s5">,</span>
                            <span class="s1">fromhints=byfrom</span><span class="s5">,</span>
                            <span class="s1">from_linter=from_linter</span><span class="s5">,</span>
                            <span class="s1">**kwargs</span><span class="s5">,</span>
                        <span class="s1">)</span>
                        <span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">froms</span>
                    <span class="s1">]</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">text += </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
                    <span class="s1">[</span>
                        <span class="s1">f._compiler_dispatch(</span>
                            <span class="s1">self</span><span class="s5">,</span>
                            <span class="s1">asfrom=</span><span class="s3">True</span><span class="s5">,</span>
                            <span class="s1">from_linter=from_linter</span><span class="s5">,</span>
                            <span class="s1">**kwargs</span><span class="s5">,</span>
                        <span class="s1">)</span>
                        <span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">froms</span>
                    <span class="s1">]</span>
                <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">text += self.default_from()</span>

        <span class="s3">if </span><span class="s1">select._where_criteria:</span>
            <span class="s1">t = self._generate_delimited_and_list(</span>
                <span class="s1">select._where_criteria</span><span class="s5">, </span><span class="s1">from_linter=from_linter</span><span class="s5">, </span><span class="s1">**kwargs</span>
            <span class="s1">)</span>
            <span class="s3">if </span><span class="s1">t:</span>
                <span class="s1">text += </span><span class="s4">&quot; </span><span class="s7">\n</span><span class="s4">WHERE &quot; </span><span class="s1">+ t</span>

        <span class="s3">if </span><span class="s1">warn_linting:</span>
            <span class="s3">assert </span><span class="s1">from_linter </span><span class="s3">is not None</span>
            <span class="s1">from_linter.warn()</span>

        <span class="s3">if </span><span class="s1">select._group_by_clauses:</span>
            <span class="s1">text += self.group_by_clause(select</span><span class="s5">, </span><span class="s1">**kwargs)</span>

        <span class="s3">if </span><span class="s1">select._having_criteria:</span>
            <span class="s1">t = self._generate_delimited_and_list(</span>
                <span class="s1">select._having_criteria</span><span class="s5">, </span><span class="s1">**kwargs</span>
            <span class="s1">)</span>
            <span class="s3">if </span><span class="s1">t:</span>
                <span class="s1">text += </span><span class="s4">&quot; </span><span class="s7">\n</span><span class="s4">HAVING &quot; </span><span class="s1">+ t</span>

        <span class="s3">if </span><span class="s1">select._order_by_clauses:</span>
            <span class="s1">text += self.order_by_clause(select</span><span class="s5">, </span><span class="s1">**kwargs)</span>

        <span class="s3">if </span><span class="s1">select._has_row_limiting_clause:</span>
            <span class="s1">text += self._row_limit_clause(select</span><span class="s5">, </span><span class="s1">**kwargs)</span>

        <span class="s3">if </span><span class="s1">select._for_update_arg </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">text += self.for_update_clause(select</span><span class="s5">, </span><span class="s1">**kwargs)</span>

        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">_generate_prefixes(self</span><span class="s5">, </span><span class="s1">stmt</span><span class="s5">, </span><span class="s1">prefixes</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">clause = </span><span class="s4">&quot; &quot;</span><span class="s1">.join(</span>
            <span class="s1">prefix._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kw)</span>
            <span class="s3">for </span><span class="s1">prefix</span><span class="s5">, </span><span class="s1">dialect_name </span><span class="s3">in </span><span class="s1">prefixes</span>
            <span class="s3">if </span><span class="s1">dialect_name </span><span class="s3">in </span><span class="s1">(</span><span class="s3">None</span><span class="s5">, </span><span class="s4">&quot;*&quot;</span><span class="s1">) </span><span class="s3">or </span><span class="s1">dialect_name == self.dialect.name</span>
        <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">clause:</span>
            <span class="s1">clause += </span><span class="s4">&quot; &quot;</span>
        <span class="s3">return </span><span class="s1">clause</span>

    <span class="s3">def </span><span class="s1">_render_cte_clause(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">nesting_level=</span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">include_following_stack=</span><span class="s3">False</span><span class="s5">,</span>
    <span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        include_following_stack 
            Also render the nesting CTEs on the next stack. Useful for 
            SQL structures like UNION or INSERT that can wrap SELECT 
            statements containing nesting CTEs. 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">self.ctes:</span>
            <span class="s3">return </span><span class="s4">&quot;&quot;</span>

        <span class="s1">ctes: MutableMapping[CTE</span><span class="s5">, </span><span class="s1">str]</span>

        <span class="s3">if </span><span class="s1">nesting_level </span><span class="s3">and </span><span class="s1">nesting_level &gt; </span><span class="s6">1</span><span class="s1">:</span>
            <span class="s1">ctes = util.OrderedDict()</span>
            <span class="s3">for </span><span class="s1">cte </span><span class="s3">in </span><span class="s1">list(self.ctes.keys()):</span>
                <span class="s1">cte_level</span><span class="s5">, </span><span class="s1">cte_name</span><span class="s5">, </span><span class="s1">cte_opts = self.level_name_by_cte[</span>
                    <span class="s1">cte._get_reference_cte()</span>
                <span class="s1">]</span>
                <span class="s1">nesting = cte.nesting </span><span class="s3">or </span><span class="s1">cte_opts.nesting</span>
                <span class="s1">is_rendered_level = cte_level == nesting_level </span><span class="s3">or </span><span class="s1">(</span>
                    <span class="s1">include_following_stack </span><span class="s3">and </span><span class="s1">cte_level == nesting_level + </span><span class="s6">1</span>
                <span class="s1">)</span>
                <span class="s3">if not </span><span class="s1">(nesting </span><span class="s3">and </span><span class="s1">is_rendered_level):</span>
                    <span class="s3">continue</span>

                <span class="s1">ctes[cte] = self.ctes[cte]</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">ctes = self.ctes</span>

        <span class="s3">if not </span><span class="s1">ctes:</span>
            <span class="s3">return </span><span class="s4">&quot;&quot;</span>
        <span class="s1">ctes_recursive = any([cte.recursive </span><span class="s3">for </span><span class="s1">cte </span><span class="s3">in </span><span class="s1">ctes])</span>

        <span class="s1">cte_text = self.get_cte_preamble(ctes_recursive) + </span><span class="s4">&quot; &quot;</span>
        <span class="s1">cte_text += </span><span class="s4">&quot;, </span><span class="s7">\n</span><span class="s4">&quot;</span><span class="s1">.join([txt </span><span class="s3">for </span><span class="s1">txt </span><span class="s3">in </span><span class="s1">ctes.values()])</span>
        <span class="s1">cte_text += </span><span class="s4">&quot;</span><span class="s7">\n </span><span class="s4">&quot;</span>

        <span class="s3">if </span><span class="s1">nesting_level </span><span class="s3">and </span><span class="s1">nesting_level &gt; </span><span class="s6">1</span><span class="s1">:</span>
            <span class="s3">for </span><span class="s1">cte </span><span class="s3">in </span><span class="s1">list(ctes.keys()):</span>
                <span class="s1">cte_level</span><span class="s5">, </span><span class="s1">cte_name</span><span class="s5">, </span><span class="s1">cte_opts = self.level_name_by_cte[</span>
                    <span class="s1">cte._get_reference_cte()</span>
                <span class="s1">]</span>
                <span class="s3">del </span><span class="s1">self.ctes[cte]</span>
                <span class="s3">del </span><span class="s1">self.ctes_by_level_name[(cte_level</span><span class="s5">, </span><span class="s1">cte_name)]</span>
                <span class="s3">del </span><span class="s1">self.level_name_by_cte[cte._get_reference_cte()]</span>

        <span class="s3">return </span><span class="s1">cte_text</span>

    <span class="s3">def </span><span class="s1">get_cte_preamble(self</span><span class="s5">, </span><span class="s1">recursive):</span>
        <span class="s3">if </span><span class="s1">recursive:</span>
            <span class="s3">return </span><span class="s4">&quot;WITH RECURSIVE&quot;</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">&quot;WITH&quot;</span>

    <span class="s3">def </span><span class="s1">get_select_precolumns(self</span><span class="s5">, </span><span class="s1">select</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s2">&quot;&quot;&quot;Called when building a ``SELECT`` statement, position is just 
        before column list. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">select._distinct_on:</span>
            <span class="s1">util.warn_deprecated(</span>
                <span class="s4">&quot;DISTINCT ON is currently supported only by the PostgreSQL &quot;</span>
                <span class="s4">&quot;dialect.  Use of DISTINCT ON for other backends is currently &quot;</span>
                <span class="s4">&quot;silently ignored, however this usage is deprecated, and will &quot;</span>
                <span class="s4">&quot;raise CompileError in a future release for all backends &quot;</span>
                <span class="s4">&quot;that do not support this syntax.&quot;</span><span class="s5">,</span>
                <span class="s1">version=</span><span class="s4">&quot;1.4&quot;</span><span class="s5">,</span>
            <span class="s1">)</span>
        <span class="s3">return </span><span class="s4">&quot;DISTINCT &quot; </span><span class="s3">if </span><span class="s1">select._distinct </span><span class="s3">else </span><span class="s4">&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">group_by_clause(self</span><span class="s5">, </span><span class="s1">select</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s2">&quot;&quot;&quot;allow dialects to customize how GROUP BY is rendered.&quot;&quot;&quot;</span>

        <span class="s1">group_by = self._generate_delimited_list(</span>
            <span class="s1">select._group_by_clauses</span><span class="s5">, </span><span class="s1">OPERATORS[operators.comma_op]</span><span class="s5">, </span><span class="s1">**kw</span>
        <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">group_by:</span>
            <span class="s3">return </span><span class="s4">&quot; GROUP BY &quot; </span><span class="s1">+ group_by</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">order_by_clause(self</span><span class="s5">, </span><span class="s1">select</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s2">&quot;&quot;&quot;allow dialects to customize how ORDER BY is rendered.&quot;&quot;&quot;</span>

        <span class="s1">order_by = self._generate_delimited_list(</span>
            <span class="s1">select._order_by_clauses</span><span class="s5">, </span><span class="s1">OPERATORS[operators.comma_op]</span><span class="s5">, </span><span class="s1">**kw</span>
        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">order_by:</span>
            <span class="s3">return </span><span class="s4">&quot; ORDER BY &quot; </span><span class="s1">+ order_by</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">for_update_clause(self</span><span class="s5">, </span><span class="s1">select</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot; FOR UPDATE&quot;</span>

    <span class="s3">def </span><span class="s1">returning_clause(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">stmt: UpdateBase</span><span class="s5">,</span>
        <span class="s1">returning_cols: Sequence[ColumnElement[Any]]</span><span class="s5">,</span>
        <span class="s1">*</span><span class="s5">,</span>
        <span class="s1">populate_result_map: bool</span><span class="s5">,</span>
        <span class="s1">**kw: Any</span><span class="s5">,</span>
    <span class="s1">) -&gt; str:</span>
        <span class="s1">columns = [</span>
            <span class="s1">self._label_returning_column(</span>
                <span class="s1">stmt</span><span class="s5">,</span>
                <span class="s1">column</span><span class="s5">,</span>
                <span class="s1">populate_result_map</span><span class="s5">,</span>
                <span class="s1">fallback_label_name=fallback_label_name</span><span class="s5">,</span>
                <span class="s1">column_is_repeated=repeated</span><span class="s5">,</span>
                <span class="s1">name=name</span><span class="s5">,</span>
                <span class="s1">proxy_name=proxy_name</span><span class="s5">,</span>
                <span class="s1">**kw</span><span class="s5">,</span>
            <span class="s1">)</span>
            <span class="s3">for </span><span class="s1">(</span>
                <span class="s1">name</span><span class="s5">,</span>
                <span class="s1">proxy_name</span><span class="s5">,</span>
                <span class="s1">fallback_label_name</span><span class="s5">,</span>
                <span class="s1">column</span><span class="s5">,</span>
                <span class="s1">repeated</span><span class="s5">,</span>
            <span class="s1">) </span><span class="s3">in </span><span class="s1">stmt._generate_columns_plus_names(</span>
                <span class="s3">True</span><span class="s5">, </span><span class="s1">cols=base._select_iterables(returning_cols)</span>
            <span class="s1">)</span>
        <span class="s1">]</span>

        <span class="s3">return </span><span class="s4">&quot;RETURNING &quot; </span><span class="s1">+ </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(columns)</span>

    <span class="s3">def </span><span class="s1">limit_clause(self</span><span class="s5">, </span><span class="s1">select</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">text = </span><span class="s4">&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">select._limit_clause </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">text += </span><span class="s4">&quot;</span><span class="s7">\n </span><span class="s4">LIMIT &quot; </span><span class="s1">+ self.process(select._limit_clause</span><span class="s5">, </span><span class="s1">**kw)</span>
        <span class="s3">if </span><span class="s1">select._offset_clause </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">select._limit_clause </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">text += </span><span class="s4">&quot;</span><span class="s7">\n </span><span class="s4">LIMIT -1&quot;</span>
            <span class="s1">text += </span><span class="s4">&quot; OFFSET &quot; </span><span class="s1">+ self.process(select._offset_clause</span><span class="s5">, </span><span class="s1">**kw)</span>
        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">fetch_clause(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">select</span><span class="s5">,</span>
        <span class="s1">fetch_clause=</span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">require_offset=</span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">use_literal_execute_for_simple_int=</span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">**kw</span><span class="s5">,</span>
    <span class="s1">):</span>
        <span class="s3">if </span><span class="s1">fetch_clause </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">fetch_clause = select._fetch_clause</span>
            <span class="s1">fetch_clause_options = select._fetch_clause_options</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">fetch_clause_options = {</span><span class="s4">&quot;percent&quot;</span><span class="s1">: </span><span class="s3">False</span><span class="s5">, </span><span class="s4">&quot;with_ties&quot;</span><span class="s1">: </span><span class="s3">False</span><span class="s1">}</span>

        <span class="s1">text = </span><span class="s4">&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">select._offset_clause </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">offset_clause = select._offset_clause</span>
            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">use_literal_execute_for_simple_int</span>
                <span class="s3">and </span><span class="s1">select._simple_int_clause(offset_clause)</span>
            <span class="s1">):</span>
                <span class="s1">offset_clause = offset_clause.render_literal_execute()</span>
            <span class="s1">offset_str = self.process(offset_clause</span><span class="s5">, </span><span class="s1">**kw)</span>
            <span class="s1">text += </span><span class="s4">&quot;</span><span class="s7">\n </span><span class="s4">OFFSET %s ROWS&quot; </span><span class="s1">% offset_str</span>
        <span class="s3">elif </span><span class="s1">require_offset:</span>
            <span class="s1">text += </span><span class="s4">&quot;</span><span class="s7">\n </span><span class="s4">OFFSET 0 ROWS&quot;</span>

        <span class="s3">if </span><span class="s1">fetch_clause </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">use_literal_execute_for_simple_int</span>
                <span class="s3">and </span><span class="s1">select._simple_int_clause(fetch_clause)</span>
            <span class="s1">):</span>
                <span class="s1">fetch_clause = fetch_clause.render_literal_execute()</span>
            <span class="s1">text += </span><span class="s4">&quot;</span><span class="s7">\n </span><span class="s4">FETCH FIRST %s%s ROWS %s&quot; </span><span class="s1">% (</span>
                <span class="s1">self.process(fetch_clause</span><span class="s5">, </span><span class="s1">**kw)</span><span class="s5">,</span>
                <span class="s4">&quot; PERCENT&quot; </span><span class="s3">if </span><span class="s1">fetch_clause_options[</span><span class="s4">&quot;percent&quot;</span><span class="s1">] </span><span class="s3">else </span><span class="s4">&quot;&quot;</span><span class="s5">,</span>
                <span class="s4">&quot;WITH TIES&quot; </span><span class="s3">if </span><span class="s1">fetch_clause_options[</span><span class="s4">&quot;with_ties&quot;</span><span class="s1">] </span><span class="s3">else </span><span class="s4">&quot;ONLY&quot;</span><span class="s5">,</span>
            <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">visit_table(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">table</span><span class="s5">,</span>
        <span class="s1">asfrom=</span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">iscrud=</span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">ashint=</span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">fromhints=</span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">use_schema=</span><span class="s3">True</span><span class="s5">,</span>
        <span class="s1">from_linter=</span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">ambiguous_table_name_map=</span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">**kwargs</span><span class="s5">,</span>
    <span class="s1">):</span>
        <span class="s3">if </span><span class="s1">from_linter:</span>
            <span class="s1">from_linter.froms[table] = table.fullname</span>

        <span class="s3">if </span><span class="s1">asfrom </span><span class="s3">or </span><span class="s1">ashint:</span>
            <span class="s1">effective_schema = self.preparer.schema_for_object(table)</span>

            <span class="s3">if </span><span class="s1">use_schema </span><span class="s3">and </span><span class="s1">effective_schema:</span>
                <span class="s1">ret = (</span>
                    <span class="s1">self.preparer.quote_schema(effective_schema)</span>
                    <span class="s1">+ </span><span class="s4">&quot;.&quot;</span>
                    <span class="s1">+ self.preparer.quote(table.name)</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">ret = self.preparer.quote(table.name)</span>

                <span class="s3">if </span><span class="s1">(</span>
                    <span class="s3">not </span><span class="s1">effective_schema</span>
                    <span class="s3">and </span><span class="s1">ambiguous_table_name_map</span>
                    <span class="s3">and </span><span class="s1">table.name </span><span class="s3">in </span><span class="s1">ambiguous_table_name_map</span>
                <span class="s1">):</span>
                    <span class="s1">anon_name = self._truncated_identifier(</span>
                        <span class="s4">&quot;alias&quot;</span><span class="s5">, </span><span class="s1">ambiguous_table_name_map[table.name]</span>
                    <span class="s1">)</span>

                    <span class="s1">ret = ret + self.get_render_as_alias_suffix(</span>
                        <span class="s1">self.preparer.format_alias(</span><span class="s3">None</span><span class="s5">, </span><span class="s1">anon_name)</span>
                    <span class="s1">)</span>

            <span class="s3">if </span><span class="s1">fromhints </span><span class="s3">and </span><span class="s1">table </span><span class="s3">in </span><span class="s1">fromhints:</span>
                <span class="s1">ret = self.format_from_hint_text(</span>
                    <span class="s1">ret</span><span class="s5">, </span><span class="s1">table</span><span class="s5">, </span><span class="s1">fromhints[table]</span><span class="s5">, </span><span class="s1">iscrud</span>
                <span class="s1">)</span>
            <span class="s3">return </span><span class="s1">ret</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">visit_join(self</span><span class="s5">, </span><span class="s1">join</span><span class="s5">, </span><span class="s1">asfrom=</span><span class="s3">False</span><span class="s5">, </span><span class="s1">from_linter=</span><span class="s3">None</span><span class="s5">, </span><span class="s1">**kwargs):</span>
        <span class="s3">if </span><span class="s1">from_linter:</span>
            <span class="s1">from_linter.edges.update(</span>
                <span class="s1">itertools.product(</span>
                    <span class="s1">_de_clone(join.left._from_objects)</span><span class="s5">,</span>
                    <span class="s1">_de_clone(join.right._from_objects)</span><span class="s5">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">join.full:</span>
            <span class="s1">join_type = </span><span class="s4">&quot; FULL OUTER JOIN &quot;</span>
        <span class="s3">elif </span><span class="s1">join.isouter:</span>
            <span class="s1">join_type = </span><span class="s4">&quot; LEFT OUTER JOIN &quot;</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">join_type = </span><span class="s4">&quot; JOIN &quot;</span>
        <span class="s3">return </span><span class="s1">(</span>
            <span class="s1">join.left._compiler_dispatch(</span>
                <span class="s1">self</span><span class="s5">, </span><span class="s1">asfrom=</span><span class="s3">True</span><span class="s5">, </span><span class="s1">from_linter=from_linter</span><span class="s5">, </span><span class="s1">**kwargs</span>
            <span class="s1">)</span>
            <span class="s1">+ join_type</span>
            <span class="s1">+ join.right._compiler_dispatch(</span>
                <span class="s1">self</span><span class="s5">, </span><span class="s1">asfrom=</span><span class="s3">True</span><span class="s5">, </span><span class="s1">from_linter=from_linter</span><span class="s5">, </span><span class="s1">**kwargs</span>
            <span class="s1">)</span>
            <span class="s1">+ </span><span class="s4">&quot; ON &quot;</span>
            <span class="s0"># TODO: likely need asfrom=True here?</span>
            <span class="s1">+ join.onclause._compiler_dispatch(</span>
                <span class="s1">self</span><span class="s5">, </span><span class="s1">from_linter=from_linter</span><span class="s5">, </span><span class="s1">**kwargs</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_setup_crud_hints(self</span><span class="s5">, </span><span class="s1">stmt</span><span class="s5">, </span><span class="s1">table_text):</span>
        <span class="s1">dialect_hints = {</span>
            <span class="s1">table: hint_text</span>
            <span class="s3">for </span><span class="s1">(table</span><span class="s5">, </span><span class="s1">dialect)</span><span class="s5">, </span><span class="s1">hint_text </span><span class="s3">in </span><span class="s1">stmt._hints.items()</span>
            <span class="s3">if </span><span class="s1">dialect </span><span class="s3">in </span><span class="s1">(</span><span class="s4">&quot;*&quot;</span><span class="s5">, </span><span class="s1">self.dialect.name)</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">stmt.table </span><span class="s3">in </span><span class="s1">dialect_hints:</span>
            <span class="s1">table_text = self.format_from_hint_text(</span>
                <span class="s1">table_text</span><span class="s5">, </span><span class="s1">stmt.table</span><span class="s5">, </span><span class="s1">dialect_hints[stmt.table]</span><span class="s5">, </span><span class="s3">True</span>
            <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">dialect_hints</span><span class="s5">, </span><span class="s1">table_text</span>

    <span class="s0"># within the realm of &quot;insertmanyvalues sentinel columns&quot;,</span>
    <span class="s0"># these lookups match different kinds of Column() configurations</span>
    <span class="s0"># to specific backend capabilities.  they are broken into two</span>
    <span class="s0"># lookups, one for autoincrement columns and the other for non</span>
    <span class="s0"># autoincrement columns</span>
    <span class="s1">_sentinel_col_non_autoinc_lookup = util.immutabledict(</span>
        <span class="s1">{</span>
            <span class="s1">_SentinelDefaultCharacterization.CLIENTSIDE: (</span>
                <span class="s1">InsertmanyvaluesSentinelOpts._SUPPORTED_OR_NOT</span>
            <span class="s1">)</span><span class="s5">,</span>
            <span class="s1">_SentinelDefaultCharacterization.SENTINEL_DEFAULT: (</span>
                <span class="s1">InsertmanyvaluesSentinelOpts._SUPPORTED_OR_NOT</span>
            <span class="s1">)</span><span class="s5">,</span>
            <span class="s1">_SentinelDefaultCharacterization.NONE: (</span>
                <span class="s1">InsertmanyvaluesSentinelOpts._SUPPORTED_OR_NOT</span>
            <span class="s1">)</span><span class="s5">,</span>
            <span class="s1">_SentinelDefaultCharacterization.IDENTITY: (</span>
                <span class="s1">InsertmanyvaluesSentinelOpts.IDENTITY</span>
            <span class="s1">)</span><span class="s5">,</span>
            <span class="s1">_SentinelDefaultCharacterization.SEQUENCE: (</span>
                <span class="s1">InsertmanyvaluesSentinelOpts.SEQUENCE</span>
            <span class="s1">)</span><span class="s5">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">_sentinel_col_autoinc_lookup = _sentinel_col_non_autoinc_lookup.union(</span>
        <span class="s1">{</span>
            <span class="s1">_SentinelDefaultCharacterization.NONE: (</span>
                <span class="s1">InsertmanyvaluesSentinelOpts.AUTOINCREMENT</span>
            <span class="s1">)</span><span class="s5">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_get_sentinel_column_for_table(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">table: Table</span>
    <span class="s1">) -&gt; Optional[Sequence[Column[Any]]]:</span>
        <span class="s2">&quot;&quot;&quot;given a :class:`.Table`, return a usable sentinel column or 
        columns for this dialect if any. 
 
        Return None if no sentinel columns could be identified, or raise an 
        error if a column was marked as a sentinel explicitly but isn't 
        compatible with this dialect. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">sentinel_opts = self.dialect.insertmanyvalues_implicit_sentinel</span>
        <span class="s1">sentinel_characteristics = table._sentinel_column_characteristics</span>

        <span class="s1">sent_cols = sentinel_characteristics.columns</span>

        <span class="s3">if </span><span class="s1">sent_cols </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return None</span>

        <span class="s3">if </span><span class="s1">sentinel_characteristics.is_autoinc:</span>
            <span class="s1">bitmask = self._sentinel_col_autoinc_lookup.get(</span>
                <span class="s1">sentinel_characteristics.default_characterization</span><span class="s5">, </span><span class="s6">0</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">bitmask = self._sentinel_col_non_autoinc_lookup.get(</span>
                <span class="s1">sentinel_characteristics.default_characterization</span><span class="s5">, </span><span class="s6">0</span>
            <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">sentinel_opts &amp; bitmask:</span>
            <span class="s3">return </span><span class="s1">sent_cols</span>

        <span class="s3">if </span><span class="s1">sentinel_characteristics.is_explicit:</span>
            <span class="s0"># a column was explicitly marked as insert_sentinel=True,</span>
            <span class="s0"># however it is not compatible with this dialect.   they should</span>
            <span class="s0"># not indicate this column as a sentinel if they need to include</span>
            <span class="s0"># this dialect.</span>

            <span class="s0"># TODO: do we want non-primary key explicit sentinel cols</span>
            <span class="s0"># that can gracefully degrade for some backends?</span>
            <span class="s0"># insert_sentinel=&quot;degrade&quot; perhaps.  not for the initial release.</span>
            <span class="s0"># I am hoping people are generally not dealing with this sentinel</span>
            <span class="s0"># business at all.</span>

            <span class="s0"># if is_explicit is True, there will be only one sentinel column.</span>

            <span class="s3">raise </span><span class="s1">exc.InvalidRequestError(</span>
                <span class="s4">f&quot;Column </span><span class="s7">{</span><span class="s1">sent_cols[</span><span class="s6">0</span><span class="s1">]</span><span class="s7">} </span><span class="s4">can't be explicitly &quot;</span>
                <span class="s4">&quot;marked as a sentinel column when using the &quot;</span>
                <span class="s4">f&quot;</span><span class="s7">{</span><span class="s1">self.dialect.name</span><span class="s7">} </span><span class="s4">dialect, as the &quot;</span>
                <span class="s4">&quot;particular type of default generation on this column is &quot;</span>
                <span class="s4">&quot;not currently compatible with this dialect's specific &quot;</span>
                <span class="s4">f&quot;INSERT..RETURNING syntax which can receive the &quot;</span>
                <span class="s4">&quot;server-generated value in &quot;</span>
                <span class="s4">&quot;a deterministic way.  To remove this error, remove &quot;</span>
                <span class="s4">&quot;insert_sentinel=True from primary key autoincrement &quot;</span>
                <span class="s4">&quot;columns; these columns are automatically used as &quot;</span>
                <span class="s4">&quot;sentinels for supported dialects in any case.&quot;</span>
            <span class="s1">)</span>

        <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">_deliver_insertmanyvalues_batches(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">statement: str</span><span class="s5">,</span>
        <span class="s1">parameters: _DBAPIMultiExecuteParams</span><span class="s5">,</span>
        <span class="s1">compiled_parameters: List[_MutableCoreSingleExecuteParams]</span><span class="s5">,</span>
        <span class="s1">generic_setinputsizes: Optional[_GenericSetInputSizesType]</span><span class="s5">,</span>
        <span class="s1">batch_size: int</span><span class="s5">,</span>
        <span class="s1">sort_by_parameter_order: bool</span><span class="s5">,</span>
        <span class="s1">schema_translate_map: Optional[SchemaTranslateMapType]</span><span class="s5">,</span>
    <span class="s1">) -&gt; Iterator[_InsertManyValuesBatch]:</span>
        <span class="s1">imv = self._insertmanyvalues</span>
        <span class="s3">assert </span><span class="s1">imv </span><span class="s3">is not None</span>

        <span class="s3">if not </span><span class="s1">imv.sentinel_param_keys:</span>
            <span class="s1">_sentinel_from_params = </span><span class="s3">None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">_sentinel_from_params = operator.itemgetter(</span>
                <span class="s1">*imv.sentinel_param_keys</span>
            <span class="s1">)</span>

        <span class="s1">lenparams = len(parameters)</span>
        <span class="s3">if </span><span class="s1">imv.is_default_expr </span><span class="s3">and not </span><span class="s1">self.dialect.supports_default_metavalue:</span>
            <span class="s0"># backend doesn't support</span>
            <span class="s0"># INSERT INTO table (pk_col) VALUES (DEFAULT), (DEFAULT), ...</span>
            <span class="s0"># at the moment this is basically SQL Server due to</span>
            <span class="s0"># not being able to use DEFAULT for identity column</span>
            <span class="s0"># just yield out that many single statements!  still</span>
            <span class="s0"># faster than a whole connection.execute() call ;)</span>
            <span class="s0">#</span>
            <span class="s0"># note we still are taking advantage of the fact that we know</span>
            <span class="s0"># we are using RETURNING.   The generalized approach of fetching</span>
            <span class="s0"># cursor.lastrowid etc. still goes through the more heavyweight</span>
            <span class="s0"># &quot;ExecutionContext per statement&quot; system as it isn't usable</span>
            <span class="s0"># as a generic &quot;RETURNING&quot; approach</span>
            <span class="s1">use_row_at_a_time = </span><span class="s3">True</span>
            <span class="s1">downgraded = </span><span class="s3">False</span>
        <span class="s3">elif not </span><span class="s1">self.dialect.supports_multivalues_insert </span><span class="s3">or </span><span class="s1">(</span>
            <span class="s1">sort_by_parameter_order</span>
            <span class="s3">and </span><span class="s1">self._result_columns</span>
            <span class="s3">and </span><span class="s1">(imv.sentinel_columns </span><span class="s3">is None or </span><span class="s1">imv.includes_upsert_behaviors)</span>
        <span class="s1">):</span>
            <span class="s0"># deterministic order was requested and the compiler could</span>
            <span class="s0"># not organize sentinel columns for this dialect/statement.</span>
            <span class="s0"># use row at a time</span>
            <span class="s1">use_row_at_a_time = </span><span class="s3">True</span>
            <span class="s1">downgraded = </span><span class="s3">True</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">use_row_at_a_time = </span><span class="s3">False</span>
            <span class="s1">downgraded = </span><span class="s3">False</span>

        <span class="s3">if </span><span class="s1">use_row_at_a_time:</span>
            <span class="s3">for </span><span class="s1">batchnum</span><span class="s5">, </span><span class="s1">(param</span><span class="s5">, </span><span class="s1">compiled_param) </span><span class="s3">in </span><span class="s1">enumerate(</span>
                <span class="s1">cast(</span>
                    <span class="s4">&quot;Sequence[Tuple[_DBAPISingleExecuteParams, _MutableCoreSingleExecuteParams]]&quot;</span><span class="s5">,  </span><span class="s0"># noqa: E501</span>
                    <span class="s1">zip(parameters</span><span class="s5">, </span><span class="s1">compiled_parameters)</span><span class="s5">,</span>
                <span class="s1">)</span><span class="s5">,</span>
                <span class="s6">1</span><span class="s5">,</span>
            <span class="s1">):</span>
                <span class="s3">yield </span><span class="s1">_InsertManyValuesBatch(</span>
                    <span class="s1">statement</span><span class="s5">,</span>
                    <span class="s1">param</span><span class="s5">,</span>
                    <span class="s1">generic_setinputsizes</span><span class="s5">,</span>
                    <span class="s1">[param]</span><span class="s5">,</span>
                    <span class="s1">(</span>
                        <span class="s1">[_sentinel_from_params(compiled_param)]</span>
                        <span class="s3">if </span><span class="s1">_sentinel_from_params</span>
                        <span class="s3">else </span><span class="s1">[]</span>
                    <span class="s1">)</span><span class="s5">,</span>
                    <span class="s6">1</span><span class="s5">,</span>
                    <span class="s1">batchnum</span><span class="s5">,</span>
                    <span class="s1">lenparams</span><span class="s5">,</span>
                    <span class="s1">sort_by_parameter_order</span><span class="s5">,</span>
                    <span class="s1">downgraded</span><span class="s5">,</span>
                <span class="s1">)</span>
            <span class="s3">return</span>

        <span class="s3">if </span><span class="s1">schema_translate_map:</span>
            <span class="s1">rst = functools.partial(</span>
                <span class="s1">self.preparer._render_schema_translates</span><span class="s5">,</span>
                <span class="s1">schema_translate_map=schema_translate_map</span><span class="s5">,</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">rst = </span><span class="s3">None</span>

        <span class="s1">imv_single_values_expr = imv.single_values_expr</span>
        <span class="s3">if </span><span class="s1">rst:</span>
            <span class="s1">imv_single_values_expr = rst(imv_single_values_expr)</span>

        <span class="s1">executemany_values = </span><span class="s4">f&quot;(</span><span class="s7">{</span><span class="s1">imv_single_values_expr</span><span class="s7">}</span><span class="s4">)&quot;</span>
        <span class="s1">statement = statement.replace(executemany_values</span><span class="s5">, </span><span class="s4">&quot;__EXECMANY_TOKEN__&quot;</span><span class="s1">)</span>

        <span class="s0"># Use optional insertmanyvalues_max_parameters</span>
        <span class="s0"># to further shrink the batch size so that there are no more than</span>
        <span class="s0"># insertmanyvalues_max_parameters params.</span>
        <span class="s0"># Currently used by SQL Server, which limits statements to 2100 bound</span>
        <span class="s0"># parameters (actually 2099).</span>
        <span class="s1">max_params = self.dialect.insertmanyvalues_max_parameters</span>
        <span class="s3">if </span><span class="s1">max_params:</span>
            <span class="s1">total_num_of_params = len(self.bind_names)</span>
            <span class="s1">num_params_per_batch = len(imv.insert_crud_params)</span>
            <span class="s1">num_params_outside_of_batch = (</span>
                <span class="s1">total_num_of_params - num_params_per_batch</span>
            <span class="s1">)</span>
            <span class="s1">batch_size = min(</span>
                <span class="s1">batch_size</span><span class="s5">,</span>
                <span class="s1">(</span>
                    <span class="s1">(max_params - num_params_outside_of_batch)</span>
                    <span class="s1">// num_params_per_batch</span>
                <span class="s1">)</span><span class="s5">,</span>
            <span class="s1">)</span>

        <span class="s1">batches = cast(</span><span class="s4">&quot;List[Sequence[Any]]&quot;</span><span class="s5">, </span><span class="s1">list(parameters))</span>
        <span class="s1">compiled_batches = cast(</span>
            <span class="s4">&quot;List[Sequence[Any]]&quot;</span><span class="s5">, </span><span class="s1">list(compiled_parameters)</span>
        <span class="s1">)</span>

        <span class="s1">processed_setinputsizes: Optional[_GenericSetInputSizesType] = </span><span class="s3">None</span>
        <span class="s1">batchnum = </span><span class="s6">1</span>
        <span class="s1">total_batches = lenparams // batch_size + (</span>
            <span class="s6">1 </span><span class="s3">if </span><span class="s1">lenparams % batch_size </span><span class="s3">else </span><span class="s6">0</span>
        <span class="s1">)</span>

        <span class="s1">insert_crud_params = imv.insert_crud_params</span>
        <span class="s3">assert </span><span class="s1">insert_crud_params </span><span class="s3">is not None</span>

        <span class="s3">if </span><span class="s1">rst:</span>
            <span class="s1">insert_crud_params = [</span>
                <span class="s1">(col</span><span class="s5">, </span><span class="s1">key</span><span class="s5">, </span><span class="s1">rst(expr)</span><span class="s5">, </span><span class="s1">st)</span>
                <span class="s3">for </span><span class="s1">col</span><span class="s5">, </span><span class="s1">key</span><span class="s5">, </span><span class="s1">expr</span><span class="s5">, </span><span class="s1">st </span><span class="s3">in </span><span class="s1">insert_crud_params</span>
            <span class="s1">]</span>

        <span class="s1">escaped_bind_names: Mapping[str</span><span class="s5">, </span><span class="s1">str]</span>
        <span class="s1">expand_pos_lower_index = expand_pos_upper_index = </span><span class="s6">0</span>

        <span class="s3">if not </span><span class="s1">self.positional:</span>
            <span class="s3">if </span><span class="s1">self.escaped_bind_names:</span>
                <span class="s1">escaped_bind_names = self.escaped_bind_names</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">escaped_bind_names = {}</span>

            <span class="s1">all_keys = set(parameters[</span><span class="s6">0</span><span class="s1">])</span>

            <span class="s3">def </span><span class="s1">apply_placeholders(keys</span><span class="s5">, </span><span class="s1">formatted):</span>
                <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">keys:</span>
                    <span class="s1">key = escaped_bind_names.get(key</span><span class="s5">, </span><span class="s1">key)</span>
                    <span class="s1">formatted = formatted.replace(</span>
                        <span class="s1">self.bindtemplate % {</span><span class="s4">&quot;name&quot;</span><span class="s1">: key}</span><span class="s5">,</span>
                        <span class="s1">self.bindtemplate</span>
                        <span class="s1">% {</span><span class="s4">&quot;name&quot;</span><span class="s1">: </span><span class="s4">f&quot;</span><span class="s7">{</span><span class="s1">key</span><span class="s7">}</span><span class="s4">__EXECMANY_INDEX__&quot;</span><span class="s1">}</span><span class="s5">,</span>
                    <span class="s1">)</span>
                <span class="s3">return </span><span class="s1">formatted</span>

            <span class="s3">if </span><span class="s1">imv.embed_values_counter:</span>
                <span class="s1">imv_values_counter = </span><span class="s4">&quot;, _IMV_VALUES_COUNTER&quot;</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">imv_values_counter = </span><span class="s4">&quot;&quot;</span>
            <span class="s1">formatted_values_clause = </span><span class="s4">f&quot;&quot;&quot;(</span><span class="s7">{</span><span class="s4">', '</span><span class="s1">.join(</span>
                <span class="s1">apply_placeholders(bind_keys</span><span class="s5">, </span><span class="s1">formatted)</span>
                <span class="s3">for </span><span class="s1">_</span><span class="s5">, </span><span class="s1">_</span><span class="s5">, </span><span class="s1">formatted</span><span class="s5">, </span><span class="s1">bind_keys </span><span class="s3">in </span><span class="s1">insert_crud_params</span>
            <span class="s1">)</span><span class="s7">}{</span><span class="s1">imv_values_counter</span><span class="s7">}</span><span class="s4">)&quot;&quot;&quot;</span>

            <span class="s1">keys_to_replace = all_keys.intersection(</span>
                <span class="s1">escaped_bind_names.get(key</span><span class="s5">, </span><span class="s1">key)</span>
                <span class="s3">for </span><span class="s1">_</span><span class="s5">, </span><span class="s1">_</span><span class="s5">, </span><span class="s1">_</span><span class="s5">, </span><span class="s1">bind_keys </span><span class="s3">in </span><span class="s1">insert_crud_params</span>
                <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">bind_keys</span>
            <span class="s1">)</span>
            <span class="s1">base_parameters = {</span>
                <span class="s1">key: parameters[</span><span class="s6">0</span><span class="s1">][key]</span>
                <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">all_keys.difference(keys_to_replace)</span>
            <span class="s1">}</span>
            <span class="s1">executemany_values_w_comma = </span><span class="s4">&quot;&quot;</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">formatted_values_clause = </span><span class="s4">&quot;&quot;</span>
            <span class="s1">keys_to_replace = set()</span>
            <span class="s1">base_parameters = {}</span>

            <span class="s3">if </span><span class="s1">imv.embed_values_counter:</span>
                <span class="s1">executemany_values_w_comma = (</span>
                    <span class="s4">f&quot;(</span><span class="s7">{</span><span class="s1">imv_single_values_expr</span><span class="s7">}</span><span class="s4">, _IMV_VALUES_COUNTER), &quot;</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">executemany_values_w_comma = </span><span class="s4">f&quot;(</span><span class="s7">{</span><span class="s1">imv_single_values_expr</span><span class="s7">}</span><span class="s4">), &quot;</span>

            <span class="s1">all_names_we_will_expand: Set[str] = set()</span>
            <span class="s3">for </span><span class="s1">elem </span><span class="s3">in </span><span class="s1">imv.insert_crud_params:</span>
                <span class="s1">all_names_we_will_expand.update(elem[</span><span class="s6">3</span><span class="s1">])</span>

            <span class="s0"># get the start and end position in a particular list</span>
            <span class="s0"># of parameters where we will be doing the &quot;expanding&quot;.</span>
            <span class="s0"># statements can have params on either side or both sides,</span>
            <span class="s0"># given RETURNING and CTEs</span>
            <span class="s3">if </span><span class="s1">all_names_we_will_expand:</span>
                <span class="s1">positiontup = self.positiontup</span>
                <span class="s3">assert </span><span class="s1">positiontup </span><span class="s3">is not None</span>

                <span class="s1">all_expand_positions = {</span>
                    <span class="s1">idx</span>
                    <span class="s3">for </span><span class="s1">idx</span><span class="s5">, </span><span class="s1">name </span><span class="s3">in </span><span class="s1">enumerate(positiontup)</span>
                    <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">all_names_we_will_expand</span>
                <span class="s1">}</span>
                <span class="s1">expand_pos_lower_index = min(all_expand_positions)</span>
                <span class="s1">expand_pos_upper_index = max(all_expand_positions) + </span><span class="s6">1</span>
                <span class="s3">assert </span><span class="s1">(</span>
                    <span class="s1">len(all_expand_positions)</span>
                    <span class="s1">== expand_pos_upper_index - expand_pos_lower_index</span>
                <span class="s1">)</span>

            <span class="s3">if </span><span class="s1">self._numeric_binds:</span>
                <span class="s1">escaped = re.escape(self._numeric_binds_identifier_char)</span>
                <span class="s1">executemany_values_w_comma = re.sub(</span>
                    <span class="s4">rf&quot;</span><span class="s7">{</span><span class="s1">escaped</span><span class="s7">}</span><span class="s4">\d+&quot;</span><span class="s5">, </span><span class="s4">&quot;%s&quot;</span><span class="s5">, </span><span class="s1">executemany_values_w_comma</span>
                <span class="s1">)</span>

        <span class="s3">while </span><span class="s1">batches:</span>
            <span class="s1">batch = batches[</span><span class="s6">0</span><span class="s1">:batch_size]</span>
            <span class="s1">compiled_batch = compiled_batches[</span><span class="s6">0</span><span class="s1">:batch_size]</span>

            <span class="s1">batches[</span><span class="s6">0</span><span class="s1">:batch_size] = []</span>
            <span class="s1">compiled_batches[</span><span class="s6">0</span><span class="s1">:batch_size] = []</span>

            <span class="s3">if </span><span class="s1">batches:</span>
                <span class="s1">current_batch_size = batch_size</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">current_batch_size = len(batch)</span>

            <span class="s3">if </span><span class="s1">generic_setinputsizes:</span>
                <span class="s0"># if setinputsizes is present, expand this collection to</span>
                <span class="s0"># suit the batch length as well</span>
                <span class="s0"># currently this will be mssql+pyodbc for internal dialects</span>
                <span class="s1">processed_setinputsizes = [</span>
                    <span class="s1">(new_key</span><span class="s5">, </span><span class="s1">len_</span><span class="s5">, </span><span class="s1">typ)</span>
                    <span class="s3">for </span><span class="s1">new_key</span><span class="s5">, </span><span class="s1">len_</span><span class="s5">, </span><span class="s1">typ </span><span class="s3">in </span><span class="s1">(</span>
                        <span class="s1">(</span><span class="s4">f&quot;</span><span class="s7">{</span><span class="s1">key</span><span class="s7">}</span><span class="s4">_</span><span class="s7">{</span><span class="s1">index</span><span class="s7">}</span><span class="s4">&quot;</span><span class="s5">, </span><span class="s1">len_</span><span class="s5">, </span><span class="s1">typ)</span>
                        <span class="s3">for </span><span class="s1">index </span><span class="s3">in </span><span class="s1">range(current_batch_size)</span>
                        <span class="s3">for </span><span class="s1">key</span><span class="s5">, </span><span class="s1">len_</span><span class="s5">, </span><span class="s1">typ </span><span class="s3">in </span><span class="s1">generic_setinputsizes</span>
                    <span class="s1">)</span>
                <span class="s1">]</span>

            <span class="s1">replaced_parameters: Any</span>
            <span class="s3">if </span><span class="s1">self.positional:</span>
                <span class="s1">num_ins_params = imv.num_positional_params_counted</span>

                <span class="s1">batch_iterator: Iterable[Sequence[Any]]</span>
                <span class="s1">extra_params_left: Sequence[Any]</span>
                <span class="s1">extra_params_right: Sequence[Any]</span>

                <span class="s3">if </span><span class="s1">num_ins_params == len(batch[</span><span class="s6">0</span><span class="s1">]):</span>
                    <span class="s1">extra_params_left = extra_params_right = ()</span>
                    <span class="s1">batch_iterator = batch</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">extra_params_left = batch[</span><span class="s6">0</span><span class="s1">][:expand_pos_lower_index]</span>
                    <span class="s1">extra_params_right = batch[</span><span class="s6">0</span><span class="s1">][expand_pos_upper_index:]</span>
                    <span class="s1">batch_iterator = (</span>
                        <span class="s1">b[expand_pos_lower_index:expand_pos_upper_index]</span>
                        <span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">batch</span>
                    <span class="s1">)</span>

                <span class="s3">if </span><span class="s1">imv.embed_values_counter:</span>
                    <span class="s1">expanded_values_string = (</span>
                        <span class="s4">&quot;&quot;</span><span class="s1">.join(</span>
                            <span class="s1">executemany_values_w_comma.replace(</span>
                                <span class="s4">&quot;_IMV_VALUES_COUNTER&quot;</span><span class="s5">, </span><span class="s1">str(i)</span>
                            <span class="s1">)</span>
                            <span class="s3">for </span><span class="s1">i</span><span class="s5">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">enumerate(batch)</span>
                        <span class="s1">)</span>
                    <span class="s1">)[:-</span><span class="s6">2</span><span class="s1">]</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">expanded_values_string = (</span>
                        <span class="s1">(executemany_values_w_comma * current_batch_size)</span>
                    <span class="s1">)[:-</span><span class="s6">2</span><span class="s1">]</span>

                <span class="s3">if </span><span class="s1">self._numeric_binds </span><span class="s3">and </span><span class="s1">num_ins_params &gt; </span><span class="s6">0</span><span class="s1">:</span>
                    <span class="s0"># numeric will always number the parameters inside of</span>
                    <span class="s0"># VALUES (and thus order self.positiontup) to be higher</span>
                    <span class="s0"># than non-VALUES parameters, no matter where in the</span>
                    <span class="s0"># statement those non-VALUES parameters appear (this is</span>
                    <span class="s0"># ensured in _process_numeric by numbering first all</span>
                    <span class="s0"># params that are not in _values_bindparam)</span>
                    <span class="s0"># therefore all extra params are always</span>
                    <span class="s0"># on the left side and numbered lower than the VALUES</span>
                    <span class="s0"># parameters</span>
                    <span class="s3">assert not </span><span class="s1">extra_params_right</span>

                    <span class="s1">start = expand_pos_lower_index + </span><span class="s6">1</span>
                    <span class="s1">end = num_ins_params * (current_batch_size) + start</span>

                    <span class="s0"># need to format here, since statement may contain</span>
                    <span class="s0"># unescaped %, while values_string contains just (%s, %s)</span>
                    <span class="s1">positions = tuple(</span>
                        <span class="s4">f&quot;</span><span class="s7">{</span><span class="s1">self._numeric_binds_identifier_char</span><span class="s7">}{</span><span class="s1">i</span><span class="s7">}</span><span class="s4">&quot;</span>
                        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(start</span><span class="s5">, </span><span class="s1">end)</span>
                    <span class="s1">)</span>
                    <span class="s1">expanded_values_string = expanded_values_string % positions</span>

                <span class="s1">replaced_statement = statement.replace(</span>
                    <span class="s4">&quot;__EXECMANY_TOKEN__&quot;</span><span class="s5">, </span><span class="s1">expanded_values_string</span>
                <span class="s1">)</span>

                <span class="s1">replaced_parameters = tuple(</span>
                    <span class="s1">itertools.chain.from_iterable(batch_iterator)</span>
                <span class="s1">)</span>

                <span class="s1">replaced_parameters = (</span>
                    <span class="s1">extra_params_left</span>
                    <span class="s1">+ replaced_parameters</span>
                    <span class="s1">+ extra_params_right</span>
                <span class="s1">)</span>

            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">replaced_values_clauses = []</span>
                <span class="s1">replaced_parameters = base_parameters.copy()</span>

                <span class="s3">for </span><span class="s1">i</span><span class="s5">, </span><span class="s1">param </span><span class="s3">in </span><span class="s1">enumerate(batch):</span>
                    <span class="s1">fmv = formatted_values_clause.replace(</span>
                        <span class="s4">&quot;EXECMANY_INDEX__&quot;</span><span class="s5">, </span><span class="s1">str(i)</span>
                    <span class="s1">)</span>
                    <span class="s3">if </span><span class="s1">imv.embed_values_counter:</span>
                        <span class="s1">fmv = fmv.replace(</span><span class="s4">&quot;_IMV_VALUES_COUNTER&quot;</span><span class="s5">, </span><span class="s1">str(i))</span>

                    <span class="s1">replaced_values_clauses.append(fmv)</span>
                    <span class="s1">replaced_parameters.update(</span>
                        <span class="s1">{</span><span class="s4">f&quot;</span><span class="s7">{</span><span class="s1">key</span><span class="s7">}</span><span class="s4">__</span><span class="s7">{</span><span class="s1">i</span><span class="s7">}</span><span class="s4">&quot;</span><span class="s1">: param[key] </span><span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">keys_to_replace}</span>
                    <span class="s1">)</span>

                <span class="s1">replaced_statement = statement.replace(</span>
                    <span class="s4">&quot;__EXECMANY_TOKEN__&quot;</span><span class="s5">,</span>
                    <span class="s4">&quot;, &quot;</span><span class="s1">.join(replaced_values_clauses)</span><span class="s5">,</span>
                <span class="s1">)</span>

            <span class="s3">yield </span><span class="s1">_InsertManyValuesBatch(</span>
                <span class="s1">replaced_statement</span><span class="s5">,</span>
                <span class="s1">replaced_parameters</span><span class="s5">,</span>
                <span class="s1">processed_setinputsizes</span><span class="s5">,</span>
                <span class="s1">batch</span><span class="s5">,</span>
                <span class="s1">(</span>
                    <span class="s1">[_sentinel_from_params(cb) </span><span class="s3">for </span><span class="s1">cb </span><span class="s3">in </span><span class="s1">compiled_batch]</span>
                    <span class="s3">if </span><span class="s1">_sentinel_from_params</span>
                    <span class="s3">else </span><span class="s1">[]</span>
                <span class="s1">)</span><span class="s5">,</span>
                <span class="s1">current_batch_size</span><span class="s5">,</span>
                <span class="s1">batchnum</span><span class="s5">,</span>
                <span class="s1">total_batches</span><span class="s5">,</span>
                <span class="s1">sort_by_parameter_order</span><span class="s5">,</span>
                <span class="s3">False</span><span class="s5">,</span>
            <span class="s1">)</span>
            <span class="s1">batchnum += </span><span class="s6">1</span>

    <span class="s3">def </span><span class="s1">visit_insert(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">insert_stmt</span><span class="s5">, </span><span class="s1">visited_bindparam=</span><span class="s3">None</span><span class="s5">, </span><span class="s1">visiting_cte=</span><span class="s3">None</span><span class="s5">, </span><span class="s1">**kw</span>
    <span class="s1">):</span>
        <span class="s1">compile_state = insert_stmt._compile_state_factory(</span>
            <span class="s1">insert_stmt</span><span class="s5">, </span><span class="s1">self</span><span class="s5">, </span><span class="s1">**kw</span>
        <span class="s1">)</span>
        <span class="s1">insert_stmt = compile_state.statement</span>

        <span class="s3">if </span><span class="s1">visiting_cte </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">kw[</span><span class="s4">&quot;visiting_cte&quot;</span><span class="s1">] = visiting_cte</span>
            <span class="s1">toplevel = </span><span class="s3">False</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">toplevel = </span><span class="s3">not </span><span class="s1">self.stack</span>

        <span class="s3">if </span><span class="s1">toplevel:</span>
            <span class="s1">self.isinsert = </span><span class="s3">True</span>
            <span class="s3">if not </span><span class="s1">self.dml_compile_state:</span>
                <span class="s1">self.dml_compile_state = compile_state</span>
            <span class="s3">if not </span><span class="s1">self.compile_state:</span>
                <span class="s1">self.compile_state = compile_state</span>

        <span class="s1">self.stack.append(</span>
            <span class="s1">{</span>
                <span class="s4">&quot;correlate_froms&quot;</span><span class="s1">: set()</span><span class="s5">,</span>
                <span class="s4">&quot;asfrom_froms&quot;</span><span class="s1">: set()</span><span class="s5">,</span>
                <span class="s4">&quot;selectable&quot;</span><span class="s1">: insert_stmt</span><span class="s5">,</span>
            <span class="s1">}</span>
        <span class="s1">)</span>

        <span class="s1">counted_bindparam = </span><span class="s6">0</span>

        <span class="s0"># reset any incoming &quot;visited_bindparam&quot; collection</span>
        <span class="s1">visited_bindparam = </span><span class="s3">None</span>

        <span class="s0"># for positional, insertmanyvalues needs to know how many</span>
        <span class="s0"># bound parameters are in the VALUES sequence; there's no simple</span>
        <span class="s0"># rule because default expressions etc. can have zero or more</span>
        <span class="s0"># params inside them.   After multiple attempts to figure this out,</span>
        <span class="s0"># this very simplistic &quot;count after&quot; works and is</span>
        <span class="s0"># likely the least amount of callcounts, though looks clumsy</span>
        <span class="s3">if </span><span class="s1">self.positional </span><span class="s3">and </span><span class="s1">visiting_cte </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s0"># if we are inside a CTE, don't count parameters</span>
            <span class="s0"># here since they wont be for insertmanyvalues. keep</span>
            <span class="s0"># visited_bindparam at None so no counting happens.</span>
            <span class="s0"># see #9173</span>
            <span class="s1">visited_bindparam = []</span>

        <span class="s1">crud_params_struct = crud._get_crud_params(</span>
            <span class="s1">self</span><span class="s5">,</span>
            <span class="s1">insert_stmt</span><span class="s5">,</span>
            <span class="s1">compile_state</span><span class="s5">,</span>
            <span class="s1">toplevel</span><span class="s5">,</span>
            <span class="s1">visited_bindparam=visited_bindparam</span><span class="s5">,</span>
            <span class="s1">**kw</span><span class="s5">,</span>
        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">self.positional </span><span class="s3">and </span><span class="s1">visited_bindparam </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">counted_bindparam = len(visited_bindparam)</span>
            <span class="s3">if </span><span class="s1">self._numeric_binds:</span>
                <span class="s3">if </span><span class="s1">self._values_bindparam </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">self._values_bindparam += visited_bindparam</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">self._values_bindparam = visited_bindparam</span>

        <span class="s1">crud_params_single = crud_params_struct.single_params</span>

        <span class="s3">if </span><span class="s1">(</span>
            <span class="s3">not </span><span class="s1">crud_params_single</span>
            <span class="s3">and not </span><span class="s1">self.dialect.supports_default_values</span>
            <span class="s3">and not </span><span class="s1">self.dialect.supports_default_metavalue</span>
            <span class="s3">and not </span><span class="s1">self.dialect.supports_empty_insert</span>
        <span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
                <span class="s4">&quot;The '%s' dialect with current database &quot;</span>
                <span class="s4">&quot;version settings does not support empty &quot;</span>
                <span class="s4">&quot;inserts.&quot; </span><span class="s1">% self.dialect.name</span>
            <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">compile_state._has_multi_parameters:</span>
            <span class="s3">if not </span><span class="s1">self.dialect.supports_multivalues_insert:</span>
                <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
                    <span class="s4">&quot;The '%s' dialect with current database &quot;</span>
                    <span class="s4">&quot;version settings does not support &quot;</span>
                    <span class="s4">&quot;in-place multirow inserts.&quot; </span><span class="s1">% self.dialect.name</span>
                <span class="s1">)</span>
            <span class="s3">elif </span><span class="s1">(</span>
                <span class="s1">self.implicit_returning </span><span class="s3">or </span><span class="s1">insert_stmt._returning</span>
            <span class="s1">) </span><span class="s3">and </span><span class="s1">insert_stmt._sort_by_parameter_order:</span>
                <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
                    <span class="s4">&quot;RETURNING cannot be determinstically sorted when &quot;</span>
                    <span class="s4">&quot;using an INSERT which includes multi-row values().&quot;</span>
                <span class="s1">)</span>
            <span class="s1">crud_params_single = crud_params_struct.single_params</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">crud_params_single = crud_params_struct.single_params</span>

        <span class="s1">preparer = self.preparer</span>
        <span class="s1">supports_default_values = self.dialect.supports_default_values</span>

        <span class="s1">text = </span><span class="s4">&quot;INSERT &quot;</span>

        <span class="s3">if </span><span class="s1">insert_stmt._prefixes:</span>
            <span class="s1">text += self._generate_prefixes(</span>
                <span class="s1">insert_stmt</span><span class="s5">, </span><span class="s1">insert_stmt._prefixes</span><span class="s5">, </span><span class="s1">**kw</span>
            <span class="s1">)</span>

        <span class="s1">text += </span><span class="s4">&quot;INTO &quot;</span>
        <span class="s1">table_text = preparer.format_table(insert_stmt.table)</span>

        <span class="s3">if </span><span class="s1">insert_stmt._hints:</span>
            <span class="s1">_</span><span class="s5">, </span><span class="s1">table_text = self._setup_crud_hints(insert_stmt</span><span class="s5">, </span><span class="s1">table_text)</span>

        <span class="s3">if </span><span class="s1">insert_stmt._independent_ctes:</span>
            <span class="s1">self._dispatch_independent_ctes(insert_stmt</span><span class="s5">, </span><span class="s1">kw)</span>

        <span class="s1">text += table_text</span>

        <span class="s3">if </span><span class="s1">crud_params_single </span><span class="s3">or not </span><span class="s1">supports_default_values:</span>
            <span class="s1">text += </span><span class="s4">&quot; (%s)&quot; </span><span class="s1">% </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
                <span class="s1">[expr </span><span class="s3">for </span><span class="s1">_</span><span class="s5">, </span><span class="s1">expr</span><span class="s5">, </span><span class="s1">_</span><span class="s5">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">crud_params_single]</span>
            <span class="s1">)</span>

        <span class="s0"># look for insertmanyvalues attributes that would have been configured</span>
        <span class="s0"># by crud.py as it scanned through the columns to be part of the</span>
        <span class="s0"># INSERT</span>
        <span class="s1">use_insertmanyvalues = crud_params_struct.use_insertmanyvalues</span>
        <span class="s1">named_sentinel_params: Optional[Sequence[str]] = </span><span class="s3">None</span>
        <span class="s1">add_sentinel_cols = </span><span class="s3">None</span>
        <span class="s1">implicit_sentinel = </span><span class="s3">False</span>

        <span class="s1">returning_cols = self.implicit_returning </span><span class="s3">or </span><span class="s1">insert_stmt._returning</span>
        <span class="s3">if </span><span class="s1">returning_cols:</span>
            <span class="s1">add_sentinel_cols = crud_params_struct.use_sentinel_columns</span>
            <span class="s3">if </span><span class="s1">add_sentinel_cols </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">assert </span><span class="s1">use_insertmanyvalues</span>

                <span class="s0"># search for the sentinel column explicitly present</span>
                <span class="s0"># in the INSERT columns list, and additionally check that</span>
                <span class="s0"># this column has a bound parameter name set up that's in the</span>
                <span class="s0"># parameter list.  If both of these cases are present, it means</span>
                <span class="s0"># we will have a client side value for the sentinel in each</span>
                <span class="s0"># parameter set.</span>

                <span class="s1">_params_by_col = {</span>
                    <span class="s1">col: param_names</span>
                    <span class="s3">for </span><span class="s1">col</span><span class="s5">, </span><span class="s1">_</span><span class="s5">, </span><span class="s1">_</span><span class="s5">, </span><span class="s1">param_names </span><span class="s3">in </span><span class="s1">crud_params_single</span>
                <span class="s1">}</span>
                <span class="s1">named_sentinel_params = []</span>
                <span class="s3">for </span><span class="s1">_add_sentinel_col </span><span class="s3">in </span><span class="s1">add_sentinel_cols:</span>
                    <span class="s3">if </span><span class="s1">_add_sentinel_col </span><span class="s3">not in </span><span class="s1">_params_by_col:</span>
                        <span class="s1">named_sentinel_params = </span><span class="s3">None</span>
                        <span class="s3">break</span>
                    <span class="s1">param_name = self._within_exec_param_key_getter(</span>
                        <span class="s1">_add_sentinel_col</span>
                    <span class="s1">)</span>
                    <span class="s3">if </span><span class="s1">param_name </span><span class="s3">not in </span><span class="s1">_params_by_col[_add_sentinel_col]:</span>
                        <span class="s1">named_sentinel_params = </span><span class="s3">None</span>
                        <span class="s3">break</span>
                    <span class="s1">named_sentinel_params.append(param_name)</span>

                <span class="s3">if </span><span class="s1">named_sentinel_params </span><span class="s3">is None</span><span class="s1">:</span>
                    <span class="s0"># if we are not going to have a client side value for</span>
                    <span class="s0"># the sentinel in the parameter set, that means it's</span>
                    <span class="s0"># an autoincrement, an IDENTITY, or a server-side SQL</span>
                    <span class="s0"># expression like nextval('seqname').  So this is</span>
                    <span class="s0"># an &quot;implicit&quot; sentinel; we will look for it in</span>
                    <span class="s0"># RETURNING</span>
                    <span class="s0"># only, and then sort on it.  For this case on PG,</span>
                    <span class="s0"># SQL Server we have to use a special INSERT form</span>
                    <span class="s0"># that guarantees the server side function lines up with</span>
                    <span class="s0"># the entries in the VALUES.</span>
                    <span class="s3">if </span><span class="s1">(</span>
                        <span class="s1">self.dialect.insertmanyvalues_implicit_sentinel</span>
                        <span class="s1">&amp; InsertmanyvaluesSentinelOpts.ANY_AUTOINCREMENT</span>
                    <span class="s1">):</span>
                        <span class="s1">implicit_sentinel = </span><span class="s3">True</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s0"># here, we are not using a sentinel at all</span>
                        <span class="s0"># and we are likely the SQLite dialect.</span>
                        <span class="s0"># The first add_sentinel_col that we have should not</span>
                        <span class="s0"># be marked as &quot;insert_sentinel=True&quot;.  if it was,</span>
                        <span class="s0"># an error should have been raised in</span>
                        <span class="s0"># _get_sentinel_column_for_table.</span>
                        <span class="s3">assert not </span><span class="s1">add_sentinel_cols[</span><span class="s6">0</span><span class="s1">]._insert_sentinel</span><span class="s5">, </span><span class="s1">(</span>
                            <span class="s4">&quot;sentinel selection rules should have prevented &quot;</span>
                            <span class="s4">&quot;us from getting here for this dialect&quot;</span>
                        <span class="s1">)</span>

                <span class="s0"># always put the sentinel columns last.  even if they are</span>
                <span class="s0"># in the returning list already, they will be there twice</span>
                <span class="s0"># then.</span>
                <span class="s1">returning_cols = list(returning_cols) + list(add_sentinel_cols)</span>

            <span class="s1">returning_clause = self.returning_clause(</span>
                <span class="s1">insert_stmt</span><span class="s5">,</span>
                <span class="s1">returning_cols</span><span class="s5">,</span>
                <span class="s1">populate_result_map=toplevel</span><span class="s5">,</span>
            <span class="s1">)</span>

            <span class="s3">if </span><span class="s1">self.returning_precedes_values:</span>
                <span class="s1">text += </span><span class="s4">&quot; &quot; </span><span class="s1">+ returning_clause</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">returning_clause = </span><span class="s3">None</span>

        <span class="s3">if </span><span class="s1">insert_stmt.select </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s0"># placed here by crud.py</span>
            <span class="s1">select_text = self.process(</span>
                <span class="s1">self.stack[-</span><span class="s6">1</span><span class="s1">][</span><span class="s4">&quot;insert_from_select&quot;</span><span class="s1">]</span><span class="s5">, </span><span class="s1">insert_into=</span><span class="s3">True</span><span class="s5">, </span><span class="s1">**kw</span>
            <span class="s1">)</span>

            <span class="s3">if </span><span class="s1">self.ctes </span><span class="s3">and </span><span class="s1">self.dialect.cte_follows_insert:</span>
                <span class="s1">nesting_level = len(self.stack) </span><span class="s3">if not </span><span class="s1">toplevel </span><span class="s3">else None</span>
                <span class="s1">text += </span><span class="s4">&quot; %s%s&quot; </span><span class="s1">% (</span>
                    <span class="s1">self._render_cte_clause(</span>
                        <span class="s1">nesting_level=nesting_level</span><span class="s5">,</span>
                        <span class="s1">include_following_stack=</span><span class="s3">True</span><span class="s5">,</span>
                    <span class="s1">)</span><span class="s5">,</span>
                    <span class="s1">select_text</span><span class="s5">,</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">text += </span><span class="s4">&quot; %s&quot; </span><span class="s1">% select_text</span>
        <span class="s3">elif not </span><span class="s1">crud_params_single </span><span class="s3">and </span><span class="s1">supports_default_values:</span>
            <span class="s1">text += </span><span class="s4">&quot; DEFAULT VALUES&quot;</span>
            <span class="s3">if </span><span class="s1">use_insertmanyvalues:</span>
                <span class="s1">self._insertmanyvalues = _InsertManyValues(</span>
                    <span class="s3">True</span><span class="s5">,</span>
                    <span class="s1">self.dialect.default_metavalue_token</span><span class="s5">,</span>
                    <span class="s1">cast(</span>
                        <span class="s4">&quot;List[crud._CrudParamElementStr]&quot;</span><span class="s5">, </span><span class="s1">crud_params_single</span>
                    <span class="s1">)</span><span class="s5">,</span>
                    <span class="s1">counted_bindparam</span><span class="s5">,</span>
                    <span class="s1">sort_by_parameter_order=(</span>
                        <span class="s1">insert_stmt._sort_by_parameter_order</span>
                    <span class="s1">)</span><span class="s5">,</span>
                    <span class="s1">includes_upsert_behaviors=(</span>
                        <span class="s1">insert_stmt._post_values_clause </span><span class="s3">is not None</span>
                    <span class="s1">)</span><span class="s5">,</span>
                    <span class="s1">sentinel_columns=add_sentinel_cols</span><span class="s5">,</span>
                    <span class="s1">num_sentinel_columns=(</span>
                        <span class="s1">len(add_sentinel_cols) </span><span class="s3">if </span><span class="s1">add_sentinel_cols </span><span class="s3">else </span><span class="s6">0</span>
                    <span class="s1">)</span><span class="s5">,</span>
                    <span class="s1">implicit_sentinel=implicit_sentinel</span><span class="s5">,</span>
                <span class="s1">)</span>
        <span class="s3">elif </span><span class="s1">compile_state._has_multi_parameters:</span>
            <span class="s1">text += </span><span class="s4">&quot; VALUES %s&quot; </span><span class="s1">% (</span>
                <span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
                    <span class="s4">&quot;(%s)&quot;</span>
                    <span class="s1">% (</span><span class="s4">&quot;, &quot;</span><span class="s1">.join(value </span><span class="s3">for </span><span class="s1">_</span><span class="s5">, </span><span class="s1">_</span><span class="s5">, </span><span class="s1">value</span><span class="s5">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">crud_param_set))</span>
                    <span class="s3">for </span><span class="s1">crud_param_set </span><span class="s3">in </span><span class="s1">crud_params_struct.all_multi_params</span>
                <span class="s1">)</span><span class="s5">,</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">insert_single_values_expr = </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
                <span class="s1">[</span>
                    <span class="s1">value</span>
                    <span class="s3">for </span><span class="s1">_</span><span class="s5">, </span><span class="s1">_</span><span class="s5">, </span><span class="s1">value</span><span class="s5">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">cast(</span>
                        <span class="s4">&quot;List[crud._CrudParamElementStr]&quot;</span><span class="s5">,</span>
                        <span class="s1">crud_params_single</span><span class="s5">,</span>
                    <span class="s1">)</span>
                <span class="s1">]</span>
            <span class="s1">)</span>

            <span class="s3">if </span><span class="s1">use_insertmanyvalues:</span>
                <span class="s3">if </span><span class="s1">(</span>
                    <span class="s1">implicit_sentinel</span>
                    <span class="s3">and </span><span class="s1">(</span>
                        <span class="s1">self.dialect.insertmanyvalues_implicit_sentinel</span>
                        <span class="s1">&amp; InsertmanyvaluesSentinelOpts.USE_INSERT_FROM_SELECT</span>
                    <span class="s1">)</span>
                    <span class="s0"># this is checking if we have</span>
                    <span class="s0"># INSERT INTO table (id) VALUES (DEFAULT).</span>
                    <span class="s3">and not </span><span class="s1">(crud_params_struct.is_default_metavalue_only)</span>
                <span class="s1">):</span>
                    <span class="s0"># if we have a sentinel column that is server generated,</span>
                    <span class="s0"># then for selected backends render the VALUES list as a</span>
                    <span class="s0"># subquery.  This is the orderable form supported by</span>
                    <span class="s0"># PostgreSQL and SQL Server.</span>
                    <span class="s1">embed_sentinel_value = </span><span class="s3">True</span>

                    <span class="s1">render_bind_casts = (</span>
                        <span class="s1">self.dialect.insertmanyvalues_implicit_sentinel</span>
                        <span class="s1">&amp; InsertmanyvaluesSentinelOpts.RENDER_SELECT_COL_CASTS</span>
                    <span class="s1">)</span>

                    <span class="s1">colnames = </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
                        <span class="s4">f&quot;p</span><span class="s7">{</span><span class="s1">i</span><span class="s7">}</span><span class="s4">&quot; </span><span class="s3">for </span><span class="s1">i</span><span class="s5">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">enumerate(crud_params_single)</span>
                    <span class="s1">)</span>

                    <span class="s3">if </span><span class="s1">render_bind_casts:</span>
                        <span class="s0"># render casts for the SELECT list.  For PG, we are</span>
                        <span class="s0"># already rendering bind casts in the parameter list,</span>
                        <span class="s0"># selectively for the more &quot;tricky&quot; types like ARRAY.</span>
                        <span class="s0"># however, even for the &quot;easy&quot; types, if the parameter</span>
                        <span class="s0"># is NULL for every entry, PG gives up and says</span>
                        <span class="s0"># &quot;it must be TEXT&quot;, which fails for other easy types</span>
                        <span class="s0"># like ints.  So we cast on this side too.</span>
                        <span class="s1">colnames_w_cast = </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
                            <span class="s1">self.render_bind_cast(</span>
                                <span class="s1">col.type</span><span class="s5">,</span>
                                <span class="s1">col.type._unwrapped_dialect_impl(self.dialect)</span><span class="s5">,</span>
                                <span class="s4">f&quot;p</span><span class="s7">{</span><span class="s1">i</span><span class="s7">}</span><span class="s4">&quot;</span><span class="s5">,</span>
                            <span class="s1">)</span>
                            <span class="s3">for </span><span class="s1">i</span><span class="s5">, </span><span class="s1">(col</span><span class="s5">, </span><span class="s1">*_) </span><span class="s3">in </span><span class="s1">enumerate(crud_params_single)</span>
                        <span class="s1">)</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">colnames_w_cast = colnames</span>

                    <span class="s1">text += (</span>
                        <span class="s4">f&quot; SELECT </span><span class="s7">{</span><span class="s1">colnames_w_cast</span><span class="s7">} </span><span class="s4">FROM &quot;</span>
                        <span class="s4">f&quot;(VALUES (</span><span class="s7">{</span><span class="s1">insert_single_values_expr</span><span class="s7">}</span><span class="s4">)) &quot;</span>
                        <span class="s4">f&quot;AS imp_sen(</span><span class="s7">{</span><span class="s1">colnames</span><span class="s7">}</span><span class="s4">, sen_counter) &quot;</span>
                        <span class="s4">&quot;ORDER BY sen_counter&quot;</span>
                    <span class="s1">)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s0"># otherwise, if no sentinel or backend doesn't support</span>
                    <span class="s0"># orderable subquery form, use a plain VALUES list</span>
                    <span class="s1">embed_sentinel_value = </span><span class="s3">False</span>
                    <span class="s1">text += </span><span class="s4">f&quot; VALUES (</span><span class="s7">{</span><span class="s1">insert_single_values_expr</span><span class="s7">}</span><span class="s4">)&quot;</span>

                <span class="s1">self._insertmanyvalues = _InsertManyValues(</span>
                    <span class="s1">is_default_expr=</span><span class="s3">False</span><span class="s5">,</span>
                    <span class="s1">single_values_expr=insert_single_values_expr</span><span class="s5">,</span>
                    <span class="s1">insert_crud_params=cast(</span>
                        <span class="s4">&quot;List[crud._CrudParamElementStr]&quot;</span><span class="s5">,</span>
                        <span class="s1">crud_params_single</span><span class="s5">,</span>
                    <span class="s1">)</span><span class="s5">,</span>
                    <span class="s1">num_positional_params_counted=counted_bindparam</span><span class="s5">,</span>
                    <span class="s1">sort_by_parameter_order=(</span>
                        <span class="s1">insert_stmt._sort_by_parameter_order</span>
                    <span class="s1">)</span><span class="s5">,</span>
                    <span class="s1">includes_upsert_behaviors=(</span>
                        <span class="s1">insert_stmt._post_values_clause </span><span class="s3">is not None</span>
                    <span class="s1">)</span><span class="s5">,</span>
                    <span class="s1">sentinel_columns=add_sentinel_cols</span><span class="s5">,</span>
                    <span class="s1">num_sentinel_columns=(</span>
                        <span class="s1">len(add_sentinel_cols) </span><span class="s3">if </span><span class="s1">add_sentinel_cols </span><span class="s3">else </span><span class="s6">0</span>
                    <span class="s1">)</span><span class="s5">,</span>
                    <span class="s1">sentinel_param_keys=named_sentinel_params</span><span class="s5">,</span>
                    <span class="s1">implicit_sentinel=implicit_sentinel</span><span class="s5">,</span>
                    <span class="s1">embed_values_counter=embed_sentinel_value</span><span class="s5">,</span>
                <span class="s1">)</span>

            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">text += </span><span class="s4">f&quot; VALUES (</span><span class="s7">{</span><span class="s1">insert_single_values_expr</span><span class="s7">}</span><span class="s4">)&quot;</span>

        <span class="s3">if </span><span class="s1">insert_stmt._post_values_clause </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">post_values_clause = self.process(</span>
                <span class="s1">insert_stmt._post_values_clause</span><span class="s5">, </span><span class="s1">**kw</span>
            <span class="s1">)</span>
            <span class="s3">if </span><span class="s1">post_values_clause:</span>
                <span class="s1">text += </span><span class="s4">&quot; &quot; </span><span class="s1">+ post_values_clause</span>

        <span class="s3">if </span><span class="s1">returning_clause </span><span class="s3">and not </span><span class="s1">self.returning_precedes_values:</span>
            <span class="s1">text += </span><span class="s4">&quot; &quot; </span><span class="s1">+ returning_clause</span>

        <span class="s3">if </span><span class="s1">self.ctes </span><span class="s3">and not </span><span class="s1">self.dialect.cte_follows_insert:</span>
            <span class="s1">nesting_level = len(self.stack) </span><span class="s3">if not </span><span class="s1">toplevel </span><span class="s3">else None</span>
            <span class="s1">text = (</span>
                <span class="s1">self._render_cte_clause(</span>
                    <span class="s1">nesting_level=nesting_level</span><span class="s5">,</span>
                    <span class="s1">include_following_stack=</span><span class="s3">True</span><span class="s5">,</span>
                <span class="s1">)</span>
                <span class="s1">+ text</span>
            <span class="s1">)</span>

        <span class="s1">self.stack.pop(-</span><span class="s6">1</span><span class="s1">)</span>

        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">update_limit_clause(self</span><span class="s5">, </span><span class="s1">update_stmt):</span>
        <span class="s2">&quot;&quot;&quot;Provide a hook for MySQL to add LIMIT to the UPDATE&quot;&quot;&quot;</span>
        <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">update_tables_clause(self</span><span class="s5">, </span><span class="s1">update_stmt</span><span class="s5">, </span><span class="s1">from_table</span><span class="s5">, </span><span class="s1">extra_froms</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s2">&quot;&quot;&quot;Provide a hook to override the initial table clause 
        in an UPDATE statement. 
 
        MySQL overrides this. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">kw[</span><span class="s4">&quot;asfrom&quot;</span><span class="s1">] = </span><span class="s3">True</span>
        <span class="s3">return </span><span class="s1">from_table._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">iscrud=</span><span class="s3">True</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">update_from_clause(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">update_stmt</span><span class="s5">, </span><span class="s1">from_table</span><span class="s5">, </span><span class="s1">extra_froms</span><span class="s5">, </span><span class="s1">from_hints</span><span class="s5">, </span><span class="s1">**kw</span>
    <span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Provide a hook to override the generation of an 
        UPDATE..FROM clause. 
 
        MySQL and MSSQL override this. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span>
            <span class="s4">&quot;This backend does not support multiple-table &quot;</span>
            <span class="s4">&quot;criteria within UPDATE&quot;</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_update(self</span><span class="s5">, </span><span class="s1">update_stmt</span><span class="s5">, </span><span class="s1">visiting_cte=</span><span class="s3">None</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">compile_state = update_stmt._compile_state_factory(</span>
            <span class="s1">update_stmt</span><span class="s5">, </span><span class="s1">self</span><span class="s5">, </span><span class="s1">**kw</span>
        <span class="s1">)</span>
        <span class="s1">update_stmt = compile_state.statement</span>

        <span class="s3">if </span><span class="s1">visiting_cte </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">kw[</span><span class="s4">&quot;visiting_cte&quot;</span><span class="s1">] = visiting_cte</span>
            <span class="s1">toplevel = </span><span class="s3">False</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">toplevel = </span><span class="s3">not </span><span class="s1">self.stack</span>

        <span class="s3">if </span><span class="s1">toplevel:</span>
            <span class="s1">self.isupdate = </span><span class="s3">True</span>
            <span class="s3">if not </span><span class="s1">self.dml_compile_state:</span>
                <span class="s1">self.dml_compile_state = compile_state</span>
            <span class="s3">if not </span><span class="s1">self.compile_state:</span>
                <span class="s1">self.compile_state = compile_state</span>

        <span class="s3">if </span><span class="s1">self.linting &amp; COLLECT_CARTESIAN_PRODUCTS:</span>
            <span class="s1">from_linter = FromLinter({}</span><span class="s5">, </span><span class="s1">set())</span>
            <span class="s1">warn_linting = self.linting &amp; WARN_LINTING</span>
            <span class="s3">if </span><span class="s1">toplevel:</span>
                <span class="s1">self.from_linter = from_linter</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">from_linter = </span><span class="s3">None</span>
            <span class="s1">warn_linting = </span><span class="s3">False</span>

        <span class="s1">extra_froms = compile_state._extra_froms</span>
        <span class="s1">is_multitable = bool(extra_froms)</span>

        <span class="s3">if </span><span class="s1">is_multitable:</span>
            <span class="s0"># main table might be a JOIN</span>
            <span class="s1">main_froms = set(_from_objects(update_stmt.table))</span>
            <span class="s1">render_extra_froms = [</span>
                <span class="s1">f </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">extra_froms </span><span class="s3">if </span><span class="s1">f </span><span class="s3">not in </span><span class="s1">main_froms</span>
            <span class="s1">]</span>
            <span class="s1">correlate_froms = main_froms.union(extra_froms)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">render_extra_froms = []</span>
            <span class="s1">correlate_froms = {update_stmt.table}</span>

        <span class="s1">self.stack.append(</span>
            <span class="s1">{</span>
                <span class="s4">&quot;correlate_froms&quot;</span><span class="s1">: correlate_froms</span><span class="s5">,</span>
                <span class="s4">&quot;asfrom_froms&quot;</span><span class="s1">: correlate_froms</span><span class="s5">,</span>
                <span class="s4">&quot;selectable&quot;</span><span class="s1">: update_stmt</span><span class="s5">,</span>
            <span class="s1">}</span>
        <span class="s1">)</span>

        <span class="s1">text = </span><span class="s4">&quot;UPDATE &quot;</span>

        <span class="s3">if </span><span class="s1">update_stmt._prefixes:</span>
            <span class="s1">text += self._generate_prefixes(</span>
                <span class="s1">update_stmt</span><span class="s5">, </span><span class="s1">update_stmt._prefixes</span><span class="s5">, </span><span class="s1">**kw</span>
            <span class="s1">)</span>

        <span class="s1">table_text = self.update_tables_clause(</span>
            <span class="s1">update_stmt</span><span class="s5">,</span>
            <span class="s1">update_stmt.table</span><span class="s5">,</span>
            <span class="s1">render_extra_froms</span><span class="s5">,</span>
            <span class="s1">from_linter=from_linter</span><span class="s5">,</span>
            <span class="s1">**kw</span><span class="s5">,</span>
        <span class="s1">)</span>
        <span class="s1">crud_params_struct = crud._get_crud_params(</span>
            <span class="s1">self</span><span class="s5">, </span><span class="s1">update_stmt</span><span class="s5">, </span><span class="s1">compile_state</span><span class="s5">, </span><span class="s1">toplevel</span><span class="s5">, </span><span class="s1">**kw</span>
        <span class="s1">)</span>
        <span class="s1">crud_params = crud_params_struct.single_params</span>

        <span class="s3">if </span><span class="s1">update_stmt._hints:</span>
            <span class="s1">dialect_hints</span><span class="s5">, </span><span class="s1">table_text = self._setup_crud_hints(</span>
                <span class="s1">update_stmt</span><span class="s5">, </span><span class="s1">table_text</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">dialect_hints = </span><span class="s3">None</span>

        <span class="s3">if </span><span class="s1">update_stmt._independent_ctes:</span>
            <span class="s1">self._dispatch_independent_ctes(update_stmt</span><span class="s5">, </span><span class="s1">kw)</span>

        <span class="s1">text += table_text</span>

        <span class="s1">text += </span><span class="s4">&quot; SET &quot;</span>
        <span class="s1">text += </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
            <span class="s1">expr + </span><span class="s4">&quot;=&quot; </span><span class="s1">+ value</span>
            <span class="s3">for </span><span class="s1">_</span><span class="s5">, </span><span class="s1">expr</span><span class="s5">, </span><span class="s1">value</span><span class="s5">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">cast(</span>
                <span class="s4">&quot;List[Tuple[Any, str, str, Any]]&quot;</span><span class="s5">, </span><span class="s1">crud_params</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">self.implicit_returning </span><span class="s3">or </span><span class="s1">update_stmt._returning:</span>
            <span class="s3">if </span><span class="s1">self.returning_precedes_values:</span>
                <span class="s1">text += </span><span class="s4">&quot; &quot; </span><span class="s1">+ self.returning_clause(</span>
                    <span class="s1">update_stmt</span><span class="s5">,</span>
                    <span class="s1">self.implicit_returning </span><span class="s3">or </span><span class="s1">update_stmt._returning</span><span class="s5">,</span>
                    <span class="s1">populate_result_map=toplevel</span><span class="s5">,</span>
                <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">extra_froms:</span>
            <span class="s1">extra_from_text = self.update_from_clause(</span>
                <span class="s1">update_stmt</span><span class="s5">,</span>
                <span class="s1">update_stmt.table</span><span class="s5">,</span>
                <span class="s1">render_extra_froms</span><span class="s5">,</span>
                <span class="s1">dialect_hints</span><span class="s5">,</span>
                <span class="s1">from_linter=from_linter</span><span class="s5">,</span>
                <span class="s1">**kw</span><span class="s5">,</span>
            <span class="s1">)</span>
            <span class="s3">if </span><span class="s1">extra_from_text:</span>
                <span class="s1">text += </span><span class="s4">&quot; &quot; </span><span class="s1">+ extra_from_text</span>

        <span class="s3">if </span><span class="s1">update_stmt._where_criteria:</span>
            <span class="s1">t = self._generate_delimited_and_list(</span>
                <span class="s1">update_stmt._where_criteria</span><span class="s5">, </span><span class="s1">from_linter=from_linter</span><span class="s5">, </span><span class="s1">**kw</span>
            <span class="s1">)</span>
            <span class="s3">if </span><span class="s1">t:</span>
                <span class="s1">text += </span><span class="s4">&quot; WHERE &quot; </span><span class="s1">+ t</span>

        <span class="s1">limit_clause = self.update_limit_clause(update_stmt)</span>
        <span class="s3">if </span><span class="s1">limit_clause:</span>
            <span class="s1">text += </span><span class="s4">&quot; &quot; </span><span class="s1">+ limit_clause</span>

        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">self.implicit_returning </span><span class="s3">or </span><span class="s1">update_stmt._returning</span>
        <span class="s1">) </span><span class="s3">and not </span><span class="s1">self.returning_precedes_values:</span>
            <span class="s1">text += </span><span class="s4">&quot; &quot; </span><span class="s1">+ self.returning_clause(</span>
                <span class="s1">update_stmt</span><span class="s5">,</span>
                <span class="s1">self.implicit_returning </span><span class="s3">or </span><span class="s1">update_stmt._returning</span><span class="s5">,</span>
                <span class="s1">populate_result_map=toplevel</span><span class="s5">,</span>
            <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">self.ctes:</span>
            <span class="s1">nesting_level = len(self.stack) </span><span class="s3">if not </span><span class="s1">toplevel </span><span class="s3">else None</span>
            <span class="s1">text = self._render_cte_clause(nesting_level=nesting_level) + text</span>

        <span class="s3">if </span><span class="s1">warn_linting:</span>
            <span class="s3">assert </span><span class="s1">from_linter </span><span class="s3">is not None</span>
            <span class="s1">from_linter.warn(stmt_type=</span><span class="s4">&quot;UPDATE&quot;</span><span class="s1">)</span>

        <span class="s1">self.stack.pop(-</span><span class="s6">1</span><span class="s1">)</span>

        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">delete_extra_from_clause(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">update_stmt</span><span class="s5">, </span><span class="s1">from_table</span><span class="s5">, </span><span class="s1">extra_froms</span><span class="s5">, </span><span class="s1">from_hints</span><span class="s5">, </span><span class="s1">**kw</span>
    <span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Provide a hook to override the generation of an 
        DELETE..FROM clause. 
 
        This can be used to implement DELETE..USING for example. 
 
        MySQL and MSSQL override this. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span>
            <span class="s4">&quot;This backend does not support multiple-table &quot;</span>
            <span class="s4">&quot;criteria within DELETE&quot;</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">delete_table_clause(self</span><span class="s5">, </span><span class="s1">delete_stmt</span><span class="s5">, </span><span class="s1">from_table</span><span class="s5">, </span><span class="s1">extra_froms</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">from_table._compiler_dispatch(</span>
            <span class="s1">self</span><span class="s5">, </span><span class="s1">asfrom=</span><span class="s3">True</span><span class="s5">, </span><span class="s1">iscrud=</span><span class="s3">True</span><span class="s5">, </span><span class="s1">**kw</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_delete(self</span><span class="s5">, </span><span class="s1">delete_stmt</span><span class="s5">, </span><span class="s1">visiting_cte=</span><span class="s3">None</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">compile_state = delete_stmt._compile_state_factory(</span>
            <span class="s1">delete_stmt</span><span class="s5">, </span><span class="s1">self</span><span class="s5">, </span><span class="s1">**kw</span>
        <span class="s1">)</span>
        <span class="s1">delete_stmt = compile_state.statement</span>

        <span class="s3">if </span><span class="s1">visiting_cte </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">kw[</span><span class="s4">&quot;visiting_cte&quot;</span><span class="s1">] = visiting_cte</span>
            <span class="s1">toplevel = </span><span class="s3">False</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">toplevel = </span><span class="s3">not </span><span class="s1">self.stack</span>

        <span class="s3">if </span><span class="s1">toplevel:</span>
            <span class="s1">self.isdelete = </span><span class="s3">True</span>
            <span class="s3">if not </span><span class="s1">self.dml_compile_state:</span>
                <span class="s1">self.dml_compile_state = compile_state</span>
            <span class="s3">if not </span><span class="s1">self.compile_state:</span>
                <span class="s1">self.compile_state = compile_state</span>

        <span class="s3">if </span><span class="s1">self.linting &amp; COLLECT_CARTESIAN_PRODUCTS:</span>
            <span class="s1">from_linter = FromLinter({}</span><span class="s5">, </span><span class="s1">set())</span>
            <span class="s1">warn_linting = self.linting &amp; WARN_LINTING</span>
            <span class="s3">if </span><span class="s1">toplevel:</span>
                <span class="s1">self.from_linter = from_linter</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">from_linter = </span><span class="s3">None</span>
            <span class="s1">warn_linting = </span><span class="s3">False</span>

        <span class="s1">extra_froms = compile_state._extra_froms</span>

        <span class="s1">correlate_froms = {delete_stmt.table}.union(extra_froms)</span>
        <span class="s1">self.stack.append(</span>
            <span class="s1">{</span>
                <span class="s4">&quot;correlate_froms&quot;</span><span class="s1">: correlate_froms</span><span class="s5">,</span>
                <span class="s4">&quot;asfrom_froms&quot;</span><span class="s1">: correlate_froms</span><span class="s5">,</span>
                <span class="s4">&quot;selectable&quot;</span><span class="s1">: delete_stmt</span><span class="s5">,</span>
            <span class="s1">}</span>
        <span class="s1">)</span>

        <span class="s1">text = </span><span class="s4">&quot;DELETE &quot;</span>

        <span class="s3">if </span><span class="s1">delete_stmt._prefixes:</span>
            <span class="s1">text += self._generate_prefixes(</span>
                <span class="s1">delete_stmt</span><span class="s5">, </span><span class="s1">delete_stmt._prefixes</span><span class="s5">, </span><span class="s1">**kw</span>
            <span class="s1">)</span>

        <span class="s1">text += </span><span class="s4">&quot;FROM &quot;</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">table_text = self.delete_table_clause(</span>
                <span class="s1">delete_stmt</span><span class="s5">,</span>
                <span class="s1">delete_stmt.table</span><span class="s5">,</span>
                <span class="s1">extra_froms</span><span class="s5">,</span>
                <span class="s1">from_linter=from_linter</span><span class="s5">,</span>
            <span class="s1">)</span>
        <span class="s3">except </span><span class="s1">TypeError:</span>
            <span class="s0"># anticipate 3rd party dialects that don't include **kw</span>
            <span class="s0"># TODO: remove in 2.1</span>
            <span class="s1">table_text = self.delete_table_clause(</span>
                <span class="s1">delete_stmt</span><span class="s5">, </span><span class="s1">delete_stmt.table</span><span class="s5">, </span><span class="s1">extra_froms</span>
            <span class="s1">)</span>
            <span class="s3">if </span><span class="s1">from_linter:</span>
                <span class="s1">_ = self.process(delete_stmt.table</span><span class="s5">, </span><span class="s1">from_linter=from_linter)</span>

        <span class="s1">crud._get_crud_params(self</span><span class="s5">, </span><span class="s1">delete_stmt</span><span class="s5">, </span><span class="s1">compile_state</span><span class="s5">, </span><span class="s1">toplevel</span><span class="s5">, </span><span class="s1">**kw)</span>

        <span class="s3">if </span><span class="s1">delete_stmt._hints:</span>
            <span class="s1">dialect_hints</span><span class="s5">, </span><span class="s1">table_text = self._setup_crud_hints(</span>
                <span class="s1">delete_stmt</span><span class="s5">, </span><span class="s1">table_text</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">dialect_hints = </span><span class="s3">None</span>

        <span class="s3">if </span><span class="s1">delete_stmt._independent_ctes:</span>
            <span class="s1">self._dispatch_independent_ctes(delete_stmt</span><span class="s5">, </span><span class="s1">kw)</span>

        <span class="s1">text += table_text</span>

        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">self.implicit_returning </span><span class="s3">or </span><span class="s1">delete_stmt._returning</span>
        <span class="s1">) </span><span class="s3">and </span><span class="s1">self.returning_precedes_values:</span>
            <span class="s1">text += </span><span class="s4">&quot; &quot; </span><span class="s1">+ self.returning_clause(</span>
                <span class="s1">delete_stmt</span><span class="s5">,</span>
                <span class="s1">self.implicit_returning </span><span class="s3">or </span><span class="s1">delete_stmt._returning</span><span class="s5">,</span>
                <span class="s1">populate_result_map=toplevel</span><span class="s5">,</span>
            <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">extra_froms:</span>
            <span class="s1">extra_from_text = self.delete_extra_from_clause(</span>
                <span class="s1">delete_stmt</span><span class="s5">,</span>
                <span class="s1">delete_stmt.table</span><span class="s5">,</span>
                <span class="s1">extra_froms</span><span class="s5">,</span>
                <span class="s1">dialect_hints</span><span class="s5">,</span>
                <span class="s1">from_linter=from_linter</span><span class="s5">,</span>
                <span class="s1">**kw</span><span class="s5">,</span>
            <span class="s1">)</span>
            <span class="s3">if </span><span class="s1">extra_from_text:</span>
                <span class="s1">text += </span><span class="s4">&quot; &quot; </span><span class="s1">+ extra_from_text</span>

        <span class="s3">if </span><span class="s1">delete_stmt._where_criteria:</span>
            <span class="s1">t = self._generate_delimited_and_list(</span>
                <span class="s1">delete_stmt._where_criteria</span><span class="s5">, </span><span class="s1">from_linter=from_linter</span><span class="s5">, </span><span class="s1">**kw</span>
            <span class="s1">)</span>
            <span class="s3">if </span><span class="s1">t:</span>
                <span class="s1">text += </span><span class="s4">&quot; WHERE &quot; </span><span class="s1">+ t</span>

        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">self.implicit_returning </span><span class="s3">or </span><span class="s1">delete_stmt._returning</span>
        <span class="s1">) </span><span class="s3">and not </span><span class="s1">self.returning_precedes_values:</span>
            <span class="s1">text += </span><span class="s4">&quot; &quot; </span><span class="s1">+ self.returning_clause(</span>
                <span class="s1">delete_stmt</span><span class="s5">,</span>
                <span class="s1">self.implicit_returning </span><span class="s3">or </span><span class="s1">delete_stmt._returning</span><span class="s5">,</span>
                <span class="s1">populate_result_map=toplevel</span><span class="s5">,</span>
            <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">self.ctes:</span>
            <span class="s1">nesting_level = len(self.stack) </span><span class="s3">if not </span><span class="s1">toplevel </span><span class="s3">else None</span>
            <span class="s1">text = self._render_cte_clause(nesting_level=nesting_level) + text</span>

        <span class="s3">if </span><span class="s1">warn_linting:</span>
            <span class="s3">assert </span><span class="s1">from_linter </span><span class="s3">is not None</span>
            <span class="s1">from_linter.warn(stmt_type=</span><span class="s4">&quot;DELETE&quot;</span><span class="s1">)</span>

        <span class="s1">self.stack.pop(-</span><span class="s6">1</span><span class="s1">)</span>

        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">visit_savepoint(self</span><span class="s5">, </span><span class="s1">savepoint_stmt</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;SAVEPOINT %s&quot; </span><span class="s1">% self.preparer.format_savepoint(savepoint_stmt)</span>

    <span class="s3">def </span><span class="s1">visit_rollback_to_savepoint(self</span><span class="s5">, </span><span class="s1">savepoint_stmt</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;ROLLBACK TO SAVEPOINT %s&quot; </span><span class="s1">% self.preparer.format_savepoint(</span>
            <span class="s1">savepoint_stmt</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_release_savepoint(self</span><span class="s5">, </span><span class="s1">savepoint_stmt</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;RELEASE SAVEPOINT %s&quot; </span><span class="s1">% self.preparer.format_savepoint(</span>
            <span class="s1">savepoint_stmt</span>
        <span class="s1">)</span>


<span class="s3">class </span><span class="s1">StrSQLCompiler(SQLCompiler):</span>
    <span class="s2">&quot;&quot;&quot;A :class:`.SQLCompiler` subclass which allows a small selection 
    of non-standard SQL features to render into a string value. 
 
    The :class:`.StrSQLCompiler` is invoked whenever a Core expression 
    element is directly stringified without calling upon the 
    :meth:`_expression.ClauseElement.compile` method. 
    It can render a limited set 
    of non-standard SQL constructs to assist in basic stringification, 
    however for more substantial custom or dialect-specific SQL constructs, 
    it will be necessary to make use of 
    :meth:`_expression.ClauseElement.compile` 
    directly. 
 
    .. seealso:: 
 
        :ref:`faq_sql_expression_string` 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">_fallback_column_name(self</span><span class="s5">, </span><span class="s1">column):</span>
        <span class="s3">return </span><span class="s4">&quot;&lt;name unknown&gt;&quot;</span>

    <span class="s1">@util.preload_module(</span><span class="s4">&quot;sqlalchemy.engine.url&quot;</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">visit_unsupported_compilation(self</span><span class="s5">, </span><span class="s1">element</span><span class="s5">, </span><span class="s1">err</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">if </span><span class="s1">element.stringify_dialect != </span><span class="s4">&quot;default&quot;</span><span class="s1">:</span>
            <span class="s1">url = util.preloaded.engine_url</span>
            <span class="s1">dialect = url.URL.create(element.stringify_dialect).get_dialect()()</span>

            <span class="s1">compiler = dialect.statement_compiler(</span>
                <span class="s1">dialect</span><span class="s5">, </span><span class="s3">None</span><span class="s5">, </span><span class="s1">_supporting_against=self</span>
            <span class="s1">)</span>
            <span class="s3">if not </span><span class="s1">isinstance(compiler</span><span class="s5">, </span><span class="s1">StrSQLCompiler):</span>
                <span class="s3">return </span><span class="s1">compiler.process(element</span><span class="s5">, </span><span class="s1">**kw)</span>

        <span class="s3">return </span><span class="s1">super().visit_unsupported_compilation(element</span><span class="s5">, </span><span class="s1">err)</span>

    <span class="s3">def </span><span class="s1">visit_getitem_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;%s[%s]&quot; </span><span class="s1">% (</span>
            <span class="s1">self.process(binary.left</span><span class="s5">, </span><span class="s1">**kw)</span><span class="s5">,</span>
            <span class="s1">self.process(binary.right</span><span class="s5">, </span><span class="s1">**kw)</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_json_getitem_op_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self.visit_getitem_binary(binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_json_path_getitem_op_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self.visit_getitem_binary(binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_sequence(self</span><span class="s5">, </span><span class="s1">sequence</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">(</span>
            <span class="s4">f&quot;&lt;next sequence value: </span><span class="s7">{</span><span class="s1">self.preparer.format_sequence(sequence)</span><span class="s7">}</span><span class="s4">&gt;&quot;</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">returning_clause(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">stmt: UpdateBase</span><span class="s5">,</span>
        <span class="s1">returning_cols: Sequence[ColumnElement[Any]]</span><span class="s5">,</span>
        <span class="s1">*</span><span class="s5">,</span>
        <span class="s1">populate_result_map: bool</span><span class="s5">,</span>
        <span class="s1">**kw: Any</span><span class="s5">,</span>
    <span class="s1">) -&gt; str:</span>
        <span class="s1">columns = [</span>
            <span class="s1">self._label_select_column(</span><span class="s3">None</span><span class="s5">, </span><span class="s1">c</span><span class="s5">, </span><span class="s3">True</span><span class="s5">, </span><span class="s3">False</span><span class="s5">, </span><span class="s1">{})</span>
            <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">base._select_iterables(returning_cols)</span>
        <span class="s1">]</span>
        <span class="s3">return </span><span class="s4">&quot;RETURNING &quot; </span><span class="s1">+ </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(columns)</span>

    <span class="s3">def </span><span class="s1">update_from_clause(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">update_stmt</span><span class="s5">, </span><span class="s1">from_table</span><span class="s5">, </span><span class="s1">extra_froms</span><span class="s5">, </span><span class="s1">from_hints</span><span class="s5">, </span><span class="s1">**kw</span>
    <span class="s1">):</span>
        <span class="s1">kw[</span><span class="s4">&quot;asfrom&quot;</span><span class="s1">] = </span><span class="s3">True</span>
        <span class="s3">return </span><span class="s4">&quot;FROM &quot; </span><span class="s1">+ </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
            <span class="s1">t._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">fromhints=from_hints</span><span class="s5">, </span><span class="s1">**kw)</span>
            <span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">extra_froms</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">delete_extra_from_clause(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">update_stmt</span><span class="s5">, </span><span class="s1">from_table</span><span class="s5">, </span><span class="s1">extra_froms</span><span class="s5">, </span><span class="s1">from_hints</span><span class="s5">, </span><span class="s1">**kw</span>
    <span class="s1">):</span>
        <span class="s1">kw[</span><span class="s4">&quot;asfrom&quot;</span><span class="s1">] = </span><span class="s3">True</span>
        <span class="s3">return </span><span class="s4">&quot;, &quot; </span><span class="s1">+ </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
            <span class="s1">t._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">fromhints=from_hints</span><span class="s5">, </span><span class="s1">**kw)</span>
            <span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">extra_froms</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_empty_set_expr(self</span><span class="s5">, </span><span class="s1">element_types</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;SELECT 1 WHERE 1!=1&quot;</span>

    <span class="s3">def </span><span class="s1">get_from_hint_text(self</span><span class="s5">, </span><span class="s1">table</span><span class="s5">, </span><span class="s1">text):</span>
        <span class="s3">return </span><span class="s4">&quot;[%s]&quot; </span><span class="s1">% text</span>

    <span class="s3">def </span><span class="s1">visit_regexp_match_op_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self._generate_generic_binary(binary</span><span class="s5">, </span><span class="s4">&quot; &lt;regexp&gt; &quot;</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_not_regexp_match_op_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self._generate_generic_binary(binary</span><span class="s5">, </span><span class="s4">&quot; &lt;not regexp&gt; &quot;</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_regexp_replace_op_binary(self</span><span class="s5">, </span><span class="s1">binary</span><span class="s5">, </span><span class="s1">operator</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;&lt;regexp replace&gt;(%s, %s)&quot; </span><span class="s1">% (</span>
            <span class="s1">binary.left._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kw)</span><span class="s5">,</span>
            <span class="s1">binary.right._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kw)</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_try_cast(self</span><span class="s5">, </span><span class="s1">cast</span><span class="s5">, </span><span class="s1">**kwargs):</span>
        <span class="s3">return </span><span class="s4">&quot;TRY_CAST(%s AS %s)&quot; </span><span class="s1">% (</span>
            <span class="s1">cast.clause._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kwargs)</span><span class="s5">,</span>
            <span class="s1">cast.typeclause._compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kwargs)</span><span class="s5">,</span>
        <span class="s1">)</span>


<span class="s3">class </span><span class="s1">DDLCompiler(Compiled):</span>
    <span class="s1">is_ddl = </span><span class="s3">True</span>

    <span class="s3">if </span><span class="s1">TYPE_CHECKING:</span>

        <span class="s3">def </span><span class="s1">__init__(</span>
            <span class="s1">self</span><span class="s5">,</span>
            <span class="s1">dialect: Dialect</span><span class="s5">,</span>
            <span class="s1">statement: ExecutableDDLElement</span><span class="s5">,</span>
            <span class="s1">schema_translate_map: Optional[SchemaTranslateMapType] = ...</span><span class="s5">,</span>
            <span class="s1">render_schema_translate: bool = ...</span><span class="s5">,</span>
            <span class="s1">compile_kwargs: Mapping[str</span><span class="s5">, </span><span class="s1">Any] = ...</span><span class="s5">,</span>
        <span class="s1">): ...</span>

    <span class="s1">@util.memoized_property</span>
    <span class="s3">def </span><span class="s1">sql_compiler(self):</span>
        <span class="s3">return </span><span class="s1">self.dialect.statement_compiler(</span>
            <span class="s1">self.dialect</span><span class="s5">, </span><span class="s3">None</span><span class="s5">, </span><span class="s1">schema_translate_map=self.schema_translate_map</span>
        <span class="s1">)</span>

    <span class="s1">@util.memoized_property</span>
    <span class="s3">def </span><span class="s1">type_compiler(self):</span>
        <span class="s3">return </span><span class="s1">self.dialect.type_compiler_instance</span>

    <span class="s3">def </span><span class="s1">construct_params(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">params: Optional[_CoreSingleExecuteParams] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">extracted_parameters: Optional[Sequence[BindParameter[Any]]] = </span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">escape_names: bool = </span><span class="s3">True</span><span class="s5">,</span>
    <span class="s1">) -&gt; Optional[_MutableCoreSingleExecuteParams]:</span>
        <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">visit_ddl(self</span><span class="s5">, </span><span class="s1">ddl</span><span class="s5">, </span><span class="s1">**kwargs):</span>
        <span class="s0"># table events can substitute table and schema name</span>
        <span class="s1">context = ddl.context</span>
        <span class="s3">if </span><span class="s1">isinstance(ddl.target</span><span class="s5">, </span><span class="s1">schema.Table):</span>
            <span class="s1">context = context.copy()</span>

            <span class="s1">preparer = self.preparer</span>
            <span class="s1">path = preparer.format_table_seq(ddl.target)</span>
            <span class="s3">if </span><span class="s1">len(path) == </span><span class="s6">1</span><span class="s1">:</span>
                <span class="s1">table</span><span class="s5">, </span><span class="s1">sch = path[</span><span class="s6">0</span><span class="s1">]</span><span class="s5">, </span><span class="s4">&quot;&quot;</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">table</span><span class="s5">, </span><span class="s1">sch = path[-</span><span class="s6">1</span><span class="s1">]</span><span class="s5">, </span><span class="s1">path[</span><span class="s6">0</span><span class="s1">]</span>

            <span class="s1">context.setdefault(</span><span class="s4">&quot;table&quot;</span><span class="s5">, </span><span class="s1">table)</span>
            <span class="s1">context.setdefault(</span><span class="s4">&quot;schema&quot;</span><span class="s5">, </span><span class="s1">sch)</span>
            <span class="s1">context.setdefault(</span><span class="s4">&quot;fullname&quot;</span><span class="s5">, </span><span class="s1">preparer.format_table(ddl.target))</span>

        <span class="s3">return </span><span class="s1">self.sql_compiler.post_process_text(ddl.statement % context)</span>

    <span class="s3">def </span><span class="s1">visit_create_schema(self</span><span class="s5">, </span><span class="s1">create</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">text = </span><span class="s4">&quot;CREATE SCHEMA &quot;</span>
        <span class="s3">if </span><span class="s1">create.if_not_exists:</span>
            <span class="s1">text += </span><span class="s4">&quot;IF NOT EXISTS &quot;</span>
        <span class="s3">return </span><span class="s1">text + self.preparer.format_schema(create.element)</span>

    <span class="s3">def </span><span class="s1">visit_drop_schema(self</span><span class="s5">, </span><span class="s1">drop</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">text = </span><span class="s4">&quot;DROP SCHEMA &quot;</span>
        <span class="s3">if </span><span class="s1">drop.if_exists:</span>
            <span class="s1">text += </span><span class="s4">&quot;IF EXISTS &quot;</span>
        <span class="s1">text += self.preparer.format_schema(drop.element)</span>
        <span class="s3">if </span><span class="s1">drop.cascade:</span>
            <span class="s1">text += </span><span class="s4">&quot; CASCADE&quot;</span>
        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">visit_create_table(self</span><span class="s5">, </span><span class="s1">create</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">table = create.element</span>
        <span class="s1">preparer = self.preparer</span>

        <span class="s1">text = </span><span class="s4">&quot;</span><span class="s7">\n</span><span class="s4">CREATE &quot;</span>
        <span class="s3">if </span><span class="s1">table._prefixes:</span>
            <span class="s1">text += </span><span class="s4">&quot; &quot;</span><span class="s1">.join(table._prefixes) + </span><span class="s4">&quot; &quot;</span>

        <span class="s1">text += </span><span class="s4">&quot;TABLE &quot;</span>
        <span class="s3">if </span><span class="s1">create.if_not_exists:</span>
            <span class="s1">text += </span><span class="s4">&quot;IF NOT EXISTS &quot;</span>

        <span class="s1">text += preparer.format_table(table) + </span><span class="s4">&quot; &quot;</span>

        <span class="s1">create_table_suffix = self.create_table_suffix(table)</span>
        <span class="s3">if </span><span class="s1">create_table_suffix:</span>
            <span class="s1">text += create_table_suffix + </span><span class="s4">&quot; &quot;</span>

        <span class="s1">text += </span><span class="s4">&quot;(&quot;</span>

        <span class="s1">separator = </span><span class="s4">&quot;</span><span class="s7">\n</span><span class="s4">&quot;</span>

        <span class="s0"># if only one primary key, specify it along with the column</span>
        <span class="s1">first_pk = </span><span class="s3">False</span>
        <span class="s3">for </span><span class="s1">create_column </span><span class="s3">in </span><span class="s1">create.columns:</span>
            <span class="s1">column = create_column.element</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">processed = self.process(</span>
                    <span class="s1">create_column</span><span class="s5">, </span><span class="s1">first_pk=column.primary_key </span><span class="s3">and not </span><span class="s1">first_pk</span>
                <span class="s1">)</span>
                <span class="s3">if </span><span class="s1">processed </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">text += separator</span>
                    <span class="s1">separator = </span><span class="s4">&quot;, </span><span class="s7">\n</span><span class="s4">&quot;</span>
                    <span class="s1">text += </span><span class="s4">&quot;</span><span class="s7">\t</span><span class="s4">&quot; </span><span class="s1">+ processed</span>
                <span class="s3">if </span><span class="s1">column.primary_key:</span>
                    <span class="s1">first_pk = </span><span class="s3">True</span>
            <span class="s3">except </span><span class="s1">exc.CompileError </span><span class="s3">as </span><span class="s1">ce:</span>
                <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
                    <span class="s4">&quot;(in table '%s', column '%s'): %s&quot;</span>
                    <span class="s1">% (table.description</span><span class="s5">, </span><span class="s1">column.name</span><span class="s5">, </span><span class="s1">ce.args[</span><span class="s6">0</span><span class="s1">])</span>
                <span class="s1">) </span><span class="s3">from </span><span class="s1">ce</span>

        <span class="s1">const = self.create_table_constraints(</span>
            <span class="s1">table</span><span class="s5">,</span>
            <span class="s1">_include_foreign_key_constraints=create.include_foreign_key_constraints</span><span class="s5">,  </span><span class="s0"># noqa</span>
        <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">const:</span>
            <span class="s1">text += separator + </span><span class="s4">&quot;</span><span class="s7">\t</span><span class="s4">&quot; </span><span class="s1">+ const</span>

        <span class="s1">text += </span><span class="s4">&quot;</span><span class="s7">\n</span><span class="s4">)%s</span><span class="s7">\n\n</span><span class="s4">&quot; </span><span class="s1">% self.post_create_table(table)</span>
        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">visit_create_column(self</span><span class="s5">, </span><span class="s1">create</span><span class="s5">, </span><span class="s1">first_pk=</span><span class="s3">False</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">column = create.element</span>

        <span class="s3">if </span><span class="s1">column.system:</span>
            <span class="s3">return None</span>

        <span class="s1">text = self.get_column_specification(column</span><span class="s5">, </span><span class="s1">first_pk=first_pk)</span>
        <span class="s1">const = </span><span class="s4">&quot; &quot;</span><span class="s1">.join(</span>
            <span class="s1">self.process(constraint) </span><span class="s3">for </span><span class="s1">constraint </span><span class="s3">in </span><span class="s1">column.constraints</span>
        <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">const:</span>
            <span class="s1">text += </span><span class="s4">&quot; &quot; </span><span class="s1">+ const</span>

        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">create_table_constraints(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">table</span><span class="s5">, </span><span class="s1">_include_foreign_key_constraints=</span><span class="s3">None</span><span class="s5">, </span><span class="s1">**kw</span>
    <span class="s1">):</span>
        <span class="s0"># On some DB order is significant: visit PK first, then the</span>
        <span class="s0"># other constraints (engine.ReflectionTest.testbasic failed on FB2)</span>
        <span class="s1">constraints = []</span>
        <span class="s3">if </span><span class="s1">table.primary_key:</span>
            <span class="s1">constraints.append(table.primary_key)</span>

        <span class="s1">all_fkcs = table.foreign_key_constraints</span>
        <span class="s3">if </span><span class="s1">_include_foreign_key_constraints </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">omit_fkcs = all_fkcs.difference(_include_foreign_key_constraints)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">omit_fkcs = set()</span>

        <span class="s1">constraints.extend(</span>
            <span class="s1">[</span>
                <span class="s1">c</span>
                <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">table._sorted_constraints</span>
                <span class="s3">if </span><span class="s1">c </span><span class="s3">is not </span><span class="s1">table.primary_key </span><span class="s3">and </span><span class="s1">c </span><span class="s3">not in </span><span class="s1">omit_fkcs</span>
            <span class="s1">]</span>
        <span class="s1">)</span>

        <span class="s3">return </span><span class="s4">&quot;, </span><span class="s7">\n\t</span><span class="s4">&quot;</span><span class="s1">.join(</span>
            <span class="s1">p</span>
            <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">(</span>
                <span class="s1">self.process(constraint)</span>
                <span class="s3">for </span><span class="s1">constraint </span><span class="s3">in </span><span class="s1">constraints</span>
                <span class="s3">if </span><span class="s1">(constraint._should_create_for_compiler(self))</span>
                <span class="s3">and </span><span class="s1">(</span>
                    <span class="s3">not </span><span class="s1">self.dialect.supports_alter</span>
                    <span class="s3">or not </span><span class="s1">getattr(constraint</span><span class="s5">, </span><span class="s4">&quot;use_alter&quot;</span><span class="s5">, </span><span class="s3">False</span><span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s3">if </span><span class="s1">p </span><span class="s3">is not None</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_drop_table(self</span><span class="s5">, </span><span class="s1">drop</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">text = </span><span class="s4">&quot;</span><span class="s7">\n</span><span class="s4">DROP TABLE &quot;</span>
        <span class="s3">if </span><span class="s1">drop.if_exists:</span>
            <span class="s1">text += </span><span class="s4">&quot;IF EXISTS &quot;</span>
        <span class="s3">return </span><span class="s1">text + self.preparer.format_table(drop.element)</span>

    <span class="s3">def </span><span class="s1">visit_drop_view(self</span><span class="s5">, </span><span class="s1">drop</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;</span><span class="s7">\n</span><span class="s4">DROP VIEW &quot; </span><span class="s1">+ self.preparer.format_table(drop.element)</span>

    <span class="s3">def </span><span class="s1">_verify_index_table(self</span><span class="s5">, </span><span class="s1">index):</span>
        <span class="s3">if </span><span class="s1">index.table </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
                <span class="s4">&quot;Index '%s' is not associated with any table.&quot; </span><span class="s1">% index.name</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_create_index(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">create</span><span class="s5">, </span><span class="s1">include_schema=</span><span class="s3">False</span><span class="s5">, </span><span class="s1">include_table_schema=</span><span class="s3">True</span><span class="s5">, </span><span class="s1">**kw</span>
    <span class="s1">):</span>
        <span class="s1">index = create.element</span>
        <span class="s1">self._verify_index_table(index)</span>
        <span class="s1">preparer = self.preparer</span>
        <span class="s1">text = </span><span class="s4">&quot;CREATE &quot;</span>
        <span class="s3">if </span><span class="s1">index.unique:</span>
            <span class="s1">text += </span><span class="s4">&quot;UNIQUE &quot;</span>
        <span class="s3">if </span><span class="s1">index.name </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
                <span class="s4">&quot;CREATE INDEX requires that the index have a name&quot;</span>
            <span class="s1">)</span>

        <span class="s1">text += </span><span class="s4">&quot;INDEX &quot;</span>
        <span class="s3">if </span><span class="s1">create.if_not_exists:</span>
            <span class="s1">text += </span><span class="s4">&quot;IF NOT EXISTS &quot;</span>

        <span class="s1">text += </span><span class="s4">&quot;%s ON %s (%s)&quot; </span><span class="s1">% (</span>
            <span class="s1">self._prepared_index_name(index</span><span class="s5">, </span><span class="s1">include_schema=include_schema)</span><span class="s5">,</span>
            <span class="s1">preparer.format_table(</span>
                <span class="s1">index.table</span><span class="s5">, </span><span class="s1">use_schema=include_table_schema</span>
            <span class="s1">)</span><span class="s5">,</span>
            <span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
                <span class="s1">self.sql_compiler.process(</span>
                    <span class="s1">expr</span><span class="s5">, </span><span class="s1">include_table=</span><span class="s3">False</span><span class="s5">, </span><span class="s1">literal_binds=</span><span class="s3">True</span>
                <span class="s1">)</span>
                <span class="s3">for </span><span class="s1">expr </span><span class="s3">in </span><span class="s1">index.expressions</span>
            <span class="s1">)</span><span class="s5">,</span>
        <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">visit_drop_index(self</span><span class="s5">, </span><span class="s1">drop</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">index = drop.element</span>

        <span class="s3">if </span><span class="s1">index.name </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
                <span class="s4">&quot;DROP INDEX requires that the index have a name&quot;</span>
            <span class="s1">)</span>
        <span class="s1">text = </span><span class="s4">&quot;</span><span class="s7">\n</span><span class="s4">DROP INDEX &quot;</span>
        <span class="s3">if </span><span class="s1">drop.if_exists:</span>
            <span class="s1">text += </span><span class="s4">&quot;IF EXISTS &quot;</span>

        <span class="s3">return </span><span class="s1">text + self._prepared_index_name(index</span><span class="s5">, </span><span class="s1">include_schema=</span><span class="s3">True</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_prepared_index_name(self</span><span class="s5">, </span><span class="s1">index</span><span class="s5">, </span><span class="s1">include_schema=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">index.table </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">effective_schema = self.preparer.schema_for_object(index.table)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">effective_schema = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">include_schema </span><span class="s3">and </span><span class="s1">effective_schema:</span>
            <span class="s1">schema_name = self.preparer.quote_schema(effective_schema)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">schema_name = </span><span class="s3">None</span>

        <span class="s1">index_name = self.preparer.format_index(index)</span>

        <span class="s3">if </span><span class="s1">schema_name:</span>
            <span class="s1">index_name = schema_name + </span><span class="s4">&quot;.&quot; </span><span class="s1">+ index_name</span>
        <span class="s3">return </span><span class="s1">index_name</span>

    <span class="s3">def </span><span class="s1">visit_add_constraint(self</span><span class="s5">, </span><span class="s1">create</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;ALTER TABLE %s ADD %s&quot; </span><span class="s1">% (</span>
            <span class="s1">self.preparer.format_table(create.element.table)</span><span class="s5">,</span>
            <span class="s1">self.process(create.element)</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_set_table_comment(self</span><span class="s5">, </span><span class="s1">create</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;COMMENT ON TABLE %s IS %s&quot; </span><span class="s1">% (</span>
            <span class="s1">self.preparer.format_table(create.element)</span><span class="s5">,</span>
            <span class="s1">self.sql_compiler.render_literal_value(</span>
                <span class="s1">create.element.comment</span><span class="s5">, </span><span class="s1">sqltypes.String()</span>
            <span class="s1">)</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_drop_table_comment(self</span><span class="s5">, </span><span class="s1">drop</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;COMMENT ON TABLE %s IS NULL&quot; </span><span class="s1">% self.preparer.format_table(</span>
            <span class="s1">drop.element</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_set_column_comment(self</span><span class="s5">, </span><span class="s1">create</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;COMMENT ON COLUMN %s IS %s&quot; </span><span class="s1">% (</span>
            <span class="s1">self.preparer.format_column(</span>
                <span class="s1">create.element</span><span class="s5">, </span><span class="s1">use_table=</span><span class="s3">True</span><span class="s5">, </span><span class="s1">use_schema=</span><span class="s3">True</span>
            <span class="s1">)</span><span class="s5">,</span>
            <span class="s1">self.sql_compiler.render_literal_value(</span>
                <span class="s1">create.element.comment</span><span class="s5">, </span><span class="s1">sqltypes.String()</span>
            <span class="s1">)</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_drop_column_comment(self</span><span class="s5">, </span><span class="s1">drop</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;COMMENT ON COLUMN %s IS NULL&quot; </span><span class="s1">% self.preparer.format_column(</span>
            <span class="s1">drop.element</span><span class="s5">, </span><span class="s1">use_table=</span><span class="s3">True</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_set_constraint_comment(self</span><span class="s5">, </span><span class="s1">create</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">raise </span><span class="s1">exc.UnsupportedCompilationError(self</span><span class="s5">, </span><span class="s1">type(create))</span>

    <span class="s3">def </span><span class="s1">visit_drop_constraint_comment(self</span><span class="s5">, </span><span class="s1">drop</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">raise </span><span class="s1">exc.UnsupportedCompilationError(self</span><span class="s5">, </span><span class="s1">type(drop))</span>

    <span class="s3">def </span><span class="s1">get_identity_options(self</span><span class="s5">, </span><span class="s1">identity_options):</span>
        <span class="s1">text = []</span>
        <span class="s3">if </span><span class="s1">identity_options.increment </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">text.append(</span><span class="s4">&quot;INCREMENT BY %d&quot; </span><span class="s1">% identity_options.increment)</span>
        <span class="s3">if </span><span class="s1">identity_options.start </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">text.append(</span><span class="s4">&quot;START WITH %d&quot; </span><span class="s1">% identity_options.start)</span>
        <span class="s3">if </span><span class="s1">identity_options.minvalue </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">text.append(</span><span class="s4">&quot;MINVALUE %d&quot; </span><span class="s1">% identity_options.minvalue)</span>
        <span class="s3">if </span><span class="s1">identity_options.maxvalue </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">text.append(</span><span class="s4">&quot;MAXVALUE %d&quot; </span><span class="s1">% identity_options.maxvalue)</span>
        <span class="s3">if </span><span class="s1">identity_options.nominvalue </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">text.append(</span><span class="s4">&quot;NO MINVALUE&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">identity_options.nomaxvalue </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">text.append(</span><span class="s4">&quot;NO MAXVALUE&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">identity_options.cache </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">text.append(</span><span class="s4">&quot;CACHE %d&quot; </span><span class="s1">% identity_options.cache)</span>
        <span class="s3">if </span><span class="s1">identity_options.cycle </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">text.append(</span><span class="s4">&quot;CYCLE&quot; </span><span class="s3">if </span><span class="s1">identity_options.cycle </span><span class="s3">else </span><span class="s4">&quot;NO CYCLE&quot;</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s4">&quot; &quot;</span><span class="s1">.join(text)</span>

    <span class="s3">def </span><span class="s1">visit_create_sequence(self</span><span class="s5">, </span><span class="s1">create</span><span class="s5">, </span><span class="s1">prefix=</span><span class="s3">None</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">text = </span><span class="s4">&quot;CREATE SEQUENCE &quot;</span>
        <span class="s3">if </span><span class="s1">create.if_not_exists:</span>
            <span class="s1">text += </span><span class="s4">&quot;IF NOT EXISTS &quot;</span>
        <span class="s1">text += self.preparer.format_sequence(create.element)</span>

        <span class="s3">if </span><span class="s1">prefix:</span>
            <span class="s1">text += prefix</span>
        <span class="s1">options = self.get_identity_options(create.element)</span>
        <span class="s3">if </span><span class="s1">options:</span>
            <span class="s1">text += </span><span class="s4">&quot; &quot; </span><span class="s1">+ options</span>
        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">visit_drop_sequence(self</span><span class="s5">, </span><span class="s1">drop</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">text = </span><span class="s4">&quot;DROP SEQUENCE &quot;</span>
        <span class="s3">if </span><span class="s1">drop.if_exists:</span>
            <span class="s1">text += </span><span class="s4">&quot;IF EXISTS &quot;</span>
        <span class="s3">return </span><span class="s1">text + self.preparer.format_sequence(drop.element)</span>

    <span class="s3">def </span><span class="s1">visit_drop_constraint(self</span><span class="s5">, </span><span class="s1">drop</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">constraint = drop.element</span>
        <span class="s3">if </span><span class="s1">constraint.name </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">formatted_name = self.preparer.format_constraint(constraint)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">formatted_name = </span><span class="s3">None</span>

        <span class="s3">if </span><span class="s1">formatted_name </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
                <span class="s4">&quot;Can't emit DROP CONSTRAINT for constraint %r; &quot;</span>
                <span class="s4">&quot;it has no name&quot; </span><span class="s1">% drop.element</span>
            <span class="s1">)</span>
        <span class="s3">return </span><span class="s4">&quot;ALTER TABLE %s DROP CONSTRAINT %s%s%s&quot; </span><span class="s1">% (</span>
            <span class="s1">self.preparer.format_table(drop.element.table)</span><span class="s5">,</span>
            <span class="s4">&quot;IF EXISTS &quot; </span><span class="s3">if </span><span class="s1">drop.if_exists </span><span class="s3">else </span><span class="s4">&quot;&quot;</span><span class="s5">,</span>
            <span class="s1">formatted_name</span><span class="s5">,</span>
            <span class="s4">&quot; CASCADE&quot; </span><span class="s3">if </span><span class="s1">drop.cascade </span><span class="s3">else </span><span class="s4">&quot;&quot;</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">get_column_specification(self</span><span class="s5">, </span><span class="s1">column</span><span class="s5">, </span><span class="s1">**kwargs):</span>
        <span class="s1">colspec = (</span>
            <span class="s1">self.preparer.format_column(column)</span>
            <span class="s1">+ </span><span class="s4">&quot; &quot;</span>
            <span class="s1">+ self.dialect.type_compiler_instance.process(</span>
                <span class="s1">column.type</span><span class="s5">, </span><span class="s1">type_expression=column</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">default = self.get_column_default_string(column)</span>
        <span class="s3">if </span><span class="s1">default </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">colspec += </span><span class="s4">&quot; DEFAULT &quot; </span><span class="s1">+ default</span>

        <span class="s3">if </span><span class="s1">column.computed </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">colspec += </span><span class="s4">&quot; &quot; </span><span class="s1">+ self.process(column.computed)</span>

        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">column.identity </span><span class="s3">is not None</span>
            <span class="s3">and </span><span class="s1">self.dialect.supports_identity_columns</span>
        <span class="s1">):</span>
            <span class="s1">colspec += </span><span class="s4">&quot; &quot; </span><span class="s1">+ self.process(column.identity)</span>

        <span class="s3">if not </span><span class="s1">column.nullable </span><span class="s3">and </span><span class="s1">(</span>
            <span class="s3">not </span><span class="s1">column.identity </span><span class="s3">or not </span><span class="s1">self.dialect.supports_identity_columns</span>
        <span class="s1">):</span>
            <span class="s1">colspec += </span><span class="s4">&quot; NOT NULL&quot;</span>
        <span class="s3">return </span><span class="s1">colspec</span>

    <span class="s3">def </span><span class="s1">create_table_suffix(self</span><span class="s5">, </span><span class="s1">table):</span>
        <span class="s3">return </span><span class="s4">&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">post_create_table(self</span><span class="s5">, </span><span class="s1">table):</span>
        <span class="s3">return </span><span class="s4">&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">get_column_default_string(self</span><span class="s5">, </span><span class="s1">column):</span>
        <span class="s3">if </span><span class="s1">isinstance(column.server_default</span><span class="s5">, </span><span class="s1">schema.DefaultClause):</span>
            <span class="s3">return </span><span class="s1">self.render_default_string(column.server_default.arg)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">render_default_string(self</span><span class="s5">, </span><span class="s1">default):</span>
        <span class="s3">if </span><span class="s1">isinstance(default</span><span class="s5">, </span><span class="s1">str):</span>
            <span class="s3">return </span><span class="s1">self.sql_compiler.render_literal_value(</span>
                <span class="s1">default</span><span class="s5">, </span><span class="s1">sqltypes.STRINGTYPE</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.sql_compiler.process(default</span><span class="s5">, </span><span class="s1">literal_binds=</span><span class="s3">True</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_table_or_column_check_constraint(self</span><span class="s5">, </span><span class="s1">constraint</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">if </span><span class="s1">constraint.is_column_level:</span>
            <span class="s3">return </span><span class="s1">self.visit_column_check_constraint(constraint)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.visit_check_constraint(constraint)</span>

    <span class="s3">def </span><span class="s1">visit_check_constraint(self</span><span class="s5">, </span><span class="s1">constraint</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">text = </span><span class="s4">&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">constraint.name </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">formatted_name = self.preparer.format_constraint(constraint)</span>
            <span class="s3">if </span><span class="s1">formatted_name </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">text += </span><span class="s4">&quot;CONSTRAINT %s &quot; </span><span class="s1">% formatted_name</span>
        <span class="s1">text += </span><span class="s4">&quot;CHECK (%s)&quot; </span><span class="s1">% self.sql_compiler.process(</span>
            <span class="s1">constraint.sqltext</span><span class="s5">, </span><span class="s1">include_table=</span><span class="s3">False</span><span class="s5">, </span><span class="s1">literal_binds=</span><span class="s3">True</span>
        <span class="s1">)</span>
        <span class="s1">text += self.define_constraint_deferrability(constraint)</span>
        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">visit_column_check_constraint(self</span><span class="s5">, </span><span class="s1">constraint</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">text = </span><span class="s4">&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">constraint.name </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">formatted_name = self.preparer.format_constraint(constraint)</span>
            <span class="s3">if </span><span class="s1">formatted_name </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">text += </span><span class="s4">&quot;CONSTRAINT %s &quot; </span><span class="s1">% formatted_name</span>
        <span class="s1">text += </span><span class="s4">&quot;CHECK (%s)&quot; </span><span class="s1">% self.sql_compiler.process(</span>
            <span class="s1">constraint.sqltext</span><span class="s5">, </span><span class="s1">include_table=</span><span class="s3">False</span><span class="s5">, </span><span class="s1">literal_binds=</span><span class="s3">True</span>
        <span class="s1">)</span>
        <span class="s1">text += self.define_constraint_deferrability(constraint)</span>
        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">visit_primary_key_constraint(self</span><span class="s5">, </span><span class="s1">constraint</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">if </span><span class="s1">len(constraint) == </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">&quot;&quot;</span>
        <span class="s1">text = </span><span class="s4">&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">constraint.name </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">formatted_name = self.preparer.format_constraint(constraint)</span>
            <span class="s3">if </span><span class="s1">formatted_name </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">text += </span><span class="s4">&quot;CONSTRAINT %s &quot; </span><span class="s1">% formatted_name</span>
        <span class="s1">text += </span><span class="s4">&quot;PRIMARY KEY &quot;</span>
        <span class="s1">text += </span><span class="s4">&quot;(%s)&quot; </span><span class="s1">% </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
            <span class="s1">self.preparer.quote(c.name)</span>
            <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">(</span>
                <span class="s1">constraint.columns_autoinc_first</span>
                <span class="s3">if </span><span class="s1">constraint._implicit_generated</span>
                <span class="s3">else </span><span class="s1">constraint.columns</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">text += self.define_constraint_deferrability(constraint)</span>
        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">visit_foreign_key_constraint(self</span><span class="s5">, </span><span class="s1">constraint</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">preparer = self.preparer</span>
        <span class="s1">text = </span><span class="s4">&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">constraint.name </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">formatted_name = self.preparer.format_constraint(constraint)</span>
            <span class="s3">if </span><span class="s1">formatted_name </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">text += </span><span class="s4">&quot;CONSTRAINT %s &quot; </span><span class="s1">% formatted_name</span>
        <span class="s1">remote_table = list(constraint.elements)[</span><span class="s6">0</span><span class="s1">].column.table</span>
        <span class="s1">text += </span><span class="s4">&quot;FOREIGN KEY(%s) REFERENCES %s (%s)&quot; </span><span class="s1">% (</span>
            <span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
                <span class="s1">preparer.quote(f.parent.name) </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">constraint.elements</span>
            <span class="s1">)</span><span class="s5">,</span>
            <span class="s1">self.define_constraint_remote_table(</span>
                <span class="s1">constraint</span><span class="s5">, </span><span class="s1">remote_table</span><span class="s5">, </span><span class="s1">preparer</span>
            <span class="s1">)</span><span class="s5">,</span>
            <span class="s4">&quot;, &quot;</span><span class="s1">.join(</span>
                <span class="s1">preparer.quote(f.column.name) </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">constraint.elements</span>
            <span class="s1">)</span><span class="s5">,</span>
        <span class="s1">)</span>
        <span class="s1">text += self.define_constraint_match(constraint)</span>
        <span class="s1">text += self.define_constraint_cascades(constraint)</span>
        <span class="s1">text += self.define_constraint_deferrability(constraint)</span>
        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">define_constraint_remote_table(self</span><span class="s5">, </span><span class="s1">constraint</span><span class="s5">, </span><span class="s1">table</span><span class="s5">, </span><span class="s1">preparer):</span>
        <span class="s2">&quot;&quot;&quot;Format the remote table clause of a CREATE CONSTRAINT clause.&quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">preparer.format_table(table)</span>

    <span class="s3">def </span><span class="s1">visit_unique_constraint(self</span><span class="s5">, </span><span class="s1">constraint</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">if </span><span class="s1">len(constraint) == </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">&quot;&quot;</span>
        <span class="s1">text = </span><span class="s4">&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">constraint.name </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">formatted_name = self.preparer.format_constraint(constraint)</span>
            <span class="s3">if </span><span class="s1">formatted_name </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">text += </span><span class="s4">&quot;CONSTRAINT %s &quot; </span><span class="s1">% formatted_name</span>
        <span class="s1">text += </span><span class="s4">&quot;UNIQUE %s(%s)&quot; </span><span class="s1">% (</span>
            <span class="s1">self.define_unique_constraint_distinct(constraint</span><span class="s5">, </span><span class="s1">**kw)</span><span class="s5">,</span>
            <span class="s4">&quot;, &quot;</span><span class="s1">.join(self.preparer.quote(c.name) </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">constraint)</span><span class="s5">,</span>
        <span class="s1">)</span>
        <span class="s1">text += self.define_constraint_deferrability(constraint)</span>
        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">define_unique_constraint_distinct(self</span><span class="s5">, </span><span class="s1">constraint</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">define_constraint_cascades(self</span><span class="s5">, </span><span class="s1">constraint):</span>
        <span class="s1">text = </span><span class="s4">&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">constraint.ondelete </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">text += </span><span class="s4">&quot; ON DELETE %s&quot; </span><span class="s1">% self.preparer.validate_sql_phrase(</span>
                <span class="s1">constraint.ondelete</span><span class="s5">, </span><span class="s1">FK_ON_DELETE</span>
            <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">constraint.onupdate </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">text += </span><span class="s4">&quot; ON UPDATE %s&quot; </span><span class="s1">% self.preparer.validate_sql_phrase(</span>
                <span class="s1">constraint.onupdate</span><span class="s5">, </span><span class="s1">FK_ON_UPDATE</span>
            <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">define_constraint_deferrability(self</span><span class="s5">, </span><span class="s1">constraint):</span>
        <span class="s1">text = </span><span class="s4">&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">constraint.deferrable </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">constraint.deferrable:</span>
                <span class="s1">text += </span><span class="s4">&quot; DEFERRABLE&quot;</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">text += </span><span class="s4">&quot; NOT DEFERRABLE&quot;</span>
        <span class="s3">if </span><span class="s1">constraint.initially </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">text += </span><span class="s4">&quot; INITIALLY %s&quot; </span><span class="s1">% self.preparer.validate_sql_phrase(</span>
                <span class="s1">constraint.initially</span><span class="s5">, </span><span class="s1">FK_INITIALLY</span>
            <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">define_constraint_match(self</span><span class="s5">, </span><span class="s1">constraint):</span>
        <span class="s1">text = </span><span class="s4">&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">constraint.match </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">text += </span><span class="s4">&quot; MATCH %s&quot; </span><span class="s1">% constraint.match</span>
        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">visit_computed_column(self</span><span class="s5">, </span><span class="s1">generated</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">text = </span><span class="s4">&quot;GENERATED ALWAYS AS (%s)&quot; </span><span class="s1">% self.sql_compiler.process(</span>
            <span class="s1">generated.sqltext</span><span class="s5">, </span><span class="s1">include_table=</span><span class="s3">False</span><span class="s5">, </span><span class="s1">literal_binds=</span><span class="s3">True</span>
        <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">generated.persisted </span><span class="s3">is True</span><span class="s1">:</span>
            <span class="s1">text += </span><span class="s4">&quot; STORED&quot;</span>
        <span class="s3">elif </span><span class="s1">generated.persisted </span><span class="s3">is False</span><span class="s1">:</span>
            <span class="s1">text += </span><span class="s4">&quot; VIRTUAL&quot;</span>
        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">visit_identity_column(self</span><span class="s5">, </span><span class="s1">identity</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s1">text = </span><span class="s4">&quot;GENERATED %s AS IDENTITY&quot; </span><span class="s1">% (</span>
            <span class="s4">&quot;ALWAYS&quot; </span><span class="s3">if </span><span class="s1">identity.always </span><span class="s3">else </span><span class="s4">&quot;BY DEFAULT&quot;</span><span class="s5">,</span>
        <span class="s1">)</span>
        <span class="s1">options = self.get_identity_options(identity)</span>
        <span class="s3">if </span><span class="s1">options:</span>
            <span class="s1">text += </span><span class="s4">&quot; (%s)&quot; </span><span class="s1">% options</span>
        <span class="s3">return </span><span class="s1">text</span>


<span class="s3">class </span><span class="s1">GenericTypeCompiler(TypeCompiler):</span>
    <span class="s3">def </span><span class="s1">visit_FLOAT(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;FLOAT&quot;</span>

    <span class="s3">def </span><span class="s1">visit_DOUBLE(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;DOUBLE&quot;</span>

    <span class="s3">def </span><span class="s1">visit_DOUBLE_PRECISION(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;DOUBLE PRECISION&quot;</span>

    <span class="s3">def </span><span class="s1">visit_REAL(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;REAL&quot;</span>

    <span class="s3">def </span><span class="s1">visit_NUMERIC(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">if </span><span class="s1">type_.precision </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">&quot;NUMERIC&quot;</span>
        <span class="s3">elif </span><span class="s1">type_.scale </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">&quot;NUMERIC(%(precision)s)&quot; </span><span class="s1">% {</span><span class="s4">&quot;precision&quot;</span><span class="s1">: type_.precision}</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">&quot;NUMERIC(%(precision)s, %(scale)s)&quot; </span><span class="s1">% {</span>
                <span class="s4">&quot;precision&quot;</span><span class="s1">: type_.precision</span><span class="s5">,</span>
                <span class="s4">&quot;scale&quot;</span><span class="s1">: type_.scale</span><span class="s5">,</span>
            <span class="s1">}</span>

    <span class="s3">def </span><span class="s1">visit_DECIMAL(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">if </span><span class="s1">type_.precision </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">&quot;DECIMAL&quot;</span>
        <span class="s3">elif </span><span class="s1">type_.scale </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">&quot;DECIMAL(%(precision)s)&quot; </span><span class="s1">% {</span><span class="s4">&quot;precision&quot;</span><span class="s1">: type_.precision}</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">&quot;DECIMAL(%(precision)s, %(scale)s)&quot; </span><span class="s1">% {</span>
                <span class="s4">&quot;precision&quot;</span><span class="s1">: type_.precision</span><span class="s5">,</span>
                <span class="s4">&quot;scale&quot;</span><span class="s1">: type_.scale</span><span class="s5">,</span>
            <span class="s1">}</span>

    <span class="s3">def </span><span class="s1">visit_INTEGER(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;INTEGER&quot;</span>

    <span class="s3">def </span><span class="s1">visit_SMALLINT(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;SMALLINT&quot;</span>

    <span class="s3">def </span><span class="s1">visit_BIGINT(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;BIGINT&quot;</span>

    <span class="s3">def </span><span class="s1">visit_TIMESTAMP(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;TIMESTAMP&quot;</span>

    <span class="s3">def </span><span class="s1">visit_DATETIME(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;DATETIME&quot;</span>

    <span class="s3">def </span><span class="s1">visit_DATE(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;DATE&quot;</span>

    <span class="s3">def </span><span class="s1">visit_TIME(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;TIME&quot;</span>

    <span class="s3">def </span><span class="s1">visit_CLOB(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;CLOB&quot;</span>

    <span class="s3">def </span><span class="s1">visit_NCLOB(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;NCLOB&quot;</span>

    <span class="s3">def </span><span class="s1">_render_string_type(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">name</span><span class="s5">, </span><span class="s1">length_override=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">text = name</span>
        <span class="s3">if </span><span class="s1">length_override:</span>
            <span class="s1">text += </span><span class="s4">&quot;(%d)&quot; </span><span class="s1">% length_override</span>
        <span class="s3">elif </span><span class="s1">type_.length:</span>
            <span class="s1">text += </span><span class="s4">&quot;(%d)&quot; </span><span class="s1">% type_.length</span>
        <span class="s3">if </span><span class="s1">type_.collation:</span>
            <span class="s1">text += </span><span class="s4">' COLLATE &quot;%s&quot;' </span><span class="s1">% type_.collation</span>
        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">visit_CHAR(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self._render_string_type(type_</span><span class="s5">, </span><span class="s4">&quot;CHAR&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_NCHAR(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self._render_string_type(type_</span><span class="s5">, </span><span class="s4">&quot;NCHAR&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_VARCHAR(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self._render_string_type(type_</span><span class="s5">, </span><span class="s4">&quot;VARCHAR&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_NVARCHAR(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self._render_string_type(type_</span><span class="s5">, </span><span class="s4">&quot;NVARCHAR&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_TEXT(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self._render_string_type(type_</span><span class="s5">, </span><span class="s4">&quot;TEXT&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_UUID(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;UUID&quot;</span>

    <span class="s3">def </span><span class="s1">visit_BLOB(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;BLOB&quot;</span>

    <span class="s3">def </span><span class="s1">visit_BINARY(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;BINARY&quot; </span><span class="s1">+ (type_.length </span><span class="s3">and </span><span class="s4">&quot;(%d)&quot; </span><span class="s1">% type_.length </span><span class="s3">or </span><span class="s4">&quot;&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_VARBINARY(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;VARBINARY&quot; </span><span class="s1">+ (type_.length </span><span class="s3">and </span><span class="s4">&quot;(%d)&quot; </span><span class="s1">% type_.length </span><span class="s3">or </span><span class="s4">&quot;&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_BOOLEAN(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;BOOLEAN&quot;</span>

    <span class="s3">def </span><span class="s1">visit_uuid(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">if not </span><span class="s1">type_.native_uuid </span><span class="s3">or not </span><span class="s1">self.dialect.supports_native_uuid:</span>
            <span class="s3">return </span><span class="s1">self._render_string_type(type_</span><span class="s5">, </span><span class="s4">&quot;CHAR&quot;</span><span class="s5">, </span><span class="s1">length_override=</span><span class="s6">32</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.visit_UUID(type_</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_large_binary(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self.visit_BLOB(type_</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_boolean(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self.visit_BOOLEAN(type_</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_time(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self.visit_TIME(type_</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_datetime(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self.visit_DATETIME(type_</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_date(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self.visit_DATE(type_</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_big_integer(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self.visit_BIGINT(type_</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_small_integer(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self.visit_SMALLINT(type_</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_integer(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self.visit_INTEGER(type_</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_real(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self.visit_REAL(type_</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_float(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self.visit_FLOAT(type_</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_double(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self.visit_DOUBLE(type_</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_numeric(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self.visit_NUMERIC(type_</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_string(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self.visit_VARCHAR(type_</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_unicode(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self.visit_VARCHAR(type_</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_text(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self.visit_TEXT(type_</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_unicode_text(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self.visit_TEXT(type_</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_enum(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self.visit_VARCHAR(type_</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_null(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
            <span class="s4">&quot;Can't generate DDL for %r; &quot;</span>
            <span class="s4">&quot;did you forget to specify a &quot;</span>
            <span class="s4">&quot;type on this Column?&quot; </span><span class="s1">% type_</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_type_decorator(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">self.process(type_.type_engine(self.dialect)</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">visit_user_defined(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s1">type_.get_col_spec(**kw)</span>


<span class="s3">class </span><span class="s1">StrSQLTypeCompiler(GenericTypeCompiler):</span>
    <span class="s3">def </span><span class="s1">process(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">_compiler_dispatch = type_._compiler_dispatch</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s3">return </span><span class="s1">self._visit_unknown(type_</span><span class="s5">, </span><span class="s1">**kw)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">_compiler_dispatch(self</span><span class="s5">, </span><span class="s1">**kw)</span>

    <span class="s3">def </span><span class="s1">__getattr__(self</span><span class="s5">, </span><span class="s1">key):</span>
        <span class="s3">if </span><span class="s1">key.startswith(</span><span class="s4">&quot;visit_&quot;</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s1">self._visit_unknown</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">AttributeError(key)</span>

    <span class="s3">def </span><span class="s1">_visit_unknown(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">if </span><span class="s1">type_.__class__.__name__ == type_.__class__.__name__.upper():</span>
            <span class="s3">return </span><span class="s1">type_.__class__.__name__</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">repr(type_)</span>

    <span class="s3">def </span><span class="s1">visit_null(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">return </span><span class="s4">&quot;NULL&quot;</span>

    <span class="s3">def </span><span class="s1">visit_user_defined(self</span><span class="s5">, </span><span class="s1">type_</span><span class="s5">, </span><span class="s1">**kw):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">get_col_spec = type_.get_col_spec</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s3">return </span><span class="s1">repr(type_)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">get_col_spec(**kw)</span>


<span class="s3">class </span><span class="s1">_SchemaForObjectCallable(Protocol):</span>
    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s5">, </span><span class="s1">__obj: Any) -&gt; str: ...</span>


<span class="s3">class </span><span class="s1">_BindNameForColProtocol(Protocol):</span>
    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s5">, </span><span class="s1">col: ColumnClause[Any]) -&gt; str: ...</span>


<span class="s3">class </span><span class="s1">IdentifierPreparer:</span>
    <span class="s2">&quot;&quot;&quot;Handle quoting and case-folding of identifiers based on options.&quot;&quot;&quot;</span>

    <span class="s1">reserved_words = RESERVED_WORDS</span>

    <span class="s1">legal_characters = LEGAL_CHARACTERS</span>

    <span class="s1">illegal_initial_characters = ILLEGAL_INITIAL_CHARACTERS</span>

    <span class="s1">initial_quote: str</span>

    <span class="s1">final_quote: str</span>

    <span class="s1">_strings: MutableMapping[str</span><span class="s5">, </span><span class="s1">str]</span>

    <span class="s1">schema_for_object: _SchemaForObjectCallable = operator.attrgetter(</span><span class="s4">&quot;schema&quot;</span><span class="s1">)</span>
    <span class="s4">&quot;&quot;&quot;Return the .schema attribute for an object. 
 
    For the default IdentifierPreparer, the schema for an object is always 
    the value of the &quot;.schema&quot; attribute.   if the preparer is replaced 
    with one that has a non-empty schema_translate_map, the value of the 
    &quot;.schema&quot; attribute is rendered a symbol that will be converted to a 
    real schema name from the mapping post-compile. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_includes_none_schema_translate: bool = </span><span class="s3">False</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">dialect</span><span class="s5">,</span>
        <span class="s1">initial_quote=</span><span class="s4">'&quot;'</span><span class="s5">,</span>
        <span class="s1">final_quote=</span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">escape_quote=</span><span class="s4">'&quot;'</span><span class="s5">,</span>
        <span class="s1">quote_case_sensitive_collations=</span><span class="s3">True</span><span class="s5">,</span>
        <span class="s1">omit_schema=</span><span class="s3">False</span><span class="s5">,</span>
    <span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Construct a new ``IdentifierPreparer`` object. 
 
        initial_quote 
          Character that begins a delimited identifier. 
 
        final_quote 
          Character that ends a delimited identifier. Defaults to 
          `initial_quote`. 
 
        omit_schema 
          Prevent prepending schema name. Useful for databases that do 
          not support schemae. 
        &quot;&quot;&quot;</span>

        <span class="s1">self.dialect = dialect</span>
        <span class="s1">self.initial_quote = initial_quote</span>
        <span class="s1">self.final_quote = final_quote </span><span class="s3">or </span><span class="s1">self.initial_quote</span>
        <span class="s1">self.escape_quote = escape_quote</span>
        <span class="s1">self.escape_to_quote = self.escape_quote * </span><span class="s6">2</span>
        <span class="s1">self.omit_schema = omit_schema</span>
        <span class="s1">self.quote_case_sensitive_collations = quote_case_sensitive_collations</span>
        <span class="s1">self._strings = {}</span>
        <span class="s1">self._double_percents = self.dialect.paramstyle </span><span class="s3">in </span><span class="s1">(</span>
            <span class="s4">&quot;format&quot;</span><span class="s5">,</span>
            <span class="s4">&quot;pyformat&quot;</span><span class="s5">,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_with_schema_translate(self</span><span class="s5">, </span><span class="s1">schema_translate_map):</span>
        <span class="s1">prep = self.__class__.__new__(self.__class__)</span>
        <span class="s1">prep.__dict__.update(self.__dict__)</span>

        <span class="s1">includes_none = </span><span class="s3">None in </span><span class="s1">schema_translate_map</span>

        <span class="s3">def </span><span class="s1">symbol_getter(obj):</span>
            <span class="s1">name = obj.schema</span>
            <span class="s3">if </span><span class="s1">obj._use_schema_map </span><span class="s3">and </span><span class="s1">(name </span><span class="s3">is not None or </span><span class="s1">includes_none):</span>
                <span class="s3">if </span><span class="s1">name </span><span class="s3">is not None and </span><span class="s1">(</span><span class="s4">&quot;[&quot; </span><span class="s3">in </span><span class="s1">name </span><span class="s3">or </span><span class="s4">&quot;]&quot; </span><span class="s3">in </span><span class="s1">name):</span>
                    <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
                        <span class="s4">&quot;Square bracket characters ([]) not supported &quot;</span>
                        <span class="s4">&quot;in schema translate name '%s'&quot; </span><span class="s1">% name</span>
                    <span class="s1">)</span>
                <span class="s3">return </span><span class="s1">quoted_name(</span>
                    <span class="s4">&quot;__[SCHEMA_%s]&quot; </span><span class="s1">% (name </span><span class="s3">or </span><span class="s4">&quot;_none&quot;</span><span class="s1">)</span><span class="s5">, </span><span class="s1">quote=</span><span class="s3">False</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">obj.schema</span>

        <span class="s1">prep.schema_for_object = symbol_getter</span>
        <span class="s1">prep._includes_none_schema_translate = includes_none</span>
        <span class="s3">return </span><span class="s1">prep</span>

    <span class="s3">def </span><span class="s1">_render_schema_translates(self</span><span class="s5">, </span><span class="s1">statement</span><span class="s5">, </span><span class="s1">schema_translate_map):</span>
        <span class="s1">d = schema_translate_map</span>
        <span class="s3">if None in </span><span class="s1">d:</span>
            <span class="s3">if not </span><span class="s1">self._includes_none_schema_translate:</span>
                <span class="s3">raise </span><span class="s1">exc.InvalidRequestError(</span>
                    <span class="s4">&quot;schema translate map which previously did not have &quot;</span>
                    <span class="s4">&quot;`None` present as a key now has `None` present; compiled &quot;</span>
                    <span class="s4">&quot;statement may lack adequate placeholders.  Please use &quot;</span>
                    <span class="s4">&quot;consistent keys in successive &quot;</span>
                    <span class="s4">&quot;schema_translate_map dictionaries.&quot;</span>
                <span class="s1">)</span>

            <span class="s1">d[</span><span class="s4">&quot;_none&quot;</span><span class="s1">] = d[</span><span class="s3">None</span><span class="s1">]</span>

        <span class="s3">def </span><span class="s1">replace(m):</span>
            <span class="s1">name = m.group(</span><span class="s6">2</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">d:</span>
                <span class="s1">effective_schema = d[name]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">(</span><span class="s3">None</span><span class="s5">, </span><span class="s4">&quot;_none&quot;</span><span class="s1">):</span>
                    <span class="s3">raise </span><span class="s1">exc.InvalidRequestError(</span>
                        <span class="s4">&quot;schema translate map which previously had `None` &quot;</span>
                        <span class="s4">&quot;present as a key now no longer has it present; don't &quot;</span>
                        <span class="s4">&quot;know how to apply schema for compiled statement. &quot;</span>
                        <span class="s4">&quot;Please use consistent keys in successive &quot;</span>
                        <span class="s4">&quot;schema_translate_map dictionaries.&quot;</span>
                    <span class="s1">)</span>
                <span class="s1">effective_schema = name</span>

            <span class="s3">if not </span><span class="s1">effective_schema:</span>
                <span class="s1">effective_schema = self.dialect.default_schema_name</span>
                <span class="s3">if not </span><span class="s1">effective_schema:</span>
                    <span class="s0"># TODO: no coverage here</span>
                    <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
                        <span class="s4">&quot;Dialect has no default schema name; can't &quot;</span>
                        <span class="s4">&quot;use None as dynamic schema target.&quot;</span>
                    <span class="s1">)</span>
            <span class="s3">return </span><span class="s1">self.quote_schema(effective_schema)</span>

        <span class="s3">return </span><span class="s1">re.sub(</span><span class="s4">r&quot;(__\[SCHEMA_([^\]]+)\])&quot;</span><span class="s5">, </span><span class="s1">replace</span><span class="s5">, </span><span class="s1">statement)</span>

    <span class="s3">def </span><span class="s1">_escape_identifier(self</span><span class="s5">, </span><span class="s1">value: str) -&gt; str:</span>
        <span class="s2">&quot;&quot;&quot;Escape an identifier. 
 
        Subclasses should override this to provide database-dependent 
        escaping behavior. 
        &quot;&quot;&quot;</span>

        <span class="s1">value = value.replace(self.escape_quote</span><span class="s5">, </span><span class="s1">self.escape_to_quote)</span>
        <span class="s3">if </span><span class="s1">self._double_percents:</span>
            <span class="s1">value = value.replace(</span><span class="s4">&quot;%&quot;</span><span class="s5">, </span><span class="s4">&quot;%%&quot;</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">value</span>

    <span class="s3">def </span><span class="s1">_unescape_identifier(self</span><span class="s5">, </span><span class="s1">value: str) -&gt; str:</span>
        <span class="s2">&quot;&quot;&quot;Canonicalize an escaped identifier. 
 
        Subclasses should override this to provide database-dependent 
        unescaping behavior that reverses _escape_identifier. 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">value.replace(self.escape_to_quote</span><span class="s5">, </span><span class="s1">self.escape_quote)</span>

    <span class="s3">def </span><span class="s1">validate_sql_phrase(self</span><span class="s5">, </span><span class="s1">element</span><span class="s5">, </span><span class="s1">reg):</span>
        <span class="s2">&quot;&quot;&quot;keyword sequence filter. 
 
        a filter for elements that are intended to represent keyword sequences, 
        such as &quot;INITIALLY&quot;, &quot;INITIALLY DEFERRED&quot;, etc.   no special characters 
        should be present. 
 
        .. versionadded:: 1.3 
 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">element </span><span class="s3">is not None and not </span><span class="s1">reg.match(element):</span>
            <span class="s3">raise </span><span class="s1">exc.CompileError(</span>
                <span class="s4">&quot;Unexpected SQL phrase: %r (matching against %r)&quot;</span>
                <span class="s1">% (element</span><span class="s5">, </span><span class="s1">reg.pattern)</span>
            <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">element</span>

    <span class="s3">def </span><span class="s1">quote_identifier(self</span><span class="s5">, </span><span class="s1">value: str) -&gt; str:</span>
        <span class="s2">&quot;&quot;&quot;Quote an identifier. 
 
        Subclasses should override this to provide database-dependent 
        quoting behavior. 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">(</span>
            <span class="s1">self.initial_quote</span>
            <span class="s1">+ self._escape_identifier(value)</span>
            <span class="s1">+ self.final_quote</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_requires_quotes(self</span><span class="s5">, </span><span class="s1">value: str) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot;Return True if the given identifier requires quoting.&quot;&quot;&quot;</span>
        <span class="s1">lc_value = value.lower()</span>
        <span class="s3">return </span><span class="s1">(</span>
            <span class="s1">lc_value </span><span class="s3">in </span><span class="s1">self.reserved_words</span>
            <span class="s3">or </span><span class="s1">value[</span><span class="s6">0</span><span class="s1">] </span><span class="s3">in </span><span class="s1">self.illegal_initial_characters</span>
            <span class="s3">or not </span><span class="s1">self.legal_characters.match(str(value))</span>
            <span class="s3">or </span><span class="s1">(lc_value != value)</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_requires_quotes_illegal_chars(self</span><span class="s5">, </span><span class="s1">value):</span>
        <span class="s2">&quot;&quot;&quot;Return True if the given identifier requires quoting, but 
        not taking case convention into account.&quot;&quot;&quot;</span>
        <span class="s3">return not </span><span class="s1">self.legal_characters.match(str(value))</span>

    <span class="s3">def </span><span class="s1">quote_schema(self</span><span class="s5">, </span><span class="s1">schema: str</span><span class="s5">, </span><span class="s1">force: Any = </span><span class="s3">None</span><span class="s1">) -&gt; str:</span>
        <span class="s2">&quot;&quot;&quot;Conditionally quote a schema name. 
 
 
        The name is quoted if it is a reserved word, contains quote-necessary 
        characters, or is an instance of :class:`.quoted_name` which includes 
        ``quote`` set to ``True``. 
 
        Subclasses can override this to provide database-dependent 
        quoting behavior for schema names. 
 
        :param schema: string schema name 
        :param force: unused 
 
            .. deprecated:: 0.9 
 
                The :paramref:`.IdentifierPreparer.quote_schema.force` 
                parameter is deprecated and will be removed in a future 
                release.  This flag has no effect on the behavior of the 
                :meth:`.IdentifierPreparer.quote` method; please refer to 
                :class:`.quoted_name`. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">force </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s0"># not using the util.deprecated_params() decorator in this</span>
            <span class="s0"># case because of the additional function call overhead on this</span>
            <span class="s0"># very performance-critical spot.</span>
            <span class="s1">util.warn_deprecated(</span>
                <span class="s4">&quot;The IdentifierPreparer.quote_schema.force parameter is &quot;</span>
                <span class="s4">&quot;deprecated and will be removed in a future release.  This &quot;</span>
                <span class="s4">&quot;flag has no effect on the behavior of the &quot;</span>
                <span class="s4">&quot;IdentifierPreparer.quote method; please refer to &quot;</span>
                <span class="s4">&quot;quoted_name().&quot;</span><span class="s5">,</span>
                <span class="s0"># deprecated 0.9. warning from 1.3</span>
                <span class="s1">version=</span><span class="s4">&quot;0.9&quot;</span><span class="s5">,</span>
            <span class="s1">)</span>

        <span class="s3">return </span><span class="s1">self.quote(schema)</span>

    <span class="s3">def </span><span class="s1">quote(self</span><span class="s5">, </span><span class="s1">ident: str</span><span class="s5">, </span><span class="s1">force: Any = </span><span class="s3">None</span><span class="s1">) -&gt; str:</span>
        <span class="s2">&quot;&quot;&quot;Conditionally quote an identifier. 
 
        The identifier is quoted if it is a reserved word, contains 
        quote-necessary characters, or is an instance of 
        :class:`.quoted_name` which includes ``quote`` set to ``True``. 
 
        Subclasses can override this to provide database-dependent 
        quoting behavior for identifier names. 
 
        :param ident: string identifier 
        :param force: unused 
 
            .. deprecated:: 0.9 
 
                The :paramref:`.IdentifierPreparer.quote.force` 
                parameter is deprecated and will be removed in a future 
                release.  This flag has no effect on the behavior of the 
                :meth:`.IdentifierPreparer.quote` method; please refer to 
                :class:`.quoted_name`. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">force </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s0"># not using the util.deprecated_params() decorator in this</span>
            <span class="s0"># case because of the additional function call overhead on this</span>
            <span class="s0"># very performance-critical spot.</span>
            <span class="s1">util.warn_deprecated(</span>
                <span class="s4">&quot;The IdentifierPreparer.quote.force parameter is &quot;</span>
                <span class="s4">&quot;deprecated and will be removed in a future release.  This &quot;</span>
                <span class="s4">&quot;flag has no effect on the behavior of the &quot;</span>
                <span class="s4">&quot;IdentifierPreparer.quote method; please refer to &quot;</span>
                <span class="s4">&quot;quoted_name().&quot;</span><span class="s5">,</span>
                <span class="s0"># deprecated 0.9. warning from 1.3</span>
                <span class="s1">version=</span><span class="s4">&quot;0.9&quot;</span><span class="s5">,</span>
            <span class="s1">)</span>

        <span class="s1">force = getattr(ident</span><span class="s5">, </span><span class="s4">&quot;quote&quot;</span><span class="s5">, </span><span class="s3">None</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">force </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">ident </span><span class="s3">in </span><span class="s1">self._strings:</span>
                <span class="s3">return </span><span class="s1">self._strings[ident]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">self._requires_quotes(ident):</span>
                    <span class="s1">self._strings[ident] = self.quote_identifier(ident)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">self._strings[ident] = ident</span>
                <span class="s3">return </span><span class="s1">self._strings[ident]</span>
        <span class="s3">elif </span><span class="s1">force:</span>
            <span class="s3">return </span><span class="s1">self.quote_identifier(ident)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">ident</span>

    <span class="s3">def </span><span class="s1">format_collation(self</span><span class="s5">, </span><span class="s1">collation_name):</span>
        <span class="s3">if </span><span class="s1">self.quote_case_sensitive_collations:</span>
            <span class="s3">return </span><span class="s1">self.quote(collation_name)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">collation_name</span>

    <span class="s3">def </span><span class="s1">format_sequence(self</span><span class="s5">, </span><span class="s1">sequence</span><span class="s5">, </span><span class="s1">use_schema=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s1">name = self.quote(sequence.name)</span>

        <span class="s1">effective_schema = self.schema_for_object(sequence)</span>

        <span class="s3">if </span><span class="s1">(</span>
            <span class="s3">not </span><span class="s1">self.omit_schema</span>
            <span class="s3">and </span><span class="s1">use_schema</span>
            <span class="s3">and </span><span class="s1">effective_schema </span><span class="s3">is not None</span>
        <span class="s1">):</span>
            <span class="s1">name = self.quote_schema(effective_schema) + </span><span class="s4">&quot;.&quot; </span><span class="s1">+ name</span>
        <span class="s3">return </span><span class="s1">name</span>

    <span class="s3">def </span><span class="s1">format_label(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">label: Label[Any]</span><span class="s5">, </span><span class="s1">name: Optional[str] = </span><span class="s3">None</span>
    <span class="s1">) -&gt; str:</span>
        <span class="s3">return </span><span class="s1">self.quote(name </span><span class="s3">or </span><span class="s1">label.name)</span>

    <span class="s3">def </span><span class="s1">format_alias(</span>
        <span class="s1">self</span><span class="s5">, </span><span class="s1">alias: Optional[AliasedReturnsRows]</span><span class="s5">, </span><span class="s1">name: Optional[str] = </span><span class="s3">None</span>
    <span class="s1">) -&gt; str:</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">assert </span><span class="s1">alias </span><span class="s3">is not None</span>
            <span class="s3">return </span><span class="s1">self.quote(alias.name)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.quote(name)</span>

    <span class="s3">def </span><span class="s1">format_savepoint(self</span><span class="s5">, </span><span class="s1">savepoint</span><span class="s5">, </span><span class="s1">name=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0"># Running the savepoint name through quoting is unnecessary</span>
        <span class="s0"># for all known dialects.  This is here to support potential</span>
        <span class="s0"># third party use cases</span>
        <span class="s1">ident = name </span><span class="s3">or </span><span class="s1">savepoint.ident</span>
        <span class="s3">if </span><span class="s1">self._requires_quotes(ident):</span>
            <span class="s1">ident = self.quote_identifier(ident)</span>
        <span class="s3">return </span><span class="s1">ident</span>

    <span class="s1">@util.preload_module(</span><span class="s4">&quot;sqlalchemy.sql.naming&quot;</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">format_constraint(self</span><span class="s5">, </span><span class="s1">constraint</span><span class="s5">, </span><span class="s1">_alembic_quote=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s1">naming = util.preloaded.sql_naming</span>

        <span class="s3">if </span><span class="s1">constraint.name </span><span class="s3">is </span><span class="s1">_NONE_NAME:</span>
            <span class="s1">name = naming._constraint_name_for_table(</span>
                <span class="s1">constraint</span><span class="s5">, </span><span class="s1">constraint.table</span>
            <span class="s1">)</span>

            <span class="s3">if </span><span class="s1">name </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s3">return None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">name = constraint.name</span>

        <span class="s3">if </span><span class="s1">constraint.__visit_name__ == </span><span class="s4">&quot;index&quot;</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.truncate_and_render_index_name(</span>
                <span class="s1">name</span><span class="s5">, </span><span class="s1">_alembic_quote=_alembic_quote</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.truncate_and_render_constraint_name(</span>
                <span class="s1">name</span><span class="s5">, </span><span class="s1">_alembic_quote=_alembic_quote</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">truncate_and_render_index_name(self</span><span class="s5">, </span><span class="s1">name</span><span class="s5">, </span><span class="s1">_alembic_quote=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s0"># calculate these at format time so that ad-hoc changes</span>
        <span class="s0"># to dialect.max_identifier_length etc. can be reflected</span>
        <span class="s0"># as IdentifierPreparer is long lived</span>
        <span class="s1">max_ = (</span>
            <span class="s1">self.dialect.max_index_name_length</span>
            <span class="s3">or </span><span class="s1">self.dialect.max_identifier_length</span>
        <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self._truncate_and_render_maxlen_name(</span>
            <span class="s1">name</span><span class="s5">, </span><span class="s1">max_</span><span class="s5">, </span><span class="s1">_alembic_quote</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">truncate_and_render_constraint_name(self</span><span class="s5">, </span><span class="s1">name</span><span class="s5">, </span><span class="s1">_alembic_quote=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s0"># calculate these at format time so that ad-hoc changes</span>
        <span class="s0"># to dialect.max_identifier_length etc. can be reflected</span>
        <span class="s0"># as IdentifierPreparer is long lived</span>
        <span class="s1">max_ = (</span>
            <span class="s1">self.dialect.max_constraint_name_length</span>
            <span class="s3">or </span><span class="s1">self.dialect.max_identifier_length</span>
        <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self._truncate_and_render_maxlen_name(</span>
            <span class="s1">name</span><span class="s5">, </span><span class="s1">max_</span><span class="s5">, </span><span class="s1">_alembic_quote</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_truncate_and_render_maxlen_name(self</span><span class="s5">, </span><span class="s1">name</span><span class="s5">, </span><span class="s1">max_</span><span class="s5">, </span><span class="s1">_alembic_quote):</span>
        <span class="s3">if </span><span class="s1">isinstance(name</span><span class="s5">, </span><span class="s1">elements._truncated_label):</span>
            <span class="s3">if </span><span class="s1">len(name) &gt; max_:</span>
                <span class="s1">name = name[</span><span class="s6">0 </span><span class="s1">: max_ - </span><span class="s6">8</span><span class="s1">] + </span><span class="s4">&quot;_&quot; </span><span class="s1">+ util.md5_hex(name)[-</span><span class="s6">4</span><span class="s1">:]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.dialect.validate_identifier(name)</span>

        <span class="s3">if not </span><span class="s1">_alembic_quote:</span>
            <span class="s3">return </span><span class="s1">name</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.quote(name)</span>

    <span class="s3">def </span><span class="s1">format_index(self</span><span class="s5">, </span><span class="s1">index):</span>
        <span class="s3">return </span><span class="s1">self.format_constraint(index)</span>

    <span class="s3">def </span><span class="s1">format_table(self</span><span class="s5">, </span><span class="s1">table</span><span class="s5">, </span><span class="s1">use_schema=</span><span class="s3">True</span><span class="s5">, </span><span class="s1">name=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Prepare a quoted table and schema name.&quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">name </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">name = table.name</span>

        <span class="s1">result = self.quote(name)</span>

        <span class="s1">effective_schema = self.schema_for_object(table)</span>

        <span class="s3">if not </span><span class="s1">self.omit_schema </span><span class="s3">and </span><span class="s1">use_schema </span><span class="s3">and </span><span class="s1">effective_schema:</span>
            <span class="s1">result = self.quote_schema(effective_schema) + </span><span class="s4">&quot;.&quot; </span><span class="s1">+ result</span>
        <span class="s3">return </span><span class="s1">result</span>

    <span class="s3">def </span><span class="s1">format_schema(self</span><span class="s5">, </span><span class="s1">name):</span>
        <span class="s2">&quot;&quot;&quot;Prepare a quoted schema name.&quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">self.quote(name)</span>

    <span class="s3">def </span><span class="s1">format_label_name(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">name</span><span class="s5">,</span>
        <span class="s1">anon_map=</span><span class="s3">None</span><span class="s5">,</span>
    <span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Prepare a quoted column name.&quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">anon_map </span><span class="s3">is not None and </span><span class="s1">isinstance(</span>
            <span class="s1">name</span><span class="s5">, </span><span class="s1">elements._truncated_label</span>
        <span class="s1">):</span>
            <span class="s1">name = name.apply_map(anon_map)</span>

        <span class="s3">return </span><span class="s1">self.quote(name)</span>

    <span class="s3">def </span><span class="s1">format_column(</span>
        <span class="s1">self</span><span class="s5">,</span>
        <span class="s1">column</span><span class="s5">,</span>
        <span class="s1">use_table=</span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">name=</span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">table_name=</span><span class="s3">None</span><span class="s5">,</span>
        <span class="s1">use_schema=</span><span class="s3">False</span><span class="s5">,</span>
        <span class="s1">anon_map=</span><span class="s3">None</span><span class="s5">,</span>
    <span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Prepare a quoted column name.&quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">name </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">name = column.name</span>

        <span class="s3">if </span><span class="s1">anon_map </span><span class="s3">is not None and </span><span class="s1">isinstance(</span>
            <span class="s1">name</span><span class="s5">, </span><span class="s1">elements._truncated_label</span>
        <span class="s1">):</span>
            <span class="s1">name = name.apply_map(anon_map)</span>

        <span class="s3">if not </span><span class="s1">getattr(column</span><span class="s5">, </span><span class="s4">&quot;is_literal&quot;</span><span class="s5">, </span><span class="s3">False</span><span class="s1">):</span>
            <span class="s3">if </span><span class="s1">use_table:</span>
                <span class="s3">return </span><span class="s1">(</span>
                    <span class="s1">self.format_table(</span>
                        <span class="s1">column.table</span><span class="s5">, </span><span class="s1">use_schema=use_schema</span><span class="s5">, </span><span class="s1">name=table_name</span>
                    <span class="s1">)</span>
                    <span class="s1">+ </span><span class="s4">&quot;.&quot;</span>
                    <span class="s1">+ self.quote(name)</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">self.quote(name)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># literal textual elements get stuck into ColumnClause a lot,</span>
            <span class="s0"># which shouldn't get quoted</span>

            <span class="s3">if </span><span class="s1">use_table:</span>
                <span class="s3">return </span><span class="s1">(</span>
                    <span class="s1">self.format_table(</span>
                        <span class="s1">column.table</span><span class="s5">, </span><span class="s1">use_schema=use_schema</span><span class="s5">, </span><span class="s1">name=table_name</span>
                    <span class="s1">)</span>
                    <span class="s1">+ </span><span class="s4">&quot;.&quot;</span>
                    <span class="s1">+ name</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">name</span>

    <span class="s3">def </span><span class="s1">format_table_seq(self</span><span class="s5">, </span><span class="s1">table</span><span class="s5">, </span><span class="s1">use_schema=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Format table name and schema as a tuple.&quot;&quot;&quot;</span>

        <span class="s0"># Dialects with more levels in their fully qualified references</span>
        <span class="s0"># ('database', 'owner', etc.) could override this and return</span>
        <span class="s0"># a longer sequence.</span>

        <span class="s1">effective_schema = self.schema_for_object(table)</span>

        <span class="s3">if not </span><span class="s1">self.omit_schema </span><span class="s3">and </span><span class="s1">use_schema </span><span class="s3">and </span><span class="s1">effective_schema:</span>
            <span class="s3">return </span><span class="s1">(</span>
                <span class="s1">self.quote_schema(effective_schema)</span><span class="s5">,</span>
                <span class="s1">self.format_table(table</span><span class="s5">, </span><span class="s1">use_schema=</span><span class="s3">False</span><span class="s1">)</span><span class="s5">,</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">(self.format_table(table</span><span class="s5">, </span><span class="s1">use_schema=</span><span class="s3">False</span><span class="s1">)</span><span class="s5">,</span><span class="s1">)</span>

    <span class="s1">@util.memoized_property</span>
    <span class="s3">def </span><span class="s1">_r_identifiers(self):</span>
        <span class="s1">initial</span><span class="s5">, </span><span class="s1">final</span><span class="s5">, </span><span class="s1">escaped_final = (</span>
            <span class="s1">re.escape(s)</span>
            <span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">(</span>
                <span class="s1">self.initial_quote</span><span class="s5">,</span>
                <span class="s1">self.final_quote</span><span class="s5">,</span>
                <span class="s1">self._escape_identifier(self.final_quote)</span><span class="s5">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">r = re.compile(</span>
            <span class="s4">r&quot;(?:&quot;</span>
            <span class="s4">r&quot;(?:%(initial)s((?:%(escaped)s|[^%(final)s])+)%(final)s&quot;</span>
            <span class="s4">r&quot;|([^\.]+))(?=\.|$))+&quot;</span>
            <span class="s1">% {</span><span class="s4">&quot;initial&quot;</span><span class="s1">: initial</span><span class="s5">, </span><span class="s4">&quot;final&quot;</span><span class="s1">: final</span><span class="s5">, </span><span class="s4">&quot;escaped&quot;</span><span class="s1">: escaped_final}</span>
        <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">r</span>

    <span class="s3">def </span><span class="s1">unformat_identifiers(self</span><span class="s5">, </span><span class="s1">identifiers):</span>
        <span class="s2">&quot;&quot;&quot;Unpack 'schema.table.column'-like strings into components.&quot;&quot;&quot;</span>

        <span class="s1">r = self._r_identifiers</span>
        <span class="s3">return </span><span class="s1">[</span>
            <span class="s1">self._unescape_identifier(i)</span>
            <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">[a </span><span class="s3">or </span><span class="s1">b </span><span class="s3">for </span><span class="s1">a</span><span class="s5">, </span><span class="s1">b </span><span class="s3">in </span><span class="s1">r.findall(identifiers)]</span>
        <span class="s1">]</span>
</pre>
</body>
</html>