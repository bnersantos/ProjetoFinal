<html>
<head>
<title>api.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5d69bb;}
.s1 { color: #d8d8d8;}
.s2 { color: #717ed3; font-style: italic;}
.s3 { color: #cc8b60;}
.s4 { color: #96bf7d;}
.s5 { color: #cc7832;}
</style>
</head>
<body bgcolor="#1a1a25">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
api.py</font>
</center></td></tr></table>
<pre><span class="s0"># event/api.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>

<span class="s2">&quot;&quot;&quot;Public API functions for the event system. 
 
&quot;&quot;&quot;</span>
<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">annotations</span>

<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Callable</span>

<span class="s3">from </span><span class="s1">.base </span><span class="s3">import </span><span class="s1">_registrars</span>
<span class="s3">from </span><span class="s1">.registry </span><span class="s3">import </span><span class="s1">_ET</span>
<span class="s3">from </span><span class="s1">.registry </span><span class="s3">import </span><span class="s1">_EventKey</span>
<span class="s3">from </span><span class="s1">.registry </span><span class="s3">import </span><span class="s1">_ListenerFnType</span>
<span class="s3">from </span><span class="s1">.. </span><span class="s3">import </span><span class="s1">exc</span>
<span class="s3">from </span><span class="s1">.. </span><span class="s3">import </span><span class="s1">util</span>


<span class="s1">CANCEL = util.symbol(</span><span class="s4">&quot;CANCEL&quot;</span><span class="s1">)</span>
<span class="s1">NO_RETVAL = util.symbol(</span><span class="s4">&quot;NO_RETVAL&quot;</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">_event_key(</span>
    <span class="s1">target: _ET</span><span class="s5">, </span><span class="s1">identifier: str</span><span class="s5">, </span><span class="s1">fn: _ListenerFnType</span>
<span class="s1">) -&gt; _EventKey[_ET]:</span>
    <span class="s3">for </span><span class="s1">evt_cls </span><span class="s3">in </span><span class="s1">_registrars[identifier]:</span>
        <span class="s1">tgt = evt_cls._accept_with(target</span><span class="s5">, </span><span class="s1">identifier)</span>
        <span class="s3">if </span><span class="s1">tgt </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">_EventKey(target</span><span class="s5">, </span><span class="s1">identifier</span><span class="s5">, </span><span class="s1">fn</span><span class="s5">, </span><span class="s1">tgt)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">exc.InvalidRequestError(</span>
            <span class="s4">&quot;No such event '%s' for target '%s'&quot; </span><span class="s1">% (identifier</span><span class="s5">, </span><span class="s1">target)</span>
        <span class="s1">)</span>


<span class="s3">def </span><span class="s1">listen(</span>
    <span class="s1">target: Any</span><span class="s5">, </span><span class="s1">identifier: str</span><span class="s5">, </span><span class="s1">fn: Callable[...</span><span class="s5">, </span><span class="s1">Any]</span><span class="s5">, </span><span class="s1">*args: Any</span><span class="s5">, </span><span class="s1">**kw: Any</span>
<span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Register a listener function for the given target. 
 
    The :func:`.listen` function is part of the primary interface for the 
    SQLAlchemy event system, documented at :ref:`event_toplevel`. 
 
    e.g.:: 
 
        from sqlalchemy import event 
        from sqlalchemy.schema import UniqueConstraint 
 
        def unique_constraint_name(const, table): 
            const.name = &quot;uq_%s_%s&quot; % ( 
                table.name, 
                list(const.columns)[0].name 
            ) 
        event.listen( 
                UniqueConstraint, 
                &quot;after_parent_attach&quot;, 
                unique_constraint_name) 
 
    :param bool insert: The default behavior for event handlers is to append 
      the decorated user defined function to an internal list of registered 
      event listeners upon discovery. If a user registers a function with 
      ``insert=True``, SQLAlchemy will insert (prepend) the function to the 
      internal list upon discovery. This feature is not typically used or 
      recommended by the SQLAlchemy maintainers, but is provided to ensure 
      certain user defined functions can run before others, such as when 
      :ref:`Changing the sql_mode in MySQL &lt;mysql_sql_mode&gt;`. 
 
    :param bool named: When using named argument passing, the names listed in 
      the function argument specification will be used as keys in the 
      dictionary. 
      See :ref:`event_named_argument_styles`. 
 
    :param bool once: Private/Internal API usage. Deprecated.  This parameter 
      would provide that an event function would run only once per given 
      target. It does not however imply automatic de-registration of the 
      listener function; associating an arbitrarily high number of listeners 
      without explicitly removing them will cause memory to grow unbounded even 
      if ``once=True`` is specified. 
 
    :param bool propagate: The ``propagate`` kwarg is available when working 
      with ORM instrumentation and mapping events. 
      See :class:`_ormevent.MapperEvents` and 
      :meth:`_ormevent.MapperEvents.before_mapper_configured` for examples. 
 
    :param bool retval: This flag applies only to specific event listeners, 
      each of which includes documentation explaining when it should be used. 
      By default, no listener ever requires a return value. 
      However, some listeners do support special behaviors for return values, 
      and include in their documentation that the ``retval=True`` flag is 
      necessary for a return value to be processed. 
 
      Event listener suites that make use of :paramref:`_event.listen.retval` 
      include :class:`_events.ConnectionEvents` and 
      :class:`_ormevent.AttributeEvents`. 
 
    .. note:: 
 
        The :func:`.listen` function cannot be called at the same time 
        that the target event is being run.   This has implications 
        for thread safety, and also means an event cannot be added 
        from inside the listener function for itself.  The list of 
        events to be run are present inside of a mutable collection 
        that can't be changed during iteration. 
 
        Event registration and removal is not intended to be a &quot;high 
        velocity&quot; operation; it is a configurational operation.  For 
        systems that need to quickly associate and deassociate with 
        events at high scale, use a mutable structure that is handled 
        from inside of a single listener. 
 
    .. seealso:: 
 
        :func:`.listens_for` 
 
        :func:`.remove` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_event_key(target</span><span class="s5">, </span><span class="s1">identifier</span><span class="s5">, </span><span class="s1">fn).listen(*args</span><span class="s5">, </span><span class="s1">**kw)</span>


<span class="s3">def </span><span class="s1">listens_for(</span>
    <span class="s1">target: Any</span><span class="s5">, </span><span class="s1">identifier: str</span><span class="s5">, </span><span class="s1">*args: Any</span><span class="s5">, </span><span class="s1">**kw: Any</span>
<span class="s1">) -&gt; Callable[[Callable[...</span><span class="s5">, </span><span class="s1">Any]]</span><span class="s5">, </span><span class="s1">Callable[...</span><span class="s5">, </span><span class="s1">Any]]:</span>
    <span class="s2">&quot;&quot;&quot;Decorate a function as a listener for the given target + identifier. 
 
    The :func:`.listens_for` decorator is part of the primary interface for the 
    SQLAlchemy event system, documented at :ref:`event_toplevel`. 
 
    This function generally shares the same kwargs as :func:`.listen`. 
 
    e.g.:: 
 
        from sqlalchemy import event 
        from sqlalchemy.schema import UniqueConstraint 
 
        @event.listens_for(UniqueConstraint, &quot;after_parent_attach&quot;) 
        def unique_constraint_name(const, table): 
            const.name = &quot;uq_%s_%s&quot; % ( 
                table.name, 
                list(const.columns)[0].name 
            ) 
 
    A given function can also be invoked for only the first invocation 
    of the event using the ``once`` argument:: 
 
        @event.listens_for(Mapper, &quot;before_configure&quot;, once=True) 
        def on_config(): 
            do_config() 
 
 
    .. warning:: The ``once`` argument does not imply automatic de-registration 
       of the listener function after it has been invoked a first time; a 
       listener entry will remain associated with the target object. 
       Associating an arbitrarily high number of listeners without explicitly 
       removing them will cause memory to grow unbounded even if ``once=True`` 
       is specified. 
 
    .. seealso:: 
 
        :func:`.listen` - general description of event listening 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">decorate(fn: Callable[...</span><span class="s5">, </span><span class="s1">Any]) -&gt; Callable[...</span><span class="s5">, </span><span class="s1">Any]:</span>
        <span class="s1">listen(target</span><span class="s5">, </span><span class="s1">identifier</span><span class="s5">, </span><span class="s1">fn</span><span class="s5">, </span><span class="s1">*args</span><span class="s5">, </span><span class="s1">**kw)</span>
        <span class="s3">return </span><span class="s1">fn</span>

    <span class="s3">return </span><span class="s1">decorate</span>


<span class="s3">def </span><span class="s1">remove(target: Any</span><span class="s5">, </span><span class="s1">identifier: str</span><span class="s5">, </span><span class="s1">fn: Callable[...</span><span class="s5">, </span><span class="s1">Any]) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Remove an event listener. 
 
    The arguments here should match exactly those which were sent to 
    :func:`.listen`; all the event registration which proceeded as a result 
    of this call will be reverted by calling :func:`.remove` with the same 
    arguments. 
 
    e.g.:: 
 
        # if a function was registered like this... 
        @event.listens_for(SomeMappedClass, &quot;before_insert&quot;, propagate=True) 
        def my_listener_function(*arg): 
            pass 
 
        # ... it's removed like this 
        event.remove(SomeMappedClass, &quot;before_insert&quot;, my_listener_function) 
 
    Above, the listener function associated with ``SomeMappedClass`` was also 
    propagated to subclasses of ``SomeMappedClass``; the :func:`.remove` 
    function will revert all of these operations. 
 
    .. note:: 
 
        The :func:`.remove` function cannot be called at the same time 
        that the target event is being run.   This has implications 
        for thread safety, and also means an event cannot be removed 
        from inside the listener function for itself.  The list of 
        events to be run are present inside of a mutable collection 
        that can't be changed during iteration. 
 
        Event registration and removal is not intended to be a &quot;high 
        velocity&quot; operation; it is a configurational operation.  For 
        systems that need to quickly associate and deassociate with 
        events at high scale, use a mutable structure that is handled 
        from inside of a single listener. 
 
    .. seealso:: 
 
        :func:`.listen` 
 
    &quot;&quot;&quot;</span>
    <span class="s1">_event_key(target</span><span class="s5">, </span><span class="s1">identifier</span><span class="s5">, </span><span class="s1">fn).remove()</span>


<span class="s3">def </span><span class="s1">contains(target: Any</span><span class="s5">, </span><span class="s1">identifier: str</span><span class="s5">, </span><span class="s1">fn: Callable[...</span><span class="s5">, </span><span class="s1">Any]) -&gt; bool:</span>
    <span class="s2">&quot;&quot;&quot;Return True if the given target/ident/fn is set up to listen.&quot;&quot;&quot;</span>

    <span class="s3">return </span><span class="s1">_event_key(target</span><span class="s5">, </span><span class="s1">identifier</span><span class="s5">, </span><span class="s1">fn).contains()</span>
</pre>
</body>
</html>