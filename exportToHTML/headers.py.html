<html>
<head>
<title>headers.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc8b60;}
.s1 { color: #d8d8d8;}
.s2 { color: #96bf7d;}
.s3 { color: #717ed3; font-style: italic;}
.s4 { color: #cc7832;}
.s5 { color: #bbb55b;}
.s6 { color: #5d69bb;}
.s7 { color: #d7539b; font-weight: bold;}
</style>
</head>
<body bgcolor="#1a1a25">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
headers.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">collections.abc </span><span class="s0">as </span><span class="s1">cabc</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">typing </span><span class="s0">as </span><span class="s1">t</span>

<span class="s0">from </span><span class="s1">.._internal </span><span class="s0">import </span><span class="s1">_missing</span>
<span class="s0">from </span><span class="s1">..exceptions </span><span class="s0">import </span><span class="s1">BadRequestKeyError</span>
<span class="s0">from </span><span class="s1">.mixins </span><span class="s0">import </span><span class="s1">ImmutableHeadersMixin</span>
<span class="s0">from </span><span class="s1">.structures </span><span class="s0">import </span><span class="s1">iter_multi_items</span>
<span class="s0">from </span><span class="s1">.structures </span><span class="s0">import </span><span class="s1">MultiDict</span>

<span class="s0">if </span><span class="s1">t.TYPE_CHECKING:</span>
    <span class="s0">import </span><span class="s1">typing_extensions </span><span class="s0">as </span><span class="s1">te</span>
    <span class="s0">from </span><span class="s1">_typeshed.wsgi </span><span class="s0">import </span><span class="s1">WSGIEnvironment</span>

<span class="s1">T = t.TypeVar(</span><span class="s2">&quot;T&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">Headers:</span>
    <span class="s3">&quot;&quot;&quot;An object that stores some headers. It has a dict-like interface, 
    but is ordered, can store the same key multiple times, and iterating 
    yields ``(key, value)`` pairs instead of only keys. 
 
    This data structure is useful if you want a nicer way to handle WSGI 
    headers which are stored as tuples in a list. 
 
    From Werkzeug 0.3 onwards, the :exc:`KeyError` raised by this class is 
    also a subclass of the :class:`~exceptions.BadRequest` HTTP exception 
    and will render a page for a ``400 BAD REQUEST`` if caught in a 
    catch-all for HTTP exceptions. 
 
    Headers is mostly compatible with the Python :class:`wsgiref.headers.Headers` 
    class, with the exception of `__getitem__`.  :mod:`wsgiref` will return 
    `None` for ``headers['missing']``, whereas :class:`Headers` will raise 
    a :class:`KeyError`. 
 
    To create a new ``Headers`` object, pass it a list, dict, or 
    other ``Headers`` object with default values. These values are 
    validated the same way values added later are. 
 
    :param defaults: The list of default values for the :class:`Headers`. 
 
    .. versionchanged:: 3.1 
        Implement ``|`` and ``|=`` operators. 
 
    .. versionchanged:: 2.1.0 
        Default values are validated the same as values added later. 
 
    .. versionchanged:: 0.9 
       This data structure now stores unicode values similar to how the 
       multi dicts do it.  The main difference is that bytes can be set as 
       well which will automatically be latin1 decoded. 
 
    .. versionchanged:: 0.9 
       The :meth:`linked` function was removed without replacement as it 
       was an API that does not support the changes to the encoding model. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">defaults: (</span>
            <span class="s1">Headers</span>
            <span class="s1">| MultiDict[str</span><span class="s4">, </span><span class="s1">t.Any]</span>
            <span class="s1">| cabc.Mapping[str</span><span class="s4">, </span><span class="s1">t.Any | list[t.Any] | tuple[t.Any</span><span class="s4">, </span><span class="s1">...] | set[t.Any]]</span>
            <span class="s1">| cabc.Iterable[tuple[str</span><span class="s4">, </span><span class="s1">t.Any]]</span>
            <span class="s1">| </span><span class="s0">None</span>
        <span class="s1">) = </span><span class="s0">None</span><span class="s4">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self._list: list[tuple[str</span><span class="s4">, </span><span class="s1">str]] = []</span>

        <span class="s0">if </span><span class="s1">defaults </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.extend(defaults)</span>

    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s4">, </span><span class="s1">key: str) -&gt; str: ...</span>
    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s4">, </span><span class="s1">key: int) -&gt; tuple[str</span><span class="s4">, </span><span class="s1">str]: ...</span>
    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s4">, </span><span class="s1">key: slice) -&gt; te.Self: ...</span>
    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s4">, </span><span class="s1">key: str | int | slice) -&gt; str | tuple[str</span><span class="s4">, </span><span class="s1">str] | te.Self:</span>
        <span class="s0">if </span><span class="s1">isinstance(key</span><span class="s4">, </span><span class="s1">str):</span>
            <span class="s0">return </span><span class="s1">self._get_key(key)</span>

        <span class="s0">if </span><span class="s1">isinstance(key</span><span class="s4">, </span><span class="s1">int):</span>
            <span class="s0">return </span><span class="s1">self._list[key]</span>

        <span class="s0">return </span><span class="s1">self.__class__(self._list[key])</span>

    <span class="s0">def </span><span class="s1">_get_key(self</span><span class="s4">, </span><span class="s1">key: str) -&gt; str:</span>
        <span class="s1">ikey = key.lower()</span>

        <span class="s0">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self._list:</span>
            <span class="s0">if </span><span class="s1">k.lower() == ikey:</span>
                <span class="s0">return </span><span class="s1">v</span>

        <span class="s0">raise </span><span class="s1">BadRequestKeyError(key)</span>

    <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s4">, </span><span class="s1">other: object) -&gt; bool:</span>
        <span class="s0">if </span><span class="s1">other.__class__ </span><span class="s0">is not </span><span class="s1">self.__class__:</span>
            <span class="s0">return </span><span class="s1">NotImplemented</span>

        <span class="s0">def </span><span class="s1">lowered(item: tuple[str</span><span class="s4">, </span><span class="s1">...]) -&gt; tuple[str</span><span class="s4">, </span><span class="s1">...]:</span>
            <span class="s0">return </span><span class="s1">item[</span><span class="s5">0</span><span class="s1">].lower()</span><span class="s4">, </span><span class="s1">*item[</span><span class="s5">1</span><span class="s1">:]</span>

        <span class="s0">return </span><span class="s1">set(map(lowered</span><span class="s4">, </span><span class="s1">other._list)) == set(map(lowered</span><span class="s4">, </span><span class="s1">self._list))  </span><span class="s6"># type: ignore[attr-defined]</span>

    <span class="s1">__hash__ = </span><span class="s0">None  </span><span class="s6"># type: ignore[assignment]</span>

    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">get(self</span><span class="s4">, </span><span class="s1">key: str) -&gt; str | </span><span class="s0">None</span><span class="s1">: ...</span>
    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">get(self</span><span class="s4">, </span><span class="s1">key: str</span><span class="s4">, </span><span class="s1">default: str) -&gt; str: ...</span>
    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">get(self</span><span class="s4">, </span><span class="s1">key: str</span><span class="s4">, </span><span class="s1">default: T) -&gt; str | T: ...</span>
    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">get(self</span><span class="s4">, </span><span class="s1">key: str</span><span class="s4">, </span><span class="s1">type: cabc.Callable[[str]</span><span class="s4">, </span><span class="s1">T]) -&gt; T | </span><span class="s0">None</span><span class="s1">: ...</span>
    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">get(self</span><span class="s4">, </span><span class="s1">key: str</span><span class="s4">, </span><span class="s1">default: T</span><span class="s4">, </span><span class="s1">type: cabc.Callable[[str]</span><span class="s4">, </span><span class="s1">T]) -&gt; T: ...</span>
    <span class="s0">def </span><span class="s1">get(  </span><span class="s6"># type: ignore[misc]</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">key: str</span><span class="s4">,</span>
        <span class="s1">default: str | T | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s4">,</span>
        <span class="s1">type: cabc.Callable[[str]</span><span class="s4">, </span><span class="s1">T] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s4">,</span>
    <span class="s1">) -&gt; str | T | </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Return the default value if the requested data doesn't exist. 
        If `type` is provided and is a callable it should convert the value, 
        return it or raise a :exc:`ValueError` if that is not possible.  In 
        this case the function will return the default as if the value was not 
        found: 
 
        &gt;&gt;&gt; d = Headers([('Content-Length', '42')]) 
        &gt;&gt;&gt; d.get('Content-Length', type=int) 
        42 
 
        :param key: The key to be looked up. 
        :param default: The default value to be returned if the key can't 
                        be looked up.  If not further specified `None` is 
                        returned. 
        :param type: A callable that is used to cast the value in the 
                     :class:`Headers`.  If a :exc:`ValueError` is raised 
                     by this callable the default value is returned. 
 
        .. versionchanged:: 3.0 
            The ``as_bytes`` parameter was removed. 
 
        .. versionchanged:: 0.9 
            The ``as_bytes`` parameter was added. 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">rv = self._get_key(key)</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s0">return </span><span class="s1">default</span>

        <span class="s0">if </span><span class="s1">type </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">rv</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">type(rv)</span>
        <span class="s0">except </span><span class="s1">ValueError:</span>
            <span class="s0">return </span><span class="s1">default</span>

    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">getlist(self</span><span class="s4">, </span><span class="s1">key: str) -&gt; list[str]: ...</span>
    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">getlist(self</span><span class="s4">, </span><span class="s1">key: str</span><span class="s4">, </span><span class="s1">type: cabc.Callable[[str]</span><span class="s4">, </span><span class="s1">T]) -&gt; list[T]: ...</span>
    <span class="s0">def </span><span class="s1">getlist(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">key: str</span><span class="s4">, </span><span class="s1">type: cabc.Callable[[str]</span><span class="s4">, </span><span class="s1">T] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>
    <span class="s1">) -&gt; list[str] | list[T]:</span>
        <span class="s3">&quot;&quot;&quot;Return the list of items for a given key. If that key is not in the 
        :class:`Headers`, the return value will be an empty list.  Just like 
        :meth:`get`, :meth:`getlist` accepts a `type` parameter.  All items will 
        be converted with the callable defined there. 
 
        :param key: The key to be looked up. 
        :param type: A callable that is used to cast the value in the 
                     :class:`Headers`.  If a :exc:`ValueError` is raised 
                     by this callable the value will be removed from the list. 
        :return: a :class:`list` of all the values for the key. 
 
        .. versionchanged:: 3.0 
            The ``as_bytes`` parameter was removed. 
 
        .. versionchanged:: 0.9 
            The ``as_bytes`` parameter was added. 
        &quot;&quot;&quot;</span>
        <span class="s1">ikey = key.lower()</span>

        <span class="s0">if </span><span class="s1">type </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">result = []</span>

            <span class="s0">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self:</span>
                <span class="s0">if </span><span class="s1">k.lower() == ikey:</span>
                    <span class="s0">try</span><span class="s1">:</span>
                        <span class="s1">result.append(type(v))</span>
                    <span class="s0">except </span><span class="s1">ValueError:</span>
                        <span class="s0">continue</span>

            <span class="s0">return </span><span class="s1">result</span>

        <span class="s0">return </span><span class="s1">[v </span><span class="s0">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self </span><span class="s0">if </span><span class="s1">k.lower() == ikey]</span>

    <span class="s0">def </span><span class="s1">get_all(self</span><span class="s4">, </span><span class="s1">name: str) -&gt; list[str]:</span>
        <span class="s3">&quot;&quot;&quot;Return a list of all the values for the named field. 
 
        This method is compatible with the :mod:`wsgiref` 
        :meth:`~wsgiref.headers.Headers.get_all` method. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.getlist(name)</span>

    <span class="s0">def </span><span class="s1">items(self</span><span class="s4">, </span><span class="s1">lower: bool = </span><span class="s0">False</span><span class="s1">) -&gt; t.Iterable[tuple[str</span><span class="s4">, </span><span class="s1">str]]:</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s4">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">self:</span>
            <span class="s0">if </span><span class="s1">lower:</span>
                <span class="s1">key = key.lower()</span>
            <span class="s0">yield </span><span class="s1">key</span><span class="s4">, </span><span class="s1">value</span>

    <span class="s0">def </span><span class="s1">keys(self</span><span class="s4">, </span><span class="s1">lower: bool = </span><span class="s0">False</span><span class="s1">) -&gt; t.Iterable[str]:</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s4">, </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">self.items(lower):</span>
            <span class="s0">yield </span><span class="s1">key</span>

    <span class="s0">def </span><span class="s1">values(self) -&gt; t.Iterable[str]:</span>
        <span class="s0">for </span><span class="s1">_</span><span class="s4">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">self.items():</span>
            <span class="s0">yield </span><span class="s1">value</span>

    <span class="s0">def </span><span class="s1">extend(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">arg: (</span>
            <span class="s1">Headers</span>
            <span class="s1">| MultiDict[str</span><span class="s4">, </span><span class="s1">t.Any]</span>
            <span class="s1">| cabc.Mapping[str</span><span class="s4">, </span><span class="s1">t.Any | list[t.Any] | tuple[t.Any</span><span class="s4">, </span><span class="s1">...] | set[t.Any]]</span>
            <span class="s1">| cabc.Iterable[tuple[str</span><span class="s4">, </span><span class="s1">t.Any]]</span>
            <span class="s1">| </span><span class="s0">None</span>
        <span class="s1">) = </span><span class="s0">None</span><span class="s4">,</span>
        <span class="s1">/</span><span class="s4">,</span>
        <span class="s1">**kwargs: str</span><span class="s4">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Extend headers in this object with items from another object 
        containing header items as well as keyword arguments. 
 
        To replace existing keys instead of extending, use 
        :meth:`update` instead. 
 
        If provided, the first argument can be another :class:`Headers` 
        object, a :class:`MultiDict`, :class:`dict`, or iterable of 
        pairs. 
 
        .. versionchanged:: 1.0 
            Support :class:`MultiDict`. Allow passing ``kwargs``. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">arg </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">key</span><span class="s4">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">iter_multi_items(arg):</span>
                <span class="s1">self.add(key</span><span class="s4">, </span><span class="s1">value)</span>

        <span class="s0">for </span><span class="s1">key</span><span class="s4">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">iter_multi_items(kwargs):</span>
            <span class="s1">self.add(key</span><span class="s4">, </span><span class="s1">value)</span>

    <span class="s0">def </span><span class="s1">__delitem__(self</span><span class="s4">, </span><span class="s1">key: str | int | slice) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">isinstance(key</span><span class="s4">, </span><span class="s1">str):</span>
            <span class="s1">self._del_key(key)</span>
            <span class="s0">return</span>

        <span class="s0">del </span><span class="s1">self._list[key]</span>

    <span class="s0">def </span><span class="s1">_del_key(self</span><span class="s4">, </span><span class="s1">key: str) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">key = key.lower()</span>
        <span class="s1">new = []</span>

        <span class="s0">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self._list:</span>
            <span class="s0">if </span><span class="s1">k.lower() != key:</span>
                <span class="s1">new.append((k</span><span class="s4">, </span><span class="s1">v))</span>

        <span class="s1">self._list[:] = new</span>

    <span class="s0">def </span><span class="s1">remove(self</span><span class="s4">, </span><span class="s1">key: str) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Remove a key. 
 
        :param key: The key to be removed. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._del_key(key)</span>

    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">pop(self) -&gt; tuple[str</span><span class="s4">, </span><span class="s1">str]: ...</span>
    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">pop(self</span><span class="s4">, </span><span class="s1">key: str) -&gt; str: ...</span>
    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">pop(self</span><span class="s4">, </span><span class="s1">key: int | </span><span class="s0">None </span><span class="s1">= ...) -&gt; tuple[str</span><span class="s4">, </span><span class="s1">str]: ...</span>
    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">pop(self</span><span class="s4">, </span><span class="s1">key: str</span><span class="s4">, </span><span class="s1">default: str) -&gt; str: ...</span>
    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">pop(self</span><span class="s4">, </span><span class="s1">key: str</span><span class="s4">, </span><span class="s1">default: T) -&gt; str | T: ...</span>
    <span class="s0">def </span><span class="s1">pop(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">key: str | int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s4">,</span>
        <span class="s1">default: str | T = _missing</span><span class="s4">,  </span><span class="s6"># type: ignore[assignment]</span>
    <span class="s1">) -&gt; str | tuple[str</span><span class="s4">, </span><span class="s1">str] | T:</span>
        <span class="s3">&quot;&quot;&quot;Removes and returns a key or index. 
 
        :param key: The key to be popped.  If this is an integer the item at 
                    that position is removed, if it's a string the value for 
                    that key is.  If the key is omitted or `None` the last 
                    item is removed. 
        :return: an item. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">key </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self._list.pop()</span>

        <span class="s0">if </span><span class="s1">isinstance(key</span><span class="s4">, </span><span class="s1">int):</span>
            <span class="s0">return </span><span class="s1">self._list.pop(key)</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">rv = self._get_key(key)</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s0">if </span><span class="s1">default </span><span class="s0">is not </span><span class="s1">_missing:</span>
                <span class="s0">return </span><span class="s1">default</span>

            <span class="s0">raise</span>

        <span class="s1">self.remove(key)</span>
        <span class="s0">return </span><span class="s1">rv</span>

    <span class="s0">def </span><span class="s1">popitem(self) -&gt; tuple[str</span><span class="s4">, </span><span class="s1">str]:</span>
        <span class="s3">&quot;&quot;&quot;Removes a key or index and returns a (key, value) item.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._list.pop()</span>

    <span class="s0">def </span><span class="s1">__contains__(self</span><span class="s4">, </span><span class="s1">key: str) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot;Check if a key is present.&quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self._get_key(key)</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s0">return False</span>

        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">__iter__(self) -&gt; t.Iterator[tuple[str</span><span class="s4">, </span><span class="s1">str]]:</span>
        <span class="s3">&quot;&quot;&quot;Yield ``(key, value)`` tuples.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">iter(self._list)</span>

    <span class="s0">def </span><span class="s1">__len__(self) -&gt; int:</span>
        <span class="s0">return </span><span class="s1">len(self._list)</span>

    <span class="s0">def </span><span class="s1">add(self</span><span class="s4">, </span><span class="s1">key: str</span><span class="s4">, </span><span class="s1">value: t.Any</span><span class="s4">, </span><span class="s1">/</span><span class="s4">, </span><span class="s1">**kwargs: t.Any) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Add a new header tuple to the list. 
 
        Keyword arguments can specify additional parameters for the header 
        value, with underscores converted to dashes:: 
 
        &gt;&gt;&gt; d = Headers() 
        &gt;&gt;&gt; d.add('Content-Type', 'text/plain') 
        &gt;&gt;&gt; d.add('Content-Disposition', 'attachment', filename='foo.png') 
 
        The keyword argument dumping uses :func:`dump_options_header` 
        behind the scenes. 
 
        .. versionchanged:: 0.4.1 
            keyword arguments were added for :mod:`wsgiref` compatibility. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">kwargs:</span>
            <span class="s1">value = _options_header_vkw(value</span><span class="s4">, </span><span class="s1">kwargs)</span>

        <span class="s1">value_str = _str_header_value(value)</span>
        <span class="s1">self._list.append((key</span><span class="s4">, </span><span class="s1">value_str))</span>

    <span class="s0">def </span><span class="s1">add_header(self</span><span class="s4">, </span><span class="s1">key: str</span><span class="s4">, </span><span class="s1">value: t.Any</span><span class="s4">, </span><span class="s1">/</span><span class="s4">, </span><span class="s1">**kwargs: t.Any) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Add a new header tuple to the list. 
 
        An alias for :meth:`add` for compatibility with the :mod:`wsgiref` 
        :meth:`~wsgiref.headers.Headers.add_header` method. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.add(key</span><span class="s4">, </span><span class="s1">value</span><span class="s4">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">clear(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Clears all headers.&quot;&quot;&quot;</span>
        <span class="s1">self._list.clear()</span>

    <span class="s0">def </span><span class="s1">set(self</span><span class="s4">, </span><span class="s1">key: str</span><span class="s4">, </span><span class="s1">value: t.Any</span><span class="s4">, </span><span class="s1">/</span><span class="s4">, </span><span class="s1">**kwargs: t.Any) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Remove all header tuples for `key` and add a new one.  The newly 
        added key either appears at the end of the list if there was no 
        entry or replaces the first one. 
 
        Keyword arguments can specify additional parameters for the header 
        value, with underscores converted to dashes.  See :meth:`add` for 
        more information. 
 
        .. versionchanged:: 0.6.1 
           :meth:`set` now accepts the same arguments as :meth:`add`. 
 
        :param key: The key to be inserted. 
        :param value: The value to be inserted. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">kwargs:</span>
            <span class="s1">value = _options_header_vkw(value</span><span class="s4">, </span><span class="s1">kwargs)</span>

        <span class="s1">value_str = _str_header_value(value)</span>

        <span class="s0">if not </span><span class="s1">self._list:</span>
            <span class="s1">self._list.append((key</span><span class="s4">, </span><span class="s1">value_str))</span>
            <span class="s0">return</span>

        <span class="s1">iter_list = iter(self._list)</span>
        <span class="s1">ikey = key.lower()</span>

        <span class="s0">for </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">(old_key</span><span class="s4">, </span><span class="s1">_) </span><span class="s0">in </span><span class="s1">enumerate(iter_list):</span>
            <span class="s0">if </span><span class="s1">old_key.lower() == ikey:</span>
                <span class="s6"># replace first occurrence</span>
                <span class="s1">self._list[idx] = (key</span><span class="s4">, </span><span class="s1">value_str)</span>
                <span class="s0">break</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s6"># no existing occurrences</span>
            <span class="s1">self._list.append((key</span><span class="s4">, </span><span class="s1">value_str))</span>
            <span class="s0">return</span>

        <span class="s6"># remove remaining occurrences</span>
        <span class="s1">self._list[idx + </span><span class="s5">1 </span><span class="s1">:] = [t </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">iter_list </span><span class="s0">if </span><span class="s1">t[</span><span class="s5">0</span><span class="s1">].lower() != ikey]</span>

    <span class="s0">def </span><span class="s1">setlist(self</span><span class="s4">, </span><span class="s1">key: str</span><span class="s4">, </span><span class="s1">values: cabc.Iterable[t.Any]) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Remove any existing values for a header and add new ones. 
 
        :param key: The header key to set. 
        :param values: An iterable of values to set for the key. 
 
        .. versionadded:: 1.0 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">values:</span>
            <span class="s1">values_iter = iter(values)</span>
            <span class="s1">self.set(key</span><span class="s4">, </span><span class="s1">next(values_iter))</span>

            <span class="s0">for </span><span class="s1">value </span><span class="s0">in </span><span class="s1">values_iter:</span>
                <span class="s1">self.add(key</span><span class="s4">, </span><span class="s1">value)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.remove(key)</span>

    <span class="s0">def </span><span class="s1">setdefault(self</span><span class="s4">, </span><span class="s1">key: str</span><span class="s4">, </span><span class="s1">default: t.Any) -&gt; str:</span>
        <span class="s3">&quot;&quot;&quot;Return the first value for the key if it is in the headers, 
        otherwise set the header to the value given by ``default`` and 
        return that. 
 
        :param key: The header key to get. 
        :param default: The value to set for the key if it is not in the 
            headers. 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self._get_key(key)</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s0">pass</span>

        <span class="s1">self.set(key</span><span class="s4">, </span><span class="s1">default)</span>
        <span class="s0">return </span><span class="s1">self._get_key(key)</span>

    <span class="s0">def </span><span class="s1">setlistdefault(self</span><span class="s4">, </span><span class="s1">key: str</span><span class="s4">, </span><span class="s1">default: cabc.Iterable[t.Any]) -&gt; list[str]:</span>
        <span class="s3">&quot;&quot;&quot;Return the list of values for the key if it is in the 
        headers, otherwise set the header to the list of values given 
        by ``default`` and return that. 
 
        Unlike :meth:`MultiDict.setlistdefault`, modifying the returned 
        list will not affect the headers. 
 
        :param key: The header key to get. 
        :param default: An iterable of values to set for the key if it 
            is not in the headers. 
 
        .. versionadded:: 1.0 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">self:</span>
            <span class="s1">self.setlist(key</span><span class="s4">, </span><span class="s1">default)</span>

        <span class="s0">return </span><span class="s1">self.getlist(key)</span>

    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">__setitem__(self</span><span class="s4">, </span><span class="s1">key: str</span><span class="s4">, </span><span class="s1">value: t.Any) -&gt; </span><span class="s0">None</span><span class="s1">: ...</span>
    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">__setitem__(self</span><span class="s4">, </span><span class="s1">key: int</span><span class="s4">, </span><span class="s1">value: tuple[str</span><span class="s4">, </span><span class="s1">t.Any]) -&gt; </span><span class="s0">None</span><span class="s1">: ...</span>
    <span class="s1">@t.overload</span>
    <span class="s0">def </span><span class="s1">__setitem__(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">key: slice</span><span class="s4">, </span><span class="s1">value: cabc.Iterable[tuple[str</span><span class="s4">, </span><span class="s1">t.Any]]</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">: ...</span>
    <span class="s0">def </span><span class="s1">__setitem__(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">key: str | int | slice</span><span class="s4">,</span>
        <span class="s1">value: t.Any | tuple[str</span><span class="s4">, </span><span class="s1">t.Any] | cabc.Iterable[tuple[str</span><span class="s4">, </span><span class="s1">t.Any]]</span><span class="s4">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Like :meth:`set` but also supports index/slice based setting.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(key</span><span class="s4">, </span><span class="s1">str):</span>
            <span class="s1">self.set(key</span><span class="s4">, </span><span class="s1">value)</span>
        <span class="s0">elif </span><span class="s1">isinstance(key</span><span class="s4">, </span><span class="s1">int):</span>
            <span class="s1">self._list[key] = value[</span><span class="s5">0</span><span class="s1">]</span><span class="s4">, </span><span class="s1">_str_header_value(value[</span><span class="s5">1</span><span class="s1">])  </span><span class="s6"># type: ignore[index]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self._list[key] = [(k</span><span class="s4">, </span><span class="s1">_str_header_value(v)) </span><span class="s0">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">value]  </span><span class="s6"># type: ignore[misc]</span>

    <span class="s0">def </span><span class="s1">update(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">arg: (</span>
            <span class="s1">Headers</span>
            <span class="s1">| MultiDict[str</span><span class="s4">, </span><span class="s1">t.Any]</span>
            <span class="s1">| cabc.Mapping[</span>
                <span class="s1">str</span><span class="s4">, </span><span class="s1">t.Any | list[t.Any] | tuple[t.Any</span><span class="s4">, </span><span class="s1">...] | cabc.Set[t.Any]</span>
            <span class="s1">]</span>
            <span class="s1">| cabc.Iterable[tuple[str</span><span class="s4">, </span><span class="s1">t.Any]]</span>
            <span class="s1">| </span><span class="s0">None</span>
        <span class="s1">) = </span><span class="s0">None</span><span class="s4">,</span>
        <span class="s1">/</span><span class="s4">,</span>
        <span class="s1">**kwargs: t.Any | list[t.Any] | tuple[t.Any</span><span class="s4">, </span><span class="s1">...] | cabc.Set[t.Any]</span><span class="s4">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Replace headers in this object with items from another 
        headers object and keyword arguments. 
 
        To extend existing keys instead of replacing, use :meth:`extend` 
        instead. 
 
        If provided, the first argument can be another :class:`Headers` 
        object, a :class:`MultiDict`, :class:`dict`, or iterable of 
        pairs. 
 
        .. versionadded:: 1.0 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">arg </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(arg</span><span class="s4">, </span><span class="s1">(Headers</span><span class="s4">, </span><span class="s1">MultiDict)):</span>
                <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">arg.keys():</span>
                    <span class="s1">self.setlist(key</span><span class="s4">, </span><span class="s1">arg.getlist(key))</span>
            <span class="s0">elif </span><span class="s1">isinstance(arg</span><span class="s4">, </span><span class="s1">cabc.Mapping):</span>
                <span class="s0">for </span><span class="s1">key</span><span class="s4">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">arg.items():</span>
                    <span class="s0">if </span><span class="s1">isinstance(value</span><span class="s4">, </span><span class="s1">(list</span><span class="s4">, </span><span class="s1">tuple</span><span class="s4">, </span><span class="s1">set)):</span>
                        <span class="s1">self.setlist(key</span><span class="s4">, </span><span class="s1">value)</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">self.set(key</span><span class="s4">, </span><span class="s1">value)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">for </span><span class="s1">key</span><span class="s4">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">arg:</span>
                    <span class="s1">self.set(key</span><span class="s4">, </span><span class="s1">value)</span>

        <span class="s0">for </span><span class="s1">key</span><span class="s4">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">kwargs.items():</span>
            <span class="s0">if </span><span class="s1">isinstance(value</span><span class="s4">, </span><span class="s1">(list</span><span class="s4">, </span><span class="s1">tuple</span><span class="s4">, </span><span class="s1">set)):</span>
                <span class="s1">self.setlist(key</span><span class="s4">, </span><span class="s1">value)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.set(key</span><span class="s4">, </span><span class="s1">value)</span>

    <span class="s0">def </span><span class="s1">__or__(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">other: cabc.Mapping[</span>
            <span class="s1">str</span><span class="s4">, </span><span class="s1">t.Any | list[t.Any] | tuple[t.Any</span><span class="s4">, </span><span class="s1">...] | cabc.Set[t.Any]</span>
        <span class="s1">]</span><span class="s4">,</span>
    <span class="s1">) -&gt; te.Self:</span>
        <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s4">, </span><span class="s1">cabc.Mapping):</span>
            <span class="s0">return </span><span class="s1">NotImplemented</span>

        <span class="s1">rv = self.copy()</span>
        <span class="s1">rv.update(other)</span>
        <span class="s0">return </span><span class="s1">rv</span>

    <span class="s0">def </span><span class="s1">__ior__(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">other: (</span>
            <span class="s1">cabc.Mapping[str</span><span class="s4">, </span><span class="s1">t.Any | list[t.Any] | tuple[t.Any</span><span class="s4">, </span><span class="s1">...] | cabc.Set[t.Any]]</span>
            <span class="s1">| cabc.Iterable[tuple[str</span><span class="s4">, </span><span class="s1">t.Any]]</span>
        <span class="s1">)</span><span class="s4">,</span>
    <span class="s1">) -&gt; te.Self:</span>
        <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s4">, </span><span class="s1">(cabc.Mapping</span><span class="s4">, </span><span class="s1">cabc.Iterable)):</span>
            <span class="s0">return </span><span class="s1">NotImplemented</span>

        <span class="s1">self.update(other)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">to_wsgi_list(self) -&gt; list[tuple[str</span><span class="s4">, </span><span class="s1">str]]:</span>
        <span class="s3">&quot;&quot;&quot;Convert the headers into a list suitable for WSGI. 
 
        :return: list 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">list(self)</span>

    <span class="s0">def </span><span class="s1">copy(self) -&gt; te.Self:</span>
        <span class="s0">return </span><span class="s1">self.__class__(self._list)</span>

    <span class="s0">def </span><span class="s1">__copy__(self) -&gt; te.Self:</span>
        <span class="s0">return </span><span class="s1">self.copy()</span>

    <span class="s0">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s3">&quot;&quot;&quot;Returns formatted headers suitable for HTTP transmission.&quot;&quot;&quot;</span>
        <span class="s1">strs = []</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s4">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">self.to_wsgi_list():</span>
            <span class="s1">strs.append(</span><span class="s2">f&quot;</span><span class="s7">{</span><span class="s1">key</span><span class="s7">}</span><span class="s2">: </span><span class="s7">{</span><span class="s1">value</span><span class="s7">}</span><span class="s2">&quot;</span><span class="s1">)</span>
        <span class="s1">strs.append(</span><span class="s2">&quot;</span><span class="s7">\r\n</span><span class="s2">&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s2">&quot;</span><span class="s7">\r\n</span><span class="s2">&quot;</span><span class="s1">.join(strs)</span>

    <span class="s0">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s2">f&quot;</span><span class="s7">{</span><span class="s1">type(self).__name__</span><span class="s7">}</span><span class="s2">(</span><span class="s7">{</span><span class="s1">list(self)</span><span class="s7">!r}</span><span class="s2">)&quot;</span>


<span class="s0">def </span><span class="s1">_options_header_vkw(value: str</span><span class="s4">, </span><span class="s1">kw: dict[str</span><span class="s4">, </span><span class="s1">t.Any]) -&gt; str:</span>
    <span class="s0">return </span><span class="s1">http.dump_options_header(</span>
        <span class="s1">value</span><span class="s4">, </span><span class="s1">{k.replace(</span><span class="s2">&quot;_&quot;</span><span class="s4">, </span><span class="s2">&quot;-&quot;</span><span class="s1">): v </span><span class="s0">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">kw.items()}</span>
    <span class="s1">)</span>


<span class="s1">_newline_re = re.compile(</span><span class="s2">r&quot;[\r\n]&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_str_header_value(value: t.Any) -&gt; str:</span>
    <span class="s0">if not </span><span class="s1">isinstance(value</span><span class="s4">, </span><span class="s1">str):</span>
        <span class="s1">value = str(value)</span>

    <span class="s0">if </span><span class="s1">_newline_re.search(value) </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Header values must not contain newline characters.&quot;</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">value  </span><span class="s6"># type: ignore[no-any-return]</span>


<span class="s0">class </span><span class="s1">EnvironHeaders(ImmutableHeadersMixin</span><span class="s4">, </span><span class="s1">Headers):  </span><span class="s6"># type: ignore[misc]</span>
    <span class="s3">&quot;&quot;&quot;Read only version of the headers from a WSGI environment.  This 
    provides the same interface as `Headers` and is constructed from 
    a WSGI environment. 
    From Werkzeug 0.3 onwards, the `KeyError` raised by this class is also a 
    subclass of the :exc:`~exceptions.BadRequest` HTTP exception and will 
    render a page for a ``400 BAD REQUEST`` if caught in a catch-all for 
    HTTP exceptions. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">environ: WSGIEnvironment) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.environ = environ</span>

    <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s4">, </span><span class="s1">other: object) -&gt; bool:</span>
        <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s4">, </span><span class="s1">EnvironHeaders):</span>
            <span class="s0">return </span><span class="s1">NotImplemented</span>

        <span class="s0">return </span><span class="s1">self.environ </span><span class="s0">is </span><span class="s1">other.environ</span>

    <span class="s1">__hash__ = </span><span class="s0">None  </span><span class="s6"># type: ignore[assignment]</span>

    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s4">, </span><span class="s1">key: str) -&gt; str:  </span><span class="s6"># type: ignore[override]</span>
        <span class="s0">return </span><span class="s1">self._get_key(key)</span>

    <span class="s0">def </span><span class="s1">_get_key(self</span><span class="s4">, </span><span class="s1">key: str) -&gt; str:</span>
        <span class="s0">if not </span><span class="s1">isinstance(key</span><span class="s4">, </span><span class="s1">str):</span>
            <span class="s0">raise </span><span class="s1">BadRequestKeyError(key)</span>

        <span class="s1">key = key.upper().replace(</span><span class="s2">&quot;-&quot;</span><span class="s4">, </span><span class="s2">&quot;_&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">{</span><span class="s2">&quot;CONTENT_TYPE&quot;</span><span class="s4">, </span><span class="s2">&quot;CONTENT_LENGTH&quot;</span><span class="s1">}:</span>
            <span class="s0">return </span><span class="s1">self.environ[key]  </span><span class="s6"># type: ignore[no-any-return]</span>

        <span class="s0">return </span><span class="s1">self.environ[</span><span class="s2">f&quot;HTTP_</span><span class="s7">{</span><span class="s1">key</span><span class="s7">}</span><span class="s2">&quot;</span><span class="s1">]  </span><span class="s6"># type: ignore[no-any-return]</span>

    <span class="s0">def </span><span class="s1">__len__(self) -&gt; int:</span>
        <span class="s0">return </span><span class="s1">sum(</span><span class="s5">1 </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">self)</span>

    <span class="s0">def </span><span class="s1">__iter__(self) -&gt; cabc.Iterator[tuple[str</span><span class="s4">, </span><span class="s1">str]]:</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s4">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">self.environ.items():</span>
            <span class="s0">if </span><span class="s1">key.startswith(</span><span class="s2">&quot;HTTP_&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">{</span>
                <span class="s2">&quot;HTTP_CONTENT_TYPE&quot;</span><span class="s4">,</span>
                <span class="s2">&quot;HTTP_CONTENT_LENGTH&quot;</span><span class="s4">,</span>
            <span class="s1">}:</span>
                <span class="s0">yield </span><span class="s1">key[</span><span class="s5">5</span><span class="s1">:].replace(</span><span class="s2">&quot;_&quot;</span><span class="s4">, </span><span class="s2">&quot;-&quot;</span><span class="s1">).title()</span><span class="s4">, </span><span class="s1">value</span>
            <span class="s0">elif </span><span class="s1">key </span><span class="s0">in </span><span class="s1">{</span><span class="s2">&quot;CONTENT_TYPE&quot;</span><span class="s4">, </span><span class="s2">&quot;CONTENT_LENGTH&quot;</span><span class="s1">} </span><span class="s0">and </span><span class="s1">value:</span>
                <span class="s0">yield </span><span class="s1">key.replace(</span><span class="s2">&quot;_&quot;</span><span class="s4">, </span><span class="s2">&quot;-&quot;</span><span class="s1">).title()</span><span class="s4">, </span><span class="s1">value</span>

    <span class="s0">def </span><span class="s1">copy(self) -&gt; t.NoReturn:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">f&quot;cannot create </span><span class="s7">{</span><span class="s1">type(self).__name__</span><span class="s7">!r} </span><span class="s2">copies&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__or__(self</span><span class="s4">, </span><span class="s1">other: t.Any) -&gt; t.NoReturn:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">f&quot;cannot create </span><span class="s7">{</span><span class="s1">type(self).__name__</span><span class="s7">!r} </span><span class="s2">copies&quot;</span><span class="s1">)</span>


<span class="s6"># circular dependencies</span>
<span class="s0">from </span><span class="s1">.. </span><span class="s0">import </span><span class="s1">http</span>
</pre>
</body>
</html>