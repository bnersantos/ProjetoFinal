<html>
<head>
<title>lambdas.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5d69bb;}
.s1 { color: #d8d8d8;}
.s2 { color: #cc8b60;}
.s3 { color: #cc7832;}
.s4 { color: #96bf7d;}
.s5 { color: #bbb55b;}
.s6 { color: #717ed3; font-style: italic;}
.s7 { color: #d7539b; font-weight: bold;}
</style>
</head>
<body bgcolor="#1a1a25">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
lambdas.py</font>
</center></td></tr></table>
<pre><span class="s0"># sql/lambdas.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>
<span class="s0"># mypy: allow-untyped-defs, allow-untyped-calls</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">import </span><span class="s1">collections.abc </span><span class="s2">as </span><span class="s1">collections_abc</span>
<span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">operator</span>
<span class="s2">import </span><span class="s1">threading</span>
<span class="s2">import </span><span class="s1">types</span>
<span class="s2">from </span><span class="s1">types </span><span class="s2">import </span><span class="s1">CodeType</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Any</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Callable</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">cast</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">List</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">MutableMapping</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Optional</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Tuple</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Type</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TypeVar</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Union</span>
<span class="s2">import </span><span class="s1">weakref</span>

<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">cache_key </span><span class="s2">as </span><span class="s1">_cache_key</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">coercions</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">elements</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">roles</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">schema</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">visitors</span>
<span class="s2">from </span><span class="s1">.base </span><span class="s2">import </span><span class="s1">_clone</span>
<span class="s2">from </span><span class="s1">.base </span><span class="s2">import </span><span class="s1">Executable</span>
<span class="s2">from </span><span class="s1">.base </span><span class="s2">import </span><span class="s1">Options</span>
<span class="s2">from </span><span class="s1">.cache_key </span><span class="s2">import </span><span class="s1">CacheConst</span>
<span class="s2">from </span><span class="s1">.operators </span><span class="s2">import </span><span class="s1">ColumnOperators</span>
<span class="s2">from </span><span class="s1">.. </span><span class="s2">import </span><span class="s1">exc</span>
<span class="s2">from </span><span class="s1">.. </span><span class="s2">import </span><span class="s1">inspection</span>
<span class="s2">from </span><span class="s1">.. </span><span class="s2">import </span><span class="s1">util</span>
<span class="s2">from </span><span class="s1">..util.typing </span><span class="s2">import </span><span class="s1">Literal</span>


<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s2">from </span><span class="s1">.elements </span><span class="s2">import </span><span class="s1">BindParameter</span>
    <span class="s2">from </span><span class="s1">.elements </span><span class="s2">import </span><span class="s1">ClauseElement</span>
    <span class="s2">from </span><span class="s1">.roles </span><span class="s2">import </span><span class="s1">SQLRole</span>
    <span class="s2">from </span><span class="s1">.visitors </span><span class="s2">import </span><span class="s1">_CloneCallableType</span>

<span class="s1">_LambdaCacheType = MutableMapping[</span>
    <span class="s1">Tuple[Any</span><span class="s3">, </span><span class="s1">...]</span><span class="s3">, </span><span class="s1">Union[</span><span class="s4">&quot;NonAnalyzedFunction&quot;</span><span class="s3">, </span><span class="s4">&quot;AnalyzedFunction&quot;</span><span class="s1">]</span>
<span class="s1">]</span>
<span class="s1">_BoundParameterGetter = Callable[...</span><span class="s3">, </span><span class="s1">Any]</span>

<span class="s1">_closure_per_cache_key: _LambdaCacheType = util.LRUCache(</span><span class="s5">1000</span><span class="s1">)</span>


<span class="s1">_LambdaType = Callable[[]</span><span class="s3">, </span><span class="s1">Any]</span>

<span class="s1">_AnyLambdaType = Callable[...</span><span class="s3">, </span><span class="s1">Any]</span>

<span class="s1">_StmtLambdaType = Callable[[]</span><span class="s3">, </span><span class="s1">Any]</span>

<span class="s1">_E = TypeVar(</span><span class="s4">&quot;_E&quot;</span><span class="s3">, </span><span class="s1">bound=Executable)</span>
<span class="s1">_StmtLambdaElementType = Callable[[_E]</span><span class="s3">, </span><span class="s1">Any]</span>


<span class="s2">class </span><span class="s1">LambdaOptions(Options):</span>
    <span class="s1">enable_tracking = </span><span class="s2">True</span>
    <span class="s1">track_closure_variables = </span><span class="s2">True</span>
    <span class="s1">track_on: Optional[object] = </span><span class="s2">None</span>
    <span class="s1">global_track_bound_values = </span><span class="s2">True</span>
    <span class="s1">track_bound_values = </span><span class="s2">True</span>
    <span class="s1">lambda_cache: Optional[_LambdaCacheType] = </span><span class="s2">None</span>


<span class="s2">def </span><span class="s1">lambda_stmt(</span>
    <span class="s1">lmb: _StmtLambdaType</span><span class="s3">,</span>
    <span class="s1">enable_tracking: bool = </span><span class="s2">True</span><span class="s3">,</span>
    <span class="s1">track_closure_variables: bool = </span><span class="s2">True</span><span class="s3">,</span>
    <span class="s1">track_on: Optional[object] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">global_track_bound_values: bool = </span><span class="s2">True</span><span class="s3">,</span>
    <span class="s1">track_bound_values: bool = </span><span class="s2">True</span><span class="s3">,</span>
    <span class="s1">lambda_cache: Optional[_LambdaCacheType] = </span><span class="s2">None</span><span class="s3">,</span>
<span class="s1">) -&gt; StatementLambdaElement:</span>
    <span class="s6">&quot;&quot;&quot;Produce a SQL statement that is cached as a lambda. 
 
    The Python code object within the lambda is scanned for both Python 
    literals that will become bound parameters as well as closure variables 
    that refer to Core or ORM constructs that may vary.   The lambda itself 
    will be invoked only once per particular set of constructs detected. 
 
    E.g.:: 
 
        from sqlalchemy import lambda_stmt 
 
        stmt = lambda_stmt(lambda: table.select()) 
        stmt += lambda s: s.where(table.c.id == 5) 
 
        result = connection.execute(stmt) 
 
    The object returned is an instance of :class:`_sql.StatementLambdaElement`. 
 
    .. versionadded:: 1.4 
 
    :param lmb: a Python function, typically a lambda, which takes no arguments 
     and returns a SQL expression construct 
    :param enable_tracking: when False, all scanning of the given lambda for 
     changes in closure variables or bound parameters is disabled.  Use for 
     a lambda that produces the identical results in all cases with no 
     parameterization. 
    :param track_closure_variables: when False, changes in closure variables 
     within the lambda will not be scanned.   Use for a lambda where the 
     state of its closure variables will never change the SQL structure 
     returned by the lambda. 
    :param track_bound_values: when False, bound parameter tracking will 
     be disabled for the given lambda.  Use for a lambda that either does 
     not produce any bound values, or where the initial bound values never 
     change. 
    :param global_track_bound_values: when False, bound parameter tracking 
     will be disabled for the entire statement including additional links 
     added via the :meth:`_sql.StatementLambdaElement.add_criteria` method. 
    :param lambda_cache: a dictionary or other mapping-like object where 
     information about the lambda's Python code as well as the tracked closure 
     variables in the lambda itself will be stored.   Defaults 
     to a global LRU cache.  This cache is independent of the &quot;compiled_cache&quot; 
     used by the :class:`_engine.Connection` object. 
 
    .. seealso:: 
 
        :ref:`engine_lambda_caching` 
 
 
    &quot;&quot;&quot;</span>

    <span class="s2">return </span><span class="s1">StatementLambdaElement(</span>
        <span class="s1">lmb</span><span class="s3">,</span>
        <span class="s1">roles.StatementRole</span><span class="s3">,</span>
        <span class="s1">LambdaOptions(</span>
            <span class="s1">enable_tracking=enable_tracking</span><span class="s3">,</span>
            <span class="s1">track_on=track_on</span><span class="s3">,</span>
            <span class="s1">track_closure_variables=track_closure_variables</span><span class="s3">,</span>
            <span class="s1">global_track_bound_values=global_track_bound_values</span><span class="s3">,</span>
            <span class="s1">track_bound_values=track_bound_values</span><span class="s3">,</span>
            <span class="s1">lambda_cache=lambda_cache</span><span class="s3">,</span>
        <span class="s1">)</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s2">class </span><span class="s1">LambdaElement(elements.ClauseElement):</span>
    <span class="s6">&quot;&quot;&quot;A SQL construct where the state is stored as an un-invoked lambda. 
 
    The :class:`_sql.LambdaElement` is produced transparently whenever 
    passing lambda expressions into SQL constructs, such as:: 
 
        stmt = select(table).where(lambda: table.c.col == parameter) 
 
    The :class:`_sql.LambdaElement` is the base of the 
    :class:`_sql.StatementLambdaElement` which represents a full statement 
    within a lambda. 
 
    .. versionadded:: 1.4 
 
    .. seealso:: 
 
        :ref:`engine_lambda_caching` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ = </span><span class="s4">&quot;lambda_element&quot;</span>

    <span class="s1">_is_lambda_element = </span><span class="s2">True</span>

    <span class="s1">_traverse_internals = [</span>
        <span class="s1">(</span><span class="s4">&quot;_resolved&quot;</span><span class="s3">, </span><span class="s1">visitors.InternalTraversal.dp_clauseelement)</span>
    <span class="s1">]</span>

    <span class="s1">_transforms: Tuple[_CloneCallableType</span><span class="s3">, </span><span class="s1">...] = ()</span>

    <span class="s1">_resolved_bindparams: List[BindParameter[Any]]</span>
    <span class="s1">parent_lambda: Optional[StatementLambdaElement] = </span><span class="s2">None</span>
    <span class="s1">closure_cache_key: Union[Tuple[Any</span><span class="s3">, </span><span class="s1">...]</span><span class="s3">, </span><span class="s1">Literal[CacheConst.NO_CACHE]]</span>
    <span class="s1">role: Type[SQLRole]</span>
    <span class="s1">_rec: Union[AnalyzedFunction</span><span class="s3">, </span><span class="s1">NonAnalyzedFunction]</span>
    <span class="s1">fn: _AnyLambdaType</span>
    <span class="s1">tracker_key: Tuple[CodeType</span><span class="s3">, </span><span class="s1">...]</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;%s(%r)&quot; </span><span class="s1">% (</span>
            <span class="s1">self.__class__.__name__</span><span class="s3">,</span>
            <span class="s1">self.fn.__code__</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">fn: _LambdaType</span><span class="s3">,</span>
        <span class="s1">role: Type[SQLRole]</span><span class="s3">,</span>
        <span class="s1">opts: Union[Type[LambdaOptions]</span><span class="s3">, </span><span class="s1">LambdaOptions] = LambdaOptions</span><span class="s3">,</span>
        <span class="s1">apply_propagate_attrs: Optional[ClauseElement] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">):</span>
        <span class="s1">self.fn = fn</span>
        <span class="s1">self.role = role</span>
        <span class="s1">self.tracker_key = (fn.__code__</span><span class="s3">,</span><span class="s1">)</span>
        <span class="s1">self.opts = opts</span>

        <span class="s2">if </span><span class="s1">apply_propagate_attrs </span><span class="s2">is None and </span><span class="s1">(role </span><span class="s2">is </span><span class="s1">roles.StatementRole):</span>
            <span class="s1">apply_propagate_attrs = self</span>

        <span class="s1">rec = self._retrieve_tracker_rec(fn</span><span class="s3">, </span><span class="s1">apply_propagate_attrs</span><span class="s3">, </span><span class="s1">opts)</span>

        <span class="s2">if </span><span class="s1">apply_propagate_attrs </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">propagate_attrs = rec.propagate_attrs</span>
            <span class="s2">if </span><span class="s1">propagate_attrs:</span>
                <span class="s1">apply_propagate_attrs._propagate_attrs = propagate_attrs</span>

    <span class="s2">def </span><span class="s1">_retrieve_tracker_rec(self</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">, </span><span class="s1">apply_propagate_attrs</span><span class="s3">, </span><span class="s1">opts):</span>
        <span class="s1">lambda_cache = opts.lambda_cache</span>
        <span class="s2">if </span><span class="s1">lambda_cache </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">lambda_cache = _closure_per_cache_key</span>

        <span class="s1">tracker_key = self.tracker_key</span>

        <span class="s1">fn = self.fn</span>
        <span class="s1">closure = fn.__closure__</span>
        <span class="s1">tracker = AnalyzedCode.get(</span>
            <span class="s1">fn</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">,</span>
            <span class="s1">opts</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s1">bindparams: List[BindParameter[Any]]</span>
        <span class="s1">self._resolved_bindparams = bindparams = []</span>

        <span class="s2">if </span><span class="s1">self.parent_lambda </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">parent_closure_cache_key = self.parent_lambda.closure_cache_key</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">parent_closure_cache_key = ()</span>

        <span class="s1">cache_key: Union[Tuple[Any</span><span class="s3">, </span><span class="s1">...]</span><span class="s3">, </span><span class="s1">Literal[CacheConst.NO_CACHE]]</span>

        <span class="s2">if </span><span class="s1">parent_closure_cache_key </span><span class="s2">is not </span><span class="s1">_cache_key.NO_CACHE:</span>
            <span class="s1">anon_map = visitors.anon_map()</span>
            <span class="s1">cache_key = tuple(</span>
                <span class="s1">[</span>
                    <span class="s1">getter(closure</span><span class="s3">, </span><span class="s1">opts</span><span class="s3">, </span><span class="s1">anon_map</span><span class="s3">, </span><span class="s1">bindparams)</span>
                    <span class="s2">for </span><span class="s1">getter </span><span class="s2">in </span><span class="s1">tracker.closure_trackers</span>
                <span class="s1">]</span>
            <span class="s1">)</span>

            <span class="s2">if </span><span class="s1">_cache_key.NO_CACHE </span><span class="s2">not in </span><span class="s1">anon_map:</span>
                <span class="s1">cache_key = parent_closure_cache_key + cache_key</span>

                <span class="s1">self.closure_cache_key = cache_key</span>

                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">rec = lambda_cache[tracker_key + cache_key]</span>
                <span class="s2">except </span><span class="s1">KeyError:</span>
                    <span class="s1">rec = </span><span class="s2">None</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">cache_key = _cache_key.NO_CACHE</span>
                <span class="s1">rec = </span><span class="s2">None</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">cache_key = _cache_key.NO_CACHE</span>
            <span class="s1">rec = </span><span class="s2">None</span>

        <span class="s1">self.closure_cache_key = cache_key</span>

        <span class="s2">if </span><span class="s1">rec </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">cache_key </span><span class="s2">is not </span><span class="s1">_cache_key.NO_CACHE:</span>
                <span class="s2">with </span><span class="s1">AnalyzedCode._generation_mutex:</span>
                    <span class="s1">key = tracker_key + cache_key</span>
                    <span class="s2">if </span><span class="s1">key </span><span class="s2">not in </span><span class="s1">lambda_cache:</span>
                        <span class="s1">rec = AnalyzedFunction(</span>
                            <span class="s1">tracker</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">apply_propagate_attrs</span><span class="s3">, </span><span class="s1">fn</span>
                        <span class="s1">)</span>
                        <span class="s1">rec.closure_bindparams = bindparams</span>
                        <span class="s1">lambda_cache[key] = rec</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">rec = lambda_cache[key]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">rec = NonAnalyzedFunction(self._invoke_user_fn(fn))</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">bindparams[:] = [</span>
                <span class="s1">orig_bind._with_value(new_bind.value</span><span class="s3">, </span><span class="s1">maintain_key=</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s2">for </span><span class="s1">orig_bind</span><span class="s3">, </span><span class="s1">new_bind </span><span class="s2">in </span><span class="s1">zip(</span>
                    <span class="s1">rec.closure_bindparams</span><span class="s3">, </span><span class="s1">bindparams</span>
                <span class="s1">)</span>
            <span class="s1">]</span>

        <span class="s1">self._rec = rec</span>

        <span class="s2">if </span><span class="s1">cache_key </span><span class="s2">is not </span><span class="s1">_cache_key.NO_CACHE:</span>
            <span class="s2">if </span><span class="s1">self.parent_lambda </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">bindparams[:</span><span class="s5">0</span><span class="s1">] = self.parent_lambda._resolved_bindparams</span>

            <span class="s1">lambda_element: Optional[LambdaElement] = self</span>
            <span class="s2">while </span><span class="s1">lambda_element </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">rec = lambda_element._rec</span>
                <span class="s2">if </span><span class="s1">rec.bindparam_trackers:</span>
                    <span class="s1">tracker_instrumented_fn = rec.tracker_instrumented_fn</span>
                    <span class="s2">for </span><span class="s1">tracker </span><span class="s2">in </span><span class="s1">rec.bindparam_trackers:</span>
                        <span class="s1">tracker(</span>
                            <span class="s1">lambda_element.fn</span><span class="s3">,</span>
                            <span class="s1">tracker_instrumented_fn</span><span class="s3">,</span>
                            <span class="s1">bindparams</span><span class="s3">,</span>
                        <span class="s1">)</span>
                <span class="s1">lambda_element = lambda_element.parent_lambda</span>

        <span class="s2">return </span><span class="s1">rec</span>

    <span class="s2">def </span><span class="s1">__getattr__(self</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s2">return </span><span class="s1">getattr(self._rec.expected_expr</span><span class="s3">, </span><span class="s1">key)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_is_sequence(self):</span>
        <span class="s2">return </span><span class="s1">self._rec.is_sequence</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_select_iterable(self):</span>
        <span class="s2">if </span><span class="s1">self._is_sequence:</span>
            <span class="s2">return </span><span class="s1">itertools.chain.from_iterable(</span>
                <span class="s1">[element._select_iterable </span><span class="s2">for </span><span class="s1">element </span><span class="s2">in </span><span class="s1">self._resolved]</span>
            <span class="s1">)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._resolved._select_iterable</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_from_objects(self):</span>
        <span class="s2">if </span><span class="s1">self._is_sequence:</span>
            <span class="s2">return </span><span class="s1">itertools.chain.from_iterable(</span>
                <span class="s1">[element._from_objects </span><span class="s2">for </span><span class="s1">element </span><span class="s2">in </span><span class="s1">self._resolved]</span>
            <span class="s1">)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._resolved._from_objects</span>

    <span class="s2">def </span><span class="s1">_param_dict(self):</span>
        <span class="s2">return </span><span class="s1">{b.key: b.value </span><span class="s2">for </span><span class="s1">b </span><span class="s2">in </span><span class="s1">self._resolved_bindparams}</span>

    <span class="s2">def </span><span class="s1">_setup_binds_for_tracked_expr(self</span><span class="s3">, </span><span class="s1">expr):</span>
        <span class="s1">bindparam_lookup = {b.key: b </span><span class="s2">for </span><span class="s1">b </span><span class="s2">in </span><span class="s1">self._resolved_bindparams}</span>

        <span class="s2">def </span><span class="s1">replace(</span>
            <span class="s1">element: Optional[visitors.ExternallyTraversible]</span><span class="s3">, </span><span class="s1">**kw: Any</span>
        <span class="s1">) -&gt; Optional[visitors.ExternallyTraversible]:</span>
            <span class="s2">if </span><span class="s1">isinstance(element</span><span class="s3">, </span><span class="s1">elements.BindParameter):</span>
                <span class="s2">if </span><span class="s1">element.key </span><span class="s2">in </span><span class="s1">bindparam_lookup:</span>
                    <span class="s1">bind = bindparam_lookup[element.key]</span>
                    <span class="s2">if </span><span class="s1">element.expanding:</span>
                        <span class="s1">bind.expanding = </span><span class="s2">True</span>
                        <span class="s1">bind.expand_op = element.expand_op</span>
                        <span class="s1">bind.type = element.type</span>
                    <span class="s2">return </span><span class="s1">bind</span>

            <span class="s2">return None</span>

        <span class="s2">if </span><span class="s1">self._rec.is_sequence:</span>
            <span class="s1">expr = [</span>
                <span class="s1">visitors.replacement_traverse(sub_expr</span><span class="s3">, </span><span class="s1">{}</span><span class="s3">, </span><span class="s1">replace)</span>
                <span class="s2">for </span><span class="s1">sub_expr </span><span class="s2">in </span><span class="s1">expr</span>
            <span class="s1">]</span>
        <span class="s2">elif </span><span class="s1">getattr(expr</span><span class="s3">, </span><span class="s4">&quot;is_clause_element&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s1">):</span>
            <span class="s1">expr = visitors.replacement_traverse(expr</span><span class="s3">, </span><span class="s1">{}</span><span class="s3">, </span><span class="s1">replace)</span>

        <span class="s2">return </span><span class="s1">expr</span>

    <span class="s2">def </span><span class="s1">_copy_internals(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">clone: _CloneCallableType = _clone</span><span class="s3">,</span>
        <span class="s1">deferred_copy_internals: Optional[_CloneCallableType] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">**kw: Any</span><span class="s3">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0"># TODO: this needs A LOT of tests</span>
        <span class="s1">self._resolved = clone(</span>
            <span class="s1">self._resolved</span><span class="s3">,</span>
            <span class="s1">deferred_copy_internals=deferred_copy_internals</span><span class="s3">,</span>
            <span class="s1">**kw</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s1">@util.memoized_property</span>
    <span class="s2">def </span><span class="s1">_resolved(self):</span>
        <span class="s1">expr = self._rec.expected_expr</span>

        <span class="s2">if </span><span class="s1">self._resolved_bindparams:</span>
            <span class="s1">expr = self._setup_binds_for_tracked_expr(expr)</span>

        <span class="s2">return </span><span class="s1">expr</span>

    <span class="s2">def </span><span class="s1">_gen_cache_key(self</span><span class="s3">, </span><span class="s1">anon_map</span><span class="s3">, </span><span class="s1">bindparams):</span>
        <span class="s2">if </span><span class="s1">self.closure_cache_key </span><span class="s2">is </span><span class="s1">_cache_key.NO_CACHE:</span>
            <span class="s1">anon_map[_cache_key.NO_CACHE] = </span><span class="s2">True</span>
            <span class="s2">return None</span>

        <span class="s1">cache_key = (</span>
            <span class="s1">self.fn.__code__</span><span class="s3">,</span>
            <span class="s1">self.__class__</span><span class="s3">,</span>
        <span class="s1">) + self.closure_cache_key</span>

        <span class="s1">parent = self.parent_lambda</span>

        <span class="s2">while </span><span class="s1">parent </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">parent.closure_cache_key </span><span class="s2">is not </span><span class="s1">CacheConst.NO_CACHE</span>
            <span class="s1">parent_closure_cache_key: Tuple[Any</span><span class="s3">, </span><span class="s1">...] = (</span>
                <span class="s1">parent.closure_cache_key</span>
            <span class="s1">)</span>

            <span class="s1">cache_key = (</span>
                <span class="s1">(parent.fn.__code__</span><span class="s3">,</span><span class="s1">) + parent_closure_cache_key + cache_key</span>
            <span class="s1">)</span>

            <span class="s1">parent = parent.parent_lambda</span>

        <span class="s2">if </span><span class="s1">self._resolved_bindparams:</span>
            <span class="s1">bindparams.extend(self._resolved_bindparams)</span>
        <span class="s2">return </span><span class="s1">cache_key</span>

    <span class="s2">def </span><span class="s1">_invoke_user_fn(self</span><span class="s3">, </span><span class="s1">fn: _AnyLambdaType</span><span class="s3">, </span><span class="s1">*arg: Any) -&gt; ClauseElement:</span>
        <span class="s2">return </span><span class="s1">fn()  </span><span class="s0"># type: ignore[no-any-return]</span>


<span class="s2">class </span><span class="s1">DeferredLambdaElement(LambdaElement):</span>
    <span class="s6">&quot;&quot;&quot;A LambdaElement where the lambda accepts arguments and is 
    invoked within the compile phase with special context. 
 
    This lambda doesn't normally produce its real SQL expression outside of the 
    compile phase.  It is passed a fixed set of initial arguments 
    so that it can generate a sample expression. 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">fn: _AnyLambdaType</span><span class="s3">,</span>
        <span class="s1">role: Type[roles.SQLRole]</span><span class="s3">,</span>
        <span class="s1">opts: Union[Type[LambdaOptions]</span><span class="s3">, </span><span class="s1">LambdaOptions] = LambdaOptions</span><span class="s3">,</span>
        <span class="s1">lambda_args: Tuple[Any</span><span class="s3">, </span><span class="s1">...] = ()</span><span class="s3">,</span>
    <span class="s1">):</span>
        <span class="s1">self.lambda_args = lambda_args</span>
        <span class="s1">super().__init__(fn</span><span class="s3">, </span><span class="s1">role</span><span class="s3">, </span><span class="s1">opts)</span>

    <span class="s2">def </span><span class="s1">_invoke_user_fn(self</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">, </span><span class="s1">*arg):</span>
        <span class="s2">return </span><span class="s1">fn(*self.lambda_args)</span>

    <span class="s2">def </span><span class="s1">_resolve_with_args(self</span><span class="s3">, </span><span class="s1">*lambda_args: Any) -&gt; ClauseElement:</span>
        <span class="s2">assert </span><span class="s1">isinstance(self._rec</span><span class="s3">, </span><span class="s1">AnalyzedFunction)</span>
        <span class="s1">tracker_fn = self._rec.tracker_instrumented_fn</span>
        <span class="s1">expr = tracker_fn(*lambda_args)</span>

        <span class="s1">expr = coercions.expect(self.role</span><span class="s3">, </span><span class="s1">expr)</span>

        <span class="s1">expr = self._setup_binds_for_tracked_expr(expr)</span>

        <span class="s0"># this validation is getting very close, but not quite, to achieving</span>
        <span class="s0"># #5767.  The problem is if the base lambda uses an unnamed column</span>
        <span class="s0"># as is very common with mixins, the parameter name is different</span>
        <span class="s0"># and it produces a false positive; that is, for the documented case</span>
        <span class="s0"># that is exactly what people will be doing, it doesn't work, so</span>
        <span class="s0"># I'm not really sure how to handle this right now.</span>
        <span class="s0"># expected_binds = [</span>
        <span class="s0">#    b._orig_key</span>
        <span class="s0">#    for b in self._rec.expr._generate_cache_key()[1]</span>
        <span class="s0">#    if b.required</span>
        <span class="s0"># ]</span>
        <span class="s0"># got_binds = [</span>
        <span class="s0">#    b._orig_key for b in expr._generate_cache_key()[1] if b.required</span>
        <span class="s0"># ]</span>
        <span class="s0"># if expected_binds != got_binds:</span>
        <span class="s0">#    raise exc.InvalidRequestError(</span>
        <span class="s0">#        &quot;Lambda callable at %s produced a different set of bound &quot;</span>
        <span class="s0">#        &quot;parameters than its original run: %s&quot;</span>
        <span class="s0">#        % (self.fn.__code__, &quot;, &quot;.join(got_binds))</span>
        <span class="s0">#    )</span>

        <span class="s0"># TODO: TEST TEST TEST, this is very out there</span>
        <span class="s2">for </span><span class="s1">deferred_copy_internals </span><span class="s2">in </span><span class="s1">self._transforms:</span>
            <span class="s1">expr = deferred_copy_internals(expr)</span>

        <span class="s2">return </span><span class="s1">expr  </span><span class="s0"># type: ignore</span>

    <span class="s2">def </span><span class="s1">_copy_internals(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">clone=_clone</span><span class="s3">, </span><span class="s1">deferred_copy_internals=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">**kw</span>
    <span class="s1">):</span>
        <span class="s1">super()._copy_internals(</span>
            <span class="s1">clone=clone</span><span class="s3">,</span>
            <span class="s1">deferred_copy_internals=deferred_copy_internals</span><span class="s3">,  </span><span class="s0"># **kw</span>
            <span class="s1">opts=kw</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s0"># TODO: A LOT A LOT of tests.   for _resolve_with_args, we don't know</span>
        <span class="s0"># our expression yet.   so hold onto the replacement</span>
        <span class="s2">if </span><span class="s1">deferred_copy_internals:</span>
            <span class="s1">self._transforms += (deferred_copy_internals</span><span class="s3">,</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">StatementLambdaElement(</span>
    <span class="s1">roles.AllowsLambdaRole</span><span class="s3">, </span><span class="s1">LambdaElement</span><span class="s3">, </span><span class="s1">Executable</span>
<span class="s1">):</span>
    <span class="s6">&quot;&quot;&quot;Represent a composable SQL statement as a :class:`_sql.LambdaElement`. 
 
    The :class:`_sql.StatementLambdaElement` is constructed using the 
    :func:`_sql.lambda_stmt` function:: 
 
 
        from sqlalchemy import lambda_stmt 
 
        stmt = lambda_stmt(lambda: select(table)) 
 
    Once constructed, additional criteria can be built onto the statement 
    by adding subsequent lambdas, which accept the existing statement 
    object as a single parameter:: 
 
        stmt += lambda s: s.where(table.c.col == parameter) 
 
 
    .. versionadded:: 1.4 
 
    .. seealso:: 
 
        :ref:`engine_lambda_caching` 
 
    &quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>

        <span class="s2">def </span><span class="s1">__init__(</span>
            <span class="s1">self</span><span class="s3">,</span>
            <span class="s1">fn: _StmtLambdaType</span><span class="s3">,</span>
            <span class="s1">role: Type[SQLRole]</span><span class="s3">,</span>
            <span class="s1">opts: Union[Type[LambdaOptions]</span><span class="s3">, </span><span class="s1">LambdaOptions] = LambdaOptions</span><span class="s3">,</span>
            <span class="s1">apply_propagate_attrs: Optional[ClauseElement] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">): ...</span>

    <span class="s2">def </span><span class="s1">__add__(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">other: _StmtLambdaElementType[Any]</span>
    <span class="s1">) -&gt; StatementLambdaElement:</span>
        <span class="s2">return </span><span class="s1">self.add_criteria(other)</span>

    <span class="s2">def </span><span class="s1">add_criteria(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">other: _StmtLambdaElementType[Any]</span><span class="s3">,</span>
        <span class="s1">enable_tracking: bool = </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">track_on: Optional[Any] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">track_closure_variables: bool = </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">track_bound_values: bool = </span><span class="s2">True</span><span class="s3">,</span>
    <span class="s1">) -&gt; StatementLambdaElement:</span>
        <span class="s6">&quot;&quot;&quot;Add new criteria to this :class:`_sql.StatementLambdaElement`. 
 
        E.g.:: 
 
            &gt;&gt;&gt; def my_stmt(parameter): 
            ...     stmt = lambda_stmt( 
            ...         lambda: select(table.c.x, table.c.y), 
            ...     ) 
            ...     stmt = stmt.add_criteria( 
            ...         lambda: table.c.x &gt; parameter 
            ...     ) 
            ...     return stmt 
 
        The :meth:`_sql.StatementLambdaElement.add_criteria` method is 
        equivalent to using the Python addition operator to add a new 
        lambda, except that additional arguments may be added including 
        ``track_closure_values`` and ``track_on``:: 
 
            &gt;&gt;&gt; def my_stmt(self, foo): 
            ...     stmt = lambda_stmt( 
            ...         lambda: select(func.max(foo.x, foo.y)), 
            ...         track_closure_variables=False 
            ...     ) 
            ...     stmt = stmt.add_criteria( 
            ...         lambda: self.where_criteria, 
            ...         track_on=[self] 
            ...     ) 
            ...     return stmt 
 
        See :func:`_sql.lambda_stmt` for a description of the parameters 
        accepted. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">opts = self.opts + dict(</span>
            <span class="s1">enable_tracking=enable_tracking</span><span class="s3">,</span>
            <span class="s1">track_closure_variables=track_closure_variables</span><span class="s3">,</span>
            <span class="s1">global_track_bound_values=self.opts.global_track_bound_values</span><span class="s3">,</span>
            <span class="s1">track_on=track_on</span><span class="s3">,</span>
            <span class="s1">track_bound_values=track_bound_values</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">LinkedLambdaElement(other</span><span class="s3">, </span><span class="s1">parent_lambda=self</span><span class="s3">, </span><span class="s1">opts=opts)</span>

    <span class="s2">def </span><span class="s1">_execute_on_connection(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">connection</span><span class="s3">, </span><span class="s1">distilled_params</span><span class="s3">, </span><span class="s1">execution_options</span>
    <span class="s1">):</span>
        <span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
            <span class="s2">assert </span><span class="s1">isinstance(self._rec.expected_expr</span><span class="s3">, </span><span class="s1">ClauseElement)</span>
        <span class="s2">if </span><span class="s1">self._rec.expected_expr.supports_execution:</span>
            <span class="s2">return </span><span class="s1">connection._execute_clauseelement(</span>
                <span class="s1">self</span><span class="s3">, </span><span class="s1">distilled_params</span><span class="s3">, </span><span class="s1">execution_options</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">exc.ObjectNotExecutableError(self)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_proxied(self) -&gt; Any:</span>
        <span class="s2">return </span><span class="s1">self._rec_expected_expr</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_with_options(self):</span>
        <span class="s2">return </span><span class="s1">self._proxied._with_options</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_effective_plugin_target(self):</span>
        <span class="s2">return </span><span class="s1">self._proxied._effective_plugin_target</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_execution_options(self):</span>
        <span class="s2">return </span><span class="s1">self._proxied._execution_options</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_all_selected_columns(self):</span>
        <span class="s2">return </span><span class="s1">self._proxied._all_selected_columns</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">is_select(self):</span>
        <span class="s2">return </span><span class="s1">self._proxied.is_select</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">is_update(self):</span>
        <span class="s2">return </span><span class="s1">self._proxied.is_update</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">is_insert(self):</span>
        <span class="s2">return </span><span class="s1">self._proxied.is_insert</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">is_text(self):</span>
        <span class="s2">return </span><span class="s1">self._proxied.is_text</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">is_delete(self):</span>
        <span class="s2">return </span><span class="s1">self._proxied.is_delete</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">is_dml(self):</span>
        <span class="s2">return </span><span class="s1">self._proxied.is_dml</span>

    <span class="s2">def </span><span class="s1">spoil(self) -&gt; NullLambdaStatement:</span>
        <span class="s6">&quot;&quot;&quot;Return a new :class:`.StatementLambdaElement` that will run 
        all lambdas unconditionally each time. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">NullLambdaStatement(self.fn())</span>


<span class="s2">class </span><span class="s1">NullLambdaStatement(roles.AllowsLambdaRole</span><span class="s3">, </span><span class="s1">elements.ClauseElement):</span>
    <span class="s6">&quot;&quot;&quot;Provides the :class:`.StatementLambdaElement` API but does not 
    cache or analyze lambdas. 
 
    the lambdas are instead invoked immediately. 
 
    The intended use is to isolate issues that may arise when using 
    lambda statements. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ = </span><span class="s4">&quot;lambda_element&quot;</span>

    <span class="s1">_is_lambda_element = </span><span class="s2">True</span>

    <span class="s1">_traverse_internals = [</span>
        <span class="s1">(</span><span class="s4">&quot;_resolved&quot;</span><span class="s3">, </span><span class="s1">visitors.InternalTraversal.dp_clauseelement)</span>
    <span class="s1">]</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">statement):</span>
        <span class="s1">self._resolved = statement</span>
        <span class="s1">self._propagate_attrs = statement._propagate_attrs</span>

    <span class="s2">def </span><span class="s1">__getattr__(self</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s2">return </span><span class="s1">getattr(self._resolved</span><span class="s3">, </span><span class="s1">key)</span>

    <span class="s2">def </span><span class="s1">__add__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s1">statement = other(self._resolved)</span>

        <span class="s2">return </span><span class="s1">NullLambdaStatement(statement)</span>

    <span class="s2">def </span><span class="s1">add_criteria(self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">**kw):</span>
        <span class="s1">statement = other(self._resolved)</span>

        <span class="s2">return </span><span class="s1">NullLambdaStatement(statement)</span>

    <span class="s2">def </span><span class="s1">_execute_on_connection(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">connection</span><span class="s3">, </span><span class="s1">distilled_params</span><span class="s3">, </span><span class="s1">execution_options</span>
    <span class="s1">):</span>
        <span class="s2">if </span><span class="s1">self._resolved.supports_execution:</span>
            <span class="s2">return </span><span class="s1">connection._execute_clauseelement(</span>
                <span class="s1">self</span><span class="s3">, </span><span class="s1">distilled_params</span><span class="s3">, </span><span class="s1">execution_options</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">exc.ObjectNotExecutableError(self)</span>


<span class="s2">class </span><span class="s1">LinkedLambdaElement(StatementLambdaElement):</span>
    <span class="s6">&quot;&quot;&quot;Represent subsequent links of a :class:`.StatementLambdaElement`.&quot;&quot;&quot;</span>

    <span class="s1">parent_lambda: StatementLambdaElement</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">fn: _StmtLambdaElementType[Any]</span><span class="s3">,</span>
        <span class="s1">parent_lambda: StatementLambdaElement</span><span class="s3">,</span>
        <span class="s1">opts: Union[Type[LambdaOptions]</span><span class="s3">, </span><span class="s1">LambdaOptions]</span><span class="s3">,</span>
    <span class="s1">):</span>
        <span class="s1">self.opts = opts</span>
        <span class="s1">self.fn = fn</span>
        <span class="s1">self.parent_lambda = parent_lambda</span>

        <span class="s1">self.tracker_key = parent_lambda.tracker_key + (fn.__code__</span><span class="s3">,</span><span class="s1">)</span>
        <span class="s1">self._retrieve_tracker_rec(fn</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">opts)</span>
        <span class="s1">self._propagate_attrs = parent_lambda._propagate_attrs</span>

    <span class="s2">def </span><span class="s1">_invoke_user_fn(self</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">, </span><span class="s1">*arg):</span>
        <span class="s2">return </span><span class="s1">fn(self.parent_lambda._resolved)</span>


<span class="s2">class </span><span class="s1">AnalyzedCode:</span>
    <span class="s1">__slots__ = (</span>
        <span class="s4">&quot;track_closure_variables&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;track_bound_values&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;bindparam_trackers&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;closure_trackers&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;build_py_wrappers&quot;</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s1">_fns: weakref.WeakKeyDictionary[CodeType</span><span class="s3">, </span><span class="s1">AnalyzedCode] = (</span>
        <span class="s1">weakref.WeakKeyDictionary()</span>
    <span class="s1">)</span>

    <span class="s1">_generation_mutex = threading.RLock()</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">get(cls</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">, </span><span class="s1">lambda_element</span><span class="s3">, </span><span class="s1">lambda_kw</span><span class="s3">, </span><span class="s1">**kw):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s0"># TODO: validate kw haven't changed?</span>
            <span class="s2">return </span><span class="s1">cls._fns[fn.__code__]</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s2">pass</span>

        <span class="s2">with </span><span class="s1">cls._generation_mutex:</span>
            <span class="s0"># check for other thread already created object</span>
            <span class="s2">if </span><span class="s1">fn.__code__ </span><span class="s2">in </span><span class="s1">cls._fns:</span>
                <span class="s2">return </span><span class="s1">cls._fns[fn.__code__]</span>

            <span class="s1">analyzed: AnalyzedCode</span>
            <span class="s1">cls._fns[fn.__code__] = analyzed = AnalyzedCode(</span>
                <span class="s1">fn</span><span class="s3">, </span><span class="s1">lambda_element</span><span class="s3">, </span><span class="s1">lambda_kw</span><span class="s3">, </span><span class="s1">**kw</span>
            <span class="s1">)</span>
            <span class="s2">return </span><span class="s1">analyzed</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">, </span><span class="s1">lambda_element</span><span class="s3">, </span><span class="s1">opts):</span>
        <span class="s2">if </span><span class="s1">inspect.ismethod(fn):</span>
            <span class="s2">raise </span><span class="s1">exc.ArgumentError(</span>
                <span class="s4">&quot;Method %s may not be passed as a SQL expression&quot; </span><span class="s1">% fn</span>
            <span class="s1">)</span>
        <span class="s1">closure = fn.__closure__</span>

        <span class="s1">self.track_bound_values = (</span>
            <span class="s1">opts.track_bound_values </span><span class="s2">and </span><span class="s1">opts.global_track_bound_values</span>
        <span class="s1">)</span>
        <span class="s1">enable_tracking = opts.enable_tracking</span>
        <span class="s1">track_on = opts.track_on</span>
        <span class="s1">track_closure_variables = opts.track_closure_variables</span>

        <span class="s1">self.track_closure_variables = track_closure_variables </span><span class="s2">and not </span><span class="s1">track_on</span>

        <span class="s0"># a list of callables generated from _bound_parameter_getter_*</span>
        <span class="s0"># functions.  Each of these uses a PyWrapper object to retrieve</span>
        <span class="s0"># a parameter value</span>
        <span class="s1">self.bindparam_trackers = []</span>

        <span class="s0"># a list of callables generated from _cache_key_getter_* functions</span>
        <span class="s0"># these callables work to generate a cache key for the lambda</span>
        <span class="s0"># based on what's inside its closure variables.</span>
        <span class="s1">self.closure_trackers = []</span>

        <span class="s1">self.build_py_wrappers = []</span>

        <span class="s2">if </span><span class="s1">enable_tracking:</span>
            <span class="s2">if </span><span class="s1">track_on:</span>
                <span class="s1">self._init_track_on(track_on)</span>

            <span class="s1">self._init_globals(fn)</span>

            <span class="s2">if </span><span class="s1">closure:</span>
                <span class="s1">self._init_closure(fn)</span>

        <span class="s1">self._setup_additional_closure_trackers(fn</span><span class="s3">, </span><span class="s1">lambda_element</span><span class="s3">, </span><span class="s1">opts)</span>

    <span class="s2">def </span><span class="s1">_init_track_on(self</span><span class="s3">, </span><span class="s1">track_on):</span>
        <span class="s1">self.closure_trackers.extend(</span>
            <span class="s1">self._cache_key_getter_track_on(idx</span><span class="s3">, </span><span class="s1">elem)</span>
            <span class="s2">for </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">elem </span><span class="s2">in </span><span class="s1">enumerate(track_on)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_init_globals(self</span><span class="s3">, </span><span class="s1">fn):</span>
        <span class="s1">build_py_wrappers = self.build_py_wrappers</span>
        <span class="s1">bindparam_trackers = self.bindparam_trackers</span>
        <span class="s1">track_bound_values = self.track_bound_values</span>

        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">fn.__code__.co_names:</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">fn.__globals__:</span>
                <span class="s2">continue</span>

            <span class="s1">_bound_value = self._roll_down_to_literal(fn.__globals__[name])</span>

            <span class="s2">if </span><span class="s1">coercions._deep_is_literal(_bound_value):</span>
                <span class="s1">build_py_wrappers.append((name</span><span class="s3">, </span><span class="s2">None</span><span class="s1">))</span>
                <span class="s2">if </span><span class="s1">track_bound_values:</span>
                    <span class="s1">bindparam_trackers.append(</span>
                        <span class="s1">self._bound_parameter_getter_func_globals(name)</span>
                    <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_init_closure(self</span><span class="s3">, </span><span class="s1">fn):</span>
        <span class="s1">build_py_wrappers = self.build_py_wrappers</span>
        <span class="s1">closure = fn.__closure__</span>

        <span class="s1">track_bound_values = self.track_bound_values</span>
        <span class="s1">track_closure_variables = self.track_closure_variables</span>
        <span class="s1">bindparam_trackers = self.bindparam_trackers</span>
        <span class="s1">closure_trackers = self.closure_trackers</span>

        <span class="s2">for </span><span class="s1">closure_index</span><span class="s3">, </span><span class="s1">(fv</span><span class="s3">, </span><span class="s1">cell) </span><span class="s2">in </span><span class="s1">enumerate(</span>
            <span class="s1">zip(fn.__code__.co_freevars</span><span class="s3">, </span><span class="s1">closure)</span>
        <span class="s1">):</span>
            <span class="s1">_bound_value = self._roll_down_to_literal(cell.cell_contents)</span>

            <span class="s2">if </span><span class="s1">coercions._deep_is_literal(_bound_value):</span>
                <span class="s1">build_py_wrappers.append((fv</span><span class="s3">, </span><span class="s1">closure_index))</span>
                <span class="s2">if </span><span class="s1">track_bound_values:</span>
                    <span class="s1">bindparam_trackers.append(</span>
                        <span class="s1">self._bound_parameter_getter_func_closure(</span>
                            <span class="s1">fv</span><span class="s3">, </span><span class="s1">closure_index</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># for normal cell contents, add them to a list that</span>
                <span class="s0"># we can compare later when we get new lambdas.  if</span>
                <span class="s0"># any identities have changed, then we will</span>
                <span class="s0"># recalculate the whole lambda and run it again.</span>

                <span class="s2">if </span><span class="s1">track_closure_variables:</span>
                    <span class="s1">closure_trackers.append(</span>
                        <span class="s1">self._cache_key_getter_closure_variable(</span>
                            <span class="s1">fn</span><span class="s3">, </span><span class="s1">fv</span><span class="s3">, </span><span class="s1">closure_index</span><span class="s3">, </span><span class="s1">cell.cell_contents</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_setup_additional_closure_trackers(self</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">, </span><span class="s1">lambda_element</span><span class="s3">, </span><span class="s1">opts):</span>
        <span class="s0"># an additional step is to actually run the function, then</span>
        <span class="s0"># go through the PyWrapper objects that were set up to catch a bound</span>
        <span class="s0"># parameter.   then if they *didn't* make a param, oh they're another</span>
        <span class="s0"># object in the closure we have to track for our cache key.  so</span>
        <span class="s0"># create trackers to catch those.</span>

        <span class="s1">analyzed_function = AnalyzedFunction(</span>
            <span class="s1">self</span><span class="s3">,</span>
            <span class="s1">lambda_element</span><span class="s3">,</span>
            <span class="s2">None</span><span class="s3">,</span>
            <span class="s1">fn</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s1">closure_trackers = self.closure_trackers</span>

        <span class="s2">for </span><span class="s1">pywrapper </span><span class="s2">in </span><span class="s1">analyzed_function.closure_pywrappers:</span>
            <span class="s2">if not </span><span class="s1">pywrapper._sa__has_param:</span>
                <span class="s1">closure_trackers.append(</span>
                    <span class="s1">self._cache_key_getter_tracked_literal(fn</span><span class="s3">, </span><span class="s1">pywrapper)</span>
                <span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_roll_down_to_literal(cls</span><span class="s3">, </span><span class="s1">element):</span>
        <span class="s1">is_clause_element = hasattr(element</span><span class="s3">, </span><span class="s4">&quot;__clause_element__&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">is_clause_element:</span>
            <span class="s2">while not </span><span class="s1">isinstance(</span>
                <span class="s1">element</span><span class="s3">, </span><span class="s1">(elements.ClauseElement</span><span class="s3">, </span><span class="s1">schema.SchemaItem</span><span class="s3">, </span><span class="s1">type)</span>
            <span class="s1">):</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">element = element.__clause_element__()</span>
                <span class="s2">except </span><span class="s1">AttributeError:</span>
                    <span class="s2">break</span>

        <span class="s2">if not </span><span class="s1">is_clause_element:</span>
            <span class="s1">insp = inspection.inspect(element</span><span class="s3">, </span><span class="s1">raiseerr=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">insp </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">insp.__clause_element__()</span>
                <span class="s2">except </span><span class="s1">AttributeError:</span>
                    <span class="s2">return </span><span class="s1">insp</span>

            <span class="s0"># TODO: should we coerce consts None/True/False here?</span>
            <span class="s2">return </span><span class="s1">element</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">element</span>

    <span class="s2">def </span><span class="s1">_bound_parameter_getter_func_globals(self</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s6">&quot;&quot;&quot;Return a getter that will extend a list of bound parameters 
        with new entries from the ``__globals__`` collection of a particular 
        lambda. 
 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">extract_parameter_value(</span>
            <span class="s1">current_fn</span><span class="s3">, </span><span class="s1">tracker_instrumented_fn</span><span class="s3">, </span><span class="s1">result</span>
        <span class="s1">):</span>
            <span class="s1">wrapper = tracker_instrumented_fn.__globals__[name]</span>
            <span class="s1">object.__getattribute__(wrapper</span><span class="s3">, </span><span class="s4">&quot;_extract_bound_parameters&quot;</span><span class="s1">)(</span>
                <span class="s1">current_fn.__globals__[name]</span><span class="s3">, </span><span class="s1">result</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">extract_parameter_value</span>

    <span class="s2">def </span><span class="s1">_bound_parameter_getter_func_closure(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">closure_index):</span>
        <span class="s6">&quot;&quot;&quot;Return a getter that will extend a list of bound parameters 
        with new entries from the ``__closure__`` collection of a particular 
        lambda. 
 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">extract_parameter_value(</span>
            <span class="s1">current_fn</span><span class="s3">, </span><span class="s1">tracker_instrumented_fn</span><span class="s3">, </span><span class="s1">result</span>
        <span class="s1">):</span>
            <span class="s1">wrapper = tracker_instrumented_fn.__closure__[</span>
                <span class="s1">closure_index</span>
            <span class="s1">].cell_contents</span>
            <span class="s1">object.__getattribute__(wrapper</span><span class="s3">, </span><span class="s4">&quot;_extract_bound_parameters&quot;</span><span class="s1">)(</span>
                <span class="s1">current_fn.__closure__[closure_index].cell_contents</span><span class="s3">, </span><span class="s1">result</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">extract_parameter_value</span>

    <span class="s2">def </span><span class="s1">_cache_key_getter_track_on(self</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">elem):</span>
        <span class="s6">&quot;&quot;&quot;Return a getter that will extend a cache key with new entries 
        from the &quot;track_on&quot; parameter passed to a :class:`.LambdaElement`. 
 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">isinstance(elem</span><span class="s3">, </span><span class="s1">tuple):</span>
            <span class="s0"># tuple must contain hascachekey elements</span>
            <span class="s2">def </span><span class="s1">get(closure</span><span class="s3">, </span><span class="s1">opts</span><span class="s3">, </span><span class="s1">anon_map</span><span class="s3">, </span><span class="s1">bindparams):</span>
                <span class="s2">return </span><span class="s1">tuple(</span>
                    <span class="s1">tup_elem._gen_cache_key(anon_map</span><span class="s3">, </span><span class="s1">bindparams)</span>
                    <span class="s2">for </span><span class="s1">tup_elem </span><span class="s2">in </span><span class="s1">opts.track_on[idx]</span>
                <span class="s1">)</span>

        <span class="s2">elif </span><span class="s1">isinstance(elem</span><span class="s3">, </span><span class="s1">_cache_key.HasCacheKey):</span>

            <span class="s2">def </span><span class="s1">get(closure</span><span class="s3">, </span><span class="s1">opts</span><span class="s3">, </span><span class="s1">anon_map</span><span class="s3">, </span><span class="s1">bindparams):</span>
                <span class="s2">return </span><span class="s1">opts.track_on[idx]._gen_cache_key(anon_map</span><span class="s3">, </span><span class="s1">bindparams)</span>

        <span class="s2">else</span><span class="s1">:</span>

            <span class="s2">def </span><span class="s1">get(closure</span><span class="s3">, </span><span class="s1">opts</span><span class="s3">, </span><span class="s1">anon_map</span><span class="s3">, </span><span class="s1">bindparams):</span>
                <span class="s2">return </span><span class="s1">opts.track_on[idx]</span>

        <span class="s2">return </span><span class="s1">get</span>

    <span class="s2">def </span><span class="s1">_cache_key_getter_closure_variable(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">fn</span><span class="s3">,</span>
        <span class="s1">variable_name</span><span class="s3">,</span>
        <span class="s1">idx</span><span class="s3">,</span>
        <span class="s1">cell_contents</span><span class="s3">,</span>
        <span class="s1">use_clause_element=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">use_inspect=</span><span class="s2">False</span><span class="s3">,</span>
    <span class="s1">):</span>
        <span class="s6">&quot;&quot;&quot;Return a getter that will extend a cache key with new entries 
        from the ``__closure__`` collection of a particular lambda. 
 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">isinstance(cell_contents</span><span class="s3">, </span><span class="s1">_cache_key.HasCacheKey):</span>

            <span class="s2">def </span><span class="s1">get(closure</span><span class="s3">, </span><span class="s1">opts</span><span class="s3">, </span><span class="s1">anon_map</span><span class="s3">, </span><span class="s1">bindparams):</span>
                <span class="s1">obj = closure[idx].cell_contents</span>
                <span class="s2">if </span><span class="s1">use_inspect:</span>
                    <span class="s1">obj = inspection.inspect(obj)</span>
                <span class="s2">elif </span><span class="s1">use_clause_element:</span>
                    <span class="s2">while </span><span class="s1">hasattr(obj</span><span class="s3">, </span><span class="s4">&quot;__clause_element__&quot;</span><span class="s1">):</span>
                        <span class="s2">if not </span><span class="s1">getattr(obj</span><span class="s3">, </span><span class="s4">&quot;is_clause_element&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s1">):</span>
                            <span class="s1">obj = obj.__clause_element__()</span>

                <span class="s2">return </span><span class="s1">obj._gen_cache_key(anon_map</span><span class="s3">, </span><span class="s1">bindparams)</span>

        <span class="s2">elif </span><span class="s1">isinstance(cell_contents</span><span class="s3">, </span><span class="s1">types.FunctionType):</span>

            <span class="s2">def </span><span class="s1">get(closure</span><span class="s3">, </span><span class="s1">opts</span><span class="s3">, </span><span class="s1">anon_map</span><span class="s3">, </span><span class="s1">bindparams):</span>
                <span class="s2">return </span><span class="s1">closure[idx].cell_contents.__code__</span>

        <span class="s2">elif </span><span class="s1">isinstance(cell_contents</span><span class="s3">, </span><span class="s1">collections_abc.Sequence):</span>

            <span class="s2">def </span><span class="s1">get(closure</span><span class="s3">, </span><span class="s1">opts</span><span class="s3">, </span><span class="s1">anon_map</span><span class="s3">, </span><span class="s1">bindparams):</span>
                <span class="s1">contents = closure[idx].cell_contents</span>

                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">tuple(</span>
                        <span class="s1">elem._gen_cache_key(anon_map</span><span class="s3">, </span><span class="s1">bindparams)</span>
                        <span class="s2">for </span><span class="s1">elem </span><span class="s2">in </span><span class="s1">contents</span>
                    <span class="s1">)</span>
                <span class="s2">except </span><span class="s1">AttributeError </span><span class="s2">as </span><span class="s1">ae:</span>
                    <span class="s1">self._raise_for_uncacheable_closure_variable(</span>
                        <span class="s1">variable_name</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">, </span><span class="s1">from_=ae</span>
                    <span class="s1">)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># if the object is a mapped class or aliased class, or some</span>
            <span class="s0"># other object in the ORM realm of things like that, imitate</span>
            <span class="s0"># the logic used in coercions.expect() to roll it down to the</span>
            <span class="s0"># SQL element</span>
            <span class="s1">element = cell_contents</span>
            <span class="s1">is_clause_element = </span><span class="s2">False</span>
            <span class="s2">while </span><span class="s1">hasattr(element</span><span class="s3">, </span><span class="s4">&quot;__clause_element__&quot;</span><span class="s1">):</span>
                <span class="s1">is_clause_element = </span><span class="s2">True</span>
                <span class="s2">if not </span><span class="s1">getattr(element</span><span class="s3">, </span><span class="s4">&quot;is_clause_element&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s1">):</span>
                    <span class="s1">element = element.__clause_element__()</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">break</span>

            <span class="s2">if not </span><span class="s1">is_clause_element:</span>
                <span class="s1">insp = inspection.inspect(element</span><span class="s3">, </span><span class="s1">raiseerr=</span><span class="s2">False</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">insp </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">self._cache_key_getter_closure_variable(</span>
                        <span class="s1">fn</span><span class="s3">, </span><span class="s1">variable_name</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">insp</span><span class="s3">, </span><span class="s1">use_inspect=</span><span class="s2">True</span>
                    <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self._cache_key_getter_closure_variable(</span>
                    <span class="s1">fn</span><span class="s3">, </span><span class="s1">variable_name</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">element</span><span class="s3">, </span><span class="s1">use_clause_element=</span><span class="s2">True</span>
                <span class="s1">)</span>

            <span class="s1">self._raise_for_uncacheable_closure_variable(variable_name</span><span class="s3">, </span><span class="s1">fn)</span>

        <span class="s2">return </span><span class="s1">get</span>

    <span class="s2">def </span><span class="s1">_raise_for_uncacheable_closure_variable(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">variable_name</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">, </span><span class="s1">from_=</span><span class="s2">None</span>
    <span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">exc.InvalidRequestError(</span>
            <span class="s4">&quot;Closure variable named '%s' inside of lambda callable %s &quot;</span>
            <span class="s4">&quot;does not refer to a cacheable SQL element, and also does not &quot;</span>
            <span class="s4">&quot;appear to be serving as a SQL literal bound value based on &quot;</span>
            <span class="s4">&quot;the default &quot;</span>
            <span class="s4">&quot;SQL expression returned by the function.   This variable &quot;</span>
            <span class="s4">&quot;needs to remain outside the scope of a SQL-generating lambda &quot;</span>
            <span class="s4">&quot;so that a proper cache key may be generated from the &quot;</span>
            <span class="s4">&quot;lambda's state.  Evaluate this variable outside of the &quot;</span>
            <span class="s4">&quot;lambda, set track_on=[&lt;elements&gt;] to explicitly select &quot;</span>
            <span class="s4">&quot;closure elements to track, or set &quot;</span>
            <span class="s4">&quot;track_closure_variables=False to exclude &quot;</span>
            <span class="s4">&quot;closure variables from being part of the cache key.&quot;</span>
            <span class="s1">% (variable_name</span><span class="s3">, </span><span class="s1">fn.__code__)</span><span class="s3">,</span>
        <span class="s1">) </span><span class="s2">from </span><span class="s1">from_</span>

    <span class="s2">def </span><span class="s1">_cache_key_getter_tracked_literal(self</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">, </span><span class="s1">pytracker):</span>
        <span class="s6">&quot;&quot;&quot;Return a getter that will extend a cache key with new entries 
        from the ``__closure__`` collection of a particular lambda. 
 
        this getter differs from _cache_key_getter_closure_variable 
        in that these are detected after the function is run, and PyWrapper 
        objects have recorded that a particular literal value is in fact 
        not being interpreted as a bound parameter. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">elem = pytracker._sa__to_evaluate</span>
        <span class="s1">closure_index = pytracker._sa__closure_index</span>
        <span class="s1">variable_name = pytracker._sa__name</span>

        <span class="s2">return </span><span class="s1">self._cache_key_getter_closure_variable(</span>
            <span class="s1">fn</span><span class="s3">, </span><span class="s1">variable_name</span><span class="s3">, </span><span class="s1">closure_index</span><span class="s3">, </span><span class="s1">elem</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">NonAnalyzedFunction:</span>
    <span class="s1">__slots__ = (</span><span class="s4">&quot;expr&quot;</span><span class="s3">,</span><span class="s1">)</span>

    <span class="s1">closure_bindparams: Optional[List[BindParameter[Any]]] = </span><span class="s2">None</span>
    <span class="s1">bindparam_trackers: Optional[List[_BoundParameterGetter]] = </span><span class="s2">None</span>

    <span class="s1">is_sequence = </span><span class="s2">False</span>

    <span class="s1">expr: ClauseElement</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">expr: ClauseElement):</span>
        <span class="s1">self.expr = expr</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">expected_expr(self) -&gt; ClauseElement:</span>
        <span class="s2">return </span><span class="s1">self.expr</span>


<span class="s2">class </span><span class="s1">AnalyzedFunction:</span>
    <span class="s1">__slots__ = (</span>
        <span class="s4">&quot;analyzed_code&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;fn&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;closure_pywrappers&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;tracker_instrumented_fn&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;expr&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;bindparam_trackers&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;expected_expr&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;is_sequence&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;propagate_attrs&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;closure_bindparams&quot;</span><span class="s3">,</span>
    <span class="s1">)</span>

    <span class="s1">closure_bindparams: Optional[List[BindParameter[Any]]]</span>
    <span class="s1">expected_expr: Union[ClauseElement</span><span class="s3">, </span><span class="s1">List[ClauseElement]]</span>
    <span class="s1">bindparam_trackers: Optional[List[_BoundParameterGetter]]</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">analyzed_code</span><span class="s3">,</span>
        <span class="s1">lambda_element</span><span class="s3">,</span>
        <span class="s1">apply_propagate_attrs</span><span class="s3">,</span>
        <span class="s1">fn</span><span class="s3">,</span>
    <span class="s1">):</span>
        <span class="s1">self.analyzed_code = analyzed_code</span>
        <span class="s1">self.fn = fn</span>

        <span class="s1">self.bindparam_trackers = analyzed_code.bindparam_trackers</span>

        <span class="s1">self._instrument_and_run_function(lambda_element)</span>

        <span class="s1">self._coerce_expression(lambda_element</span><span class="s3">, </span><span class="s1">apply_propagate_attrs)</span>

    <span class="s2">def </span><span class="s1">_instrument_and_run_function(self</span><span class="s3">, </span><span class="s1">lambda_element):</span>
        <span class="s1">analyzed_code = self.analyzed_code</span>

        <span class="s1">fn = self.fn</span>
        <span class="s1">self.closure_pywrappers = closure_pywrappers = []</span>

        <span class="s1">build_py_wrappers = analyzed_code.build_py_wrappers</span>

        <span class="s2">if not </span><span class="s1">build_py_wrappers:</span>
            <span class="s1">self.tracker_instrumented_fn = tracker_instrumented_fn = fn</span>
            <span class="s1">self.expr = lambda_element._invoke_user_fn(tracker_instrumented_fn)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">track_closure_variables = analyzed_code.track_closure_variables</span>
            <span class="s1">closure = fn.__closure__</span>

            <span class="s0"># will form the __closure__ of the function when we rebuild it</span>
            <span class="s2">if </span><span class="s1">closure:</span>
                <span class="s1">new_closure = {</span>
                    <span class="s1">fv: cell.cell_contents</span>
                    <span class="s2">for </span><span class="s1">fv</span><span class="s3">, </span><span class="s1">cell </span><span class="s2">in </span><span class="s1">zip(fn.__code__.co_freevars</span><span class="s3">, </span><span class="s1">closure)</span>
                <span class="s1">}</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">new_closure = {}</span>

            <span class="s0"># will form the __globals__ of the function when we rebuild it</span>
            <span class="s1">new_globals = fn.__globals__.copy()</span>

            <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">closure_index </span><span class="s2">in </span><span class="s1">build_py_wrappers:</span>
                <span class="s2">if </span><span class="s1">closure_index </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">value = closure[closure_index].cell_contents</span>
                    <span class="s1">new_closure[name] = bind = PyWrapper(</span>
                        <span class="s1">fn</span><span class="s3">,</span>
                        <span class="s1">name</span><span class="s3">,</span>
                        <span class="s1">value</span><span class="s3">,</span>
                        <span class="s1">closure_index=closure_index</span><span class="s3">,</span>
                        <span class="s1">track_bound_values=(</span>
                            <span class="s1">self.analyzed_code.track_bound_values</span>
                        <span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">)</span>
                    <span class="s2">if </span><span class="s1">track_closure_variables:</span>
                        <span class="s1">closure_pywrappers.append(bind)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">value = fn.__globals__[name]</span>
                    <span class="s1">new_globals[name] = bind = PyWrapper(fn</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">value)</span>

            <span class="s0"># rewrite the original fn.   things that look like they will</span>
            <span class="s0"># become bound parameters are wrapped in a PyWrapper.</span>
            <span class="s1">self.tracker_instrumented_fn = tracker_instrumented_fn = (</span>
                <span class="s1">self._rewrite_code_obj(</span>
                    <span class="s1">fn</span><span class="s3">,</span>
                    <span class="s1">[new_closure[name] </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">fn.__code__.co_freevars]</span><span class="s3">,</span>
                    <span class="s1">new_globals</span><span class="s3">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

            <span class="s0"># now invoke the function.  This will give us a new SQL</span>
            <span class="s0"># expression, but all the places that there would be a bound</span>
            <span class="s0"># parameter, the PyWrapper in its place will give us a bind</span>
            <span class="s0"># with a predictable name we can match up later.</span>

            <span class="s0"># additionally, each PyWrapper will log that it did in fact</span>
            <span class="s0"># create a parameter, otherwise, it's some kind of Python</span>
            <span class="s0"># object in the closure and we want to track that, to make</span>
            <span class="s0"># sure it doesn't change to something else, or if it does,</span>
            <span class="s0"># that we create a different tracked function with that</span>
            <span class="s0"># variable.</span>
            <span class="s1">self.expr = lambda_element._invoke_user_fn(tracker_instrumented_fn)</span>

    <span class="s2">def </span><span class="s1">_coerce_expression(self</span><span class="s3">, </span><span class="s1">lambda_element</span><span class="s3">, </span><span class="s1">apply_propagate_attrs):</span>
        <span class="s6">&quot;&quot;&quot;Run the tracker-generated expression through coercion rules. 
 
        After the user-defined lambda has been invoked to produce a statement 
        for re-use, run it through coercion rules to both check that it's the 
        correct type of object and also to coerce it to its useful form. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">parent_lambda = lambda_element.parent_lambda</span>
        <span class="s1">expr = self.expr</span>

        <span class="s2">if </span><span class="s1">parent_lambda </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(expr</span><span class="s3">, </span><span class="s1">collections_abc.Sequence):</span>
                <span class="s1">self.expected_expr = [</span>
                    <span class="s1">cast(</span>
                        <span class="s4">&quot;ClauseElement&quot;</span><span class="s3">,</span>
                        <span class="s1">coercions.expect(</span>
                            <span class="s1">lambda_element.role</span><span class="s3">,</span>
                            <span class="s1">sub_expr</span><span class="s3">,</span>
                            <span class="s1">apply_propagate_attrs=apply_propagate_attrs</span><span class="s3">,</span>
                        <span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">)</span>
                    <span class="s2">for </span><span class="s1">sub_expr </span><span class="s2">in </span><span class="s1">expr</span>
                <span class="s1">]</span>
                <span class="s1">self.is_sequence = </span><span class="s2">True</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.expected_expr = cast(</span>
                    <span class="s4">&quot;ClauseElement&quot;</span><span class="s3">,</span>
                    <span class="s1">coercions.expect(</span>
                        <span class="s1">lambda_element.role</span><span class="s3">,</span>
                        <span class="s1">expr</span><span class="s3">,</span>
                        <span class="s1">apply_propagate_attrs=apply_propagate_attrs</span><span class="s3">,</span>
                    <span class="s1">)</span><span class="s3">,</span>
                <span class="s1">)</span>
                <span class="s1">self.is_sequence = </span><span class="s2">False</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.expected_expr = expr</span>
            <span class="s1">self.is_sequence = </span><span class="s2">False</span>

        <span class="s2">if </span><span class="s1">apply_propagate_attrs </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.propagate_attrs = apply_propagate_attrs._propagate_attrs</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.propagate_attrs = util.EMPTY_DICT</span>

    <span class="s2">def </span><span class="s1">_rewrite_code_obj(self</span><span class="s3">, </span><span class="s1">f</span><span class="s3">, </span><span class="s1">cell_values</span><span class="s3">, </span><span class="s1">globals_):</span>
        <span class="s6">&quot;&quot;&quot;Return a copy of f, with a new closure and new globals 
 
        yes it works in pypy :P 
 
        &quot;&quot;&quot;</span>

        <span class="s1">argrange = range(len(cell_values))</span>

        <span class="s1">code = </span><span class="s4">&quot;def make_cells():</span><span class="s7">\n</span><span class="s4">&quot;</span>
        <span class="s2">if </span><span class="s1">cell_values:</span>
            <span class="s1">code += </span><span class="s4">&quot;    (%s) = (%s)</span><span class="s7">\n</span><span class="s4">&quot; </span><span class="s1">% (</span>
                <span class="s4">&quot;, &quot;</span><span class="s1">.join(</span><span class="s4">&quot;i%d&quot; </span><span class="s1">% i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">argrange)</span><span class="s3">,</span>
                <span class="s4">&quot;, &quot;</span><span class="s1">.join(</span><span class="s4">&quot;o%d&quot; </span><span class="s1">% i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">argrange)</span><span class="s3">,</span>
            <span class="s1">)</span>
        <span class="s1">code += </span><span class="s4">&quot;    def closure():</span><span class="s7">\n</span><span class="s4">&quot;</span>
        <span class="s1">code += </span><span class="s4">&quot;        return %s</span><span class="s7">\n</span><span class="s4">&quot; </span><span class="s1">% </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span><span class="s4">&quot;i%d&quot; </span><span class="s1">% i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">argrange)</span>
        <span class="s1">code += </span><span class="s4">&quot;    return closure.__closure__&quot;</span>
        <span class="s1">vars_ = {</span><span class="s4">&quot;o%d&quot; </span><span class="s1">% i: cell_values[i] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">argrange}</span>
        <span class="s1">exec(code</span><span class="s3">, </span><span class="s1">vars_</span><span class="s3">, </span><span class="s1">vars_)</span>
        <span class="s1">closure = vars_[</span><span class="s4">&quot;make_cells&quot;</span><span class="s1">]()</span>

        <span class="s1">func = type(f)(</span>
            <span class="s1">f.__code__</span><span class="s3">, </span><span class="s1">globals_</span><span class="s3">, </span><span class="s1">f.__name__</span><span class="s3">, </span><span class="s1">f.__defaults__</span><span class="s3">, </span><span class="s1">closure</span>
        <span class="s1">)</span>
        <span class="s1">func.__annotations__ = f.__annotations__</span>
        <span class="s1">func.__kwdefaults__ = f.__kwdefaults__</span>
        <span class="s1">func.__doc__ = f.__doc__</span>
        <span class="s1">func.__module__ = f.__module__</span>

        <span class="s2">return </span><span class="s1">func</span>


<span class="s2">class </span><span class="s1">PyWrapper(ColumnOperators):</span>
    <span class="s6">&quot;&quot;&quot;A wrapper object that is injected into the ``__globals__`` and 
    ``__closure__`` of a Python function. 
 
    When the function is instrumented with :class:`.PyWrapper` objects, it is 
    then invoked just once in order to set up the wrappers.  We look through 
    all the :class:`.PyWrapper` objects we made to find the ones that generated 
    a :class:`.BindParameter` object, e.g. the expression system interpreted 
    something as a literal.   Those positions in the globals/closure are then 
    ones that we will look at, each time a new lambda comes in that refers to 
    the same ``__code__`` object.   In this way, we keep a single version of 
    the SQL expression that this lambda produced, without calling upon the 
    Python function that created it more than once, unless its other closure 
    variables have changed.   The expression is then transformed to have the 
    new bound values embedded into it. 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">fn</span><span class="s3">,</span>
        <span class="s1">name</span><span class="s3">,</span>
        <span class="s1">to_evaluate</span><span class="s3">,</span>
        <span class="s1">closure_index=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">getter=</span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">track_bound_values=</span><span class="s2">True</span><span class="s3">,</span>
    <span class="s1">):</span>
        <span class="s1">self.fn = fn</span>
        <span class="s1">self._name = name</span>
        <span class="s1">self._to_evaluate = to_evaluate</span>
        <span class="s1">self._param = </span><span class="s2">None</span>
        <span class="s1">self._has_param = </span><span class="s2">False</span>
        <span class="s1">self._bind_paths = {}</span>
        <span class="s1">self._getter = getter</span>
        <span class="s1">self._closure_index = closure_index</span>
        <span class="s1">self.track_bound_values = track_bound_values</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">*arg</span><span class="s3">, </span><span class="s1">**kw):</span>
        <span class="s1">elem = object.__getattribute__(self</span><span class="s3">, </span><span class="s4">&quot;_to_evaluate&quot;</span><span class="s1">)</span>
        <span class="s1">value = elem(*arg</span><span class="s3">, </span><span class="s1">**kw)</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">self._sa_track_bound_values</span>
            <span class="s2">and </span><span class="s1">coercions._deep_is_literal(value)</span>
            <span class="s2">and not </span><span class="s1">isinstance(</span>
                <span class="s0"># TODO: coverage where an ORM option or similar is here</span>
                <span class="s1">value</span><span class="s3">,</span>
                <span class="s1">_cache_key.HasCacheKey</span><span class="s3">,</span>
            <span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s1">name = object.__getattribute__(self</span><span class="s3">, </span><span class="s4">&quot;_name&quot;</span><span class="s1">)</span>
            <span class="s2">raise </span><span class="s1">exc.InvalidRequestError(</span>
                <span class="s4">&quot;Can't invoke Python callable %s() inside of lambda &quot;</span>
                <span class="s4">&quot;expression argument at %s; lambda SQL constructs should &quot;</span>
                <span class="s4">&quot;not invoke functions from closure variables to produce &quot;</span>
                <span class="s4">&quot;literal values since the &quot;</span>
                <span class="s4">&quot;lambda SQL system normally extracts bound values without &quot;</span>
                <span class="s4">&quot;actually &quot;</span>
                <span class="s4">&quot;invoking the lambda or any functions within it.  Call the &quot;</span>
                <span class="s4">&quot;function outside of the &quot;</span>
                <span class="s4">&quot;lambda and assign to a local variable that is used in the &quot;</span>
                <span class="s4">&quot;lambda as a closure variable, or set &quot;</span>
                <span class="s4">&quot;track_bound_values=False if the return value of this &quot;</span>
                <span class="s4">&quot;function is used in some other way other than a SQL bound &quot;</span>
                <span class="s4">&quot;value.&quot; </span><span class="s1">% (name</span><span class="s3">, </span><span class="s1">self._sa_fn.__code__)</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">value</span>

    <span class="s2">def </span><span class="s1">operate(self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">, </span><span class="s1">*other</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s1">elem = object.__getattribute__(self</span><span class="s3">, </span><span class="s4">&quot;_py_wrapper_literal&quot;</span><span class="s1">)()</span>
        <span class="s2">return </span><span class="s1">op(elem</span><span class="s3">, </span><span class="s1">*other</span><span class="s3">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">reverse_operate(self</span><span class="s3">, </span><span class="s1">op</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s1">elem = object.__getattribute__(self</span><span class="s3">, </span><span class="s4">&quot;_py_wrapper_literal&quot;</span><span class="s1">)()</span>
        <span class="s2">return </span><span class="s1">op(other</span><span class="s3">, </span><span class="s1">elem</span><span class="s3">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">_extract_bound_parameters(self</span><span class="s3">, </span><span class="s1">starting_point</span><span class="s3">, </span><span class="s1">result_list):</span>
        <span class="s1">param = object.__getattribute__(self</span><span class="s3">, </span><span class="s4">&quot;_param&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">param </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">param = param._with_value(starting_point</span><span class="s3">, </span><span class="s1">maintain_key=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">result_list.append(param)</span>
        <span class="s2">for </span><span class="s1">pywrapper </span><span class="s2">in </span><span class="s1">object.__getattribute__(self</span><span class="s3">, </span><span class="s4">&quot;_bind_paths&quot;</span><span class="s1">).values():</span>
            <span class="s1">getter = object.__getattribute__(pywrapper</span><span class="s3">, </span><span class="s4">&quot;_getter&quot;</span><span class="s1">)</span>
            <span class="s1">element = getter(starting_point)</span>
            <span class="s1">pywrapper._sa__extract_bound_parameters(element</span><span class="s3">, </span><span class="s1">result_list)</span>

    <span class="s2">def </span><span class="s1">_py_wrapper_literal(self</span><span class="s3">, </span><span class="s1">expr=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">operator=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">**kw):</span>
        <span class="s1">param = object.__getattribute__(self</span><span class="s3">, </span><span class="s4">&quot;_param&quot;</span><span class="s1">)</span>
        <span class="s1">to_evaluate = object.__getattribute__(self</span><span class="s3">, </span><span class="s4">&quot;_to_evaluate&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">param </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">name = object.__getattribute__(self</span><span class="s3">, </span><span class="s4">&quot;_name&quot;</span><span class="s1">)</span>
            <span class="s1">self._param = param = elements.BindParameter(</span>
                <span class="s1">name</span><span class="s3">,</span>
                <span class="s1">required=</span><span class="s2">False</span><span class="s3">,</span>
                <span class="s1">unique=</span><span class="s2">True</span><span class="s3">,</span>
                <span class="s1">_compared_to_operator=operator</span><span class="s3">,</span>
                <span class="s1">_compared_to_type=expr.type </span><span class="s2">if </span><span class="s1">expr </span><span class="s2">is not None else None</span><span class="s3">,</span>
            <span class="s1">)</span>
            <span class="s1">self._has_param = </span><span class="s2">True</span>
        <span class="s2">return </span><span class="s1">param._with_value(to_evaluate</span><span class="s3">, </span><span class="s1">maintain_key=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__bool__(self):</span>
        <span class="s1">to_evaluate = object.__getattribute__(self</span><span class="s3">, </span><span class="s4">&quot;_to_evaluate&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">bool(to_evaluate)</span>

    <span class="s2">def </span><span class="s1">__getattribute__(self</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s2">if </span><span class="s1">key.startswith(</span><span class="s4">&quot;_sa_&quot;</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">object.__getattribute__(self</span><span class="s3">, </span><span class="s1">key[</span><span class="s5">4</span><span class="s1">:])</span>
        <span class="s2">elif </span><span class="s1">key </span><span class="s2">in </span><span class="s1">(</span>
            <span class="s4">&quot;__clause_element__&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;operate&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;reverse_operate&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;_py_wrapper_literal&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;__class__&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;__dict__&quot;</span><span class="s3">,</span>
        <span class="s1">):</span>
            <span class="s2">return </span><span class="s1">object.__getattribute__(self</span><span class="s3">, </span><span class="s1">key)</span>

        <span class="s2">if </span><span class="s1">key.startswith(</span><span class="s4">&quot;__&quot;</span><span class="s1">):</span>
            <span class="s1">elem = object.__getattribute__(self</span><span class="s3">, </span><span class="s4">&quot;_to_evaluate&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">getattr(elem</span><span class="s3">, </span><span class="s1">key)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._sa__add_getter(key</span><span class="s3">, </span><span class="s1">operator.attrgetter)</span>

    <span class="s2">def </span><span class="s1">__iter__(self):</span>
        <span class="s1">elem = object.__getattribute__(self</span><span class="s3">, </span><span class="s4">&quot;_to_evaluate&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">iter(elem)</span>

    <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s1">elem = object.__getattribute__(self</span><span class="s3">, </span><span class="s4">&quot;_to_evaluate&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">hasattr(elem</span><span class="s3">, </span><span class="s4">&quot;__getitem__&quot;</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s4">&quot;__getitem__&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">isinstance(key</span><span class="s3">, </span><span class="s1">PyWrapper):</span>
            <span class="s0"># TODO: coverage</span>
            <span class="s2">raise </span><span class="s1">exc.InvalidRequestError(</span>
                <span class="s4">&quot;Dictionary keys / list indexes inside of a cached &quot;</span>
                <span class="s4">&quot;lambda must be Python literals only&quot;</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self._sa__add_getter(key</span><span class="s3">, </span><span class="s1">operator.itemgetter)</span>

    <span class="s2">def </span><span class="s1">_add_getter(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">getter_fn):</span>
        <span class="s1">bind_paths = object.__getattribute__(self</span><span class="s3">, </span><span class="s4">&quot;_bind_paths&quot;</span><span class="s1">)</span>

        <span class="s1">bind_path_key = (key</span><span class="s3">, </span><span class="s1">getter_fn)</span>
        <span class="s2">if </span><span class="s1">bind_path_key </span><span class="s2">in </span><span class="s1">bind_paths:</span>
            <span class="s2">return </span><span class="s1">bind_paths[bind_path_key]</span>

        <span class="s1">getter = getter_fn(key)</span>
        <span class="s1">elem = object.__getattribute__(self</span><span class="s3">, </span><span class="s4">&quot;_to_evaluate&quot;</span><span class="s1">)</span>
        <span class="s1">value = getter(elem)</span>

        <span class="s1">rolled_down_value = AnalyzedCode._roll_down_to_literal(value)</span>

        <span class="s2">if </span><span class="s1">coercions._deep_is_literal(rolled_down_value):</span>
            <span class="s1">wrapper = PyWrapper(self._sa_fn</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">getter=getter)</span>
            <span class="s1">bind_paths[bind_path_key] = wrapper</span>
            <span class="s2">return </span><span class="s1">wrapper</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">value</span>


<span class="s1">@inspection._inspects(LambdaElement)</span>
<span class="s2">def </span><span class="s1">insp(lmb):</span>
    <span class="s2">return </span><span class="s1">inspection.inspect(lmb._resolved)</span>
</pre>
</body>
</html>