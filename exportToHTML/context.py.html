<html>
<head>
<title>context.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5d69bb;}
.s1 { color: #d8d8d8;}
.s2 { color: #cc8b60;}
.s3 { color: #96bf7d;}
.s4 { color: #cc7832;}
.s5 { color: #bbb55b;}
.s6 { color: #717ed3; font-style: italic;}
.s7 { color: #d7539b; font-weight: bold;}
</style>
</head>
<body bgcolor="#1a1a25">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
context.py</font>
</center></td></tr></table>
<pre><span class="s0"># orm/context.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>
<span class="s0"># mypy: ignore-errors</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Any</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">cast</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Dict</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Iterable</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">List</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Optional</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Set</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Tuple</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Type</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TypeVar</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Union</span>

<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">attributes</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">interfaces</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">loading</span>
<span class="s2">from </span><span class="s1">.base </span><span class="s2">import </span><span class="s1">_is_aliased_class</span>
<span class="s2">from </span><span class="s1">.interfaces </span><span class="s2">import </span><span class="s1">ORMColumnDescription</span>
<span class="s2">from </span><span class="s1">.interfaces </span><span class="s2">import </span><span class="s1">ORMColumnsClauseRole</span>
<span class="s2">from </span><span class="s1">.path_registry </span><span class="s2">import </span><span class="s1">PathRegistry</span>
<span class="s2">from </span><span class="s1">.util </span><span class="s2">import </span><span class="s1">_entity_corresponds_to</span>
<span class="s2">from </span><span class="s1">.util </span><span class="s2">import </span><span class="s1">_ORMJoin</span>
<span class="s2">from </span><span class="s1">.util </span><span class="s2">import </span><span class="s1">_TraceAdaptRole</span>
<span class="s2">from </span><span class="s1">.util </span><span class="s2">import </span><span class="s1">AliasedClass</span>
<span class="s2">from </span><span class="s1">.util </span><span class="s2">import </span><span class="s1">Bundle</span>
<span class="s2">from </span><span class="s1">.util </span><span class="s2">import </span><span class="s1">ORMAdapter</span>
<span class="s2">from </span><span class="s1">.util </span><span class="s2">import </span><span class="s1">ORMStatementAdapter</span>
<span class="s2">from </span><span class="s1">.. </span><span class="s2">import </span><span class="s1">exc </span><span class="s2">as </span><span class="s1">sa_exc</span>
<span class="s2">from </span><span class="s1">.. </span><span class="s2">import </span><span class="s1">future</span>
<span class="s2">from </span><span class="s1">.. </span><span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">from </span><span class="s1">.. </span><span class="s2">import </span><span class="s1">sql</span>
<span class="s2">from </span><span class="s1">.. </span><span class="s2">import </span><span class="s1">util</span>
<span class="s2">from </span><span class="s1">..sql </span><span class="s2">import </span><span class="s1">coercions</span>
<span class="s2">from </span><span class="s1">..sql </span><span class="s2">import </span><span class="s1">expression</span>
<span class="s2">from </span><span class="s1">..sql </span><span class="s2">import </span><span class="s1">roles</span>
<span class="s2">from </span><span class="s1">..sql </span><span class="s2">import </span><span class="s1">util </span><span class="s2">as </span><span class="s1">sql_util</span>
<span class="s2">from </span><span class="s1">..sql </span><span class="s2">import </span><span class="s1">visitors</span>
<span class="s2">from </span><span class="s1">..sql._typing </span><span class="s2">import </span><span class="s1">_TP</span>
<span class="s2">from </span><span class="s1">..sql._typing </span><span class="s2">import </span><span class="s1">is_dml</span>
<span class="s2">from </span><span class="s1">..sql._typing </span><span class="s2">import </span><span class="s1">is_insert_update</span>
<span class="s2">from </span><span class="s1">..sql._typing </span><span class="s2">import </span><span class="s1">is_select_base</span>
<span class="s2">from </span><span class="s1">..sql.base </span><span class="s2">import </span><span class="s1">_select_iterables</span>
<span class="s2">from </span><span class="s1">..sql.base </span><span class="s2">import </span><span class="s1">CacheableOptions</span>
<span class="s2">from </span><span class="s1">..sql.base </span><span class="s2">import </span><span class="s1">CompileState</span>
<span class="s2">from </span><span class="s1">..sql.base </span><span class="s2">import </span><span class="s1">Executable</span>
<span class="s2">from </span><span class="s1">..sql.base </span><span class="s2">import </span><span class="s1">Generative</span>
<span class="s2">from </span><span class="s1">..sql.base </span><span class="s2">import </span><span class="s1">Options</span>
<span class="s2">from </span><span class="s1">..sql.dml </span><span class="s2">import </span><span class="s1">UpdateBase</span>
<span class="s2">from </span><span class="s1">..sql.elements </span><span class="s2">import </span><span class="s1">GroupedElement</span>
<span class="s2">from </span><span class="s1">..sql.elements </span><span class="s2">import </span><span class="s1">TextClause</span>
<span class="s2">from </span><span class="s1">..sql.selectable </span><span class="s2">import </span><span class="s1">CompoundSelectState</span>
<span class="s2">from </span><span class="s1">..sql.selectable </span><span class="s2">import </span><span class="s1">LABEL_STYLE_DISAMBIGUATE_ONLY</span>
<span class="s2">from </span><span class="s1">..sql.selectable </span><span class="s2">import </span><span class="s1">LABEL_STYLE_NONE</span>
<span class="s2">from </span><span class="s1">..sql.selectable </span><span class="s2">import </span><span class="s1">LABEL_STYLE_TABLENAME_PLUS_COL</span>
<span class="s2">from </span><span class="s1">..sql.selectable </span><span class="s2">import </span><span class="s1">Select</span>
<span class="s2">from </span><span class="s1">..sql.selectable </span><span class="s2">import </span><span class="s1">SelectLabelStyle</span>
<span class="s2">from </span><span class="s1">..sql.selectable </span><span class="s2">import </span><span class="s1">SelectState</span>
<span class="s2">from </span><span class="s1">..sql.selectable </span><span class="s2">import </span><span class="s1">TypedReturnsRows</span>
<span class="s2">from </span><span class="s1">..sql.visitors </span><span class="s2">import </span><span class="s1">InternalTraversal</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s2">from </span><span class="s1">._typing </span><span class="s2">import </span><span class="s1">_InternalEntityType</span>
    <span class="s2">from </span><span class="s1">._typing </span><span class="s2">import </span><span class="s1">OrmExecuteOptionsParameter</span>
    <span class="s2">from </span><span class="s1">.loading </span><span class="s2">import </span><span class="s1">PostLoad</span>
    <span class="s2">from </span><span class="s1">.mapper </span><span class="s2">import </span><span class="s1">Mapper</span>
    <span class="s2">from </span><span class="s1">.query </span><span class="s2">import </span><span class="s1">Query</span>
    <span class="s2">from </span><span class="s1">.session </span><span class="s2">import </span><span class="s1">_BindArguments</span>
    <span class="s2">from </span><span class="s1">.session </span><span class="s2">import </span><span class="s1">Session</span>
    <span class="s2">from </span><span class="s1">..engine </span><span class="s2">import </span><span class="s1">Result</span>
    <span class="s2">from </span><span class="s1">..engine.interfaces </span><span class="s2">import </span><span class="s1">_CoreSingleExecuteParams</span>
    <span class="s2">from </span><span class="s1">..sql._typing </span><span class="s2">import </span><span class="s1">_ColumnsClauseArgument</span>
    <span class="s2">from </span><span class="s1">..sql.compiler </span><span class="s2">import </span><span class="s1">SQLCompiler</span>
    <span class="s2">from </span><span class="s1">..sql.dml </span><span class="s2">import </span><span class="s1">_DMLTableElement</span>
    <span class="s2">from </span><span class="s1">..sql.elements </span><span class="s2">import </span><span class="s1">ColumnElement</span>
    <span class="s2">from </span><span class="s1">..sql.selectable </span><span class="s2">import </span><span class="s1">_JoinTargetElement</span>
    <span class="s2">from </span><span class="s1">..sql.selectable </span><span class="s2">import </span><span class="s1">_LabelConventionCallable</span>
    <span class="s2">from </span><span class="s1">..sql.selectable </span><span class="s2">import </span><span class="s1">_SetupJoinsElement</span>
    <span class="s2">from </span><span class="s1">..sql.selectable </span><span class="s2">import </span><span class="s1">ExecutableReturnsRows</span>
    <span class="s2">from </span><span class="s1">..sql.selectable </span><span class="s2">import </span><span class="s1">SelectBase</span>
    <span class="s2">from </span><span class="s1">..sql.type_api </span><span class="s2">import </span><span class="s1">TypeEngine</span>

<span class="s1">_T = TypeVar(</span><span class="s3">&quot;_T&quot;</span><span class="s4">, </span><span class="s1">bound=Any)</span>
<span class="s1">_path_registry = PathRegistry.root</span>

<span class="s1">_EMPTY_DICT = util.immutabledict()</span>


<span class="s1">LABEL_STYLE_LEGACY_ORM = SelectLabelStyle.LABEL_STYLE_LEGACY_ORM</span>


<span class="s2">class </span><span class="s1">QueryContext:</span>
    <span class="s1">__slots__ = (</span>
        <span class="s3">&quot;top_level_context&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;compile_state&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;query&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;user_passed_query&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;params&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;load_options&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;bind_arguments&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;execution_options&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;session&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;autoflush&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;populate_existing&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;invoke_all_eagers&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;version_check&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;refresh_state&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;create_eager_joins&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;propagated_loader_options&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;attributes&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;runid&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;partials&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;post_load_paths&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;identity_token&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;yield_per&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;loaders_require_buffering&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;loaders_require_uniquing&quot;</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">runid: int</span>
    <span class="s1">post_load_paths: Dict[PathRegistry</span><span class="s4">, </span><span class="s1">PostLoad]</span>
    <span class="s1">compile_state: ORMCompileState</span>

    <span class="s2">class </span><span class="s1">default_load_options(Options):</span>
        <span class="s1">_only_return_tuples = </span><span class="s2">False</span>
        <span class="s1">_populate_existing = </span><span class="s2">False</span>
        <span class="s1">_version_check = </span><span class="s2">False</span>
        <span class="s1">_invoke_all_eagers = </span><span class="s2">True</span>
        <span class="s1">_autoflush = </span><span class="s2">True</span>
        <span class="s1">_identity_token = </span><span class="s2">None</span>
        <span class="s1">_yield_per = </span><span class="s2">None</span>
        <span class="s1">_refresh_state = </span><span class="s2">None</span>
        <span class="s1">_lazy_loaded_from = </span><span class="s2">None</span>
        <span class="s1">_legacy_uniquing = </span><span class="s2">False</span>
        <span class="s1">_sa_top_level_orm_context = </span><span class="s2">None</span>
        <span class="s1">_is_user_refresh = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">compile_state: CompileState</span><span class="s4">,</span>
        <span class="s1">statement: Union[Select[Any]</span><span class="s4">, </span><span class="s1">FromStatement[Any]]</span><span class="s4">,</span>
        <span class="s1">user_passed_query: Union[</span>
            <span class="s1">Select[Any]</span><span class="s4">,</span>
            <span class="s1">FromStatement[Any]</span><span class="s4">,</span>
        <span class="s1">]</span><span class="s4">,</span>
        <span class="s1">params: _CoreSingleExecuteParams</span><span class="s4">,</span>
        <span class="s1">session: Session</span><span class="s4">,</span>
        <span class="s1">load_options: Union[</span>
            <span class="s1">Type[QueryContext.default_load_options]</span><span class="s4">,</span>
            <span class="s1">QueryContext.default_load_options</span><span class="s4">,</span>
        <span class="s1">]</span><span class="s4">,</span>
        <span class="s1">execution_options: Optional[OrmExecuteOptionsParameter] = </span><span class="s2">None</span><span class="s4">,</span>
        <span class="s1">bind_arguments: Optional[_BindArguments] = </span><span class="s2">None</span><span class="s4">,</span>
    <span class="s1">):</span>
        <span class="s1">self.load_options = load_options</span>
        <span class="s1">self.execution_options = execution_options </span><span class="s2">or </span><span class="s1">_EMPTY_DICT</span>
        <span class="s1">self.bind_arguments = bind_arguments </span><span class="s2">or </span><span class="s1">_EMPTY_DICT</span>
        <span class="s1">self.compile_state = compile_state</span>
        <span class="s1">self.query = statement</span>

        <span class="s0"># the query that the end user passed to Session.execute() or similar.</span>
        <span class="s0"># this is usually the same as .query, except in the bulk_persistence</span>
        <span class="s0"># routines where a separate FromStatement is manufactured in the</span>
        <span class="s0"># compile stage; this allows differentiation in that case.</span>
        <span class="s1">self.user_passed_query = user_passed_query</span>

        <span class="s1">self.session = session</span>
        <span class="s1">self.loaders_require_buffering = </span><span class="s2">False</span>
        <span class="s1">self.loaders_require_uniquing = </span><span class="s2">False</span>
        <span class="s1">self.params = params</span>
        <span class="s1">self.top_level_context = load_options._sa_top_level_orm_context</span>

        <span class="s1">cached_options = compile_state.select_statement._with_options</span>
        <span class="s1">uncached_options = user_passed_query._with_options</span>

        <span class="s0"># see issue #7447 , #8399 for some background</span>
        <span class="s0"># propagated loader options will be present on loaded InstanceState</span>
        <span class="s0"># objects under state.load_options and are typically used by</span>
        <span class="s0"># LazyLoader to apply options to the SELECT statement it emits.</span>
        <span class="s0"># For compile state options (i.e. loader strategy options), these</span>
        <span class="s0"># need to line up with the &quot;.load_path&quot; attribute which in</span>
        <span class="s0"># loader.py is pulled from context.compile_state.current_path.</span>
        <span class="s0"># so, this means these options have to be the ones from the</span>
        <span class="s0"># *cached* statement that's travelling with compile_state, not the</span>
        <span class="s0"># *current* statement which won't match up for an ad-hoc</span>
        <span class="s0"># AliasedClass</span>
        <span class="s1">self.propagated_loader_options = tuple(</span>
            <span class="s1">opt._adapt_cached_option_to_uncached_option(self</span><span class="s4">, </span><span class="s1">uncached_opt)</span>
            <span class="s2">for </span><span class="s1">opt</span><span class="s4">, </span><span class="s1">uncached_opt </span><span class="s2">in </span><span class="s1">zip(cached_options</span><span class="s4">, </span><span class="s1">uncached_options)</span>
            <span class="s2">if </span><span class="s1">opt.propagate_to_loaders</span>
        <span class="s1">)</span>

        <span class="s1">self.attributes = dict(compile_state.attributes)</span>

        <span class="s1">self.autoflush = load_options._autoflush</span>
        <span class="s1">self.populate_existing = load_options._populate_existing</span>
        <span class="s1">self.invoke_all_eagers = load_options._invoke_all_eagers</span>
        <span class="s1">self.version_check = load_options._version_check</span>
        <span class="s1">self.refresh_state = load_options._refresh_state</span>
        <span class="s1">self.yield_per = load_options._yield_per</span>
        <span class="s1">self.identity_token = load_options._identity_token</span>

    <span class="s2">def </span><span class="s1">_get_top_level_context(self) -&gt; QueryContext:</span>
        <span class="s2">return </span><span class="s1">self.top_level_context </span><span class="s2">or </span><span class="s1">self</span>


<span class="s1">_orm_load_exec_options = util.immutabledict(</span>
    <span class="s1">{</span><span class="s3">&quot;_result_disable_adapt_to_context&quot;</span><span class="s1">: </span><span class="s2">True</span><span class="s1">}</span>
<span class="s1">)</span>


<span class="s2">class </span><span class="s1">AbstractORMCompileState(CompileState):</span>
    <span class="s1">is_dml_returning = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">_init_global_attributes(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">statement</span><span class="s4">, </span><span class="s1">compiler</span><span class="s4">, </span><span class="s1">*</span><span class="s4">, </span><span class="s1">toplevel</span><span class="s4">, </span><span class="s1">process_criteria_for_toplevel</span>
    <span class="s1">):</span>
        <span class="s1">self.attributes = {}</span>

        <span class="s2">if </span><span class="s1">compiler </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s0"># this is the legacy / testing only ORM _compile_state() use case.</span>
            <span class="s0"># there is no need to apply criteria options for this.</span>
            <span class="s1">self.global_attributes = ga = {}</span>
            <span class="s2">assert </span><span class="s1">toplevel</span>
            <span class="s2">return</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.global_attributes = ga = compiler._global_attributes</span>

        <span class="s2">if </span><span class="s1">toplevel:</span>
            <span class="s1">ga[</span><span class="s3">&quot;toplevel_orm&quot;</span><span class="s1">] = </span><span class="s2">True</span>

            <span class="s2">if </span><span class="s1">process_criteria_for_toplevel:</span>
                <span class="s2">for </span><span class="s1">opt </span><span class="s2">in </span><span class="s1">statement._with_options:</span>
                    <span class="s2">if </span><span class="s1">opt._is_criteria_option:</span>
                        <span class="s1">opt.process_compile_state(self)</span>

            <span class="s2">return</span>
        <span class="s2">elif </span><span class="s1">ga.get(</span><span class="s3">&quot;toplevel_orm&quot;</span><span class="s4">, </span><span class="s2">False</span><span class="s1">):</span>
            <span class="s2">return</span>

        <span class="s1">stack_0 = compiler.stack[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">toplevel_stmt = stack_0[</span><span class="s3">&quot;selectable&quot;</span><span class="s1">]</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s2">pass</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">opt </span><span class="s2">in </span><span class="s1">toplevel_stmt._with_options:</span>
                <span class="s2">if </span><span class="s1">opt._is_compile_state </span><span class="s2">and </span><span class="s1">opt._is_criteria_option:</span>
                    <span class="s1">opt.process_compile_state(self)</span>

        <span class="s1">ga[</span><span class="s3">&quot;toplevel_orm&quot;</span><span class="s1">] = </span><span class="s2">True</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">create_for_statement(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">statement: Union[Select</span><span class="s4">, </span><span class="s1">FromStatement]</span><span class="s4">,</span>
        <span class="s1">compiler: Optional[SQLCompiler]</span><span class="s4">,</span>
        <span class="s1">**kw: Any</span><span class="s4">,</span>
    <span class="s1">) -&gt; AbstractORMCompileState:</span>
        <span class="s6">&quot;&quot;&quot;Create a context for a statement given a :class:`.Compiler`. 
 
        This method is always invoked in the context of SQLCompiler.process(). 
 
        For a Select object, this would be invoked from 
        SQLCompiler.visit_select(). For the special FromStatement object used 
        by Query to indicate &quot;Query.from_statement()&quot;, this is called by 
        FromStatement._compiler_dispatch() that would be called by 
        SQLCompiler.process(). 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">super().create_for_statement(statement</span><span class="s4">, </span><span class="s1">compiler</span><span class="s4">, </span><span class="s1">**kw)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">orm_pre_session_exec(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">session</span><span class="s4">,</span>
        <span class="s1">statement</span><span class="s4">,</span>
        <span class="s1">params</span><span class="s4">,</span>
        <span class="s1">execution_options</span><span class="s4">,</span>
        <span class="s1">bind_arguments</span><span class="s4">,</span>
        <span class="s1">is_pre_event</span><span class="s4">,</span>
    <span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">orm_execute_statement(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">session</span><span class="s4">,</span>
        <span class="s1">statement</span><span class="s4">,</span>
        <span class="s1">params</span><span class="s4">,</span>
        <span class="s1">execution_options</span><span class="s4">,</span>
        <span class="s1">bind_arguments</span><span class="s4">,</span>
        <span class="s1">conn</span><span class="s4">,</span>
    <span class="s1">) -&gt; Result:</span>
        <span class="s1">result = conn.execute(</span>
            <span class="s1">statement</span><span class="s4">, </span><span class="s1">params </span><span class="s2">or </span><span class="s1">{}</span><span class="s4">, </span><span class="s1">execution_options=execution_options</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">cls.orm_setup_cursor_result(</span>
            <span class="s1">session</span><span class="s4">,</span>
            <span class="s1">statement</span><span class="s4">,</span>
            <span class="s1">params</span><span class="s4">,</span>
            <span class="s1">execution_options</span><span class="s4">,</span>
            <span class="s1">bind_arguments</span><span class="s4">,</span>
            <span class="s1">result</span><span class="s4">,</span>
        <span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">orm_setup_cursor_result(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">session</span><span class="s4">,</span>
        <span class="s1">statement</span><span class="s4">,</span>
        <span class="s1">params</span><span class="s4">,</span>
        <span class="s1">execution_options</span><span class="s4">,</span>
        <span class="s1">bind_arguments</span><span class="s4">,</span>
        <span class="s1">result</span><span class="s4">,</span>
    <span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError()</span>


<span class="s2">class </span><span class="s1">AutoflushOnlyORMCompileState(AbstractORMCompileState):</span>
    <span class="s6">&quot;&quot;&quot;ORM compile state that is a passthrough, except for autoflush.&quot;&quot;&quot;</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">orm_pre_session_exec(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">session</span><span class="s4">,</span>
        <span class="s1">statement</span><span class="s4">,</span>
        <span class="s1">params</span><span class="s4">,</span>
        <span class="s1">execution_options</span><span class="s4">,</span>
        <span class="s1">bind_arguments</span><span class="s4">,</span>
        <span class="s1">is_pre_event</span><span class="s4">,</span>
    <span class="s1">):</span>
        <span class="s0"># consume result-level load_options.  These may have been set up</span>
        <span class="s0"># in an ORMExecuteState hook</span>
        <span class="s1">(</span>
            <span class="s1">load_options</span><span class="s4">,</span>
            <span class="s1">execution_options</span><span class="s4">,</span>
        <span class="s1">) = QueryContext.default_load_options.from_execution_options(</span>
            <span class="s3">&quot;_sa_orm_load_options&quot;</span><span class="s4">,</span>
            <span class="s1">{</span>
                <span class="s3">&quot;autoflush&quot;</span><span class="s4">,</span>
            <span class="s1">}</span><span class="s4">,</span>
            <span class="s1">execution_options</span><span class="s4">,</span>
            <span class="s1">statement._execution_options</span><span class="s4">,</span>
        <span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">is_pre_event </span><span class="s2">and </span><span class="s1">load_options._autoflush:</span>
            <span class="s1">session._autoflush()</span>

        <span class="s2">return </span><span class="s1">statement</span><span class="s4">, </span><span class="s1">execution_options</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">orm_setup_cursor_result(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">session</span><span class="s4">,</span>
        <span class="s1">statement</span><span class="s4">,</span>
        <span class="s1">params</span><span class="s4">,</span>
        <span class="s1">execution_options</span><span class="s4">,</span>
        <span class="s1">bind_arguments</span><span class="s4">,</span>
        <span class="s1">result</span><span class="s4">,</span>
    <span class="s1">):</span>
        <span class="s2">return </span><span class="s1">result</span>


<span class="s2">class </span><span class="s1">ORMCompileState(AbstractORMCompileState):</span>
    <span class="s2">class </span><span class="s1">default_compile_options(CacheableOptions):</span>
        <span class="s1">_cache_key_traversal = [</span>
            <span class="s1">(</span><span class="s3">&quot;_use_legacy_query_style&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal.dp_boolean)</span><span class="s4">,</span>
            <span class="s1">(</span><span class="s3">&quot;_for_statement&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal.dp_boolean)</span><span class="s4">,</span>
            <span class="s1">(</span><span class="s3">&quot;_bake_ok&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal.dp_boolean)</span><span class="s4">,</span>
            <span class="s1">(</span><span class="s3">&quot;_current_path&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal.dp_has_cache_key)</span><span class="s4">,</span>
            <span class="s1">(</span><span class="s3">&quot;_enable_single_crit&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal.dp_boolean)</span><span class="s4">,</span>
            <span class="s1">(</span><span class="s3">&quot;_enable_eagerloads&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal.dp_boolean)</span><span class="s4">,</span>
            <span class="s1">(</span><span class="s3">&quot;_only_load_props&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal.dp_plain_obj)</span><span class="s4">,</span>
            <span class="s1">(</span><span class="s3">&quot;_set_base_alias&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal.dp_boolean)</span><span class="s4">,</span>
            <span class="s1">(</span><span class="s3">&quot;_for_refresh_state&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal.dp_boolean)</span><span class="s4">,</span>
            <span class="s1">(</span><span class="s3">&quot;_render_for_subquery&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal.dp_boolean)</span><span class="s4">,</span>
            <span class="s1">(</span><span class="s3">&quot;_is_star&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal.dp_boolean)</span><span class="s4">,</span>
        <span class="s1">]</span>

        <span class="s0"># set to True by default from Query._statement_20(), to indicate</span>
        <span class="s0"># the rendered query should look like a legacy ORM query.  right</span>
        <span class="s0"># now this basically indicates we should use tablename_columnname</span>
        <span class="s0"># style labels.    Generally indicates the statement originated</span>
        <span class="s0"># from a Query object.</span>
        <span class="s1">_use_legacy_query_style = </span><span class="s2">False</span>

        <span class="s0"># set *only* when we are coming from the Query.statement</span>
        <span class="s0"># accessor, or a Query-level equivalent such as</span>
        <span class="s0"># query.subquery().  this supersedes &quot;toplevel&quot;.</span>
        <span class="s1">_for_statement = </span><span class="s2">False</span>

        <span class="s1">_bake_ok = </span><span class="s2">True</span>
        <span class="s1">_current_path = _path_registry</span>
        <span class="s1">_enable_single_crit = </span><span class="s2">True</span>
        <span class="s1">_enable_eagerloads = </span><span class="s2">True</span>
        <span class="s1">_only_load_props = </span><span class="s2">None</span>
        <span class="s1">_set_base_alias = </span><span class="s2">False</span>
        <span class="s1">_for_refresh_state = </span><span class="s2">False</span>
        <span class="s1">_render_for_subquery = </span><span class="s2">False</span>
        <span class="s1">_is_star = </span><span class="s2">False</span>

    <span class="s1">attributes: Dict[Any</span><span class="s4">, </span><span class="s1">Any]</span>
    <span class="s1">global_attributes: Dict[Any</span><span class="s4">, </span><span class="s1">Any]</span>

    <span class="s1">statement: Union[Select[Any]</span><span class="s4">, </span><span class="s1">FromStatement[Any]]</span>
    <span class="s1">select_statement: Union[Select[Any]</span><span class="s4">, </span><span class="s1">FromStatement[Any]]</span>
    <span class="s1">_entities: List[_QueryEntity]</span>
    <span class="s1">_polymorphic_adapters: Dict[_InternalEntityType</span><span class="s4">, </span><span class="s1">ORMAdapter]</span>
    <span class="s1">compile_options: Union[</span>
        <span class="s1">Type[default_compile_options]</span><span class="s4">, </span><span class="s1">default_compile_options</span>
    <span class="s1">]</span>
    <span class="s1">_primary_entity: Optional[_QueryEntity]</span>
    <span class="s1">use_legacy_query_style: bool</span>
    <span class="s1">_label_convention: _LabelConventionCallable</span>
    <span class="s1">primary_columns: List[ColumnElement[Any]]</span>
    <span class="s1">secondary_columns: List[ColumnElement[Any]]</span>
    <span class="s1">dedupe_columns: Set[ColumnElement[Any]]</span>
    <span class="s1">create_eager_joins: List[</span>
        <span class="s0"># TODO: this structure is set up by JoinedLoader</span>
        <span class="s1">Tuple[Any</span><span class="s4">, </span><span class="s1">...]</span>
    <span class="s1">]</span>
    <span class="s1">current_path: PathRegistry = _path_registry</span>
    <span class="s1">_has_mapper_entities = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">*arg</span><span class="s4">, </span><span class="s1">**kw):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>

        <span class="s1">@classmethod</span>
        <span class="s2">def </span><span class="s1">create_for_statement(</span>
            <span class="s1">cls</span><span class="s4">,</span>
            <span class="s1">statement: Union[Select</span><span class="s4">, </span><span class="s1">FromStatement]</span><span class="s4">,</span>
            <span class="s1">compiler: Optional[SQLCompiler]</span><span class="s4">,</span>
            <span class="s1">**kw: Any</span><span class="s4">,</span>
        <span class="s1">) -&gt; ORMCompileState: ...</span>

    <span class="s2">def </span><span class="s1">_append_dedupe_col_collection(self</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">, </span><span class="s1">col_collection):</span>
        <span class="s1">dedupe = self.dedupe_columns</span>
        <span class="s2">if </span><span class="s1">obj </span><span class="s2">not in </span><span class="s1">dedupe:</span>
            <span class="s1">dedupe.add(obj)</span>
            <span class="s1">col_collection.append(obj)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_column_naming_convention(</span>
        <span class="s1">cls</span><span class="s4">, </span><span class="s1">label_style: SelectLabelStyle</span><span class="s4">, </span><span class="s1">legacy: bool</span>
    <span class="s1">) -&gt; _LabelConventionCallable:</span>
        <span class="s2">if </span><span class="s1">legacy:</span>

            <span class="s2">def </span><span class="s1">name(col</span><span class="s4">, </span><span class="s1">col_name=</span><span class="s2">None</span><span class="s1">):</span>
                <span class="s2">if </span><span class="s1">col_name:</span>
                    <span class="s2">return </span><span class="s1">col_name</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">getattr(col</span><span class="s4">, </span><span class="s3">&quot;key&quot;</span><span class="s1">)</span>

            <span class="s2">return </span><span class="s1">name</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">SelectState._column_naming_convention(label_style)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">get_column_descriptions(cls</span><span class="s4">, </span><span class="s1">statement):</span>
        <span class="s2">return </span><span class="s1">_column_descriptions(statement)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">orm_pre_session_exec(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">session</span><span class="s4">,</span>
        <span class="s1">statement</span><span class="s4">,</span>
        <span class="s1">params</span><span class="s4">,</span>
        <span class="s1">execution_options</span><span class="s4">,</span>
        <span class="s1">bind_arguments</span><span class="s4">,</span>
        <span class="s1">is_pre_event</span><span class="s4">,</span>
    <span class="s1">):</span>
        <span class="s0"># consume result-level load_options.  These may have been set up</span>
        <span class="s0"># in an ORMExecuteState hook</span>
        <span class="s1">(</span>
            <span class="s1">load_options</span><span class="s4">,</span>
            <span class="s1">execution_options</span><span class="s4">,</span>
        <span class="s1">) = QueryContext.default_load_options.from_execution_options(</span>
            <span class="s3">&quot;_sa_orm_load_options&quot;</span><span class="s4">,</span>
            <span class="s1">{</span>
                <span class="s3">&quot;populate_existing&quot;</span><span class="s4">,</span>
                <span class="s3">&quot;autoflush&quot;</span><span class="s4">,</span>
                <span class="s3">&quot;yield_per&quot;</span><span class="s4">,</span>
                <span class="s3">&quot;identity_token&quot;</span><span class="s4">,</span>
                <span class="s3">&quot;sa_top_level_orm_context&quot;</span><span class="s4">,</span>
            <span class="s1">}</span><span class="s4">,</span>
            <span class="s1">execution_options</span><span class="s4">,</span>
            <span class="s1">statement._execution_options</span><span class="s4">,</span>
        <span class="s1">)</span>

        <span class="s0"># default execution options for ORM results:</span>
        <span class="s0"># 1. _result_disable_adapt_to_context=True</span>
        <span class="s0">#    this will disable the ResultSetMetadata._adapt_to_context()</span>
        <span class="s0">#    step which we don't need, as we have result processors cached</span>
        <span class="s0">#    against the original SELECT statement before caching.</span>

        <span class="s2">if </span><span class="s3">&quot;sa_top_level_orm_context&quot; </span><span class="s2">in </span><span class="s1">execution_options:</span>
            <span class="s1">ctx = execution_options[</span><span class="s3">&quot;sa_top_level_orm_context&quot;</span><span class="s1">]</span>
            <span class="s1">execution_options = ctx.query._execution_options.merge_with(</span>
                <span class="s1">ctx.execution_options</span><span class="s4">, </span><span class="s1">execution_options</span>
            <span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">execution_options:</span>
            <span class="s1">execution_options = _orm_load_exec_options</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">execution_options = execution_options.union(_orm_load_exec_options)</span>

        <span class="s0"># would have been placed here by legacy Query only</span>
        <span class="s2">if </span><span class="s1">load_options._yield_per:</span>
            <span class="s1">execution_options = execution_options.union(</span>
                <span class="s1">{</span><span class="s3">&quot;yield_per&quot;</span><span class="s1">: load_options._yield_per}</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">getattr(statement._compile_options</span><span class="s4">, </span><span class="s3">&quot;_current_path&quot;</span><span class="s4">, </span><span class="s2">None</span><span class="s1">)</span>
            <span class="s2">and </span><span class="s1">len(statement._compile_options._current_path) &gt; </span><span class="s5">10</span>
            <span class="s2">and </span><span class="s1">execution_options.get(</span><span class="s3">&quot;compiled_cache&quot;</span><span class="s4">, </span><span class="s2">True</span><span class="s1">) </span><span class="s2">is not None</span>
        <span class="s1">):</span>
            <span class="s1">execution_options: util.immutabledict[str</span><span class="s4">, </span><span class="s1">Any] = (</span>
                <span class="s1">execution_options.union(</span>
                    <span class="s1">{</span>
                        <span class="s3">&quot;compiled_cache&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s4">,</span>
                        <span class="s3">&quot;_cache_disable_reason&quot;</span><span class="s1">: </span><span class="s3">&quot;excess depth for &quot;</span>
                        <span class="s3">&quot;ORM loader options&quot;</span><span class="s4">,</span>
                    <span class="s1">}</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">bind_arguments[</span><span class="s3">&quot;clause&quot;</span><span class="s1">] = statement</span>

        <span class="s0"># new in 1.4 - the coercions system is leveraged to allow the</span>
        <span class="s0"># &quot;subject&quot; mapper of a statement be propagated to the top</span>
        <span class="s0"># as the statement is built.   &quot;subject&quot; mapper is the generally</span>
        <span class="s0"># standard object used as an identifier for multi-database schemes.</span>

        <span class="s0"># we are here based on the fact that _propagate_attrs contains</span>
        <span class="s0"># &quot;compile_state_plugin&quot;: &quot;orm&quot;.   The &quot;plugin_subject&quot;</span>
        <span class="s0"># needs to be present as well.</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">plugin_subject = statement._propagate_attrs[</span><span class="s3">&quot;plugin_subject&quot;</span><span class="s1">]</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s2">assert False</span><span class="s4">, </span><span class="s3">&quot;statement had 'orm' plugin but no plugin_subject&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">plugin_subject:</span>
                <span class="s1">bind_arguments[</span><span class="s3">&quot;mapper&quot;</span><span class="s1">] = plugin_subject.mapper</span>

        <span class="s2">if not </span><span class="s1">is_pre_event </span><span class="s2">and </span><span class="s1">load_options._autoflush:</span>
            <span class="s1">session._autoflush()</span>

        <span class="s2">return </span><span class="s1">statement</span><span class="s4">, </span><span class="s1">execution_options</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">orm_setup_cursor_result(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">session</span><span class="s4">,</span>
        <span class="s1">statement</span><span class="s4">,</span>
        <span class="s1">params</span><span class="s4">,</span>
        <span class="s1">execution_options</span><span class="s4">,</span>
        <span class="s1">bind_arguments</span><span class="s4">,</span>
        <span class="s1">result</span><span class="s4">,</span>
    <span class="s1">):</span>
        <span class="s1">execution_context = result.context</span>
        <span class="s1">compile_state = execution_context.compiled.compile_state</span>

        <span class="s0"># cover edge case where ORM entities used in legacy select</span>
        <span class="s0"># were passed to session.execute:</span>
        <span class="s0"># session.execute(legacy_select([User.id, User.name]))</span>
        <span class="s0"># see test_query-&gt;test_legacy_tuple_old_select</span>

        <span class="s1">load_options = execution_options.get(</span>
            <span class="s3">&quot;_sa_orm_load_options&quot;</span><span class="s4">, </span><span class="s1">QueryContext.default_load_options</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">compile_state.compile_options._is_star:</span>
            <span class="s2">return </span><span class="s1">result</span>

        <span class="s1">querycontext = QueryContext(</span>
            <span class="s1">compile_state</span><span class="s4">,</span>
            <span class="s1">statement</span><span class="s4">,</span>
            <span class="s1">statement</span><span class="s4">,</span>
            <span class="s1">params</span><span class="s4">,</span>
            <span class="s1">session</span><span class="s4">,</span>
            <span class="s1">load_options</span><span class="s4">,</span>
            <span class="s1">execution_options</span><span class="s4">,</span>
            <span class="s1">bind_arguments</span><span class="s4">,</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">loading.instances(result</span><span class="s4">, </span><span class="s1">querycontext)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_lead_mapper_entities(self):</span>
        <span class="s6">&quot;&quot;&quot;return all _MapperEntity objects in the lead entities collection. 
 
        Does **not** include entities that have been replaced by 
        with_entities(), with_only_columns() 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">[</span>
            <span class="s1">ent </span><span class="s2">for </span><span class="s1">ent </span><span class="s2">in </span><span class="s1">self._entities </span><span class="s2">if </span><span class="s1">isinstance(ent</span><span class="s4">, </span><span class="s1">_MapperEntity)</span>
        <span class="s1">]</span>

    <span class="s2">def </span><span class="s1">_create_with_polymorphic_adapter(self</span><span class="s4">, </span><span class="s1">ext_info</span><span class="s4">, </span><span class="s1">selectable):</span>
        <span class="s6">&quot;&quot;&quot;given MapperEntity or ORMColumnEntity, setup polymorphic loading 
        if called for by the Mapper. 
 
        As of #8168 in 2.0.0rc1, polymorphic adapters, which greatly increase 
        the complexity of the query creation process, are not used at all 
        except in the quasi-legacy cases of with_polymorphic referring to an 
        alias and/or subquery. This would apply to concrete polymorphic 
        loading, and joined inheritance where a subquery is 
        passed to with_polymorphic (which is completely unnecessary in modern 
        use). 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s2">not </span><span class="s1">ext_info.is_aliased_class</span>
            <span class="s2">and </span><span class="s1">ext_info.mapper.persist_selectable</span>
            <span class="s2">not in </span><span class="s1">self._polymorphic_adapters</span>
        <span class="s1">):</span>
            <span class="s2">for </span><span class="s1">mp </span><span class="s2">in </span><span class="s1">ext_info.mapper.iterate_to_root():</span>
                <span class="s1">self._mapper_loads_polymorphically_with(</span>
                    <span class="s1">mp</span><span class="s4">,</span>
                    <span class="s1">ORMAdapter(</span>
                        <span class="s1">_TraceAdaptRole.WITH_POLYMORPHIC_ADAPTER</span><span class="s4">,</span>
                        <span class="s1">mp</span><span class="s4">,</span>
                        <span class="s1">equivalents=mp._equivalent_columns</span><span class="s4">,</span>
                        <span class="s1">selectable=selectable</span><span class="s4">,</span>
                    <span class="s1">)</span><span class="s4">,</span>
                <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_mapper_loads_polymorphically_with(self</span><span class="s4">, </span><span class="s1">mapper</span><span class="s4">, </span><span class="s1">adapter):</span>
        <span class="s2">for </span><span class="s1">m2 </span><span class="s2">in </span><span class="s1">mapper._with_polymorphic_mappers </span><span class="s2">or </span><span class="s1">[mapper]:</span>
            <span class="s1">self._polymorphic_adapters[m2] = adapter</span>

            <span class="s2">for </span><span class="s1">m </span><span class="s2">in </span><span class="s1">m2.iterate_to_root():</span>
                <span class="s1">self._polymorphic_adapters[m.local_table] = adapter</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_create_entities_collection(cls</span><span class="s4">, </span><span class="s1">query</span><span class="s4">, </span><span class="s1">legacy):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span>
            <span class="s3">&quot;this method only works for ORMSelectCompileState&quot;</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">DMLReturningColFilter:</span>
    <span class="s6">&quot;&quot;&quot;an adapter used for the DML RETURNING case. 
 
    Has a subset of the interface used by 
    :class:`.ORMAdapter` and is used for :class:`._QueryEntity` 
    instances to set up their columns as used in RETURNING for a 
    DML statement. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ = (</span><span class="s3">&quot;mapper&quot;</span><span class="s4">, </span><span class="s3">&quot;columns&quot;</span><span class="s4">, </span><span class="s3">&quot;__weakref__&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">target_mapper</span><span class="s4">, </span><span class="s1">immediate_dml_mapper):</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">immediate_dml_mapper </span><span class="s2">is not None</span>
            <span class="s2">and </span><span class="s1">target_mapper.local_table</span>
            <span class="s2">is not </span><span class="s1">immediate_dml_mapper.local_table</span>
        <span class="s1">):</span>
            <span class="s0"># joined inh, or in theory other kinds of multi-table mappings</span>
            <span class="s1">self.mapper = immediate_dml_mapper</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># single inh, normal mappings, etc.</span>
            <span class="s1">self.mapper = target_mapper</span>
        <span class="s1">self.columns = self.columns = util.WeakPopulateDict(</span>
            <span class="s1">self.adapt_check_present  </span><span class="s0"># type: ignore</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s4">, </span><span class="s1">col</span><span class="s4">, </span><span class="s1">as_filter):</span>
        <span class="s2">for </span><span class="s1">cc </span><span class="s2">in </span><span class="s1">sql_util._find_columns(col):</span>
            <span class="s1">c2 = self.adapt_check_present(cc)</span>
            <span class="s2">if </span><span class="s1">c2 </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">col</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">adapt_check_present(self</span><span class="s4">, </span><span class="s1">col):</span>
        <span class="s1">mapper = self.mapper</span>
        <span class="s1">prop = mapper._columntoproperty.get(col</span><span class="s4">, </span><span class="s2">None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">prop </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return None</span>
        <span class="s2">return </span><span class="s1">mapper.local_table.c.corresponding_column(col)</span>


<span class="s1">@sql.base.CompileState.plugin_for(</span><span class="s3">&quot;orm&quot;</span><span class="s4">, </span><span class="s3">&quot;orm_from_statement&quot;</span><span class="s1">)</span>
<span class="s2">class </span><span class="s1">ORMFromStatementCompileState(ORMCompileState):</span>
    <span class="s1">_from_obj_alias = </span><span class="s2">None</span>
    <span class="s1">_has_mapper_entities = </span><span class="s2">False</span>

    <span class="s1">statement_container: FromStatement</span>
    <span class="s1">requested_statement: Union[SelectBase</span><span class="s4">, </span><span class="s1">TextClause</span><span class="s4">, </span><span class="s1">UpdateBase]</span>
    <span class="s1">dml_table: Optional[_DMLTableElement] = </span><span class="s2">None</span>

    <span class="s1">_has_orm_entities = </span><span class="s2">False</span>
    <span class="s1">multi_row_eager_loaders = </span><span class="s2">False</span>
    <span class="s1">eager_adding_joins = </span><span class="s2">False</span>
    <span class="s1">compound_eager_adapter = </span><span class="s2">None</span>

    <span class="s1">extra_criteria_entities = _EMPTY_DICT</span>
    <span class="s1">eager_joins = _EMPTY_DICT</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">create_for_statement(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">statement_container: Union[Select</span><span class="s4">, </span><span class="s1">FromStatement]</span><span class="s4">,</span>
        <span class="s1">compiler: Optional[SQLCompiler]</span><span class="s4">,</span>
        <span class="s1">**kw: Any</span><span class="s4">,</span>
    <span class="s1">) -&gt; ORMFromStatementCompileState:</span>
        <span class="s2">assert </span><span class="s1">isinstance(statement_container</span><span class="s4">, </span><span class="s1">FromStatement)</span>

        <span class="s2">if </span><span class="s1">compiler </span><span class="s2">is not None and </span><span class="s1">compiler.stack:</span>
            <span class="s2">raise </span><span class="s1">sa_exc.CompileError(</span>
                <span class="s3">&quot;The ORM FromStatement construct only supports being &quot;</span>
                <span class="s3">&quot;invoked as the topmost statement, as it is only intended to &quot;</span>
                <span class="s3">&quot;define how result rows should be returned.&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self = cls.__new__(cls)</span>
        <span class="s1">self._primary_entity = </span><span class="s2">None</span>

        <span class="s1">self.use_legacy_query_style = (</span>
            <span class="s1">statement_container._compile_options._use_legacy_query_style</span>
        <span class="s1">)</span>
        <span class="s1">self.statement_container = self.select_statement = statement_container</span>
        <span class="s1">self.requested_statement = statement = statement_container.element</span>

        <span class="s2">if </span><span class="s1">statement.is_dml:</span>
            <span class="s1">self.dml_table = statement.table</span>
            <span class="s1">self.is_dml_returning = </span><span class="s2">True</span>

        <span class="s1">self._entities = []</span>
        <span class="s1">self._polymorphic_adapters = {}</span>

        <span class="s1">self.compile_options = statement_container._compile_options</span>

        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">self.use_legacy_query_style</span>
            <span class="s2">and </span><span class="s1">isinstance(statement</span><span class="s4">, </span><span class="s1">expression.SelectBase)</span>
            <span class="s2">and not </span><span class="s1">statement._is_textual</span>
            <span class="s2">and not </span><span class="s1">statement.is_dml</span>
            <span class="s2">and </span><span class="s1">statement._label_style </span><span class="s2">is </span><span class="s1">LABEL_STYLE_NONE</span>
        <span class="s1">):</span>
            <span class="s1">self.statement = statement.set_label_style(</span>
                <span class="s1">LABEL_STYLE_TABLENAME_PLUS_COL</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.statement = statement</span>

        <span class="s1">self._label_convention = self._column_naming_convention(</span>
            <span class="s1">(</span>
                <span class="s1">statement._label_style</span>
                <span class="s2">if not </span><span class="s1">statement._is_textual </span><span class="s2">and not </span><span class="s1">statement.is_dml</span>
                <span class="s2">else </span><span class="s1">LABEL_STYLE_NONE</span>
            <span class="s1">)</span><span class="s4">,</span>
            <span class="s1">self.use_legacy_query_style</span><span class="s4">,</span>
        <span class="s1">)</span>

        <span class="s1">_QueryEntity.to_compile_state(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">statement_container._raw_columns</span><span class="s4">,</span>
            <span class="s1">self._entities</span><span class="s4">,</span>
            <span class="s1">is_current_entities=</span><span class="s2">True</span><span class="s4">,</span>
        <span class="s1">)</span>

        <span class="s1">self.current_path = statement_container._compile_options._current_path</span>

        <span class="s1">self._init_global_attributes(</span>
            <span class="s1">statement_container</span><span class="s4">,</span>
            <span class="s1">compiler</span><span class="s4">,</span>
            <span class="s1">process_criteria_for_toplevel=</span><span class="s2">False</span><span class="s4">,</span>
            <span class="s1">toplevel=</span><span class="s2">True</span><span class="s4">,</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">statement_container._with_options:</span>
            <span class="s2">for </span><span class="s1">opt </span><span class="s2">in </span><span class="s1">statement_container._with_options:</span>
                <span class="s2">if </span><span class="s1">opt._is_compile_state:</span>
                    <span class="s1">opt.process_compile_state(self)</span>

        <span class="s2">if </span><span class="s1">statement_container._with_context_options:</span>
            <span class="s2">for </span><span class="s1">fn</span><span class="s4">, </span><span class="s1">key </span><span class="s2">in </span><span class="s1">statement_container._with_context_options:</span>
                <span class="s1">fn(self)</span>

        <span class="s1">self.primary_columns = []</span>
        <span class="s1">self.secondary_columns = []</span>
        <span class="s1">self.dedupe_columns = set()</span>
        <span class="s1">self.create_eager_joins = []</span>
        <span class="s1">self._fallback_from_clauses = []</span>

        <span class="s1">self.order_by = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">isinstance(self.statement</span><span class="s4">, </span><span class="s1">expression.TextClause):</span>
            <span class="s0"># TextClause has no &quot;column&quot; objects at all.  for this case,</span>
            <span class="s0"># we generate columns from our _QueryEntity objects, then</span>
            <span class="s0"># flip on all the &quot;please match no matter what&quot; parameters.</span>
            <span class="s1">self.extra_criteria_entities = {}</span>

            <span class="s2">for </span><span class="s1">entity </span><span class="s2">in </span><span class="s1">self._entities:</span>
                <span class="s1">entity.setup_compile_state(self)</span>

            <span class="s1">compiler._ordered_columns = compiler._textual_ordered_columns = (</span>
                <span class="s2">False</span>
            <span class="s1">)</span>

            <span class="s0"># enable looser result column matching.  this is shown to be</span>
            <span class="s0"># needed by test_query.py::TextTest</span>
            <span class="s1">compiler._loose_column_name_matching = </span><span class="s2">True</span>

            <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">self.primary_columns:</span>
                <span class="s1">compiler.process(</span>
                    <span class="s1">c</span><span class="s4">,</span>
                    <span class="s1">within_columns_clause=</span><span class="s2">True</span><span class="s4">,</span>
                    <span class="s1">add_to_result_map=compiler._add_to_result_map</span><span class="s4">,</span>
                <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># for everyone else, Select, Insert, Update, TextualSelect, they</span>
            <span class="s0"># have column objects already.  After much</span>
            <span class="s0"># experimentation here, the best approach seems to be, use</span>
            <span class="s0"># those columns completely, don't interfere with the compiler</span>
            <span class="s0"># at all; just in ORM land, use an adapter to convert from</span>
            <span class="s0"># our ORM columns to whatever columns are in the statement,</span>
            <span class="s0"># before we look in the result row. Adapt on names</span>
            <span class="s0"># to accept cases such as issue #9217, however also allow</span>
            <span class="s0"># this to be overridden for cases such as #9273.</span>
            <span class="s1">self._from_obj_alias = ORMStatementAdapter(</span>
                <span class="s1">_TraceAdaptRole.ADAPT_FROM_STATEMENT</span><span class="s4">,</span>
                <span class="s1">self.statement</span><span class="s4">,</span>
                <span class="s1">adapt_on_names=statement_container._adapt_on_names</span><span class="s4">,</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">_adapt_col_list(self</span><span class="s4">, </span><span class="s1">cols</span><span class="s4">, </span><span class="s1">current_adapter):</span>
        <span class="s2">return </span><span class="s1">cols</span>

    <span class="s2">def </span><span class="s1">_get_current_adapter(self):</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">setup_dml_returning_compile_state(self</span><span class="s4">, </span><span class="s1">dml_mapper):</span>
        <span class="s6">&quot;&quot;&quot;used by BulkORMInsert (and Update / Delete?) to set up a handler 
        for RETURNING to return ORM objects and expressions 
 
        &quot;&quot;&quot;</span>
        <span class="s1">target_mapper = self.statement._propagate_attrs.get(</span>
            <span class="s3">&quot;plugin_subject&quot;</span><span class="s4">, </span><span class="s2">None</span>
        <span class="s1">)</span>
        <span class="s1">adapter = DMLReturningColFilter(target_mapper</span><span class="s4">, </span><span class="s1">dml_mapper)</span>

        <span class="s2">if </span><span class="s1">self.compile_options._is_star </span><span class="s2">and </span><span class="s1">(len(self._entities) != </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">sa_exc.CompileError(</span>
                <span class="s3">&quot;Can't generate ORM query that includes multiple expressions &quot;</span>
                <span class="s3">&quot;at the same time as '*'; query for '*' alone if present&quot;</span>
            <span class="s1">)</span>

        <span class="s2">for </span><span class="s1">entity </span><span class="s2">in </span><span class="s1">self._entities:</span>
            <span class="s1">entity.setup_dml_returning_compile_state(self</span><span class="s4">, </span><span class="s1">adapter)</span>


<span class="s2">class </span><span class="s1">FromStatement(GroupedElement</span><span class="s4">, </span><span class="s1">Generative</span><span class="s4">, </span><span class="s1">TypedReturnsRows[_TP]):</span>
    <span class="s6">&quot;&quot;&quot;Core construct that represents a load of ORM objects from various 
    :class:`.ReturnsRows` and other classes including: 
 
    :class:`.Select`, :class:`.TextClause`, :class:`.TextualSelect`, 
    :class:`.CompoundSelect`, :class`.Insert`, :class:`.Update`, 
    and in theory, :class:`.Delete`. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ = </span><span class="s3">&quot;orm_from_statement&quot;</span>

    <span class="s1">_compile_options = ORMFromStatementCompileState.default_compile_options</span>

    <span class="s1">_compile_state_factory = ORMFromStatementCompileState.create_for_statement</span>

    <span class="s1">_for_update_arg = </span><span class="s2">None</span>

    <span class="s1">element: Union[ExecutableReturnsRows</span><span class="s4">, </span><span class="s1">TextClause]</span>

    <span class="s1">_adapt_on_names: bool</span>

    <span class="s1">_traverse_internals = [</span>
        <span class="s1">(</span><span class="s3">&quot;_raw_columns&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal.dp_clauseelement_list)</span><span class="s4">,</span>
        <span class="s1">(</span><span class="s3">&quot;element&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal.dp_clauseelement)</span><span class="s4">,</span>
    <span class="s1">] + Executable._executable_traverse_internals</span>

    <span class="s1">_cache_key_traversal = _traverse_internals + [</span>
        <span class="s1">(</span><span class="s3">&quot;_compile_options&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal.dp_has_cache_key)</span>
    <span class="s1">]</span>

    <span class="s1">is_from_statement = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">entities: Iterable[_ColumnsClauseArgument[Any]]</span><span class="s4">,</span>
        <span class="s1">element: Union[ExecutableReturnsRows</span><span class="s4">, </span><span class="s1">TextClause]</span><span class="s4">,</span>
        <span class="s1">_adapt_on_names: bool = </span><span class="s2">True</span><span class="s4">,</span>
    <span class="s1">):</span>
        <span class="s1">self._raw_columns = [</span>
            <span class="s1">coercions.expect(</span>
                <span class="s1">roles.ColumnsClauseRole</span><span class="s4">,</span>
                <span class="s1">ent</span><span class="s4">,</span>
                <span class="s1">apply_propagate_attrs=self</span><span class="s4">,</span>
                <span class="s1">post_inspect=</span><span class="s2">True</span><span class="s4">,</span>
            <span class="s1">)</span>
            <span class="s2">for </span><span class="s1">ent </span><span class="s2">in </span><span class="s1">util.to_list(entities)</span>
        <span class="s1">]</span>
        <span class="s1">self.element = element</span>
        <span class="s1">self.is_dml = element.is_dml</span>
        <span class="s1">self.is_select = element.is_select</span>
        <span class="s1">self.is_delete = element.is_delete</span>
        <span class="s1">self.is_insert = element.is_insert</span>
        <span class="s1">self.is_update = element.is_update</span>
        <span class="s1">self._label_style = (</span>
            <span class="s1">element._label_style </span><span class="s2">if </span><span class="s1">is_select_base(element) </span><span class="s2">else None</span>
        <span class="s1">)</span>
        <span class="s1">self._adapt_on_names = _adapt_on_names</span>

    <span class="s2">def </span><span class="s1">_compiler_dispatch(self</span><span class="s4">, </span><span class="s1">compiler</span><span class="s4">, </span><span class="s1">**kw):</span>
        <span class="s6">&quot;&quot;&quot;provide a fixed _compiler_dispatch method. 
 
        This is roughly similar to using the sqlalchemy.ext.compiler 
        ``@compiles`` extension. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">compile_state = self._compile_state_factory(self</span><span class="s4">, </span><span class="s1">compiler</span><span class="s4">, </span><span class="s1">**kw)</span>

        <span class="s1">toplevel = </span><span class="s2">not </span><span class="s1">compiler.stack</span>

        <span class="s2">if </span><span class="s1">toplevel:</span>
            <span class="s1">compiler.compile_state = compile_state</span>

        <span class="s2">return </span><span class="s1">compiler.process(compile_state.statement</span><span class="s4">, </span><span class="s1">**kw)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">column_descriptions(self):</span>
        <span class="s6">&quot;&quot;&quot;Return a :term:`plugin-enabled` 'column descriptions' structure 
        referring to the columns which are SELECTed by this statement. 
 
        See the section :ref:`queryguide_inspection` for an overview 
        of this feature. 
 
        .. seealso:: 
 
            :ref:`queryguide_inspection` - ORM background 
 
        &quot;&quot;&quot;</span>
        <span class="s1">meth = cast(</span>
            <span class="s1">ORMSelectCompileState</span><span class="s4">, </span><span class="s1">SelectState.get_plugin_class(self)</span>
        <span class="s1">).get_column_descriptions</span>
        <span class="s2">return </span><span class="s1">meth(self)</span>

    <span class="s2">def </span><span class="s1">_ensure_disambiguated_names(self):</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">get_children(self</span><span class="s4">, </span><span class="s1">**kw):</span>
        <span class="s2">yield from </span><span class="s1">itertools.chain.from_iterable(</span>
            <span class="s1">element._from_objects </span><span class="s2">for </span><span class="s1">element </span><span class="s2">in </span><span class="s1">self._raw_columns</span>
        <span class="s1">)</span>
        <span class="s2">yield from </span><span class="s1">super().get_children(**kw)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_all_selected_columns(self):</span>
        <span class="s2">return </span><span class="s1">self.element._all_selected_columns</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_return_defaults(self):</span>
        <span class="s2">return </span><span class="s1">self.element._return_defaults </span><span class="s2">if </span><span class="s1">is_dml(self.element) </span><span class="s2">else None</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_returning(self):</span>
        <span class="s2">return </span><span class="s1">self.element._returning </span><span class="s2">if </span><span class="s1">is_dml(self.element) </span><span class="s2">else None</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_inline(self):</span>
        <span class="s2">return </span><span class="s1">self.element._inline </span><span class="s2">if </span><span class="s1">is_insert_update(self.element) </span><span class="s2">else None</span>


<span class="s1">@sql.base.CompileState.plugin_for(</span><span class="s3">&quot;orm&quot;</span><span class="s4">, </span><span class="s3">&quot;compound_select&quot;</span><span class="s1">)</span>
<span class="s2">class </span><span class="s1">CompoundSelectCompileState(</span>
    <span class="s1">AutoflushOnlyORMCompileState</span><span class="s4">, </span><span class="s1">CompoundSelectState</span>
<span class="s1">):</span>
    <span class="s2">pass</span>


<span class="s1">@sql.base.CompileState.plugin_for(</span><span class="s3">&quot;orm&quot;</span><span class="s4">, </span><span class="s3">&quot;select&quot;</span><span class="s1">)</span>
<span class="s2">class </span><span class="s1">ORMSelectCompileState(ORMCompileState</span><span class="s4">, </span><span class="s1">SelectState):</span>
    <span class="s1">_already_joined_edges = ()</span>

    <span class="s1">_memoized_entities = _EMPTY_DICT</span>

    <span class="s1">_from_obj_alias = </span><span class="s2">None</span>
    <span class="s1">_has_mapper_entities = </span><span class="s2">False</span>

    <span class="s1">_has_orm_entities = </span><span class="s2">False</span>
    <span class="s1">multi_row_eager_loaders = </span><span class="s2">False</span>
    <span class="s1">eager_adding_joins = </span><span class="s2">False</span>
    <span class="s1">compound_eager_adapter = </span><span class="s2">None</span>

    <span class="s1">correlate = </span><span class="s2">None</span>
    <span class="s1">correlate_except = </span><span class="s2">None</span>
    <span class="s1">_where_criteria = ()</span>
    <span class="s1">_having_criteria = ()</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">create_for_statement(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">statement: Union[Select</span><span class="s4">, </span><span class="s1">FromStatement]</span><span class="s4">,</span>
        <span class="s1">compiler: Optional[SQLCompiler]</span><span class="s4">,</span>
        <span class="s1">**kw: Any</span><span class="s4">,</span>
    <span class="s1">) -&gt; ORMSelectCompileState:</span>
        <span class="s6">&quot;&quot;&quot;compiler hook, we arrive here from compiler.visit_select() only.&quot;&quot;&quot;</span>

        <span class="s1">self = cls.__new__(cls)</span>

        <span class="s2">if </span><span class="s1">compiler </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">toplevel = </span><span class="s2">not </span><span class="s1">compiler.stack</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">toplevel = </span><span class="s2">True</span>

        <span class="s1">select_statement = statement</span>

        <span class="s0"># if we are a select() that was never a legacy Query, we won't</span>
        <span class="s0"># have ORM level compile options.</span>
        <span class="s1">statement._compile_options = cls.default_compile_options.safe_merge(</span>
            <span class="s1">statement._compile_options</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">select_statement._execution_options:</span>
            <span class="s0"># execution options should not impact the compilation of a</span>
            <span class="s0"># query, and at the moment subqueryloader is putting some things</span>
            <span class="s0"># in here that we explicitly don't want stuck in a cache.</span>
            <span class="s1">self.select_statement = select_statement._clone()</span>
            <span class="s1">self.select_statement._execution_options = util.immutabledict()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.select_statement = select_statement</span>

        <span class="s0"># indicates this select() came from Query.statement</span>
        <span class="s1">self.for_statement = select_statement._compile_options._for_statement</span>

        <span class="s0"># generally if we are from Query or directly from a select()</span>
        <span class="s1">self.use_legacy_query_style = (</span>
            <span class="s1">select_statement._compile_options._use_legacy_query_style</span>
        <span class="s1">)</span>

        <span class="s1">self._entities = []</span>
        <span class="s1">self._primary_entity = </span><span class="s2">None</span>
        <span class="s1">self._polymorphic_adapters = {}</span>

        <span class="s1">self.compile_options = select_statement._compile_options</span>

        <span class="s2">if not </span><span class="s1">toplevel:</span>
            <span class="s0"># for subqueries, turn off eagerloads and set</span>
            <span class="s0"># &quot;render_for_subquery&quot;.</span>
            <span class="s1">self.compile_options += {</span>
                <span class="s3">&quot;_enable_eagerloads&quot;</span><span class="s1">: </span><span class="s2">False</span><span class="s4">,</span>
                <span class="s3">&quot;_render_for_subquery&quot;</span><span class="s1">: </span><span class="s2">True</span><span class="s4">,</span>
            <span class="s1">}</span>

        <span class="s0"># determine label style.   we can make different decisions here.</span>
        <span class="s0"># at the moment, trying to see if we can always use DISAMBIGUATE_ONLY</span>
        <span class="s0"># rather than LABEL_STYLE_NONE, and if we can use disambiguate style</span>
        <span class="s0"># for new style ORM selects too.</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">self.use_legacy_query_style</span>
            <span class="s2">and </span><span class="s1">self.select_statement._label_style </span><span class="s2">is </span><span class="s1">LABEL_STYLE_LEGACY_ORM</span>
        <span class="s1">):</span>
            <span class="s2">if not </span><span class="s1">self.for_statement:</span>
                <span class="s1">self.label_style = LABEL_STYLE_TABLENAME_PLUS_COL</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.label_style = LABEL_STYLE_DISAMBIGUATE_ONLY</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.label_style = self.select_statement._label_style</span>

        <span class="s2">if </span><span class="s1">select_statement._memoized_select_entities:</span>
            <span class="s1">self._memoized_entities = {</span>
                <span class="s1">memoized_entities: _QueryEntity.to_compile_state(</span>
                    <span class="s1">self</span><span class="s4">,</span>
                    <span class="s1">memoized_entities._raw_columns</span><span class="s4">,</span>
                    <span class="s1">[]</span><span class="s4">,</span>
                    <span class="s1">is_current_entities=</span><span class="s2">False</span><span class="s4">,</span>
                <span class="s1">)</span>
                <span class="s2">for </span><span class="s1">memoized_entities </span><span class="s2">in </span><span class="s1">(</span>
                    <span class="s1">select_statement._memoized_select_entities</span>
                <span class="s1">)</span>
            <span class="s1">}</span>

        <span class="s0"># label_convention is stateful and will yield deduping keys if it</span>
        <span class="s0"># sees the same key twice.  therefore it's important that it is not</span>
        <span class="s0"># invoked for the above &quot;memoized&quot; entities that aren't actually</span>
        <span class="s0"># in the columns clause</span>
        <span class="s1">self._label_convention = self._column_naming_convention(</span>
            <span class="s1">statement._label_style</span><span class="s4">, </span><span class="s1">self.use_legacy_query_style</span>
        <span class="s1">)</span>

        <span class="s1">_QueryEntity.to_compile_state(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">select_statement._raw_columns</span><span class="s4">,</span>
            <span class="s1">self._entities</span><span class="s4">,</span>
            <span class="s1">is_current_entities=</span><span class="s2">True</span><span class="s4">,</span>
        <span class="s1">)</span>

        <span class="s1">self.current_path = select_statement._compile_options._current_path</span>

        <span class="s1">self.eager_order_by = ()</span>

        <span class="s1">self._init_global_attributes(</span>
            <span class="s1">select_statement</span><span class="s4">,</span>
            <span class="s1">compiler</span><span class="s4">,</span>
            <span class="s1">toplevel=toplevel</span><span class="s4">,</span>
            <span class="s1">process_criteria_for_toplevel=</span><span class="s2">False</span><span class="s4">,</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">toplevel </span><span class="s2">and </span><span class="s1">(</span>
            <span class="s1">select_statement._with_options</span>
            <span class="s2">or </span><span class="s1">select_statement._memoized_select_entities</span>
        <span class="s1">):</span>
            <span class="s2">for </span><span class="s1">(</span>
                <span class="s1">memoized_entities</span>
            <span class="s1">) </span><span class="s2">in </span><span class="s1">select_statement._memoized_select_entities:</span>
                <span class="s2">for </span><span class="s1">opt </span><span class="s2">in </span><span class="s1">memoized_entities._with_options:</span>
                    <span class="s2">if </span><span class="s1">opt._is_compile_state:</span>
                        <span class="s1">opt.process_compile_state_replaced_entities(</span>
                            <span class="s1">self</span><span class="s4">,</span>
                            <span class="s1">[</span>
                                <span class="s1">ent</span>
                                <span class="s2">for </span><span class="s1">ent </span><span class="s2">in </span><span class="s1">self._memoized_entities[</span>
                                    <span class="s1">memoized_entities</span>
                                <span class="s1">]</span>
                                <span class="s2">if </span><span class="s1">isinstance(ent</span><span class="s4">, </span><span class="s1">_MapperEntity)</span>
                            <span class="s1">]</span><span class="s4">,</span>
                        <span class="s1">)</span>

            <span class="s2">for </span><span class="s1">opt </span><span class="s2">in </span><span class="s1">self.select_statement._with_options:</span>
                <span class="s2">if </span><span class="s1">opt._is_compile_state:</span>
                    <span class="s1">opt.process_compile_state(self)</span>

        <span class="s0"># uncomment to print out the context.attributes structure</span>
        <span class="s0"># after it's been set up above</span>
        <span class="s0"># self._dump_option_struct()</span>

        <span class="s2">if </span><span class="s1">select_statement._with_context_options:</span>
            <span class="s2">for </span><span class="s1">fn</span><span class="s4">, </span><span class="s1">key </span><span class="s2">in </span><span class="s1">select_statement._with_context_options:</span>
                <span class="s1">fn(self)</span>

        <span class="s1">self.primary_columns = []</span>
        <span class="s1">self.secondary_columns = []</span>
        <span class="s1">self.dedupe_columns = set()</span>
        <span class="s1">self.eager_joins = {}</span>
        <span class="s1">self.extra_criteria_entities = {}</span>
        <span class="s1">self.create_eager_joins = []</span>
        <span class="s1">self._fallback_from_clauses = []</span>

        <span class="s0"># normalize the FROM clauses early by themselves, as this makes</span>
        <span class="s0"># it an easier job when we need to assemble a JOIN onto these,</span>
        <span class="s0"># for select.join() as well as joinedload().   As of 1.4 there are now</span>
        <span class="s0"># potentially more complex sets of FROM objects here as the use</span>
        <span class="s0"># of lambda statements for lazyload, load_on_pk etc. uses more</span>
        <span class="s0"># cloning of the select() construct.  See #6495</span>
        <span class="s1">self.from_clauses = self._normalize_froms(</span>
            <span class="s1">info.selectable </span><span class="s2">for </span><span class="s1">info </span><span class="s2">in </span><span class="s1">select_statement._from_obj</span>
        <span class="s1">)</span>

        <span class="s0"># this is a fairly arbitrary break into a second method,</span>
        <span class="s0"># so it might be nicer to break up create_for_statement()</span>
        <span class="s0"># and _setup_for_generate into three or four logical sections</span>
        <span class="s1">self._setup_for_generate()</span>

        <span class="s1">SelectState.__init__(self</span><span class="s4">, </span><span class="s1">self.statement</span><span class="s4">, </span><span class="s1">compiler</span><span class="s4">, </span><span class="s1">**kw)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">_dump_option_struct(self):</span>
        <span class="s1">print(</span><span class="s3">&quot;</span><span class="s7">\n</span><span class="s3">---------------------------------------------------</span><span class="s7">\n</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s1">print(</span><span class="s3">f&quot;current path: </span><span class="s7">{</span><span class="s1">self.current_path</span><span class="s7">}</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">self.attributes:</span>
            <span class="s2">if </span><span class="s1">isinstance(key</span><span class="s4">, </span><span class="s1">tuple) </span><span class="s2">and </span><span class="s1">key[</span><span class="s5">0</span><span class="s1">] == </span><span class="s3">&quot;loader&quot;</span><span class="s1">:</span>
                <span class="s1">print(</span><span class="s3">f&quot;</span><span class="s7">\n</span><span class="s3">Loader:           </span><span class="s7">{</span><span class="s1">PathRegistry.coerce(key[</span><span class="s5">1</span><span class="s1">])</span><span class="s7">}</span><span class="s3">&quot;</span><span class="s1">)</span>
                <span class="s1">print(</span><span class="s3">f&quot;    </span><span class="s7">{</span><span class="s1">self.attributes[key]</span><span class="s7">}</span><span class="s3">&quot;</span><span class="s1">)</span>
                <span class="s1">print(</span><span class="s3">f&quot;    </span><span class="s7">{</span><span class="s1">self.attributes[key].__dict__</span><span class="s7">}</span><span class="s3">&quot;</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">isinstance(key</span><span class="s4">, </span><span class="s1">tuple) </span><span class="s2">and </span><span class="s1">key[</span><span class="s5">0</span><span class="s1">] == </span><span class="s3">&quot;path_with_polymorphic&quot;</span><span class="s1">:</span>
                <span class="s1">print(</span><span class="s3">f&quot;</span><span class="s7">\n</span><span class="s3">With Polymorphic: </span><span class="s7">{</span><span class="s1">PathRegistry.coerce(key[</span><span class="s5">1</span><span class="s1">])</span><span class="s7">}</span><span class="s3">&quot;</span><span class="s1">)</span>
                <span class="s1">print(</span><span class="s3">f&quot;    </span><span class="s7">{</span><span class="s1">self.attributes[key]</span><span class="s7">}</span><span class="s3">&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_setup_for_generate(self):</span>
        <span class="s1">query = self.select_statement</span>

        <span class="s1">self.statement = </span><span class="s2">None</span>
        <span class="s1">self._join_entities = ()</span>

        <span class="s2">if </span><span class="s1">self.compile_options._set_base_alias:</span>
            <span class="s0"># legacy Query only</span>
            <span class="s1">self._set_select_from_alias()</span>

        <span class="s2">for </span><span class="s1">memoized_entities </span><span class="s2">in </span><span class="s1">query._memoized_select_entities:</span>
            <span class="s2">if </span><span class="s1">memoized_entities._setup_joins:</span>
                <span class="s1">self._join(</span>
                    <span class="s1">memoized_entities._setup_joins</span><span class="s4">,</span>
                    <span class="s1">self._memoized_entities[memoized_entities]</span><span class="s4">,</span>
                <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">query._setup_joins:</span>
            <span class="s1">self._join(query._setup_joins</span><span class="s4">, </span><span class="s1">self._entities)</span>

        <span class="s1">current_adapter = self._get_current_adapter()</span>

        <span class="s2">if </span><span class="s1">query._where_criteria:</span>
            <span class="s1">self._where_criteria = query._where_criteria</span>

            <span class="s2">if </span><span class="s1">current_adapter:</span>
                <span class="s1">self._where_criteria = tuple(</span>
                    <span class="s1">current_adapter(crit</span><span class="s4">, </span><span class="s2">True</span><span class="s1">)</span>
                    <span class="s2">for </span><span class="s1">crit </span><span class="s2">in </span><span class="s1">self._where_criteria</span>
                <span class="s1">)</span>

        <span class="s0"># TODO: some complexity with order_by here was due to mapper.order_by.</span>
        <span class="s0"># now that this is removed we can hopefully make order_by /</span>
        <span class="s0"># group_by act identically to how they are in Core select.</span>
        <span class="s1">self.order_by = (</span>
            <span class="s1">self._adapt_col_list(query._order_by_clauses</span><span class="s4">, </span><span class="s1">current_adapter)</span>
            <span class="s2">if </span><span class="s1">current_adapter </span><span class="s2">and </span><span class="s1">query._order_by_clauses </span><span class="s2">not in </span><span class="s1">(</span><span class="s2">None</span><span class="s4">, </span><span class="s2">False</span><span class="s1">)</span>
            <span class="s2">else </span><span class="s1">query._order_by_clauses</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">query._having_criteria:</span>
            <span class="s1">self._having_criteria = tuple(</span>
                <span class="s1">current_adapter(crit</span><span class="s4">, </span><span class="s2">True</span><span class="s1">) </span><span class="s2">if </span><span class="s1">current_adapter </span><span class="s2">else </span><span class="s1">crit</span>
                <span class="s2">for </span><span class="s1">crit </span><span class="s2">in </span><span class="s1">query._having_criteria</span>
            <span class="s1">)</span>

        <span class="s1">self.group_by = (</span>
            <span class="s1">self._adapt_col_list(</span>
                <span class="s1">util.flatten_iterator(query._group_by_clauses)</span><span class="s4">, </span><span class="s1">current_adapter</span>
            <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">current_adapter </span><span class="s2">and </span><span class="s1">query._group_by_clauses </span><span class="s2">not in </span><span class="s1">(</span><span class="s2">None</span><span class="s4">, </span><span class="s2">False</span><span class="s1">)</span>
            <span class="s2">else </span><span class="s1">query._group_by_clauses </span><span class="s2">or None</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.eager_order_by:</span>
            <span class="s1">adapter = self.from_clauses[</span><span class="s5">0</span><span class="s1">]._target_adapter</span>
            <span class="s1">self.eager_order_by = adapter.copy_and_process(self.eager_order_by)</span>

        <span class="s2">if </span><span class="s1">query._distinct_on:</span>
            <span class="s1">self.distinct_on = self._adapt_col_list(</span>
                <span class="s1">query._distinct_on</span><span class="s4">, </span><span class="s1">current_adapter</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.distinct_on = ()</span>

        <span class="s1">self.distinct = query._distinct</span>

        <span class="s2">if </span><span class="s1">query._correlate:</span>
            <span class="s0"># ORM mapped entities that are mapped to joins can be passed</span>
            <span class="s0"># to .correlate, so here they are broken into their component</span>
            <span class="s0"># tables.</span>
            <span class="s1">self.correlate = tuple(</span>
                <span class="s1">util.flatten_iterator(</span>
                    <span class="s1">sql_util.surface_selectables(s) </span><span class="s2">if </span><span class="s1">s </span><span class="s2">is not None else None</span>
                    <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">query._correlate</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">query._correlate_except </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.correlate_except = tuple(</span>
                <span class="s1">util.flatten_iterator(</span>
                    <span class="s1">sql_util.surface_selectables(s) </span><span class="s2">if </span><span class="s1">s </span><span class="s2">is not None else None</span>
                    <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">query._correlate_except</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">elif not </span><span class="s1">query._auto_correlate:</span>
            <span class="s1">self.correlate = (</span><span class="s2">None</span><span class="s4">,</span><span class="s1">)</span>

        <span class="s0"># PART II</span>

        <span class="s1">self._for_update_arg = query._for_update_arg</span>

        <span class="s2">if </span><span class="s1">self.compile_options._is_star </span><span class="s2">and </span><span class="s1">(len(self._entities) != </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">sa_exc.CompileError(</span>
                <span class="s3">&quot;Can't generate ORM query that includes multiple expressions &quot;</span>
                <span class="s3">&quot;at the same time as '*'; query for '*' alone if present&quot;</span>
            <span class="s1">)</span>
        <span class="s2">for </span><span class="s1">entity </span><span class="s2">in </span><span class="s1">self._entities:</span>
            <span class="s1">entity.setup_compile_state(self)</span>

        <span class="s2">for </span><span class="s1">rec </span><span class="s2">in </span><span class="s1">self.create_eager_joins:</span>
            <span class="s1">strategy = rec[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">strategy(self</span><span class="s4">, </span><span class="s1">*rec[</span><span class="s5">1</span><span class="s1">:])</span>

        <span class="s0"># else &quot;load from discrete FROMs&quot; mode,</span>
        <span class="s0"># i.e. when each _MappedEntity has its own FROM</span>

        <span class="s2">if </span><span class="s1">self.compile_options._enable_single_crit:</span>
            <span class="s1">self._adjust_for_extra_criteria()</span>

        <span class="s2">if not </span><span class="s1">self.primary_columns:</span>
            <span class="s2">if </span><span class="s1">self.compile_options._only_load_props:</span>
                <span class="s2">assert False</span><span class="s4">, </span><span class="s3">&quot;no columns were included in _only_load_props&quot;</span>

            <span class="s2">raise </span><span class="s1">sa_exc.InvalidRequestError(</span>
                <span class="s3">&quot;Query contains no columns with which to SELECT from.&quot;</span>
            <span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">self.from_clauses:</span>
            <span class="s1">self.from_clauses = list(self._fallback_from_clauses)</span>

        <span class="s2">if </span><span class="s1">self.order_by </span><span class="s2">is False</span><span class="s1">:</span>
            <span class="s1">self.order_by = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">self.multi_row_eager_loaders</span>
            <span class="s2">and </span><span class="s1">self.eager_adding_joins</span>
            <span class="s2">and </span><span class="s1">self._should_nest_selectable</span>
        <span class="s1">):</span>
            <span class="s1">self.statement = self._compound_eager_statement()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.statement = self._simple_statement()</span>

        <span class="s2">if </span><span class="s1">self.for_statement:</span>
            <span class="s1">ezero = self._mapper_zero()</span>
            <span class="s2">if </span><span class="s1">ezero </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s0"># TODO: this goes away once we get rid of the deep entity</span>
                <span class="s0"># thing</span>
                <span class="s1">self.statement = self.statement._annotate(</span>
                    <span class="s1">{</span><span class="s3">&quot;deepentity&quot;</span><span class="s1">: ezero}</span>
                <span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_create_entities_collection(cls</span><span class="s4">, </span><span class="s1">query</span><span class="s4">, </span><span class="s1">legacy):</span>
        <span class="s6">&quot;&quot;&quot;Creates a partial ORMSelectCompileState that includes 
        the full collection of _MapperEntity and other _QueryEntity objects. 
 
        Supports a few remaining use cases that are pre-compilation 
        but still need to gather some of the column  / adaption information. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self = cls.__new__(cls)</span>

        <span class="s1">self._entities = []</span>
        <span class="s1">self._primary_entity = </span><span class="s2">None</span>
        <span class="s1">self._polymorphic_adapters = {}</span>

        <span class="s1">self._label_convention = self._column_naming_convention(</span>
            <span class="s1">query._label_style</span><span class="s4">, </span><span class="s1">legacy</span>
        <span class="s1">)</span>

        <span class="s0"># entities will also set up polymorphic adapters for mappers</span>
        <span class="s0"># that have with_polymorphic configured</span>
        <span class="s1">_QueryEntity.to_compile_state(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">query._raw_columns</span><span class="s4">, </span><span class="s1">self._entities</span><span class="s4">, </span><span class="s1">is_current_entities=</span><span class="s2">True</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">determine_last_joined_entity(cls</span><span class="s4">, </span><span class="s1">statement):</span>
        <span class="s1">setup_joins = statement._setup_joins</span>

        <span class="s2">return </span><span class="s1">_determine_last_joined_entity(setup_joins</span><span class="s4">, </span><span class="s2">None</span><span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">all_selected_columns(cls</span><span class="s4">, </span><span class="s1">statement):</span>
        <span class="s2">for </span><span class="s1">element </span><span class="s2">in </span><span class="s1">statement._raw_columns:</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">element.is_selectable</span>
                <span class="s2">and </span><span class="s3">&quot;entity_namespace&quot; </span><span class="s2">in </span><span class="s1">element._annotations</span>
            <span class="s1">):</span>
                <span class="s1">ens = element._annotations[</span><span class="s3">&quot;entity_namespace&quot;</span><span class="s1">]</span>
                <span class="s2">if not </span><span class="s1">ens.is_mapper </span><span class="s2">and not </span><span class="s1">ens.is_aliased_class:</span>
                    <span class="s2">yield from </span><span class="s1">_select_iterables([element])</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">yield from </span><span class="s1">_select_iterables(ens._all_column_expressions)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">yield from </span><span class="s1">_select_iterables([element])</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">get_columns_clause_froms(cls</span><span class="s4">, </span><span class="s1">statement):</span>
        <span class="s2">return </span><span class="s1">cls._normalize_froms(</span>
            <span class="s1">itertools.chain.from_iterable(</span>
                <span class="s1">(</span>
                    <span class="s1">element._from_objects</span>
                    <span class="s2">if </span><span class="s3">&quot;parententity&quot; </span><span class="s2">not in </span><span class="s1">element._annotations</span>
                    <span class="s2">else </span><span class="s1">[</span>
                        <span class="s1">element._annotations[</span>
                            <span class="s3">&quot;parententity&quot;</span>
                        <span class="s1">].__clause_element__()</span>
                    <span class="s1">]</span>
                <span class="s1">)</span>
                <span class="s2">for </span><span class="s1">element </span><span class="s2">in </span><span class="s1">statement._raw_columns</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_statement(cls</span><span class="s4">, </span><span class="s1">statement</span><span class="s4">, </span><span class="s1">from_statement):</span>
        <span class="s1">from_statement = coercions.expect(</span>
            <span class="s1">roles.ReturnsRowsRole</span><span class="s4">,</span>
            <span class="s1">from_statement</span><span class="s4">,</span>
            <span class="s1">apply_propagate_attrs=statement</span><span class="s4">,</span>
        <span class="s1">)</span>

        <span class="s1">stmt = FromStatement(statement._raw_columns</span><span class="s4">, </span><span class="s1">from_statement)</span>

        <span class="s1">stmt.__dict__.update(</span>
            <span class="s1">_with_options=statement._with_options</span><span class="s4">,</span>
            <span class="s1">_with_context_options=statement._with_context_options</span><span class="s4">,</span>
            <span class="s1">_execution_options=statement._execution_options</span><span class="s4">,</span>
            <span class="s1">_propagate_attrs=statement._propagate_attrs</span><span class="s4">,</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">stmt</span>

    <span class="s2">def </span><span class="s1">_set_select_from_alias(self):</span>
        <span class="s6">&quot;&quot;&quot;used only for legacy Query cases&quot;&quot;&quot;</span>

        <span class="s1">query = self.select_statement  </span><span class="s0"># query</span>

        <span class="s2">assert </span><span class="s1">self.compile_options._set_base_alias</span>
        <span class="s2">assert </span><span class="s1">len(query._from_obj) == </span><span class="s5">1</span>

        <span class="s1">adapter = self._get_select_from_alias_from_obj(query._from_obj[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s2">if </span><span class="s1">adapter:</span>
            <span class="s1">self.compile_options += {</span><span class="s3">&quot;_enable_single_crit&quot;</span><span class="s1">: </span><span class="s2">False</span><span class="s1">}</span>
            <span class="s1">self._from_obj_alias = adapter</span>

    <span class="s2">def </span><span class="s1">_get_select_from_alias_from_obj(self</span><span class="s4">, </span><span class="s1">from_obj):</span>
        <span class="s6">&quot;&quot;&quot;used only for legacy Query cases&quot;&quot;&quot;</span>

        <span class="s1">info = from_obj</span>

        <span class="s2">if </span><span class="s3">&quot;parententity&quot; </span><span class="s2">in </span><span class="s1">info._annotations:</span>
            <span class="s1">info = info._annotations[</span><span class="s3">&quot;parententity&quot;</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">hasattr(info</span><span class="s4">, </span><span class="s3">&quot;mapper&quot;</span><span class="s1">):</span>
            <span class="s2">if not </span><span class="s1">info.is_aliased_class:</span>
                <span class="s2">raise </span><span class="s1">sa_exc.ArgumentError(</span>
                    <span class="s3">&quot;A selectable (FromClause) instance is &quot;</span>
                    <span class="s3">&quot;expected when the base alias is being set.&quot;</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">info._adapter</span>

        <span class="s2">elif </span><span class="s1">isinstance(info.selectable</span><span class="s4">, </span><span class="s1">sql.selectable.AliasedReturnsRows):</span>
            <span class="s1">equivs = self._all_equivs()</span>
            <span class="s2">assert </span><span class="s1">info </span><span class="s2">is </span><span class="s1">info.selectable</span>
            <span class="s2">return </span><span class="s1">ORMStatementAdapter(</span>
                <span class="s1">_TraceAdaptRole.LEGACY_SELECT_FROM_ALIAS</span><span class="s4">,</span>
                <span class="s1">info.selectable</span><span class="s4">,</span>
                <span class="s1">equivalents=equivs</span><span class="s4">,</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">_mapper_zero(self):</span>
        <span class="s6">&quot;&quot;&quot;return the Mapper associated with the first QueryEntity.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._entities[</span><span class="s5">0</span><span class="s1">].mapper</span>

    <span class="s2">def </span><span class="s1">_entity_zero(self):</span>
        <span class="s6">&quot;&quot;&quot;Return the 'entity' (mapper or AliasedClass) associated 
        with the first QueryEntity, or alternatively the 'select from' 
        entity if specified.&quot;&quot;&quot;</span>

        <span class="s2">for </span><span class="s1">ent </span><span class="s2">in </span><span class="s1">self.from_clauses:</span>
            <span class="s2">if </span><span class="s3">&quot;parententity&quot; </span><span class="s2">in </span><span class="s1">ent._annotations:</span>
                <span class="s2">return </span><span class="s1">ent._annotations[</span><span class="s3">&quot;parententity&quot;</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">qent </span><span class="s2">in </span><span class="s1">self._entities:</span>
            <span class="s2">if </span><span class="s1">qent.entity_zero:</span>
                <span class="s2">return </span><span class="s1">qent.entity_zero</span>

        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">_only_full_mapper_zero(self</span><span class="s4">, </span><span class="s1">methname):</span>
        <span class="s2">if </span><span class="s1">self._entities != [self._primary_entity]:</span>
            <span class="s2">raise </span><span class="s1">sa_exc.InvalidRequestError(</span>
                <span class="s3">&quot;%s() can only be used against &quot;</span>
                <span class="s3">&quot;a single mapped class.&quot; </span><span class="s1">% methname</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self._primary_entity.entity_zero</span>

    <span class="s2">def </span><span class="s1">_only_entity_zero(self</span><span class="s4">, </span><span class="s1">rationale=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">len(self._entities) &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">sa_exc.InvalidRequestError(</span>
                <span class="s1">rationale</span>
                <span class="s2">or </span><span class="s3">&quot;This operation requires a Query &quot;</span>
                <span class="s3">&quot;against a single mapper.&quot;</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self._entity_zero()</span>

    <span class="s2">def </span><span class="s1">_all_equivs(self):</span>
        <span class="s1">equivs = {}</span>

        <span class="s2">for </span><span class="s1">memoized_entities </span><span class="s2">in </span><span class="s1">self._memoized_entities.values():</span>
            <span class="s2">for </span><span class="s1">ent </span><span class="s2">in </span><span class="s1">[</span>
                <span class="s1">ent</span>
                <span class="s2">for </span><span class="s1">ent </span><span class="s2">in </span><span class="s1">memoized_entities</span>
                <span class="s2">if </span><span class="s1">isinstance(ent</span><span class="s4">, </span><span class="s1">_MapperEntity)</span>
            <span class="s1">]:</span>
                <span class="s1">equivs.update(ent.mapper._equivalent_columns)</span>

        <span class="s2">for </span><span class="s1">ent </span><span class="s2">in </span><span class="s1">[</span>
            <span class="s1">ent </span><span class="s2">for </span><span class="s1">ent </span><span class="s2">in </span><span class="s1">self._entities </span><span class="s2">if </span><span class="s1">isinstance(ent</span><span class="s4">, </span><span class="s1">_MapperEntity)</span>
        <span class="s1">]:</span>
            <span class="s1">equivs.update(ent.mapper._equivalent_columns)</span>
        <span class="s2">return </span><span class="s1">equivs</span>

    <span class="s2">def </span><span class="s1">_compound_eager_statement(self):</span>
        <span class="s0"># for eager joins present and LIMIT/OFFSET/DISTINCT,</span>
        <span class="s0"># wrap the query inside a select,</span>
        <span class="s0"># then append eager joins onto that</span>

        <span class="s2">if </span><span class="s1">self.order_by:</span>
            <span class="s0"># the default coercion for ORDER BY is now the OrderByRole,</span>
            <span class="s0"># which adds an additional post coercion to ByOfRole in that</span>
            <span class="s0"># elements are converted into label references.  For the</span>
            <span class="s0"># eager load / subquery wrapping case, we need to un-coerce</span>
            <span class="s0"># the original expressions outside of the label references</span>
            <span class="s0"># in order to have them render.</span>
            <span class="s1">unwrapped_order_by = [</span>
                <span class="s1">(</span>
                    <span class="s1">elem.element</span>
                    <span class="s2">if </span><span class="s1">isinstance(elem</span><span class="s4">, </span><span class="s1">sql.elements._label_reference)</span>
                    <span class="s2">else </span><span class="s1">elem</span>
                <span class="s1">)</span>
                <span class="s2">for </span><span class="s1">elem </span><span class="s2">in </span><span class="s1">self.order_by</span>
            <span class="s1">]</span>

            <span class="s1">order_by_col_expr = sql_util.expand_column_list_from_order_by(</span>
                <span class="s1">self.primary_columns</span><span class="s4">, </span><span class="s1">unwrapped_order_by</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">order_by_col_expr = []</span>
            <span class="s1">unwrapped_order_by = </span><span class="s2">None</span>

        <span class="s0"># put FOR UPDATE on the inner query, where MySQL will honor it,</span>
        <span class="s0"># as well as if it has an OF so PostgreSQL can use it.</span>
        <span class="s1">inner = self._select_statement(</span>
            <span class="s1">self.primary_columns</span>
            <span class="s1">+ [c </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">order_by_col_expr </span><span class="s2">if </span><span class="s1">c </span><span class="s2">not in </span><span class="s1">self.dedupe_columns]</span><span class="s4">,</span>
            <span class="s1">self.from_clauses</span><span class="s4">,</span>
            <span class="s1">self._where_criteria</span><span class="s4">,</span>
            <span class="s1">self._having_criteria</span><span class="s4">,</span>
            <span class="s1">self.label_style</span><span class="s4">,</span>
            <span class="s1">self.order_by</span><span class="s4">,</span>
            <span class="s1">for_update=self._for_update_arg</span><span class="s4">,</span>
            <span class="s1">hints=self.select_statement._hints</span><span class="s4">,</span>
            <span class="s1">statement_hints=self.select_statement._statement_hints</span><span class="s4">,</span>
            <span class="s1">correlate=self.correlate</span><span class="s4">,</span>
            <span class="s1">correlate_except=self.correlate_except</span><span class="s4">,</span>
            <span class="s1">**self._select_args</span><span class="s4">,</span>
        <span class="s1">)</span>

        <span class="s1">inner = inner.alias()</span>

        <span class="s1">equivs = self._all_equivs()</span>

        <span class="s1">self.compound_eager_adapter = ORMStatementAdapter(</span>
            <span class="s1">_TraceAdaptRole.COMPOUND_EAGER_STATEMENT</span><span class="s4">, </span><span class="s1">inner</span><span class="s4">, </span><span class="s1">equivalents=equivs</span>
        <span class="s1">)</span>

        <span class="s1">statement = future.select(</span>
            <span class="s1">*([inner] + self.secondary_columns)  </span><span class="s0"># use_labels=self.labels</span>
        <span class="s1">)</span>
        <span class="s1">statement._label_style = self.label_style</span>

        <span class="s0"># Oracle however does not allow FOR UPDATE on the subquery,</span>
        <span class="s0"># and the Oracle dialect ignores it, plus for PostgreSQL, MySQL</span>
        <span class="s0"># we expect that all elements of the row are locked, so also put it</span>
        <span class="s0"># on the outside (except in the case of PG when OF is used)</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">self._for_update_arg </span><span class="s2">is not None</span>
            <span class="s2">and </span><span class="s1">self._for_update_arg.of </span><span class="s2">is None</span>
        <span class="s1">):</span>
            <span class="s1">statement._for_update_arg = self._for_update_arg</span>

        <span class="s1">from_clause = inner</span>
        <span class="s2">for </span><span class="s1">eager_join </span><span class="s2">in </span><span class="s1">self.eager_joins.values():</span>
            <span class="s0"># EagerLoader places a 'stop_on' attribute on the join,</span>
            <span class="s0"># giving us a marker as to where the &quot;splice point&quot; of</span>
            <span class="s0"># the join should be</span>
            <span class="s1">from_clause = sql_util.splice_joins(</span>
                <span class="s1">from_clause</span><span class="s4">, </span><span class="s1">eager_join</span><span class="s4">, </span><span class="s1">eager_join.stop_on</span>
            <span class="s1">)</span>

        <span class="s1">statement.select_from.non_generative(statement</span><span class="s4">, </span><span class="s1">from_clause)</span>

        <span class="s2">if </span><span class="s1">unwrapped_order_by:</span>
            <span class="s1">statement.order_by.non_generative(</span>
                <span class="s1">statement</span><span class="s4">,</span>
                <span class="s1">*self.compound_eager_adapter.copy_and_process(</span>
                    <span class="s1">unwrapped_order_by</span>
                <span class="s1">)</span><span class="s4">,</span>
            <span class="s1">)</span>

        <span class="s1">statement.order_by.non_generative(statement</span><span class="s4">, </span><span class="s1">*self.eager_order_by)</span>
        <span class="s2">return </span><span class="s1">statement</span>

    <span class="s2">def </span><span class="s1">_simple_statement(self):</span>
        <span class="s1">statement = self._select_statement(</span>
            <span class="s1">self.primary_columns + self.secondary_columns</span><span class="s4">,</span>
            <span class="s1">tuple(self.from_clauses) + tuple(self.eager_joins.values())</span><span class="s4">,</span>
            <span class="s1">self._where_criteria</span><span class="s4">,</span>
            <span class="s1">self._having_criteria</span><span class="s4">,</span>
            <span class="s1">self.label_style</span><span class="s4">,</span>
            <span class="s1">self.order_by</span><span class="s4">,</span>
            <span class="s1">for_update=self._for_update_arg</span><span class="s4">,</span>
            <span class="s1">hints=self.select_statement._hints</span><span class="s4">,</span>
            <span class="s1">statement_hints=self.select_statement._statement_hints</span><span class="s4">,</span>
            <span class="s1">correlate=self.correlate</span><span class="s4">,</span>
            <span class="s1">correlate_except=self.correlate_except</span><span class="s4">,</span>
            <span class="s1">**self._select_args</span><span class="s4">,</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.eager_order_by:</span>
            <span class="s1">statement.order_by.non_generative(statement</span><span class="s4">, </span><span class="s1">*self.eager_order_by)</span>
        <span class="s2">return </span><span class="s1">statement</span>

    <span class="s2">def </span><span class="s1">_select_statement(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">raw_columns</span><span class="s4">,</span>
        <span class="s1">from_obj</span><span class="s4">,</span>
        <span class="s1">where_criteria</span><span class="s4">,</span>
        <span class="s1">having_criteria</span><span class="s4">,</span>
        <span class="s1">label_style</span><span class="s4">,</span>
        <span class="s1">order_by</span><span class="s4">,</span>
        <span class="s1">for_update</span><span class="s4">,</span>
        <span class="s1">hints</span><span class="s4">,</span>
        <span class="s1">statement_hints</span><span class="s4">,</span>
        <span class="s1">correlate</span><span class="s4">,</span>
        <span class="s1">correlate_except</span><span class="s4">,</span>
        <span class="s1">limit_clause</span><span class="s4">,</span>
        <span class="s1">offset_clause</span><span class="s4">,</span>
        <span class="s1">fetch_clause</span><span class="s4">,</span>
        <span class="s1">fetch_clause_options</span><span class="s4">,</span>
        <span class="s1">distinct</span><span class="s4">,</span>
        <span class="s1">distinct_on</span><span class="s4">,</span>
        <span class="s1">prefixes</span><span class="s4">,</span>
        <span class="s1">suffixes</span><span class="s4">,</span>
        <span class="s1">group_by</span><span class="s4">,</span>
        <span class="s1">independent_ctes</span><span class="s4">,</span>
        <span class="s1">independent_ctes_opts</span><span class="s4">,</span>
    <span class="s1">):</span>
        <span class="s1">statement = Select._create_raw_select(</span>
            <span class="s1">_raw_columns=raw_columns</span><span class="s4">,</span>
            <span class="s1">_from_obj=from_obj</span><span class="s4">,</span>
            <span class="s1">_label_style=label_style</span><span class="s4">,</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">where_criteria:</span>
            <span class="s1">statement._where_criteria = where_criteria</span>
        <span class="s2">if </span><span class="s1">having_criteria:</span>
            <span class="s1">statement._having_criteria = having_criteria</span>

        <span class="s2">if </span><span class="s1">order_by:</span>
            <span class="s1">statement._order_by_clauses += tuple(order_by)</span>

        <span class="s2">if </span><span class="s1">distinct_on:</span>
            <span class="s1">statement.distinct.non_generative(statement</span><span class="s4">, </span><span class="s1">*distinct_on)</span>
        <span class="s2">elif </span><span class="s1">distinct:</span>
            <span class="s1">statement.distinct.non_generative(statement)</span>

        <span class="s2">if </span><span class="s1">group_by:</span>
            <span class="s1">statement._group_by_clauses += tuple(group_by)</span>

        <span class="s1">statement._limit_clause = limit_clause</span>
        <span class="s1">statement._offset_clause = offset_clause</span>
        <span class="s1">statement._fetch_clause = fetch_clause</span>
        <span class="s1">statement._fetch_clause_options = fetch_clause_options</span>
        <span class="s1">statement._independent_ctes = independent_ctes</span>
        <span class="s1">statement._independent_ctes_opts = independent_ctes_opts</span>

        <span class="s2">if </span><span class="s1">prefixes:</span>
            <span class="s1">statement._prefixes = prefixes</span>

        <span class="s2">if </span><span class="s1">suffixes:</span>
            <span class="s1">statement._suffixes = suffixes</span>

        <span class="s1">statement._for_update_arg = for_update</span>

        <span class="s2">if </span><span class="s1">hints:</span>
            <span class="s1">statement._hints = hints</span>
        <span class="s2">if </span><span class="s1">statement_hints:</span>
            <span class="s1">statement._statement_hints = statement_hints</span>

        <span class="s2">if </span><span class="s1">correlate:</span>
            <span class="s1">statement.correlate.non_generative(statement</span><span class="s4">, </span><span class="s1">*correlate)</span>

        <span class="s2">if </span><span class="s1">correlate_except </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">statement.correlate_except.non_generative(</span>
                <span class="s1">statement</span><span class="s4">, </span><span class="s1">*correlate_except</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">statement</span>

    <span class="s2">def </span><span class="s1">_adapt_polymorphic_element(self</span><span class="s4">, </span><span class="s1">element):</span>
        <span class="s2">if </span><span class="s3">&quot;parententity&quot; </span><span class="s2">in </span><span class="s1">element._annotations:</span>
            <span class="s1">search = element._annotations[</span><span class="s3">&quot;parententity&quot;</span><span class="s1">]</span>
            <span class="s1">alias = self._polymorphic_adapters.get(search</span><span class="s4">, </span><span class="s2">None</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">alias:</span>
                <span class="s2">return </span><span class="s1">alias.adapt_clause(element)</span>

        <span class="s2">if </span><span class="s1">isinstance(element</span><span class="s4">, </span><span class="s1">expression.FromClause):</span>
            <span class="s1">search = element</span>
        <span class="s2">elif </span><span class="s1">hasattr(element</span><span class="s4">, </span><span class="s3">&quot;table&quot;</span><span class="s1">):</span>
            <span class="s1">search = element.table</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return None</span>

        <span class="s1">alias = self._polymorphic_adapters.get(search</span><span class="s4">, </span><span class="s2">None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">alias:</span>
            <span class="s2">return </span><span class="s1">alias.adapt_clause(element)</span>

    <span class="s2">def </span><span class="s1">_adapt_col_list(self</span><span class="s4">, </span><span class="s1">cols</span><span class="s4">, </span><span class="s1">current_adapter):</span>
        <span class="s2">if </span><span class="s1">current_adapter:</span>
            <span class="s2">return </span><span class="s1">[current_adapter(o</span><span class="s4">, </span><span class="s2">True</span><span class="s1">) </span><span class="s2">for </span><span class="s1">o </span><span class="s2">in </span><span class="s1">cols]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">cols</span>

    <span class="s2">def </span><span class="s1">_get_current_adapter(self):</span>
        <span class="s1">adapters = []</span>

        <span class="s2">if </span><span class="s1">self._from_obj_alias:</span>
            <span class="s0"># used for legacy going forward for query set_ops, e.g.</span>
            <span class="s0"># union(), union_all(), etc.</span>
            <span class="s0"># 1.4 and previously, also used for from_self(),</span>
            <span class="s0"># select_entity_from()</span>
            <span class="s0">#</span>
            <span class="s0"># for the &quot;from obj&quot; alias, apply extra rule to the</span>
            <span class="s0"># 'ORM only' check, if this query were generated from a</span>
            <span class="s0"># subquery of itself, i.e. _from_selectable(), apply adaption</span>
            <span class="s0"># to all SQL constructs.</span>
            <span class="s1">adapters.append(</span>
                <span class="s1">(</span>
                    <span class="s2">True</span><span class="s4">,</span>
                    <span class="s1">self._from_obj_alias.replace</span><span class="s4">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s0"># this was *hopefully* the only adapter we were going to need</span>
        <span class="s0"># going forward...however, we unfortunately need _from_obj_alias</span>
        <span class="s0"># for query.union(), which we can't drop</span>
        <span class="s2">if </span><span class="s1">self._polymorphic_adapters:</span>
            <span class="s1">adapters.append((</span><span class="s2">False</span><span class="s4">, </span><span class="s1">self._adapt_polymorphic_element))</span>

        <span class="s2">if not </span><span class="s1">adapters:</span>
            <span class="s2">return None</span>

        <span class="s2">def </span><span class="s1">_adapt_clause(clause</span><span class="s4">, </span><span class="s1">as_filter):</span>
            <span class="s0"># do we adapt all expression elements or only those</span>
            <span class="s0"># tagged as 'ORM' constructs ?</span>

            <span class="s2">def </span><span class="s1">replace(elem):</span>
                <span class="s1">is_orm_adapt = (</span>
                    <span class="s3">&quot;_orm_adapt&quot; </span><span class="s2">in </span><span class="s1">elem._annotations</span>
                    <span class="s2">or </span><span class="s3">&quot;parententity&quot; </span><span class="s2">in </span><span class="s1">elem._annotations</span>
                <span class="s1">)</span>
                <span class="s2">for </span><span class="s1">always_adapt</span><span class="s4">, </span><span class="s1">adapter </span><span class="s2">in </span><span class="s1">adapters:</span>
                    <span class="s2">if </span><span class="s1">is_orm_adapt </span><span class="s2">or </span><span class="s1">always_adapt:</span>
                        <span class="s1">e = adapter(elem)</span>
                        <span class="s2">if </span><span class="s1">e </span><span class="s2">is not None</span><span class="s1">:</span>
                            <span class="s2">return </span><span class="s1">e</span>

            <span class="s2">return </span><span class="s1">visitors.replacement_traverse(clause</span><span class="s4">, </span><span class="s1">{}</span><span class="s4">, </span><span class="s1">replace)</span>

        <span class="s2">return </span><span class="s1">_adapt_clause</span>

    <span class="s2">def </span><span class="s1">_join(self</span><span class="s4">, </span><span class="s1">args</span><span class="s4">, </span><span class="s1">entities_collection):</span>
        <span class="s2">for </span><span class="s1">right</span><span class="s4">, </span><span class="s1">onclause</span><span class="s4">, </span><span class="s1">from_</span><span class="s4">, </span><span class="s1">flags </span><span class="s2">in </span><span class="s1">args:</span>
            <span class="s1">isouter = flags[</span><span class="s3">&quot;isouter&quot;</span><span class="s1">]</span>
            <span class="s1">full = flags[</span><span class="s3">&quot;full&quot;</span><span class="s1">]</span>

            <span class="s1">right = inspect(right)</span>
            <span class="s2">if </span><span class="s1">onclause </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">onclause = inspect(onclause)</span>

            <span class="s2">if </span><span class="s1">isinstance(right</span><span class="s4">, </span><span class="s1">interfaces.PropComparator):</span>
                <span class="s2">if </span><span class="s1">onclause </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">sa_exc.InvalidRequestError(</span>
                        <span class="s3">&quot;No 'on clause' argument may be passed when joining &quot;</span>
                        <span class="s3">&quot;to a relationship path as a target&quot;</span>
                    <span class="s1">)</span>

                <span class="s1">onclause = right</span>
                <span class="s1">right = </span><span class="s2">None</span>
            <span class="s2">elif </span><span class="s3">&quot;parententity&quot; </span><span class="s2">in </span><span class="s1">right._annotations:</span>
                <span class="s1">right = right._annotations[</span><span class="s3">&quot;parententity&quot;</span><span class="s1">]</span>

            <span class="s2">if </span><span class="s1">onclause </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">if not </span><span class="s1">right.is_selectable </span><span class="s2">and not </span><span class="s1">hasattr(right</span><span class="s4">, </span><span class="s3">&quot;mapper&quot;</span><span class="s1">):</span>
                    <span class="s2">raise </span><span class="s1">sa_exc.ArgumentError(</span>
                        <span class="s3">&quot;Expected mapped entity or &quot;</span>
                        <span class="s3">&quot;selectable/table as join target&quot;</span>
                    <span class="s1">)</span>

            <span class="s1">of_type = </span><span class="s2">None</span>

            <span class="s2">if </span><span class="s1">isinstance(onclause</span><span class="s4">, </span><span class="s1">interfaces.PropComparator):</span>
                <span class="s0"># descriptor/property given (or determined); this tells us</span>
                <span class="s0"># explicitly what the expected &quot;left&quot; side of the join is.</span>

                <span class="s1">of_type = getattr(onclause</span><span class="s4">, </span><span class="s3">&quot;_of_type&quot;</span><span class="s4">, </span><span class="s2">None</span><span class="s1">)</span>

                <span class="s2">if </span><span class="s1">right </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">of_type:</span>
                        <span class="s1">right = of_type</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">right = onclause.property</span>

                        <span class="s2">try</span><span class="s1">:</span>
                            <span class="s1">right = right.entity</span>
                        <span class="s2">except </span><span class="s1">AttributeError </span><span class="s2">as </span><span class="s1">err:</span>
                            <span class="s2">raise </span><span class="s1">sa_exc.ArgumentError(</span>
                                <span class="s3">&quot;Join target %s does not refer to a &quot;</span>
                                <span class="s3">&quot;mapped entity&quot; </span><span class="s1">% right</span>
                            <span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>

                <span class="s1">left = onclause._parententity</span>

                <span class="s1">prop = onclause.property</span>
                <span class="s2">if not </span><span class="s1">isinstance(onclause</span><span class="s4">, </span><span class="s1">attributes.QueryableAttribute):</span>
                    <span class="s1">onclause = prop</span>

                <span class="s0"># check for this path already present.  don't render in that</span>
                <span class="s0"># case.</span>
                <span class="s2">if </span><span class="s1">(left</span><span class="s4">, </span><span class="s1">right</span><span class="s4">, </span><span class="s1">prop.key) </span><span class="s2">in </span><span class="s1">self._already_joined_edges:</span>
                    <span class="s2">continue</span>

                <span class="s2">if </span><span class="s1">from_ </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">(</span>
                        <span class="s1">from_ </span><span class="s2">is not </span><span class="s1">left</span>
                        <span class="s2">and </span><span class="s1">from_._annotations.get(</span><span class="s3">&quot;parententity&quot;</span><span class="s4">, </span><span class="s2">None</span><span class="s1">)</span>
                        <span class="s2">is not </span><span class="s1">left</span>
                    <span class="s1">):</span>
                        <span class="s2">raise </span><span class="s1">sa_exc.InvalidRequestError(</span>
                            <span class="s3">&quot;explicit from clause %s does not match left side &quot;</span>
                            <span class="s3">&quot;of relationship attribute %s&quot;</span>
                            <span class="s1">% (</span>
                                <span class="s1">from_._annotations.get(</span><span class="s3">&quot;parententity&quot;</span><span class="s4">, </span><span class="s1">from_)</span><span class="s4">,</span>
                                <span class="s1">onclause</span><span class="s4">,</span>
                            <span class="s1">)</span>
                        <span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">from_ </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">prop = </span><span class="s2">None</span>
                <span class="s1">left = from_</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># no descriptor/property given; we will need to figure out</span>
                <span class="s0"># what the effective &quot;left&quot; side is</span>
                <span class="s1">prop = left = </span><span class="s2">None</span>

            <span class="s0"># figure out the final &quot;left&quot; and &quot;right&quot; sides and create an</span>
            <span class="s0"># ORMJoin to add to our _from_obj tuple</span>
            <span class="s1">self._join_left_to_right(</span>
                <span class="s1">entities_collection</span><span class="s4">,</span>
                <span class="s1">left</span><span class="s4">,</span>
                <span class="s1">right</span><span class="s4">,</span>
                <span class="s1">onclause</span><span class="s4">,</span>
                <span class="s1">prop</span><span class="s4">,</span>
                <span class="s1">isouter</span><span class="s4">,</span>
                <span class="s1">full</span><span class="s4">,</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_join_left_to_right(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">entities_collection</span><span class="s4">,</span>
        <span class="s1">left</span><span class="s4">,</span>
        <span class="s1">right</span><span class="s4">,</span>
        <span class="s1">onclause</span><span class="s4">,</span>
        <span class="s1">prop</span><span class="s4">,</span>
        <span class="s1">outerjoin</span><span class="s4">,</span>
        <span class="s1">full</span><span class="s4">,</span>
    <span class="s1">):</span>
        <span class="s6">&quot;&quot;&quot;given raw &quot;left&quot;, &quot;right&quot;, &quot;onclause&quot; parameters consumed from 
        a particular key within _join(), add a real ORMJoin object to 
        our _from_obj list (or augment an existing one) 
 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">left </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s0"># left not given (e.g. no relationship object/name specified)</span>
            <span class="s0"># figure out the best &quot;left&quot; side based on our existing froms /</span>
            <span class="s0"># entities</span>
            <span class="s2">assert </span><span class="s1">prop </span><span class="s2">is None</span>
            <span class="s1">(</span>
                <span class="s1">left</span><span class="s4">,</span>
                <span class="s1">replace_from_obj_index</span><span class="s4">,</span>
                <span class="s1">use_entity_index</span><span class="s4">,</span>
            <span class="s1">) = self._join_determine_implicit_left_side(</span>
                <span class="s1">entities_collection</span><span class="s4">, </span><span class="s1">left</span><span class="s4">, </span><span class="s1">right</span><span class="s4">, </span><span class="s1">onclause</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># left is given via a relationship/name, or as explicit left side.</span>
            <span class="s0"># Determine where in our</span>
            <span class="s0"># &quot;froms&quot; list it should be spliced/appended as well as what</span>
            <span class="s0"># existing entity it corresponds to.</span>
            <span class="s1">(</span>
                <span class="s1">replace_from_obj_index</span><span class="s4">,</span>
                <span class="s1">use_entity_index</span><span class="s4">,</span>
            <span class="s1">) = self._join_place_explicit_left_side(entities_collection</span><span class="s4">, </span><span class="s1">left)</span>

        <span class="s2">if </span><span class="s1">left </span><span class="s2">is </span><span class="s1">right:</span>
            <span class="s2">raise </span><span class="s1">sa_exc.InvalidRequestError(</span>
                <span class="s3">&quot;Can't construct a join from %s to %s, they &quot;</span>
                <span class="s3">&quot;are the same entity&quot; </span><span class="s1">% (left</span><span class="s4">, </span><span class="s1">right)</span>
            <span class="s1">)</span>

        <span class="s0"># the right side as given often needs to be adapted.  additionally</span>
        <span class="s0"># a lot of things can be wrong with it.  handle all that and</span>
        <span class="s0"># get back the new effective &quot;right&quot; side</span>
        <span class="s1">r_info</span><span class="s4">, </span><span class="s1">right</span><span class="s4">, </span><span class="s1">onclause = self._join_check_and_adapt_right_side(</span>
            <span class="s1">left</span><span class="s4">, </span><span class="s1">right</span><span class="s4">, </span><span class="s1">onclause</span><span class="s4">, </span><span class="s1">prop</span>
        <span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">r_info.is_selectable:</span>
            <span class="s1">extra_criteria = self._get_extra_criteria(r_info)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">extra_criteria = ()</span>

        <span class="s2">if </span><span class="s1">replace_from_obj_index </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s0"># splice into an existing element in the</span>
            <span class="s0"># self._from_obj list</span>
            <span class="s1">left_clause = self.from_clauses[replace_from_obj_index]</span>

            <span class="s1">self.from_clauses = (</span>
                <span class="s1">self.from_clauses[:replace_from_obj_index]</span>
                <span class="s1">+ [</span>
                    <span class="s1">_ORMJoin(</span>
                        <span class="s1">left_clause</span><span class="s4">,</span>
                        <span class="s1">right</span><span class="s4">,</span>
                        <span class="s1">onclause</span><span class="s4">,</span>
                        <span class="s1">isouter=outerjoin</span><span class="s4">,</span>
                        <span class="s1">full=full</span><span class="s4">,</span>
                        <span class="s1">_extra_criteria=extra_criteria</span><span class="s4">,</span>
                    <span class="s1">)</span>
                <span class="s1">]</span>
                <span class="s1">+ self.from_clauses[replace_from_obj_index + </span><span class="s5">1 </span><span class="s1">:]</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># add a new element to the self._from_obj list</span>
            <span class="s2">if </span><span class="s1">use_entity_index </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s0"># make use of _MapperEntity selectable, which is usually</span>
                <span class="s0"># entity_zero.selectable, but if with_polymorphic() were used</span>
                <span class="s0"># might be distinct</span>
                <span class="s2">assert </span><span class="s1">isinstance(</span>
                    <span class="s1">entities_collection[use_entity_index]</span><span class="s4">, </span><span class="s1">_MapperEntity</span>
                <span class="s1">)</span>
                <span class="s1">left_clause = entities_collection[use_entity_index].selectable</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">left_clause = left</span>

            <span class="s1">self.from_clauses = self.from_clauses + [</span>
                <span class="s1">_ORMJoin(</span>
                    <span class="s1">left_clause</span><span class="s4">,</span>
                    <span class="s1">r_info</span><span class="s4">,</span>
                    <span class="s1">onclause</span><span class="s4">,</span>
                    <span class="s1">isouter=outerjoin</span><span class="s4">,</span>
                    <span class="s1">full=full</span><span class="s4">,</span>
                    <span class="s1">_extra_criteria=extra_criteria</span><span class="s4">,</span>
                <span class="s1">)</span>
            <span class="s1">]</span>

    <span class="s2">def </span><span class="s1">_join_determine_implicit_left_side(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">entities_collection</span><span class="s4">, </span><span class="s1">left</span><span class="s4">, </span><span class="s1">right</span><span class="s4">, </span><span class="s1">onclause</span>
    <span class="s1">):</span>
        <span class="s6">&quot;&quot;&quot;When join conditions don't express the left side explicitly, 
        determine if an existing FROM or entity in this query 
        can serve as the left hand side. 
 
        &quot;&quot;&quot;</span>

        <span class="s0"># when we are here, it means join() was called without an ORM-</span>
        <span class="s0"># specific way of telling us what the &quot;left&quot; side is, e.g.:</span>
        <span class="s0">#</span>
        <span class="s0"># join(RightEntity)</span>
        <span class="s0">#</span>
        <span class="s0"># or</span>
        <span class="s0">#</span>
        <span class="s0"># join(RightEntity, RightEntity.foo == LeftEntity.bar)</span>
        <span class="s0">#</span>

        <span class="s1">r_info = inspect(right)</span>

        <span class="s1">replace_from_obj_index = use_entity_index = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">self.from_clauses:</span>
            <span class="s0"># we have a list of FROMs already.  So by definition this</span>
            <span class="s0"># join has to connect to one of those FROMs.</span>

            <span class="s1">indexes = sql_util.find_left_clause_to_join_from(</span>
                <span class="s1">self.from_clauses</span><span class="s4">, </span><span class="s1">r_info.selectable</span><span class="s4">, </span><span class="s1">onclause</span>
            <span class="s1">)</span>

            <span class="s2">if </span><span class="s1">len(indexes) == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">replace_from_obj_index = indexes[</span><span class="s5">0</span><span class="s1">]</span>
                <span class="s1">left = self.from_clauses[replace_from_obj_index]</span>
            <span class="s2">elif </span><span class="s1">len(indexes) &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">sa_exc.InvalidRequestError(</span>
                    <span class="s3">&quot;Can't determine which FROM clause to join &quot;</span>
                    <span class="s3">&quot;from, there are multiple FROMS which can &quot;</span>
                    <span class="s3">&quot;join to this entity. Please use the .select_from() &quot;</span>
                    <span class="s3">&quot;method to establish an explicit left side, as well as &quot;</span>
                    <span class="s3">&quot;providing an explicit ON clause if not present already &quot;</span>
                    <span class="s3">&quot;to help resolve the ambiguity.&quot;</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">sa_exc.InvalidRequestError(</span>
                    <span class="s3">&quot;Don't know how to join to %r. &quot;</span>
                    <span class="s3">&quot;Please use the .select_from() &quot;</span>
                    <span class="s3">&quot;method to establish an explicit left side, as well as &quot;</span>
                    <span class="s3">&quot;providing an explicit ON clause if not present already &quot;</span>
                    <span class="s3">&quot;to help resolve the ambiguity.&quot; </span><span class="s1">% (right</span><span class="s4">,</span><span class="s1">)</span>
                <span class="s1">)</span>

        <span class="s2">elif </span><span class="s1">entities_collection:</span>
            <span class="s0"># we have no explicit FROMs, so the implicit left has to</span>
            <span class="s0"># come from our list of entities.</span>

            <span class="s1">potential = {}</span>
            <span class="s2">for </span><span class="s1">entity_index</span><span class="s4">, </span><span class="s1">ent </span><span class="s2">in </span><span class="s1">enumerate(entities_collection):</span>
                <span class="s1">entity = ent.entity_zero_or_selectable</span>
                <span class="s2">if </span><span class="s1">entity </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s2">continue</span>
                <span class="s1">ent_info = inspect(entity)</span>
                <span class="s2">if </span><span class="s1">ent_info </span><span class="s2">is </span><span class="s1">r_info:  </span><span class="s0"># left and right are the same, skip</span>
                    <span class="s2">continue</span>

                <span class="s0"># by using a dictionary with the selectables as keys this</span>
                <span class="s0"># de-duplicates those selectables as occurs when the query is</span>
                <span class="s0"># against a series of columns from the same selectable</span>
                <span class="s2">if </span><span class="s1">isinstance(ent</span><span class="s4">, </span><span class="s1">_MapperEntity):</span>
                    <span class="s1">potential[ent.selectable] = (entity_index</span><span class="s4">, </span><span class="s1">entity)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">potential[ent_info.selectable] = (</span><span class="s2">None</span><span class="s4">, </span><span class="s1">entity)</span>

            <span class="s1">all_clauses = list(potential.keys())</span>
            <span class="s1">indexes = sql_util.find_left_clause_to_join_from(</span>
                <span class="s1">all_clauses</span><span class="s4">, </span><span class="s1">r_info.selectable</span><span class="s4">, </span><span class="s1">onclause</span>
            <span class="s1">)</span>

            <span class="s2">if </span><span class="s1">len(indexes) == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">use_entity_index</span><span class="s4">, </span><span class="s1">left = potential[all_clauses[indexes[</span><span class="s5">0</span><span class="s1">]]]</span>
            <span class="s2">elif </span><span class="s1">len(indexes) &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">sa_exc.InvalidRequestError(</span>
                    <span class="s3">&quot;Can't determine which FROM clause to join &quot;</span>
                    <span class="s3">&quot;from, there are multiple FROMS which can &quot;</span>
                    <span class="s3">&quot;join to this entity. Please use the .select_from() &quot;</span>
                    <span class="s3">&quot;method to establish an explicit left side, as well as &quot;</span>
                    <span class="s3">&quot;providing an explicit ON clause if not present already &quot;</span>
                    <span class="s3">&quot;to help resolve the ambiguity.&quot;</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">sa_exc.InvalidRequestError(</span>
                    <span class="s3">&quot;Don't know how to join to %r. &quot;</span>
                    <span class="s3">&quot;Please use the .select_from() &quot;</span>
                    <span class="s3">&quot;method to establish an explicit left side, as well as &quot;</span>
                    <span class="s3">&quot;providing an explicit ON clause if not present already &quot;</span>
                    <span class="s3">&quot;to help resolve the ambiguity.&quot; </span><span class="s1">% (right</span><span class="s4">,</span><span class="s1">)</span>
                <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">sa_exc.InvalidRequestError(</span>
                <span class="s3">&quot;No entities to join from; please use &quot;</span>
                <span class="s3">&quot;select_from() to establish the left &quot;</span>
                <span class="s3">&quot;entity/selectable of this join&quot;</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">left</span><span class="s4">, </span><span class="s1">replace_from_obj_index</span><span class="s4">, </span><span class="s1">use_entity_index</span>

    <span class="s2">def </span><span class="s1">_join_place_explicit_left_side(self</span><span class="s4">, </span><span class="s1">entities_collection</span><span class="s4">, </span><span class="s1">left):</span>
        <span class="s6">&quot;&quot;&quot;When join conditions express a left side explicitly, determine 
        where in our existing list of FROM clauses we should join towards, 
        or if we need to make a new join, and if so is it from one of our 
        existing entities. 
 
        &quot;&quot;&quot;</span>

        <span class="s0"># when we are here, it means join() was called with an indicator</span>
        <span class="s0"># as to an exact left side, which means a path to a</span>
        <span class="s0"># Relationship was given, e.g.:</span>
        <span class="s0">#</span>
        <span class="s0"># join(RightEntity, LeftEntity.right)</span>
        <span class="s0">#</span>
        <span class="s0"># or</span>
        <span class="s0">#</span>
        <span class="s0"># join(LeftEntity.right)</span>
        <span class="s0">#</span>
        <span class="s0"># as well as string forms:</span>
        <span class="s0">#</span>
        <span class="s0"># join(RightEntity, &quot;right&quot;)</span>
        <span class="s0">#</span>
        <span class="s0"># etc.</span>
        <span class="s0">#</span>

        <span class="s1">replace_from_obj_index = use_entity_index = </span><span class="s2">None</span>

        <span class="s1">l_info = inspect(left)</span>
        <span class="s2">if </span><span class="s1">self.from_clauses:</span>
            <span class="s1">indexes = sql_util.find_left_clause_that_matches_given(</span>
                <span class="s1">self.from_clauses</span><span class="s4">, </span><span class="s1">l_info.selectable</span>
            <span class="s1">)</span>

            <span class="s2">if </span><span class="s1">len(indexes) &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">sa_exc.InvalidRequestError(</span>
                    <span class="s3">&quot;Can't identify which entity in which to assign the &quot;</span>
                    <span class="s3">&quot;left side of this join.   Please use a more specific &quot;</span>
                    <span class="s3">&quot;ON clause.&quot;</span>
                <span class="s1">)</span>

            <span class="s0"># have an index, means the left side is already present in</span>
            <span class="s0"># an existing FROM in the self._from_obj tuple</span>
            <span class="s2">if </span><span class="s1">indexes:</span>
                <span class="s1">replace_from_obj_index = indexes[</span><span class="s5">0</span><span class="s1">]</span>

            <span class="s0"># no index, means we need to add a new element to the</span>
            <span class="s0"># self._from_obj tuple</span>

        <span class="s0"># no from element present, so we will have to add to the</span>
        <span class="s0"># self._from_obj tuple.  Determine if this left side matches up</span>
        <span class="s0"># with existing mapper entities, in which case we want to apply the</span>
        <span class="s0"># aliasing / adaptation rules present on that entity if any</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">replace_from_obj_index </span><span class="s2">is None</span>
            <span class="s2">and </span><span class="s1">entities_collection</span>
            <span class="s2">and </span><span class="s1">hasattr(l_info</span><span class="s4">, </span><span class="s3">&quot;mapper&quot;</span><span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s2">for </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">ent </span><span class="s2">in </span><span class="s1">enumerate(entities_collection):</span>
                <span class="s0"># TODO: should we be checking for multiple mapper entities</span>
                <span class="s0"># matching?</span>
                <span class="s2">if </span><span class="s1">isinstance(ent</span><span class="s4">, </span><span class="s1">_MapperEntity) </span><span class="s2">and </span><span class="s1">ent.corresponds_to(left):</span>
                    <span class="s1">use_entity_index = idx</span>
                    <span class="s2">break</span>

        <span class="s2">return </span><span class="s1">replace_from_obj_index</span><span class="s4">, </span><span class="s1">use_entity_index</span>

    <span class="s2">def </span><span class="s1">_join_check_and_adapt_right_side(self</span><span class="s4">, </span><span class="s1">left</span><span class="s4">, </span><span class="s1">right</span><span class="s4">, </span><span class="s1">onclause</span><span class="s4">, </span><span class="s1">prop):</span>
        <span class="s6">&quot;&quot;&quot;transform the &quot;right&quot; side of the join as well as the onclause 
        according to polymorphic mapping translations, aliasing on the query 
        or on the join, special cases where the right and left side have 
        overlapping tables. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">l_info = inspect(left)</span>
        <span class="s1">r_info = inspect(right)</span>

        <span class="s1">overlap = </span><span class="s2">False</span>

        <span class="s1">right_mapper = getattr(r_info</span><span class="s4">, </span><span class="s3">&quot;mapper&quot;</span><span class="s4">, </span><span class="s2">None</span><span class="s1">)</span>
        <span class="s0"># if the target is a joined inheritance mapping,</span>
        <span class="s0"># be more liberal about auto-aliasing.</span>
        <span class="s2">if </span><span class="s1">right_mapper </span><span class="s2">and </span><span class="s1">(</span>
            <span class="s1">right_mapper.with_polymorphic</span>
            <span class="s2">or </span><span class="s1">isinstance(right_mapper.persist_selectable</span><span class="s4">, </span><span class="s1">expression.Join)</span>
        <span class="s1">):</span>
            <span class="s2">for </span><span class="s1">from_obj </span><span class="s2">in </span><span class="s1">self.from_clauses </span><span class="s2">or </span><span class="s1">[l_info.selectable]:</span>
                <span class="s2">if </span><span class="s1">sql_util.selectables_overlap(</span>
                    <span class="s1">l_info.selectable</span><span class="s4">, </span><span class="s1">from_obj</span>
                <span class="s1">) </span><span class="s2">and </span><span class="s1">sql_util.selectables_overlap(</span>
                    <span class="s1">from_obj</span><span class="s4">, </span><span class="s1">r_info.selectable</span>
                <span class="s1">):</span>
                    <span class="s1">overlap = </span><span class="s2">True</span>
                    <span class="s2">break</span>

        <span class="s2">if </span><span class="s1">overlap </span><span class="s2">and </span><span class="s1">l_info.selectable </span><span class="s2">is </span><span class="s1">r_info.selectable:</span>
            <span class="s2">raise </span><span class="s1">sa_exc.InvalidRequestError(</span>
                <span class="s3">&quot;Can't join table/selectable '%s' to itself&quot;</span>
                <span class="s1">% l_info.selectable</span>
            <span class="s1">)</span>

        <span class="s1">right_mapper</span><span class="s4">, </span><span class="s1">right_selectable</span><span class="s4">, </span><span class="s1">right_is_aliased = (</span>
            <span class="s1">getattr(r_info</span><span class="s4">, </span><span class="s3">&quot;mapper&quot;</span><span class="s4">, </span><span class="s2">None</span><span class="s1">)</span><span class="s4">,</span>
            <span class="s1">r_info.selectable</span><span class="s4">,</span>
            <span class="s1">getattr(r_info</span><span class="s4">, </span><span class="s3">&quot;is_aliased_class&quot;</span><span class="s4">, </span><span class="s2">False</span><span class="s1">)</span><span class="s4">,</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">right_mapper</span>
            <span class="s2">and </span><span class="s1">prop</span>
            <span class="s2">and not </span><span class="s1">right_mapper.common_parent(prop.mapper)</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">sa_exc.InvalidRequestError(</span>
                <span class="s3">&quot;Join target %s does not correspond to &quot;</span>
                <span class="s3">&quot;the right side of join condition %s&quot; </span><span class="s1">% (right</span><span class="s4">, </span><span class="s1">onclause)</span>
            <span class="s1">)</span>

        <span class="s0"># _join_entities is used as a hint for single-table inheritance</span>
        <span class="s0"># purposes at the moment</span>
        <span class="s2">if </span><span class="s1">hasattr(r_info</span><span class="s4">, </span><span class="s3">&quot;mapper&quot;</span><span class="s1">):</span>
            <span class="s1">self._join_entities += (r_info</span><span class="s4">,</span><span class="s1">)</span>

        <span class="s1">need_adapter = </span><span class="s2">False</span>

        <span class="s0"># test for joining to an unmapped selectable as the target</span>
        <span class="s2">if </span><span class="s1">r_info.is_clause_element:</span>
            <span class="s2">if </span><span class="s1">prop:</span>
                <span class="s1">right_mapper = prop.mapper</span>

            <span class="s2">if </span><span class="s1">right_selectable._is_lateral:</span>
                <span class="s0"># orm_only is disabled to suit the case where we have to</span>
                <span class="s0"># adapt an explicit correlate(Entity) - the select() loses</span>
                <span class="s0"># the ORM-ness in this case right now, ideally it would not</span>
                <span class="s1">current_adapter = self._get_current_adapter()</span>
                <span class="s2">if </span><span class="s1">current_adapter </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s0"># TODO: we had orm_only=False here before, removing</span>
                    <span class="s0"># it didn't break things.   if we identify the rationale,</span>
                    <span class="s0"># may need to apply &quot;_orm_only&quot; annotation here.</span>
                    <span class="s1">right = current_adapter(right</span><span class="s4">, </span><span class="s2">True</span><span class="s1">)</span>

            <span class="s2">elif </span><span class="s1">prop:</span>
                <span class="s0"># joining to selectable with a mapper property given</span>
                <span class="s0"># as the ON clause</span>

                <span class="s2">if not </span><span class="s1">right_selectable.is_derived_from(</span>
                    <span class="s1">right_mapper.persist_selectable</span>
                <span class="s1">):</span>
                    <span class="s2">raise </span><span class="s1">sa_exc.InvalidRequestError(</span>
                        <span class="s3">&quot;Selectable '%s' is not derived from '%s'&quot;</span>
                        <span class="s1">% (</span>
                            <span class="s1">right_selectable.description</span><span class="s4">,</span>
                            <span class="s1">right_mapper.persist_selectable.description</span><span class="s4">,</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>

                <span class="s0"># if the destination selectable is a plain select(),</span>
                <span class="s0"># turn it into an alias().</span>
                <span class="s2">if </span><span class="s1">isinstance(right_selectable</span><span class="s4">, </span><span class="s1">expression.SelectBase):</span>
                    <span class="s1">right_selectable = coercions.expect(</span>
                        <span class="s1">roles.FromClauseRole</span><span class="s4">, </span><span class="s1">right_selectable</span>
                    <span class="s1">)</span>
                    <span class="s1">need_adapter = </span><span class="s2">True</span>

                <span class="s0"># make the right hand side target into an ORM entity</span>
                <span class="s1">right = AliasedClass(right_mapper</span><span class="s4">, </span><span class="s1">right_selectable)</span>

                <span class="s1">util.warn_deprecated(</span>
                    <span class="s3">&quot;An alias is being generated automatically against &quot;</span>
                    <span class="s3">&quot;joined entity %s for raw clauseelement, which is &quot;</span>
                    <span class="s3">&quot;deprecated and will be removed in a later release. &quot;</span>
                    <span class="s3">&quot;Use the aliased() &quot;</span>
                    <span class="s3">&quot;construct explicitly, see the linked example.&quot;</span>
                    <span class="s1">% right_mapper</span><span class="s4">,</span>
                    <span class="s3">&quot;1.4&quot;</span><span class="s4">,</span>
                    <span class="s1">code=</span><span class="s3">&quot;xaj1&quot;</span><span class="s4">,</span>
                <span class="s1">)</span>

        <span class="s0"># test for overlap:</span>
        <span class="s0"># orm/inheritance/relationships.py</span>
        <span class="s0"># SelfReferentialM2MTest</span>
        <span class="s1">aliased_entity = right_mapper </span><span class="s2">and not </span><span class="s1">right_is_aliased </span><span class="s2">and </span><span class="s1">overlap</span>

        <span class="s2">if not </span><span class="s1">need_adapter </span><span class="s2">and </span><span class="s1">aliased_entity:</span>
            <span class="s0"># there are a few places in the ORM that automatic aliasing</span>
            <span class="s0"># is still desirable, and can't be automatic with a Core</span>
            <span class="s0"># only approach.  For illustrations of &quot;overlaps&quot; see</span>
            <span class="s0"># test/orm/inheritance/test_relationships.py.  There are also</span>
            <span class="s0"># general overlap cases with many-to-many tables where automatic</span>
            <span class="s0"># aliasing is desirable.</span>
            <span class="s1">right = AliasedClass(right</span><span class="s4">, </span><span class="s1">flat=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">need_adapter = </span><span class="s2">True</span>

            <span class="s1">util.warn(</span>
                <span class="s3">&quot;An alias is being generated automatically against &quot;</span>
                <span class="s3">&quot;joined entity %s due to overlapping tables.  This is a &quot;</span>
                <span class="s3">&quot;legacy pattern which may be &quot;</span>
                <span class="s3">&quot;deprecated in a later release.  Use the &quot;</span>
                <span class="s3">&quot;aliased(&lt;entity&gt;, flat=True) &quot;</span>
                <span class="s3">&quot;construct explicitly, see the linked example.&quot; </span><span class="s1">% right_mapper</span><span class="s4">,</span>
                <span class="s1">code=</span><span class="s3">&quot;xaj2&quot;</span><span class="s4">,</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">need_adapter:</span>
            <span class="s0"># if need_adapter is True, we are in a deprecated case and</span>
            <span class="s0"># a warning has been emitted.</span>
            <span class="s2">assert </span><span class="s1">right_mapper</span>

            <span class="s1">adapter = ORMAdapter(</span>
                <span class="s1">_TraceAdaptRole.DEPRECATED_JOIN_ADAPT_RIGHT_SIDE</span><span class="s4">,</span>
                <span class="s1">inspect(right)</span><span class="s4">,</span>
                <span class="s1">equivalents=right_mapper._equivalent_columns</span><span class="s4">,</span>
            <span class="s1">)</span>

            <span class="s0"># if an alias() on the right side was generated,</span>
            <span class="s0"># which is intended to wrap a the right side in a subquery,</span>
            <span class="s0"># ensure that columns retrieved from this target in the result</span>
            <span class="s0"># set are also adapted.</span>
            <span class="s1">self._mapper_loads_polymorphically_with(right_mapper</span><span class="s4">, </span><span class="s1">adapter)</span>
        <span class="s2">elif </span><span class="s1">(</span>
            <span class="s2">not </span><span class="s1">r_info.is_clause_element</span>
            <span class="s2">and not </span><span class="s1">right_is_aliased</span>
            <span class="s2">and </span><span class="s1">right_mapper._has_aliased_polymorphic_fromclause</span>
        <span class="s1">):</span>
            <span class="s0"># for the case where the target mapper has a with_polymorphic</span>
            <span class="s0"># set up, ensure an adapter is set up for criteria that works</span>
            <span class="s0"># against this mapper.  Previously, this logic used to</span>
            <span class="s0"># use the &quot;create_aliases or aliased_entity&quot; case to generate</span>
            <span class="s0"># an aliased() object, but this creates an alias that isn't</span>
            <span class="s0"># strictly necessary.</span>
            <span class="s0"># see test/orm/test_core_compilation.py</span>
            <span class="s0"># ::RelNaturalAliasedJoinsTest::test_straight</span>
            <span class="s0"># and similar</span>
            <span class="s1">self._mapper_loads_polymorphically_with(</span>
                <span class="s1">right_mapper</span><span class="s4">,</span>
                <span class="s1">ORMAdapter(</span>
                    <span class="s1">_TraceAdaptRole.WITH_POLYMORPHIC_ADAPTER_RIGHT_JOIN</span><span class="s4">,</span>
                    <span class="s1">right_mapper</span><span class="s4">,</span>
                    <span class="s1">selectable=right_mapper.selectable</span><span class="s4">,</span>
                    <span class="s1">equivalents=right_mapper._equivalent_columns</span><span class="s4">,</span>
                <span class="s1">)</span><span class="s4">,</span>
            <span class="s1">)</span>
        <span class="s0"># if the onclause is a ClauseElement, adapt it with any</span>
        <span class="s0"># adapters that are in place right now</span>
        <span class="s2">if </span><span class="s1">isinstance(onclause</span><span class="s4">, </span><span class="s1">expression.ClauseElement):</span>
            <span class="s1">current_adapter = self._get_current_adapter()</span>
            <span class="s2">if </span><span class="s1">current_adapter:</span>
                <span class="s1">onclause = current_adapter(onclause</span><span class="s4">, </span><span class="s2">True</span><span class="s1">)</span>

        <span class="s0"># if joining on a MapperProperty path,</span>
        <span class="s0"># track the path to prevent redundant joins</span>
        <span class="s2">if </span><span class="s1">prop:</span>
            <span class="s1">self._already_joined_edges += ((left</span><span class="s4">, </span><span class="s1">right</span><span class="s4">, </span><span class="s1">prop.key)</span><span class="s4">,</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">inspect(right)</span><span class="s4">, </span><span class="s1">right</span><span class="s4">, </span><span class="s1">onclause</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_select_args(self):</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s3">&quot;limit_clause&quot;</span><span class="s1">: self.select_statement._limit_clause</span><span class="s4">,</span>
            <span class="s3">&quot;offset_clause&quot;</span><span class="s1">: self.select_statement._offset_clause</span><span class="s4">,</span>
            <span class="s3">&quot;distinct&quot;</span><span class="s1">: self.distinct</span><span class="s4">,</span>
            <span class="s3">&quot;distinct_on&quot;</span><span class="s1">: self.distinct_on</span><span class="s4">,</span>
            <span class="s3">&quot;prefixes&quot;</span><span class="s1">: self.select_statement._prefixes</span><span class="s4">,</span>
            <span class="s3">&quot;suffixes&quot;</span><span class="s1">: self.select_statement._suffixes</span><span class="s4">,</span>
            <span class="s3">&quot;group_by&quot;</span><span class="s1">: self.group_by </span><span class="s2">or None</span><span class="s4">,</span>
            <span class="s3">&quot;fetch_clause&quot;</span><span class="s1">: self.select_statement._fetch_clause</span><span class="s4">,</span>
            <span class="s3">&quot;fetch_clause_options&quot;</span><span class="s1">: (</span>
                <span class="s1">self.select_statement._fetch_clause_options</span>
            <span class="s1">)</span><span class="s4">,</span>
            <span class="s3">&quot;independent_ctes&quot;</span><span class="s1">: self.select_statement._independent_ctes</span><span class="s4">,</span>
            <span class="s3">&quot;independent_ctes_opts&quot;</span><span class="s1">: (</span>
                <span class="s1">self.select_statement._independent_ctes_opts</span>
            <span class="s1">)</span><span class="s4">,</span>
        <span class="s1">}</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_should_nest_selectable(self):</span>
        <span class="s1">kwargs = self._select_args</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">kwargs.get(</span><span class="s3">&quot;limit_clause&quot;</span><span class="s1">) </span><span class="s2">is not None</span>
            <span class="s2">or </span><span class="s1">kwargs.get(</span><span class="s3">&quot;offset_clause&quot;</span><span class="s1">) </span><span class="s2">is not None</span>
            <span class="s2">or </span><span class="s1">kwargs.get(</span><span class="s3">&quot;distinct&quot;</span><span class="s4">, </span><span class="s2">False</span><span class="s1">)</span>
            <span class="s2">or </span><span class="s1">kwargs.get(</span><span class="s3">&quot;distinct_on&quot;</span><span class="s4">, </span><span class="s1">())</span>
            <span class="s2">or </span><span class="s1">kwargs.get(</span><span class="s3">&quot;group_by&quot;</span><span class="s4">, </span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_get_extra_criteria(self</span><span class="s4">, </span><span class="s1">ext_info):</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s3">&quot;additional_entity_criteria&quot;</span><span class="s4">,</span>
            <span class="s1">ext_info.mapper</span><span class="s4">,</span>
        <span class="s1">) </span><span class="s2">in </span><span class="s1">self.global_attributes:</span>
            <span class="s2">return </span><span class="s1">tuple(</span>
                <span class="s1">ae._resolve_where_criteria(ext_info)</span>
                <span class="s2">for </span><span class="s1">ae </span><span class="s2">in </span><span class="s1">self.global_attributes[</span>
                    <span class="s1">(</span><span class="s3">&quot;additional_entity_criteria&quot;</span><span class="s4">, </span><span class="s1">ext_info.mapper)</span>
                <span class="s1">]</span>
                <span class="s2">if </span><span class="s1">(ae.include_aliases </span><span class="s2">or </span><span class="s1">ae.entity </span><span class="s2">is </span><span class="s1">ext_info)</span>
                <span class="s2">and </span><span class="s1">ae._should_include(self)</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">()</span>

    <span class="s2">def </span><span class="s1">_adjust_for_extra_criteria(self):</span>
        <span class="s6">&quot;&quot;&quot;Apply extra criteria filtering. 
 
        For all distinct single-table-inheritance mappers represented in 
        the columns clause of this query, as well as the &quot;select from entity&quot;, 
        add criterion to the WHERE 
        clause of the given QueryContext such that only the appropriate 
        subtypes are selected from the total results. 
 
        Additionally, add WHERE criteria originating from LoaderCriteriaOptions 
        associated with the global context. 
 
        &quot;&quot;&quot;</span>

        <span class="s2">for </span><span class="s1">fromclause </span><span class="s2">in </span><span class="s1">self.from_clauses:</span>
            <span class="s1">ext_info = fromclause._annotations.get(</span><span class="s3">&quot;parententity&quot;</span><span class="s4">, </span><span class="s2">None</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">ext_info</span>
                <span class="s2">and </span><span class="s1">(</span>
                    <span class="s1">ext_info.mapper._single_table_criterion </span><span class="s2">is not None</span>
                    <span class="s2">or </span><span class="s1">(</span><span class="s3">&quot;additional_entity_criteria&quot;</span><span class="s4">, </span><span class="s1">ext_info.mapper)</span>
                    <span class="s2">in </span><span class="s1">self.global_attributes</span>
                <span class="s1">)</span>
                <span class="s2">and </span><span class="s1">ext_info </span><span class="s2">not in </span><span class="s1">self.extra_criteria_entities</span>
            <span class="s1">):</span>
                <span class="s1">self.extra_criteria_entities[ext_info] = (</span>
                    <span class="s1">ext_info</span><span class="s4">,</span>
                    <span class="s1">ext_info._adapter </span><span class="s2">if </span><span class="s1">ext_info.is_aliased_class </span><span class="s2">else None</span><span class="s4">,</span>
                <span class="s1">)</span>

        <span class="s1">search = set(self.extra_criteria_entities.values())</span>

        <span class="s2">for </span><span class="s1">ext_info</span><span class="s4">, </span><span class="s1">adapter </span><span class="s2">in </span><span class="s1">search:</span>
            <span class="s2">if </span><span class="s1">ext_info </span><span class="s2">in </span><span class="s1">self._join_entities:</span>
                <span class="s2">continue</span>

            <span class="s1">single_crit = ext_info.mapper._single_table_criterion</span>

            <span class="s2">if </span><span class="s1">self.compile_options._for_refresh_state:</span>
                <span class="s1">additional_entity_criteria = []</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">additional_entity_criteria = self._get_extra_criteria(ext_info)</span>

            <span class="s2">if </span><span class="s1">single_crit </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">additional_entity_criteria += (single_crit</span><span class="s4">,</span><span class="s1">)</span>

            <span class="s1">current_adapter = self._get_current_adapter()</span>
            <span class="s2">for </span><span class="s1">crit </span><span class="s2">in </span><span class="s1">additional_entity_criteria:</span>
                <span class="s2">if </span><span class="s1">adapter:</span>
                    <span class="s1">crit = adapter.traverse(crit)</span>

                <span class="s2">if </span><span class="s1">current_adapter:</span>
                    <span class="s1">crit = sql_util._deep_annotate(crit</span><span class="s4">, </span><span class="s1">{</span><span class="s3">&quot;_orm_adapt&quot;</span><span class="s1">: </span><span class="s2">True</span><span class="s1">})</span>
                    <span class="s1">crit = current_adapter(crit</span><span class="s4">, </span><span class="s2">False</span><span class="s1">)</span>
                <span class="s1">self._where_criteria += (crit</span><span class="s4">,</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_column_descriptions(</span>
    <span class="s1">query_or_select_stmt: Union[Query</span><span class="s4">, </span><span class="s1">Select</span><span class="s4">, </span><span class="s1">FromStatement]</span><span class="s4">,</span>
    <span class="s1">compile_state: Optional[ORMSelectCompileState] = </span><span class="s2">None</span><span class="s4">,</span>
    <span class="s1">legacy: bool = </span><span class="s2">False</span><span class="s4">,</span>
<span class="s1">) -&gt; List[ORMColumnDescription]:</span>
    <span class="s2">if </span><span class="s1">compile_state </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">compile_state = ORMSelectCompileState._create_entities_collection(</span>
            <span class="s1">query_or_select_stmt</span><span class="s4">, </span><span class="s1">legacy=legacy</span>
        <span class="s1">)</span>
    <span class="s1">ctx = compile_state</span>
    <span class="s1">d = [</span>
        <span class="s1">{</span>
            <span class="s3">&quot;name&quot;</span><span class="s1">: ent._label_name</span><span class="s4">,</span>
            <span class="s3">&quot;type&quot;</span><span class="s1">: ent.type</span><span class="s4">,</span>
            <span class="s3">&quot;aliased&quot;</span><span class="s1">: getattr(insp_ent</span><span class="s4">, </span><span class="s3">&quot;is_aliased_class&quot;</span><span class="s4">, </span><span class="s2">False</span><span class="s1">)</span><span class="s4">,</span>
            <span class="s3">&quot;expr&quot;</span><span class="s1">: ent.expr</span><span class="s4">,</span>
            <span class="s3">&quot;entity&quot;</span><span class="s1">: (</span>
                <span class="s1">getattr(insp_ent</span><span class="s4">, </span><span class="s3">&quot;entity&quot;</span><span class="s4">, </span><span class="s2">None</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">ent.entity_zero </span><span class="s2">is not None</span>
                <span class="s2">and not </span><span class="s1">insp_ent.is_clause_element</span>
                <span class="s2">else None</span>
            <span class="s1">)</span><span class="s4">,</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">ent</span><span class="s4">, </span><span class="s1">insp_ent </span><span class="s2">in </span><span class="s1">[</span>
            <span class="s1">(_ent</span><span class="s4">, </span><span class="s1">_ent.entity_zero) </span><span class="s2">for </span><span class="s1">_ent </span><span class="s2">in </span><span class="s1">ctx._entities</span>
        <span class="s1">]</span>
    <span class="s1">]</span>
    <span class="s2">return </span><span class="s1">d</span>


<span class="s2">def </span><span class="s1">_legacy_filter_by_entity_zero(</span>
    <span class="s1">query_or_augmented_select: Union[Query[Any]</span><span class="s4">, </span><span class="s1">Select[Any]]</span>
<span class="s1">) -&gt; Optional[_InternalEntityType[Any]]:</span>
    <span class="s1">self = query_or_augmented_select</span>
    <span class="s2">if </span><span class="s1">self._setup_joins:</span>
        <span class="s1">_last_joined_entity = self._last_joined_entity</span>
        <span class="s2">if </span><span class="s1">_last_joined_entity </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">_last_joined_entity</span>

    <span class="s2">if </span><span class="s1">self._from_obj </span><span class="s2">and </span><span class="s3">&quot;parententity&quot; </span><span class="s2">in </span><span class="s1">self._from_obj[</span><span class="s5">0</span><span class="s1">]._annotations:</span>
        <span class="s2">return </span><span class="s1">self._from_obj[</span><span class="s5">0</span><span class="s1">]._annotations[</span><span class="s3">&quot;parententity&quot;</span><span class="s1">]</span>

    <span class="s2">return </span><span class="s1">_entity_from_pre_ent_zero(self)</span>


<span class="s2">def </span><span class="s1">_entity_from_pre_ent_zero(</span>
    <span class="s1">query_or_augmented_select: Union[Query[Any]</span><span class="s4">, </span><span class="s1">Select[Any]]</span>
<span class="s1">) -&gt; Optional[_InternalEntityType[Any]]:</span>
    <span class="s1">self = query_or_augmented_select</span>
    <span class="s2">if not </span><span class="s1">self._raw_columns:</span>
        <span class="s2">return None</span>

    <span class="s1">ent = self._raw_columns[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s2">if </span><span class="s3">&quot;parententity&quot; </span><span class="s2">in </span><span class="s1">ent._annotations:</span>
        <span class="s2">return </span><span class="s1">ent._annotations[</span><span class="s3">&quot;parententity&quot;</span><span class="s1">]</span>
    <span class="s2">elif </span><span class="s1">isinstance(ent</span><span class="s4">, </span><span class="s1">ORMColumnsClauseRole):</span>
        <span class="s2">return </span><span class="s1">ent.entity</span>
    <span class="s2">elif </span><span class="s3">&quot;bundle&quot; </span><span class="s2">in </span><span class="s1">ent._annotations:</span>
        <span class="s2">return </span><span class="s1">ent._annotations[</span><span class="s3">&quot;bundle&quot;</span><span class="s1">]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">ent</span>


<span class="s2">def </span><span class="s1">_determine_last_joined_entity(</span>
    <span class="s1">setup_joins: Tuple[_SetupJoinsElement</span><span class="s4">, </span><span class="s1">...]</span><span class="s4">,</span>
    <span class="s1">entity_zero: Optional[_InternalEntityType[Any]] = </span><span class="s2">None</span><span class="s4">,</span>
<span class="s1">) -&gt; Optional[Union[_InternalEntityType[Any]</span><span class="s4">, </span><span class="s1">_JoinTargetElement]]:</span>
    <span class="s2">if not </span><span class="s1">setup_joins:</span>
        <span class="s2">return None</span>

    <span class="s1">(target</span><span class="s4">, </span><span class="s1">onclause</span><span class="s4">, </span><span class="s1">from_</span><span class="s4">, </span><span class="s1">flags) = setup_joins[-</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s2">if </span><span class="s1">isinstance(</span>
        <span class="s1">target</span><span class="s4">,</span>
        <span class="s1">attributes.QueryableAttribute</span><span class="s4">,</span>
    <span class="s1">):</span>
        <span class="s2">return </span><span class="s1">target.entity</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">target</span>


<span class="s2">class </span><span class="s1">_QueryEntity:</span>
    <span class="s6">&quot;&quot;&quot;represent an entity column returned within a Query result.&quot;&quot;&quot;</span>

    <span class="s1">__slots__ = ()</span>

    <span class="s1">supports_single_entity: bool</span>

    <span class="s1">_non_hashable_value = </span><span class="s2">False</span>
    <span class="s1">_null_column_type = </span><span class="s2">False</span>
    <span class="s1">use_id_for_hash = </span><span class="s2">False</span>

    <span class="s1">_label_name: Optional[str]</span>
    <span class="s1">type: Union[Type[Any]</span><span class="s4">, </span><span class="s1">TypeEngine[Any]]</span>
    <span class="s1">expr: Union[_InternalEntityType</span><span class="s4">, </span><span class="s1">ColumnElement[Any]]</span>
    <span class="s1">entity_zero: Optional[_InternalEntityType]</span>

    <span class="s2">def </span><span class="s1">setup_compile_state(self</span><span class="s4">, </span><span class="s1">compile_state: ORMCompileState) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s2">def </span><span class="s1">setup_dml_returning_compile_state(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">compile_state: ORMCompileState</span><span class="s4">,</span>
        <span class="s1">adapter: DMLReturningColFilter</span><span class="s4">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s2">def </span><span class="s1">row_processor(self</span><span class="s4">, </span><span class="s1">context</span><span class="s4">, </span><span class="s1">result):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">to_compile_state(</span>
        <span class="s1">cls</span><span class="s4">, </span><span class="s1">compile_state</span><span class="s4">, </span><span class="s1">entities</span><span class="s4">, </span><span class="s1">entities_collection</span><span class="s4">, </span><span class="s1">is_current_entities</span>
    <span class="s1">):</span>
        <span class="s2">for </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">entity </span><span class="s2">in </span><span class="s1">enumerate(entities):</span>
            <span class="s2">if </span><span class="s1">entity._is_lambda_element:</span>
                <span class="s2">if </span><span class="s1">entity._is_sequence:</span>
                    <span class="s1">cls.to_compile_state(</span>
                        <span class="s1">compile_state</span><span class="s4">,</span>
                        <span class="s1">entity._resolved</span><span class="s4">,</span>
                        <span class="s1">entities_collection</span><span class="s4">,</span>
                        <span class="s1">is_current_entities</span><span class="s4">,</span>
                    <span class="s1">)</span>
                    <span class="s2">continue</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">entity = entity._resolved</span>

            <span class="s2">if </span><span class="s1">entity.is_clause_element:</span>
                <span class="s2">if </span><span class="s1">entity.is_selectable:</span>
                    <span class="s2">if </span><span class="s3">&quot;parententity&quot; </span><span class="s2">in </span><span class="s1">entity._annotations:</span>
                        <span class="s1">_MapperEntity(</span>
                            <span class="s1">compile_state</span><span class="s4">,</span>
                            <span class="s1">entity</span><span class="s4">,</span>
                            <span class="s1">entities_collection</span><span class="s4">,</span>
                            <span class="s1">is_current_entities</span><span class="s4">,</span>
                        <span class="s1">)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">_ColumnEntity._for_columns(</span>
                            <span class="s1">compile_state</span><span class="s4">,</span>
                            <span class="s1">entity._select_iterable</span><span class="s4">,</span>
                            <span class="s1">entities_collection</span><span class="s4">,</span>
                            <span class="s1">idx</span><span class="s4">,</span>
                            <span class="s1">is_current_entities</span><span class="s4">,</span>
                        <span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">entity._annotations.get(</span><span class="s3">&quot;bundle&quot;</span><span class="s4">, </span><span class="s2">False</span><span class="s1">):</span>
                        <span class="s1">_BundleEntity(</span>
                            <span class="s1">compile_state</span><span class="s4">,</span>
                            <span class="s1">entity</span><span class="s4">,</span>
                            <span class="s1">entities_collection</span><span class="s4">,</span>
                            <span class="s1">is_current_entities</span><span class="s4">,</span>
                        <span class="s1">)</span>
                    <span class="s2">elif </span><span class="s1">entity._is_clause_list:</span>
                        <span class="s0"># this is legacy only - test_composites.py</span>
                        <span class="s0"># test_query_cols_legacy</span>
                        <span class="s1">_ColumnEntity._for_columns(</span>
                            <span class="s1">compile_state</span><span class="s4">,</span>
                            <span class="s1">entity._select_iterable</span><span class="s4">,</span>
                            <span class="s1">entities_collection</span><span class="s4">,</span>
                            <span class="s1">idx</span><span class="s4">,</span>
                            <span class="s1">is_current_entities</span><span class="s4">,</span>
                        <span class="s1">)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">_ColumnEntity._for_columns(</span>
                            <span class="s1">compile_state</span><span class="s4">,</span>
                            <span class="s1">[entity]</span><span class="s4">,</span>
                            <span class="s1">entities_collection</span><span class="s4">,</span>
                            <span class="s1">idx</span><span class="s4">,</span>
                            <span class="s1">is_current_entities</span><span class="s4">,</span>
                        <span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">entity.is_bundle:</span>
                <span class="s1">_BundleEntity(compile_state</span><span class="s4">, </span><span class="s1">entity</span><span class="s4">, </span><span class="s1">entities_collection)</span>

        <span class="s2">return </span><span class="s1">entities_collection</span>


<span class="s2">class </span><span class="s1">_MapperEntity(_QueryEntity):</span>
    <span class="s6">&quot;&quot;&quot;mapper/class/AliasedClass entity&quot;&quot;&quot;</span>

    <span class="s1">__slots__ = (</span>
        <span class="s3">&quot;expr&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;mapper&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;entity_zero&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;is_aliased_class&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;path&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;_extra_entities&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;_label_name&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;_with_polymorphic_mappers&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;selectable&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;_polymorphic_discriminator&quot;</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">expr: _InternalEntityType</span>
    <span class="s1">mapper: Mapper[Any]</span>
    <span class="s1">entity_zero: _InternalEntityType</span>
    <span class="s1">is_aliased_class: bool</span>
    <span class="s1">path: PathRegistry</span>
    <span class="s1">_label_name: str</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">compile_state</span><span class="s4">, </span><span class="s1">entity</span><span class="s4">, </span><span class="s1">entities_collection</span><span class="s4">, </span><span class="s1">is_current_entities</span>
    <span class="s1">):</span>
        <span class="s1">entities_collection.append(self)</span>
        <span class="s2">if </span><span class="s1">is_current_entities:</span>
            <span class="s2">if </span><span class="s1">compile_state._primary_entity </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">compile_state._primary_entity = self</span>
            <span class="s1">compile_state._has_mapper_entities = </span><span class="s2">True</span>
            <span class="s1">compile_state._has_orm_entities = </span><span class="s2">True</span>

        <span class="s1">entity = entity._annotations[</span><span class="s3">&quot;parententity&quot;</span><span class="s1">]</span>
        <span class="s1">entity._post_inspect</span>
        <span class="s1">ext_info = self.entity_zero = entity</span>
        <span class="s1">entity = ext_info.entity</span>

        <span class="s1">self.expr = entity</span>
        <span class="s1">self.mapper = mapper = ext_info.mapper</span>

        <span class="s1">self._extra_entities = (self.expr</span><span class="s4">,</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">ext_info.is_aliased_class:</span>
            <span class="s1">self._label_name = ext_info.name</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._label_name = mapper.class_.__name__</span>

        <span class="s1">self.is_aliased_class = ext_info.is_aliased_class</span>
        <span class="s1">self.path = ext_info._path_registry</span>

        <span class="s1">self.selectable = ext_info.selectable</span>
        <span class="s1">self._with_polymorphic_mappers = ext_info.with_polymorphic_mappers</span>
        <span class="s1">self._polymorphic_discriminator = ext_info.polymorphic_on</span>

        <span class="s2">if </span><span class="s1">mapper._should_select_with_poly_adapter:</span>
            <span class="s1">compile_state._create_with_polymorphic_adapter(</span>
                <span class="s1">ext_info</span><span class="s4">, </span><span class="s1">self.selectable</span>
            <span class="s1">)</span>

    <span class="s1">supports_single_entity = </span><span class="s2">True</span>

    <span class="s1">_non_hashable_value = </span><span class="s2">True</span>
    <span class="s1">use_id_for_hash = </span><span class="s2">True</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">type(self):</span>
        <span class="s2">return </span><span class="s1">self.mapper.class_</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">entity_zero_or_selectable(self):</span>
        <span class="s2">return </span><span class="s1">self.entity_zero</span>

    <span class="s2">def </span><span class="s1">corresponds_to(self</span><span class="s4">, </span><span class="s1">entity):</span>
        <span class="s2">return </span><span class="s1">_entity_corresponds_to(self.entity_zero</span><span class="s4">, </span><span class="s1">entity)</span>

    <span class="s2">def </span><span class="s1">_get_entity_clauses(self</span><span class="s4">, </span><span class="s1">compile_state):</span>
        <span class="s1">adapter = </span><span class="s2">None</span>

        <span class="s2">if not </span><span class="s1">self.is_aliased_class:</span>
            <span class="s2">if </span><span class="s1">compile_state._polymorphic_adapters:</span>
                <span class="s1">adapter = compile_state._polymorphic_adapters.get(</span>
                    <span class="s1">self.mapper</span><span class="s4">, </span><span class="s2">None</span>
                <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">adapter = self.entity_zero._adapter</span>

        <span class="s2">if </span><span class="s1">adapter:</span>
            <span class="s2">if </span><span class="s1">compile_state._from_obj_alias:</span>
                <span class="s1">ret = adapter.wrap(compile_state._from_obj_alias)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">ret = adapter</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">ret = compile_state._from_obj_alias</span>

        <span class="s2">return </span><span class="s1">ret</span>

    <span class="s2">def </span><span class="s1">row_processor(self</span><span class="s4">, </span><span class="s1">context</span><span class="s4">, </span><span class="s1">result):</span>
        <span class="s1">compile_state = context.compile_state</span>
        <span class="s1">adapter = self._get_entity_clauses(compile_state)</span>

        <span class="s2">if </span><span class="s1">compile_state.compound_eager_adapter </span><span class="s2">and </span><span class="s1">adapter:</span>
            <span class="s1">adapter = adapter.wrap(compile_state.compound_eager_adapter)</span>
        <span class="s2">elif not </span><span class="s1">adapter:</span>
            <span class="s1">adapter = compile_state.compound_eager_adapter</span>

        <span class="s2">if </span><span class="s1">compile_state._primary_entity </span><span class="s2">is </span><span class="s1">self:</span>
            <span class="s1">only_load_props = compile_state.compile_options._only_load_props</span>
            <span class="s1">refresh_state = context.refresh_state</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">only_load_props = refresh_state = </span><span class="s2">None</span>

        <span class="s1">_instance = loading._instance_processor(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">self.mapper</span><span class="s4">,</span>
            <span class="s1">context</span><span class="s4">,</span>
            <span class="s1">result</span><span class="s4">,</span>
            <span class="s1">self.path</span><span class="s4">,</span>
            <span class="s1">adapter</span><span class="s4">,</span>
            <span class="s1">only_load_props=only_load_props</span><span class="s4">,</span>
            <span class="s1">refresh_state=refresh_state</span><span class="s4">,</span>
            <span class="s1">polymorphic_discriminator=self._polymorphic_discriminator</span><span class="s4">,</span>
        <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">_instance</span><span class="s4">, </span><span class="s1">self._label_name</span><span class="s4">, </span><span class="s1">self._extra_entities</span>

    <span class="s2">def </span><span class="s1">setup_dml_returning_compile_state(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">compile_state: ORMCompileState</span><span class="s4">,</span>
        <span class="s1">adapter: DMLReturningColFilter</span><span class="s4">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">loading._setup_entity_query(</span>
            <span class="s1">compile_state</span><span class="s4">,</span>
            <span class="s1">self.mapper</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">self.path</span><span class="s4">,</span>
            <span class="s1">adapter</span><span class="s4">,</span>
            <span class="s1">compile_state.primary_columns</span><span class="s4">,</span>
            <span class="s1">with_polymorphic=self._with_polymorphic_mappers</span><span class="s4">,</span>
            <span class="s1">only_load_props=compile_state.compile_options._only_load_props</span><span class="s4">,</span>
            <span class="s1">polymorphic_discriminator=self._polymorphic_discriminator</span><span class="s4">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">setup_compile_state(self</span><span class="s4">, </span><span class="s1">compile_state):</span>
        <span class="s1">adapter = self._get_entity_clauses(compile_state)</span>

        <span class="s1">single_table_crit = self.mapper._single_table_criterion</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">single_table_crit </span><span class="s2">is not None</span>
            <span class="s2">or </span><span class="s1">(</span><span class="s3">&quot;additional_entity_criteria&quot;</span><span class="s4">, </span><span class="s1">self.mapper)</span>
            <span class="s2">in </span><span class="s1">compile_state.global_attributes</span>
        <span class="s1">):</span>
            <span class="s1">ext_info = self.entity_zero</span>
            <span class="s1">compile_state.extra_criteria_entities[ext_info] = (</span>
                <span class="s1">ext_info</span><span class="s4">,</span>
                <span class="s1">ext_info._adapter </span><span class="s2">if </span><span class="s1">ext_info.is_aliased_class </span><span class="s2">else None</span><span class="s4">,</span>
            <span class="s1">)</span>

        <span class="s1">loading._setup_entity_query(</span>
            <span class="s1">compile_state</span><span class="s4">,</span>
            <span class="s1">self.mapper</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">self.path</span><span class="s4">,</span>
            <span class="s1">adapter</span><span class="s4">,</span>
            <span class="s1">compile_state.primary_columns</span><span class="s4">,</span>
            <span class="s1">with_polymorphic=self._with_polymorphic_mappers</span><span class="s4">,</span>
            <span class="s1">only_load_props=compile_state.compile_options._only_load_props</span><span class="s4">,</span>
            <span class="s1">polymorphic_discriminator=self._polymorphic_discriminator</span><span class="s4">,</span>
        <span class="s1">)</span>
        <span class="s1">compile_state._fallback_from_clauses.append(self.selectable)</span>


<span class="s2">class </span><span class="s1">_BundleEntity(_QueryEntity):</span>
    <span class="s1">_extra_entities = ()</span>

    <span class="s1">__slots__ = (</span>
        <span class="s3">&quot;bundle&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;expr&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;type&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;_label_name&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;_entities&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;supports_single_entity&quot;</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">_entities: List[_QueryEntity]</span>
    <span class="s1">bundle: Bundle</span>
    <span class="s1">type: Type[Any]</span>
    <span class="s1">_label_name: str</span>
    <span class="s1">supports_single_entity: bool</span>
    <span class="s1">expr: Bundle</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">compile_state</span><span class="s4">,</span>
        <span class="s1">expr</span><span class="s4">,</span>
        <span class="s1">entities_collection</span><span class="s4">,</span>
        <span class="s1">is_current_entities</span><span class="s4">,</span>
        <span class="s1">setup_entities=</span><span class="s2">True</span><span class="s4">,</span>
        <span class="s1">parent_bundle=</span><span class="s2">None</span><span class="s4">,</span>
    <span class="s1">):</span>
        <span class="s1">compile_state._has_orm_entities = </span><span class="s2">True</span>

        <span class="s1">expr = expr._annotations[</span><span class="s3">&quot;bundle&quot;</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">parent_bundle:</span>
            <span class="s1">parent_bundle._entities.append(self)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">entities_collection.append(self)</span>

        <span class="s2">if </span><span class="s1">isinstance(</span>
            <span class="s1">expr</span><span class="s4">, </span><span class="s1">(attributes.QueryableAttribute</span><span class="s4">, </span><span class="s1">interfaces.PropComparator)</span>
        <span class="s1">):</span>
            <span class="s1">bundle = expr.__clause_element__()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">bundle = expr</span>

        <span class="s1">self.bundle = self.expr = bundle</span>
        <span class="s1">self.type = type(bundle)</span>
        <span class="s1">self._label_name = bundle.name</span>
        <span class="s1">self._entities = []</span>

        <span class="s2">if </span><span class="s1">setup_entities:</span>
            <span class="s2">for </span><span class="s1">expr </span><span class="s2">in </span><span class="s1">bundle.exprs:</span>
                <span class="s2">if </span><span class="s3">&quot;bundle&quot; </span><span class="s2">in </span><span class="s1">expr._annotations:</span>
                    <span class="s1">_BundleEntity(</span>
                        <span class="s1">compile_state</span><span class="s4">,</span>
                        <span class="s1">expr</span><span class="s4">,</span>
                        <span class="s1">entities_collection</span><span class="s4">,</span>
                        <span class="s1">is_current_entities</span><span class="s4">,</span>
                        <span class="s1">parent_bundle=self</span><span class="s4">,</span>
                    <span class="s1">)</span>
                <span class="s2">elif </span><span class="s1">isinstance(expr</span><span class="s4">, </span><span class="s1">Bundle):</span>
                    <span class="s1">_BundleEntity(</span>
                        <span class="s1">compile_state</span><span class="s4">,</span>
                        <span class="s1">expr</span><span class="s4">,</span>
                        <span class="s1">entities_collection</span><span class="s4">,</span>
                        <span class="s1">is_current_entities</span><span class="s4">,</span>
                        <span class="s1">parent_bundle=self</span><span class="s4">,</span>
                    <span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">_ORMColumnEntity._for_columns(</span>
                        <span class="s1">compile_state</span><span class="s4">,</span>
                        <span class="s1">[expr]</span><span class="s4">,</span>
                        <span class="s1">entities_collection</span><span class="s4">,</span>
                        <span class="s2">None</span><span class="s4">,</span>
                        <span class="s1">is_current_entities</span><span class="s4">,</span>
                        <span class="s1">parent_bundle=self</span><span class="s4">,</span>
                    <span class="s1">)</span>

        <span class="s1">self.supports_single_entity = self.bundle.single_entity</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">mapper(self):</span>
        <span class="s1">ezero = self.entity_zero</span>
        <span class="s2">if </span><span class="s1">ezero </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">ezero.mapper</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return None</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">entity_zero(self):</span>
        <span class="s2">for </span><span class="s1">ent </span><span class="s2">in </span><span class="s1">self._entities:</span>
            <span class="s1">ezero = ent.entity_zero</span>
            <span class="s2">if </span><span class="s1">ezero </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">ezero</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">corresponds_to(self</span><span class="s4">, </span><span class="s1">entity):</span>
        <span class="s0"># TODO: we might be able to implement this but for now</span>
        <span class="s0"># we are working around it</span>
        <span class="s2">return False</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">entity_zero_or_selectable(self):</span>
        <span class="s2">for </span><span class="s1">ent </span><span class="s2">in </span><span class="s1">self._entities:</span>
            <span class="s1">ezero = ent.entity_zero_or_selectable</span>
            <span class="s2">if </span><span class="s1">ezero </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">ezero</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">setup_compile_state(self</span><span class="s4">, </span><span class="s1">compile_state):</span>
        <span class="s2">for </span><span class="s1">ent </span><span class="s2">in </span><span class="s1">self._entities:</span>
            <span class="s1">ent.setup_compile_state(compile_state)</span>

    <span class="s2">def </span><span class="s1">setup_dml_returning_compile_state(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">compile_state: ORMCompileState</span><span class="s4">,</span>
        <span class="s1">adapter: DMLReturningColFilter</span><span class="s4">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">self.setup_compile_state(compile_state)</span>

    <span class="s2">def </span><span class="s1">row_processor(self</span><span class="s4">, </span><span class="s1">context</span><span class="s4">, </span><span class="s1">result):</span>
        <span class="s1">procs</span><span class="s4">, </span><span class="s1">labels</span><span class="s4">, </span><span class="s1">extra = zip(</span>
            <span class="s1">*[ent.row_processor(context</span><span class="s4">, </span><span class="s1">result) </span><span class="s2">for </span><span class="s1">ent </span><span class="s2">in </span><span class="s1">self._entities]</span>
        <span class="s1">)</span>

        <span class="s1">proc = self.bundle.create_row_processor(context.query</span><span class="s4">, </span><span class="s1">procs</span><span class="s4">, </span><span class="s1">labels)</span>

        <span class="s2">return </span><span class="s1">proc</span><span class="s4">, </span><span class="s1">self._label_name</span><span class="s4">, </span><span class="s1">self._extra_entities</span>


<span class="s2">class </span><span class="s1">_ColumnEntity(_QueryEntity):</span>
    <span class="s1">__slots__ = (</span>
        <span class="s3">&quot;_fetch_column&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;_row_processor&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;raw_column_index&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;translate_raw_column&quot;</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_for_columns(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">compile_state</span><span class="s4">,</span>
        <span class="s1">columns</span><span class="s4">,</span>
        <span class="s1">entities_collection</span><span class="s4">,</span>
        <span class="s1">raw_column_index</span><span class="s4">,</span>
        <span class="s1">is_current_entities</span><span class="s4">,</span>
        <span class="s1">parent_bundle=</span><span class="s2">None</span><span class="s4">,</span>
    <span class="s1">):</span>
        <span class="s2">for </span><span class="s1">column </span><span class="s2">in </span><span class="s1">columns:</span>
            <span class="s1">annotations = column._annotations</span>
            <span class="s2">if </span><span class="s3">&quot;parententity&quot; </span><span class="s2">in </span><span class="s1">annotations:</span>
                <span class="s1">_entity = annotations[</span><span class="s3">&quot;parententity&quot;</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">_entity = sql_util.extract_first_column_annotation(</span>
                    <span class="s1">column</span><span class="s4">, </span><span class="s3">&quot;parententity&quot;</span>
                <span class="s1">)</span>

            <span class="s2">if </span><span class="s1">_entity:</span>
                <span class="s2">if </span><span class="s3">&quot;identity_token&quot; </span><span class="s2">in </span><span class="s1">column._annotations:</span>
                    <span class="s1">_IdentityTokenEntity(</span>
                        <span class="s1">compile_state</span><span class="s4">,</span>
                        <span class="s1">column</span><span class="s4">,</span>
                        <span class="s1">entities_collection</span><span class="s4">,</span>
                        <span class="s1">_entity</span><span class="s4">,</span>
                        <span class="s1">raw_column_index</span><span class="s4">,</span>
                        <span class="s1">is_current_entities</span><span class="s4">,</span>
                        <span class="s1">parent_bundle=parent_bundle</span><span class="s4">,</span>
                    <span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">_ORMColumnEntity(</span>
                        <span class="s1">compile_state</span><span class="s4">,</span>
                        <span class="s1">column</span><span class="s4">,</span>
                        <span class="s1">entities_collection</span><span class="s4">,</span>
                        <span class="s1">_entity</span><span class="s4">,</span>
                        <span class="s1">raw_column_index</span><span class="s4">,</span>
                        <span class="s1">is_current_entities</span><span class="s4">,</span>
                        <span class="s1">parent_bundle=parent_bundle</span><span class="s4">,</span>
                    <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">_RawColumnEntity(</span>
                    <span class="s1">compile_state</span><span class="s4">,</span>
                    <span class="s1">column</span><span class="s4">,</span>
                    <span class="s1">entities_collection</span><span class="s4">,</span>
                    <span class="s1">raw_column_index</span><span class="s4">,</span>
                    <span class="s1">is_current_entities</span><span class="s4">,</span>
                    <span class="s1">parent_bundle=parent_bundle</span><span class="s4">,</span>
                <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">type(self):</span>
        <span class="s2">return </span><span class="s1">self.column.type</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_non_hashable_value(self):</span>
        <span class="s2">return not </span><span class="s1">self.column.type.hashable</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_null_column_type(self):</span>
        <span class="s2">return </span><span class="s1">self.column.type._isnull</span>

    <span class="s2">def </span><span class="s1">row_processor(self</span><span class="s4">, </span><span class="s1">context</span><span class="s4">, </span><span class="s1">result):</span>
        <span class="s1">compile_state = context.compile_state</span>

        <span class="s0"># the resulting callable is entirely cacheable so just return</span>
        <span class="s0"># it if we already made one</span>
        <span class="s2">if </span><span class="s1">self._row_processor </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">getter</span><span class="s4">, </span><span class="s1">label_name</span><span class="s4">, </span><span class="s1">extra_entities = self._row_processor</span>
            <span class="s2">if </span><span class="s1">self.translate_raw_column:</span>
                <span class="s1">extra_entities += (</span>
                    <span class="s1">context.query._raw_columns[self.raw_column_index]</span><span class="s4">,</span>
                <span class="s1">)</span>

            <span class="s2">return </span><span class="s1">getter</span><span class="s4">, </span><span class="s1">label_name</span><span class="s4">, </span><span class="s1">extra_entities</span>

        <span class="s0"># retrieve the column that would have been set up in</span>
        <span class="s0"># setup_compile_state, to avoid doing redundant work</span>
        <span class="s2">if </span><span class="s1">self._fetch_column </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">column = self._fetch_column</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># fetch_column will be None when we are doing a from_statement</span>
            <span class="s0"># and setup_compile_state may not have been called.</span>
            <span class="s1">column = self.column</span>

            <span class="s0"># previously, the RawColumnEntity didn't look for from_obj_alias</span>
            <span class="s0"># however I can't think of a case where we would be here and</span>
            <span class="s0"># we'd want to ignore it if this is the from_statement use case.</span>
            <span class="s0"># it's not really a use case to have raw columns + from_statement</span>
            <span class="s2">if </span><span class="s1">compile_state._from_obj_alias:</span>
                <span class="s1">column = compile_state._from_obj_alias.columns[column]</span>

            <span class="s2">if </span><span class="s1">column._annotations:</span>
                <span class="s0"># annotated columns perform more slowly in compiler and</span>
                <span class="s0"># result due to the __eq__() method, so use deannotated</span>
                <span class="s1">column = column._deannotate()</span>

        <span class="s2">if </span><span class="s1">compile_state.compound_eager_adapter:</span>
            <span class="s1">column = compile_state.compound_eager_adapter.columns[column]</span>

        <span class="s1">getter = result._getter(column)</span>
        <span class="s1">ret = getter</span><span class="s4">, </span><span class="s1">self._label_name</span><span class="s4">, </span><span class="s1">self._extra_entities</span>
        <span class="s1">self._row_processor = ret</span>

        <span class="s2">if </span><span class="s1">self.translate_raw_column:</span>
            <span class="s1">extra_entities = self._extra_entities + (</span>
                <span class="s1">context.query._raw_columns[self.raw_column_index]</span><span class="s4">,</span>
            <span class="s1">)</span>
            <span class="s2">return </span><span class="s1">getter</span><span class="s4">, </span><span class="s1">self._label_name</span><span class="s4">, </span><span class="s1">extra_entities</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">ret</span>


<span class="s2">class </span><span class="s1">_RawColumnEntity(_ColumnEntity):</span>
    <span class="s1">entity_zero = </span><span class="s2">None</span>
    <span class="s1">mapper = </span><span class="s2">None</span>
    <span class="s1">supports_single_entity = </span><span class="s2">False</span>

    <span class="s1">__slots__ = (</span>
        <span class="s3">&quot;expr&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;column&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;_label_name&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;entity_zero_or_selectable&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;_extra_entities&quot;</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">compile_state</span><span class="s4">,</span>
        <span class="s1">column</span><span class="s4">,</span>
        <span class="s1">entities_collection</span><span class="s4">,</span>
        <span class="s1">raw_column_index</span><span class="s4">,</span>
        <span class="s1">is_current_entities</span><span class="s4">,</span>
        <span class="s1">parent_bundle=</span><span class="s2">None</span><span class="s4">,</span>
    <span class="s1">):</span>
        <span class="s1">self.expr = column</span>
        <span class="s1">self.raw_column_index = raw_column_index</span>
        <span class="s1">self.translate_raw_column = raw_column_index </span><span class="s2">is not None</span>

        <span class="s2">if </span><span class="s1">column._is_star:</span>
            <span class="s1">compile_state.compile_options += {</span><span class="s3">&quot;_is_star&quot;</span><span class="s1">: </span><span class="s2">True</span><span class="s1">}</span>

        <span class="s2">if not </span><span class="s1">is_current_entities </span><span class="s2">or </span><span class="s1">column._is_text_clause:</span>
            <span class="s1">self._label_name = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">parent_bundle:</span>
                <span class="s1">self._label_name = column._proxy_key</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self._label_name = compile_state._label_convention(column)</span>

        <span class="s2">if </span><span class="s1">parent_bundle:</span>
            <span class="s1">parent_bundle._entities.append(self)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">entities_collection.append(self)</span>

        <span class="s1">self.column = column</span>
        <span class="s1">self.entity_zero_or_selectable = (</span>
            <span class="s1">self.column._from_objects[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">if </span><span class="s1">self.column._from_objects </span><span class="s2">else None</span>
        <span class="s1">)</span>
        <span class="s1">self._extra_entities = (self.expr</span><span class="s4">, </span><span class="s1">self.column)</span>
        <span class="s1">self._fetch_column = self._row_processor = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">corresponds_to(self</span><span class="s4">, </span><span class="s1">entity):</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">setup_dml_returning_compile_state(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">compile_state: ORMCompileState</span><span class="s4">,</span>
        <span class="s1">adapter: DMLReturningColFilter</span><span class="s4">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">self.setup_compile_state(compile_state)</span>

    <span class="s2">def </span><span class="s1">setup_compile_state(self</span><span class="s4">, </span><span class="s1">compile_state):</span>
        <span class="s1">current_adapter = compile_state._get_current_adapter()</span>
        <span class="s2">if </span><span class="s1">current_adapter:</span>
            <span class="s1">column = current_adapter(self.column</span><span class="s4">, </span><span class="s2">False</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">column </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">return</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">column = self.column</span>

        <span class="s2">if </span><span class="s1">column._annotations:</span>
            <span class="s0"># annotated columns perform more slowly in compiler and</span>
            <span class="s0"># result due to the __eq__() method, so use deannotated</span>
            <span class="s1">column = column._deannotate()</span>

        <span class="s1">compile_state.dedupe_columns.add(column)</span>
        <span class="s1">compile_state.primary_columns.append(column)</span>
        <span class="s1">self._fetch_column = column</span>


<span class="s2">class </span><span class="s1">_ORMColumnEntity(_ColumnEntity):</span>
    <span class="s6">&quot;&quot;&quot;Column/expression based entity.&quot;&quot;&quot;</span>

    <span class="s1">supports_single_entity = </span><span class="s2">False</span>

    <span class="s1">__slots__ = (</span>
        <span class="s3">&quot;expr&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;mapper&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;column&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;_label_name&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;entity_zero_or_selectable&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;entity_zero&quot;</span><span class="s4">,</span>
        <span class="s3">&quot;_extra_entities&quot;</span><span class="s4">,</span>
    <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">compile_state</span><span class="s4">,</span>
        <span class="s1">column</span><span class="s4">,</span>
        <span class="s1">entities_collection</span><span class="s4">,</span>
        <span class="s1">parententity</span><span class="s4">,</span>
        <span class="s1">raw_column_index</span><span class="s4">,</span>
        <span class="s1">is_current_entities</span><span class="s4">,</span>
        <span class="s1">parent_bundle=</span><span class="s2">None</span><span class="s4">,</span>
    <span class="s1">):</span>
        <span class="s1">annotations = column._annotations</span>

        <span class="s1">_entity = parententity</span>

        <span class="s0"># an AliasedClass won't have proxy_key in the annotations for</span>
        <span class="s0"># a column if it was acquired using the class' adapter directly,</span>
        <span class="s0"># such as using AliasedInsp._adapt_element().  this occurs</span>
        <span class="s0"># within internal loaders.</span>

        <span class="s1">orm_key = annotations.get(</span><span class="s3">&quot;proxy_key&quot;</span><span class="s4">, </span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">proxy_owner = annotations.get(</span><span class="s3">&quot;proxy_owner&quot;</span><span class="s4">, </span><span class="s1">_entity)</span>
        <span class="s2">if </span><span class="s1">orm_key:</span>
            <span class="s1">self.expr = getattr(proxy_owner.entity</span><span class="s4">, </span><span class="s1">orm_key)</span>
            <span class="s1">self.translate_raw_column = </span><span class="s2">False</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># if orm_key is not present, that means this is an ad-hoc</span>
            <span class="s0"># SQL ColumnElement, like a CASE() or other expression.</span>
            <span class="s0"># include this column position from the invoked statement</span>
            <span class="s0"># in the ORM-level ResultSetMetaData on each execute, so that</span>
            <span class="s0"># it can be targeted by identity after caching</span>
            <span class="s1">self.expr = column</span>
            <span class="s1">self.translate_raw_column = raw_column_index </span><span class="s2">is not None</span>

        <span class="s1">self.raw_column_index = raw_column_index</span>

        <span class="s2">if </span><span class="s1">is_current_entities:</span>
            <span class="s2">if </span><span class="s1">parent_bundle:</span>
                <span class="s1">self._label_name = orm_key </span><span class="s2">if </span><span class="s1">orm_key </span><span class="s2">else </span><span class="s1">column._proxy_key</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self._label_name = compile_state._label_convention(</span>
                    <span class="s1">column</span><span class="s4">, </span><span class="s1">col_name=orm_key</span>
                <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._label_name = </span><span class="s2">None</span>

        <span class="s1">_entity._post_inspect</span>
        <span class="s1">self.entity_zero = self.entity_zero_or_selectable = ezero = _entity</span>
        <span class="s1">self.mapper = mapper = _entity.mapper</span>

        <span class="s2">if </span><span class="s1">parent_bundle:</span>
            <span class="s1">parent_bundle._entities.append(self)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">entities_collection.append(self)</span>

        <span class="s1">compile_state._has_orm_entities = </span><span class="s2">True</span>

        <span class="s1">self.column = column</span>

        <span class="s1">self._fetch_column = self._row_processor = </span><span class="s2">None</span>

        <span class="s1">self._extra_entities = (self.expr</span><span class="s4">, </span><span class="s1">self.column)</span>

        <span class="s2">if </span><span class="s1">mapper._should_select_with_poly_adapter:</span>
            <span class="s1">compile_state._create_with_polymorphic_adapter(</span>
                <span class="s1">ezero</span><span class="s4">, </span><span class="s1">ezero.selectable</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">corresponds_to(self</span><span class="s4">, </span><span class="s1">entity):</span>
        <span class="s2">if </span><span class="s1">_is_aliased_class(entity):</span>
            <span class="s0"># TODO: polymorphic subclasses ?</span>
            <span class="s2">return </span><span class="s1">entity </span><span class="s2">is </span><span class="s1">self.entity_zero</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return not </span><span class="s1">_is_aliased_class(</span>
                <span class="s1">self.entity_zero</span>
            <span class="s1">) </span><span class="s2">and </span><span class="s1">entity.common_parent(self.entity_zero)</span>

    <span class="s2">def </span><span class="s1">setup_dml_returning_compile_state(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">compile_state: ORMCompileState</span><span class="s4">,</span>
        <span class="s1">adapter: DMLReturningColFilter</span><span class="s4">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._fetch_column = self.column</span>
        <span class="s1">column = adapter(self.column</span><span class="s4">, </span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">column </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">compile_state.dedupe_columns.add(column)</span>
            <span class="s1">compile_state.primary_columns.append(column)</span>

    <span class="s2">def </span><span class="s1">setup_compile_state(self</span><span class="s4">, </span><span class="s1">compile_state):</span>
        <span class="s1">current_adapter = compile_state._get_current_adapter()</span>
        <span class="s2">if </span><span class="s1">current_adapter:</span>
            <span class="s1">column = current_adapter(self.column</span><span class="s4">, </span><span class="s2">False</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">column </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">assert </span><span class="s1">compile_state.is_dml_returning</span>
                <span class="s1">self._fetch_column = self.column</span>
                <span class="s2">return</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">column = self.column</span>

        <span class="s1">ezero = self.entity_zero</span>

        <span class="s1">single_table_crit = self.mapper._single_table_criterion</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">single_table_crit </span><span class="s2">is not None</span>
            <span class="s2">or </span><span class="s1">(</span><span class="s3">&quot;additional_entity_criteria&quot;</span><span class="s4">, </span><span class="s1">self.mapper)</span>
            <span class="s2">in </span><span class="s1">compile_state.global_attributes</span>
        <span class="s1">):</span>
            <span class="s1">compile_state.extra_criteria_entities[ezero] = (</span>
                <span class="s1">ezero</span><span class="s4">,</span>
                <span class="s1">ezero._adapter </span><span class="s2">if </span><span class="s1">ezero.is_aliased_class </span><span class="s2">else None</span><span class="s4">,</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">column._annotations </span><span class="s2">and not </span><span class="s1">column._expression_label:</span>
            <span class="s0"># annotated columns perform more slowly in compiler and</span>
            <span class="s0"># result due to the __eq__() method, so use deannotated</span>
            <span class="s1">column = column._deannotate()</span>

        <span class="s0"># use entity_zero as the from if we have it. this is necessary</span>
        <span class="s0"># for polymorphic scenarios where our FROM is based on ORM entity,</span>
        <span class="s0"># not the FROM of the column.  but also, don't use it if our column</span>
        <span class="s0"># doesn't actually have any FROMs that line up, such as when its</span>
        <span class="s0"># a scalar subquery.</span>
        <span class="s2">if </span><span class="s1">set(self.column._from_objects).intersection(</span>
            <span class="s1">ezero.selectable._from_objects</span>
        <span class="s1">):</span>
            <span class="s1">compile_state._fallback_from_clauses.append(ezero.selectable)</span>

        <span class="s1">compile_state.dedupe_columns.add(column)</span>
        <span class="s1">compile_state.primary_columns.append(column)</span>
        <span class="s1">self._fetch_column = column</span>


<span class="s2">class </span><span class="s1">_IdentityTokenEntity(_ORMColumnEntity):</span>
    <span class="s1">translate_raw_column = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">setup_compile_state(self</span><span class="s4">, </span><span class="s1">compile_state):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">row_processor(self</span><span class="s4">, </span><span class="s1">context</span><span class="s4">, </span><span class="s1">result):</span>
        <span class="s2">def </span><span class="s1">getter(row):</span>
            <span class="s2">return </span><span class="s1">context.load_options._identity_token</span>

        <span class="s2">return </span><span class="s1">getter</span><span class="s4">, </span><span class="s1">self._label_name</span><span class="s4">, </span><span class="s1">self._extra_entities</span>
</pre>
</body>
</html>