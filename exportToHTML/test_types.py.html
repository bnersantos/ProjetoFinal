<html>
<head>
<title>test_types.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5d69bb;}
.s1 { color: #d8d8d8;}
.s2 { color: #cc8b60;}
.s3 { color: #cc7832;}
.s4 { color: #717ed3; font-style: italic;}
.s5 { color: #96bf7d;}
.s6 { color: #bbb55b;}
.s7 { color: #a5c261;}
.s8 { color: #d7539b; font-weight: bold;}
</style>
</head>
<body bgcolor="#1a1a25">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_types.py</font>
</center></td></tr></table>
<pre><span class="s0"># testing/suite/test_types.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>
<span class="s0"># mypy: ignore-errors</span>


<span class="s2">import </span><span class="s1">datetime</span>
<span class="s2">import </span><span class="s1">decimal</span>
<span class="s2">import </span><span class="s1">json</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">uuid</span>

<span class="s2">from </span><span class="s1">.. </span><span class="s2">import </span><span class="s1">config</span>
<span class="s2">from </span><span class="s1">.. </span><span class="s2">import </span><span class="s1">engines</span>
<span class="s2">from </span><span class="s1">.. </span><span class="s2">import </span><span class="s1">fixtures</span>
<span class="s2">from </span><span class="s1">.. </span><span class="s2">import </span><span class="s1">mock</span>
<span class="s2">from </span><span class="s1">..assertions </span><span class="s2">import </span><span class="s1">eq_</span>
<span class="s2">from </span><span class="s1">..assertions </span><span class="s2">import </span><span class="s1">is_</span>
<span class="s2">from </span><span class="s1">..assertions </span><span class="s2">import </span><span class="s1">ne_</span>
<span class="s2">from </span><span class="s1">..config </span><span class="s2">import </span><span class="s1">requirements</span>
<span class="s2">from </span><span class="s1">..schema </span><span class="s2">import </span><span class="s1">Column</span>
<span class="s2">from </span><span class="s1">..schema </span><span class="s2">import </span><span class="s1">Table</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">and_</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">ARRAY</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">BigInteger</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">bindparam</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">Boolean</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">case</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">cast</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">Date</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">DateTime</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">Enum</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">Float</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">Integer</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">Interval</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">JSON</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">literal</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">literal_column</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">MetaData</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">null</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">Numeric</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">select</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">String</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">testing</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">Text</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">Time</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">TIMESTAMP</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">type_coerce</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">TypeDecorator</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">Unicode</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">UnicodeText</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">UUID</span>
<span class="s2">from </span><span class="s1">... </span><span class="s2">import </span><span class="s1">Uuid</span>
<span class="s2">from </span><span class="s1">...orm </span><span class="s2">import </span><span class="s1">declarative_base</span>
<span class="s2">from </span><span class="s1">...orm </span><span class="s2">import </span><span class="s1">Session</span>
<span class="s2">from </span><span class="s1">...sql </span><span class="s2">import </span><span class="s1">sqltypes</span>
<span class="s2">from </span><span class="s1">...sql.sqltypes </span><span class="s2">import </span><span class="s1">LargeBinary</span>
<span class="s2">from </span><span class="s1">...sql.sqltypes </span><span class="s2">import </span><span class="s1">PickleType</span>


<span class="s2">class </span><span class="s1">_LiteralRoundTripFixture:</span>
    <span class="s1">supports_whereclause = </span><span class="s2">True</span>

    <span class="s1">@testing.fixture</span>
    <span class="s2">def </span><span class="s1">literal_round_trip(self</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s4">&quot;&quot;&quot;test literal rendering&quot;&quot;&quot;</span>

        <span class="s0"># for literal, we test the literal render in an INSERT</span>
        <span class="s0"># into a typed column.  we can then SELECT it back as its</span>
        <span class="s0"># official type; ideally we'd be able to use CAST here</span>
        <span class="s0"># but MySQL in particular can't CAST fully</span>

        <span class="s2">def </span><span class="s1">run(</span>
            <span class="s1">type_</span><span class="s3">,</span>
            <span class="s1">input_</span><span class="s3">,</span>
            <span class="s1">output</span><span class="s3">,</span>
            <span class="s1">filter_=</span><span class="s2">None</span><span class="s3">,</span>
            <span class="s1">compare=</span><span class="s2">None</span><span class="s3">,</span>
            <span class="s1">support_whereclause=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">):</span>
            <span class="s1">t = Table(</span><span class="s5">&quot;t&quot;</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">Column(</span><span class="s5">&quot;x&quot;</span><span class="s3">, </span><span class="s1">type_))</span>
            <span class="s1">t.create(connection)</span>

            <span class="s2">for </span><span class="s1">value </span><span class="s2">in </span><span class="s1">input_:</span>
                <span class="s1">ins = t.insert().values(</span>
                    <span class="s1">x=literal(value</span><span class="s3">, </span><span class="s1">type_</span><span class="s3">, </span><span class="s1">literal_execute=</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s1">)</span>
                <span class="s1">connection.execute(ins)</span>

            <span class="s1">ins = t.insert().values(</span>
                <span class="s1">x=literal(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">type_</span><span class="s3">, </span><span class="s1">literal_execute=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s1">connection.execute(ins)</span>

            <span class="s2">if </span><span class="s1">support_whereclause </span><span class="s2">and </span><span class="s1">self.supports_whereclause:</span>
                <span class="s2">if </span><span class="s1">compare:</span>
                    <span class="s1">stmt = t.select().where(</span>
                        <span class="s1">t.c.x</span>
                        <span class="s1">== literal(</span>
                            <span class="s1">compare</span><span class="s3">,</span>
                            <span class="s1">type_</span><span class="s3">,</span>
                            <span class="s1">literal_execute=</span><span class="s2">True</span><span class="s3">,</span>
                        <span class="s1">)</span><span class="s3">,</span>
                        <span class="s1">t.c.x</span>
                        <span class="s1">== literal(</span>
                            <span class="s1">input_[</span><span class="s6">0</span><span class="s1">]</span><span class="s3">,</span>
                            <span class="s1">type_</span><span class="s3">,</span>
                            <span class="s1">literal_execute=</span><span class="s2">True</span><span class="s3">,</span>
                        <span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">stmt = t.select().where(</span>
                        <span class="s1">t.c.x</span>
                        <span class="s1">== literal(</span>
                            <span class="s1">compare </span><span class="s2">if </span><span class="s1">compare </span><span class="s2">is not None else </span><span class="s1">input_[</span><span class="s6">0</span><span class="s1">]</span><span class="s3">,</span>
                            <span class="s1">type_</span><span class="s3">,</span>
                            <span class="s1">literal_execute=</span><span class="s2">True</span><span class="s3">,</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">stmt = t.select().where(t.c.x.is_not(</span><span class="s2">None</span><span class="s1">))</span>

            <span class="s1">rows = connection.execute(stmt).all()</span>
            <span class="s2">assert </span><span class="s1">rows</span><span class="s3">, </span><span class="s5">&quot;No rows returned&quot;</span>
            <span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">rows:</span>
                <span class="s1">value = row[</span><span class="s6">0</span><span class="s1">]</span>
                <span class="s2">if </span><span class="s1">filter_ </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">value = filter_(value)</span>
                <span class="s2">assert </span><span class="s1">value </span><span class="s2">in </span><span class="s1">output</span>

            <span class="s1">stmt = t.select().where(t.c.x.is_(</span><span class="s2">None</span><span class="s1">))</span>
            <span class="s1">rows = connection.execute(stmt).all()</span>
            <span class="s1">eq_(rows</span><span class="s3">, </span><span class="s1">[(</span><span class="s2">None</span><span class="s3">,</span><span class="s1">)])</span>

        <span class="s2">return </span><span class="s1">run</span>


<span class="s2">class </span><span class="s1">_UnicodeFixture(_LiteralRoundTripFixture</span><span class="s3">, </span><span class="s1">fixtures.TestBase):</span>
    <span class="s1">__requires__ = (</span><span class="s5">&quot;unicode_data&quot;</span><span class="s3">,</span><span class="s1">)</span>

    <span class="s1">data = (</span>
        <span class="s5">&quot;Alors vous imaginez ma 🐍 surprise, au lever du jour, &quot;</span>
        <span class="s5">&quot;quand une drôle de petite 🐍 voix m’a réveillé. Elle &quot;</span>
        <span class="s5">&quot;disait: « S’il vous plaît… dessine-moi 🐍 un mouton! »&quot;</span>
    <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">supports_whereclause(self):</span>
        <span class="s2">return </span><span class="s1">config.requirements.expressions_against_unbounded_text.enabled</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">define_tables(cls</span><span class="s3">, </span><span class="s1">metadata):</span>
        <span class="s1">Table(</span>
            <span class="s5">&quot;unicode_table&quot;</span><span class="s3">,</span>
            <span class="s1">metadata</span><span class="s3">,</span>
            <span class="s1">Column(</span>
                <span class="s5">&quot;id&quot;</span><span class="s3">, </span><span class="s1">Integer</span><span class="s3">, </span><span class="s1">primary_key=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">test_needs_autoincrement=</span><span class="s2">True</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">Column(</span><span class="s5">&quot;unicode_data&quot;</span><span class="s3">, </span><span class="s1">cls.datatype)</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_round_trip(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">unicode_table = self.tables.unicode_table</span>

        <span class="s1">connection.execute(</span>
            <span class="s1">unicode_table.insert()</span><span class="s3">, </span><span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">1</span><span class="s3">, </span><span class="s5">&quot;unicode_data&quot;</span><span class="s1">: self.data}</span>
        <span class="s1">)</span>

        <span class="s1">row = connection.execute(select(unicode_table.c.unicode_data)).first()</span>

        <span class="s1">eq_(row</span><span class="s3">, </span><span class="s1">(self.data</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s2">assert </span><span class="s1">isinstance(row[</span><span class="s6">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">str)</span>

    <span class="s2">def </span><span class="s1">test_round_trip_executemany(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">unicode_table = self.tables.unicode_table</span>

        <span class="s1">connection.execute(</span>
            <span class="s1">unicode_table.insert()</span><span class="s3">,</span>
            <span class="s1">[{</span><span class="s5">&quot;id&quot;</span><span class="s1">: i</span><span class="s3">, </span><span class="s5">&quot;unicode_data&quot;</span><span class="s1">: self.data} </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s6">1</span><span class="s3">, </span><span class="s6">4</span><span class="s1">)]</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s1">rows = connection.execute(</span>
            <span class="s1">select(unicode_table.c.unicode_data)</span>
        <span class="s1">).fetchall()</span>
        <span class="s1">eq_(rows</span><span class="s3">, </span><span class="s1">[(self.data</span><span class="s3">,</span><span class="s1">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s6">1</span><span class="s3">, </span><span class="s6">4</span><span class="s1">)])</span>
        <span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">rows:</span>
            <span class="s2">assert </span><span class="s1">isinstance(row[</span><span class="s6">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">str)</span>

    <span class="s2">def </span><span class="s1">_test_null_strings(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">unicode_table = self.tables.unicode_table</span>

        <span class="s1">connection.execute(</span>
            <span class="s1">unicode_table.insert()</span><span class="s3">, </span><span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">1</span><span class="s3">, </span><span class="s5">&quot;unicode_data&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s1">}</span>
        <span class="s1">)</span>
        <span class="s1">row = connection.execute(select(unicode_table.c.unicode_data)).first()</span>
        <span class="s1">eq_(row</span><span class="s3">, </span><span class="s1">(</span><span class="s2">None</span><span class="s3">,</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">_test_empty_strings(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">unicode_table = self.tables.unicode_table</span>

        <span class="s1">connection.execute(</span>
            <span class="s1">unicode_table.insert()</span><span class="s3">, </span><span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">1</span><span class="s3">, </span><span class="s5">&quot;unicode_data&quot;</span><span class="s1">: </span><span class="s5">&quot;&quot;</span><span class="s1">}</span>
        <span class="s1">)</span>
        <span class="s1">row = connection.execute(select(unicode_table.c.unicode_data)).first()</span>
        <span class="s1">eq_(row</span><span class="s3">, </span><span class="s1">(</span><span class="s5">&quot;&quot;</span><span class="s3">,</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_literal(self</span><span class="s3">, </span><span class="s1">literal_round_trip):</span>
        <span class="s1">literal_round_trip(self.datatype</span><span class="s3">, </span><span class="s1">[self.data]</span><span class="s3">, </span><span class="s1">[self.data])</span>

    <span class="s2">def </span><span class="s1">test_literal_non_ascii(self</span><span class="s3">, </span><span class="s1">literal_round_trip):</span>
        <span class="s1">literal_round_trip(self.datatype</span><span class="s3">, </span><span class="s1">[</span><span class="s5">&quot;réve🐍 illé&quot;</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">&quot;réve🐍 illé&quot;</span><span class="s1">])</span>


<span class="s2">class </span><span class="s1">UnicodeVarcharTest(_UnicodeFixture</span><span class="s3">, </span><span class="s1">fixtures.TablesTest):</span>
    <span class="s1">__requires__ = (</span><span class="s5">&quot;unicode_data&quot;</span><span class="s3">,</span><span class="s1">)</span>
    <span class="s1">__backend__ = </span><span class="s2">True</span>

    <span class="s1">datatype = Unicode(</span><span class="s6">255</span><span class="s1">)</span>

    <span class="s1">@requirements.empty_strings_varchar</span>
    <span class="s2">def </span><span class="s1">test_empty_strings_varchar(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">self._test_empty_strings(connection)</span>

    <span class="s2">def </span><span class="s1">test_null_strings_varchar(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">self._test_null_strings(connection)</span>


<span class="s2">class </span><span class="s1">UnicodeTextTest(_UnicodeFixture</span><span class="s3">, </span><span class="s1">fixtures.TablesTest):</span>
    <span class="s1">__requires__ = </span><span class="s5">&quot;unicode_data&quot;</span><span class="s3">, </span><span class="s5">&quot;text_type&quot;</span>
    <span class="s1">__backend__ = </span><span class="s2">True</span>

    <span class="s1">datatype = UnicodeText()</span>

    <span class="s1">@requirements.empty_strings_text</span>
    <span class="s2">def </span><span class="s1">test_empty_strings_text(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">self._test_empty_strings(connection)</span>

    <span class="s2">def </span><span class="s1">test_null_strings_text(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">self._test_null_strings(connection)</span>


<span class="s2">class </span><span class="s1">ArrayTest(_LiteralRoundTripFixture</span><span class="s3">, </span><span class="s1">fixtures.TablesTest):</span>
    <span class="s4">&quot;&quot;&quot;Add ARRAY test suite, #8138. 
 
    This only works on PostgreSQL right now. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__requires__ = (</span><span class="s5">&quot;array_type&quot;</span><span class="s3">,</span><span class="s1">)</span>
    <span class="s1">__backend__ = </span><span class="s2">True</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">define_tables(cls</span><span class="s3">, </span><span class="s1">metadata):</span>
        <span class="s1">Table(</span>
            <span class="s5">&quot;array_table&quot;</span><span class="s3">,</span>
            <span class="s1">metadata</span><span class="s3">,</span>
            <span class="s1">Column(</span>
                <span class="s5">&quot;id&quot;</span><span class="s3">, </span><span class="s1">Integer</span><span class="s3">, </span><span class="s1">primary_key=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">test_needs_autoincrement=</span><span class="s2">True</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">Column(</span><span class="s5">&quot;single_dim&quot;</span><span class="s3">, </span><span class="s1">ARRAY(Integer))</span><span class="s3">,</span>
            <span class="s1">Column(</span><span class="s5">&quot;multi_dim&quot;</span><span class="s3">, </span><span class="s1">ARRAY(String</span><span class="s3">, </span><span class="s1">dimensions=</span><span class="s6">2</span><span class="s1">))</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_array_roundtrip(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">array_table = self.tables.array_table</span>

        <span class="s1">connection.execute(</span>
            <span class="s1">array_table.insert()</span><span class="s3">,</span>
            <span class="s1">{</span>
                <span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">1</span><span class="s3">,</span>
                <span class="s5">&quot;single_dim&quot;</span><span class="s1">: [</span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">3</span><span class="s1">]</span><span class="s3">,</span>
                <span class="s5">&quot;multi_dim&quot;</span><span class="s1">: [[</span><span class="s5">&quot;one&quot;</span><span class="s3">, </span><span class="s5">&quot;two&quot;</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">&quot;thr'ee&quot;</span><span class="s3">, </span><span class="s5">&quot;réve🐍 illé&quot;</span><span class="s1">]]</span><span class="s3">,</span>
            <span class="s1">}</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s1">row = connection.execute(</span>
            <span class="s1">select(array_table.c.single_dim</span><span class="s3">, </span><span class="s1">array_table.c.multi_dim)</span>
        <span class="s1">).first()</span>
        <span class="s1">eq_(row</span><span class="s3">, </span><span class="s1">([</span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">3</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[[</span><span class="s5">&quot;one&quot;</span><span class="s3">, </span><span class="s5">&quot;two&quot;</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">&quot;thr'ee&quot;</span><span class="s3">, </span><span class="s5">&quot;réve🐍 illé&quot;</span><span class="s1">]]))</span>

    <span class="s2">def </span><span class="s1">test_literal_simple(self</span><span class="s3">, </span><span class="s1">literal_round_trip):</span>
        <span class="s1">literal_round_trip(</span>
            <span class="s1">ARRAY(Integer)</span><span class="s3">,</span>
            <span class="s1">([</span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">3</span><span class="s1">]</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">([</span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">3</span><span class="s1">]</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">support_whereclause=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_literal_complex(self</span><span class="s3">, </span><span class="s1">literal_round_trip):</span>
        <span class="s1">literal_round_trip(</span>
            <span class="s1">ARRAY(String</span><span class="s3">, </span><span class="s1">dimensions=</span><span class="s6">2</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">([[</span><span class="s5">&quot;one&quot;</span><span class="s3">, </span><span class="s5">&quot;two&quot;</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">&quot;thr'ee&quot;</span><span class="s3">, </span><span class="s5">&quot;réve🐍 illé&quot;</span><span class="s1">]]</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">([[</span><span class="s5">&quot;one&quot;</span><span class="s3">, </span><span class="s5">&quot;two&quot;</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">&quot;thr'ee&quot;</span><span class="s3">, </span><span class="s5">&quot;réve🐍 illé&quot;</span><span class="s1">]]</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">support_whereclause=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">BinaryTest(_LiteralRoundTripFixture</span><span class="s3">, </span><span class="s1">fixtures.TablesTest):</span>
    <span class="s1">__backend__ = </span><span class="s2">True</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">define_tables(cls</span><span class="s3">, </span><span class="s1">metadata):</span>
        <span class="s1">Table(</span>
            <span class="s5">&quot;binary_table&quot;</span><span class="s3">,</span>
            <span class="s1">metadata</span><span class="s3">,</span>
            <span class="s1">Column(</span>
                <span class="s5">&quot;id&quot;</span><span class="s3">, </span><span class="s1">Integer</span><span class="s3">, </span><span class="s1">primary_key=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">test_needs_autoincrement=</span><span class="s2">True</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">Column(</span><span class="s5">&quot;binary_data&quot;</span><span class="s3">, </span><span class="s1">LargeBinary)</span><span class="s3">,</span>
            <span class="s1">Column(</span><span class="s5">&quot;pickle_data&quot;</span><span class="s3">, </span><span class="s1">PickleType)</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s1">@testing.combinations(</span><span class="s7">b&quot;this is binary&quot;</span><span class="s3">, </span><span class="s7">b&quot;7</span><span class="s8">\xe7\x9f</span><span class="s7">&quot;</span><span class="s3">, </span><span class="s1">argnames=</span><span class="s5">&quot;data&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_binary_roundtrip(self</span><span class="s3">, </span><span class="s1">connection</span><span class="s3">, </span><span class="s1">data):</span>
        <span class="s1">binary_table = self.tables.binary_table</span>

        <span class="s1">connection.execute(</span>
            <span class="s1">binary_table.insert()</span><span class="s3">, </span><span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">1</span><span class="s3">, </span><span class="s5">&quot;binary_data&quot;</span><span class="s1">: data}</span>
        <span class="s1">)</span>
        <span class="s1">row = connection.execute(select(binary_table.c.binary_data)).first()</span>
        <span class="s1">eq_(row</span><span class="s3">, </span><span class="s1">(data</span><span class="s3">,</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_pickle_roundtrip(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">binary_table = self.tables.binary_table</span>

        <span class="s1">connection.execute(</span>
            <span class="s1">binary_table.insert()</span><span class="s3">,</span>
            <span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">1</span><span class="s3">, </span><span class="s5">&quot;pickle_data&quot;</span><span class="s1">: {</span><span class="s5">&quot;foo&quot;</span><span class="s1">: [</span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">3</span><span class="s1">]</span><span class="s3">, </span><span class="s5">&quot;bar&quot;</span><span class="s1">: </span><span class="s5">&quot;bat&quot;</span><span class="s1">}}</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s1">row = connection.execute(select(binary_table.c.pickle_data)).first()</span>
        <span class="s1">eq_(row</span><span class="s3">, </span><span class="s1">({</span><span class="s5">&quot;foo&quot;</span><span class="s1">: [</span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">3</span><span class="s1">]</span><span class="s3">, </span><span class="s5">&quot;bar&quot;</span><span class="s1">: </span><span class="s5">&quot;bat&quot;</span><span class="s1">}</span><span class="s3">,</span><span class="s1">))</span>


<span class="s2">class </span><span class="s1">TextTest(_LiteralRoundTripFixture</span><span class="s3">, </span><span class="s1">fixtures.TablesTest):</span>
    <span class="s1">__requires__ = (</span><span class="s5">&quot;text_type&quot;</span><span class="s3">,</span><span class="s1">)</span>
    <span class="s1">__backend__ = </span><span class="s2">True</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">supports_whereclause(self):</span>
        <span class="s2">return </span><span class="s1">config.requirements.expressions_against_unbounded_text.enabled</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">define_tables(cls</span><span class="s3">, </span><span class="s1">metadata):</span>
        <span class="s1">Table(</span>
            <span class="s5">&quot;text_table&quot;</span><span class="s3">,</span>
            <span class="s1">metadata</span><span class="s3">,</span>
            <span class="s1">Column(</span>
                <span class="s5">&quot;id&quot;</span><span class="s3">, </span><span class="s1">Integer</span><span class="s3">, </span><span class="s1">primary_key=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">test_needs_autoincrement=</span><span class="s2">True</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">Column(</span><span class="s5">&quot;text_data&quot;</span><span class="s3">, </span><span class="s1">Text)</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_text_roundtrip(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">text_table = self.tables.text_table</span>

        <span class="s1">connection.execute(</span>
            <span class="s1">text_table.insert()</span><span class="s3">, </span><span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">1</span><span class="s3">, </span><span class="s5">&quot;text_data&quot;</span><span class="s1">: </span><span class="s5">&quot;some text&quot;</span><span class="s1">}</span>
        <span class="s1">)</span>
        <span class="s1">row = connection.execute(select(text_table.c.text_data)).first()</span>
        <span class="s1">eq_(row</span><span class="s3">, </span><span class="s1">(</span><span class="s5">&quot;some text&quot;</span><span class="s3">,</span><span class="s1">))</span>

    <span class="s1">@testing.requires.empty_strings_text</span>
    <span class="s2">def </span><span class="s1">test_text_empty_strings(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">text_table = self.tables.text_table</span>

        <span class="s1">connection.execute(text_table.insert()</span><span class="s3">, </span><span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">1</span><span class="s3">, </span><span class="s5">&quot;text_data&quot;</span><span class="s1">: </span><span class="s5">&quot;&quot;</span><span class="s1">})</span>
        <span class="s1">row = connection.execute(select(text_table.c.text_data)).first()</span>
        <span class="s1">eq_(row</span><span class="s3">, </span><span class="s1">(</span><span class="s5">&quot;&quot;</span><span class="s3">,</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_text_null_strings(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">text_table = self.tables.text_table</span>

        <span class="s1">connection.execute(text_table.insert()</span><span class="s3">, </span><span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">1</span><span class="s3">, </span><span class="s5">&quot;text_data&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s1">})</span>
        <span class="s1">row = connection.execute(select(text_table.c.text_data)).first()</span>
        <span class="s1">eq_(row</span><span class="s3">, </span><span class="s1">(</span><span class="s2">None</span><span class="s3">,</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_literal(self</span><span class="s3">, </span><span class="s1">literal_round_trip):</span>
        <span class="s1">literal_round_trip(Text</span><span class="s3">, </span><span class="s1">[</span><span class="s5">&quot;some text&quot;</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">&quot;some text&quot;</span><span class="s1">])</span>

    <span class="s1">@requirements.unicode_data_no_special_types</span>
    <span class="s2">def </span><span class="s1">test_literal_non_ascii(self</span><span class="s3">, </span><span class="s1">literal_round_trip):</span>
        <span class="s1">literal_round_trip(Text</span><span class="s3">, </span><span class="s1">[</span><span class="s5">&quot;réve🐍 illé&quot;</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">&quot;réve🐍 illé&quot;</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_literal_quoting(self</span><span class="s3">, </span><span class="s1">literal_round_trip):</span>
        <span class="s1">data = </span><span class="s5">&quot;&quot;&quot;some 'text' hey &quot;hi there&quot; that's text&quot;&quot;&quot;</span>
        <span class="s1">literal_round_trip(Text</span><span class="s3">, </span><span class="s1">[data]</span><span class="s3">, </span><span class="s1">[data])</span>

    <span class="s2">def </span><span class="s1">test_literal_backslashes(self</span><span class="s3">, </span><span class="s1">literal_round_trip):</span>
        <span class="s1">data = </span><span class="s5">r&quot;backslash one \ backslash two \\ end&quot;</span>
        <span class="s1">literal_round_trip(Text</span><span class="s3">, </span><span class="s1">[data]</span><span class="s3">, </span><span class="s1">[data])</span>

    <span class="s2">def </span><span class="s1">test_literal_percentsigns(self</span><span class="s3">, </span><span class="s1">literal_round_trip):</span>
        <span class="s1">data = </span><span class="s5">r&quot;percent % signs %% percent&quot;</span>
        <span class="s1">literal_round_trip(Text</span><span class="s3">, </span><span class="s1">[data]</span><span class="s3">, </span><span class="s1">[data])</span>


<span class="s2">class </span><span class="s1">StringTest(_LiteralRoundTripFixture</span><span class="s3">, </span><span class="s1">fixtures.TestBase):</span>
    <span class="s1">__backend__ = </span><span class="s2">True</span>

    <span class="s1">@requirements.unbounded_varchar</span>
    <span class="s2">def </span><span class="s1">test_nolength_string(self):</span>
        <span class="s1">metadata = MetaData()</span>
        <span class="s1">foo = Table(</span><span class="s5">&quot;foo&quot;</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">Column(</span><span class="s5">&quot;one&quot;</span><span class="s3">, </span><span class="s1">String))</span>

        <span class="s1">foo.create(config.db)</span>
        <span class="s1">foo.drop(config.db)</span>

    <span class="s2">def </span><span class="s1">test_literal(self</span><span class="s3">, </span><span class="s1">literal_round_trip):</span>
        <span class="s0"># note that in Python 3, this invokes the Unicode</span>
        <span class="s0"># datatype for the literal part because all strings are unicode</span>
        <span class="s1">literal_round_trip(String(</span><span class="s6">40</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s5">&quot;some text&quot;</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">&quot;some text&quot;</span><span class="s1">])</span>

    <span class="s1">@requirements.unicode_data_no_special_types</span>
    <span class="s2">def </span><span class="s1">test_literal_non_ascii(self</span><span class="s3">, </span><span class="s1">literal_round_trip):</span>
        <span class="s1">literal_round_trip(String(</span><span class="s6">40</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s5">&quot;réve🐍 illé&quot;</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">&quot;réve🐍 illé&quot;</span><span class="s1">])</span>

    <span class="s1">@testing.combinations(</span>
        <span class="s1">(</span><span class="s5">&quot;%B%&quot;</span><span class="s3">, </span><span class="s1">[</span><span class="s5">&quot;AB&quot;</span><span class="s3">, </span><span class="s5">&quot;BC&quot;</span><span class="s1">])</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s5">&quot;A%C&quot;</span><span class="s3">, </span><span class="s1">[</span><span class="s5">&quot;AC&quot;</span><span class="s1">])</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s5">&quot;A%C%Z&quot;</span><span class="s3">, </span><span class="s1">[])</span><span class="s3">,</span>
        <span class="s1">argnames=</span><span class="s5">&quot;expr, expected&quot;</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_dont_truncate_rightside(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">connection</span><span class="s3">, </span><span class="s1">expr</span><span class="s3">, </span><span class="s1">expected</span>
    <span class="s1">):</span>
        <span class="s1">t = Table(</span><span class="s5">&quot;t&quot;</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">Column(</span><span class="s5">&quot;x&quot;</span><span class="s3">, </span><span class="s1">String(</span><span class="s6">2</span><span class="s1">)))</span>
        <span class="s1">t.create(connection)</span>

        <span class="s1">connection.execute(t.insert()</span><span class="s3">, </span><span class="s1">[{</span><span class="s5">&quot;x&quot;</span><span class="s1">: </span><span class="s5">&quot;AB&quot;</span><span class="s1">}</span><span class="s3">, </span><span class="s1">{</span><span class="s5">&quot;x&quot;</span><span class="s1">: </span><span class="s5">&quot;BC&quot;</span><span class="s1">}</span><span class="s3">, </span><span class="s1">{</span><span class="s5">&quot;x&quot;</span><span class="s1">: </span><span class="s5">&quot;AC&quot;</span><span class="s1">}])</span>

        <span class="s1">eq_(</span>
            <span class="s1">connection.scalars(select(t.c.x).where(t.c.x.like(expr))).all()</span><span class="s3">,</span>
            <span class="s1">expected</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_literal_quoting(self</span><span class="s3">, </span><span class="s1">literal_round_trip):</span>
        <span class="s1">data = </span><span class="s5">&quot;&quot;&quot;some 'text' hey &quot;hi there&quot; that's text&quot;&quot;&quot;</span>
        <span class="s1">literal_round_trip(String(</span><span class="s6">40</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[data]</span><span class="s3">, </span><span class="s1">[data])</span>

    <span class="s2">def </span><span class="s1">test_literal_backslashes(self</span><span class="s3">, </span><span class="s1">literal_round_trip):</span>
        <span class="s1">data = </span><span class="s5">r&quot;backslash one \ backslash two \\ end&quot;</span>
        <span class="s1">literal_round_trip(String(</span><span class="s6">40</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[data]</span><span class="s3">, </span><span class="s1">[data])</span>

    <span class="s2">def </span><span class="s1">test_concatenate_binary(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s4">&quot;&quot;&quot;dialects with special string concatenation operators should 
        implement visit_concat_op_binary() and visit_concat_op_clauselist() 
        in their compiler. 
 
        .. versionchanged:: 2.0  visit_concat_op_clauselist() is also needed 
           for dialects to override the string concatenation operator. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">eq_(connection.scalar(select(literal(</span><span class="s5">&quot;a&quot;</span><span class="s1">) + </span><span class="s5">&quot;b&quot;</span><span class="s1">))</span><span class="s3">, </span><span class="s5">&quot;ab&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_concatenate_clauselist(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s4">&quot;&quot;&quot;dialects with special string concatenation operators should 
        implement visit_concat_op_binary() and visit_concat_op_clauselist() 
        in their compiler. 
 
        .. versionchanged:: 2.0  visit_concat_op_clauselist() is also needed 
           for dialects to override the string concatenation operator. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">eq_(</span>
            <span class="s1">connection.scalar(select(literal(</span><span class="s5">&quot;a&quot;</span><span class="s1">) + </span><span class="s5">&quot;b&quot; </span><span class="s1">+ </span><span class="s5">&quot;c&quot; </span><span class="s1">+ </span><span class="s5">&quot;d&quot; </span><span class="s1">+ </span><span class="s5">&quot;e&quot;</span><span class="s1">))</span><span class="s3">,</span>
            <span class="s5">&quot;abcde&quot;</span><span class="s3">,</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">IntervalTest(_LiteralRoundTripFixture</span><span class="s3">, </span><span class="s1">fixtures.TestBase):</span>
    <span class="s1">__requires__ = (</span><span class="s5">&quot;datetime_interval&quot;</span><span class="s3">,</span><span class="s1">)</span>
    <span class="s1">__backend__ = </span><span class="s2">True</span>

    <span class="s1">datatype = Interval</span>
    <span class="s1">data = datetime.timedelta(days=</span><span class="s6">1</span><span class="s3">, </span><span class="s1">seconds=</span><span class="s6">4</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_literal(self</span><span class="s3">, </span><span class="s1">literal_round_trip):</span>
        <span class="s1">literal_round_trip(self.datatype</span><span class="s3">, </span><span class="s1">[self.data]</span><span class="s3">, </span><span class="s1">[self.data])</span>

    <span class="s2">def </span><span class="s1">test_select_direct_literal_interval(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">row = connection.execute(select(literal(self.data))).first()</span>
        <span class="s1">eq_(row</span><span class="s3">, </span><span class="s1">(self.data</span><span class="s3">,</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_arithmetic_operation_literal_interval(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">now = datetime.datetime.now().replace(microsecond=</span><span class="s6">0</span><span class="s1">)</span>
        <span class="s0"># Able to subtract</span>
        <span class="s1">row = connection.execute(</span>
            <span class="s1">select(literal(now) - literal(self.data))</span>
        <span class="s1">).scalar()</span>
        <span class="s1">eq_(row</span><span class="s3">, </span><span class="s1">now - self.data)</span>

        <span class="s0"># Able to Add</span>
        <span class="s1">row = connection.execute(</span>
            <span class="s1">select(literal(now) + literal(self.data))</span>
        <span class="s1">).scalar()</span>
        <span class="s1">eq_(row</span><span class="s3">, </span><span class="s1">now + self.data)</span>

    <span class="s1">@testing.fixture</span>
    <span class="s2">def </span><span class="s1">arithmetic_table_fixture(cls</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s2">class </span><span class="s1">Decorated(TypeDecorator):</span>
            <span class="s1">impl = cls.datatype</span>
            <span class="s1">cache_ok = </span><span class="s2">True</span>

        <span class="s1">it = Table(</span>
            <span class="s5">&quot;interval_table&quot;</span><span class="s3">,</span>
            <span class="s1">metadata</span><span class="s3">,</span>
            <span class="s1">Column(</span>
                <span class="s5">&quot;id&quot;</span><span class="s3">, </span><span class="s1">Integer</span><span class="s3">, </span><span class="s1">primary_key=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">test_needs_autoincrement=</span><span class="s2">True</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">Column(</span><span class="s5">&quot;interval_data&quot;</span><span class="s3">, </span><span class="s1">cls.datatype)</span><span class="s3">,</span>
            <span class="s1">Column(</span><span class="s5">&quot;date_data&quot;</span><span class="s3">, </span><span class="s1">DateTime)</span><span class="s3">,</span>
            <span class="s1">Column(</span><span class="s5">&quot;decorated_interval_data&quot;</span><span class="s3">, </span><span class="s1">Decorated)</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s1">it.create(connection)</span>
        <span class="s2">return </span><span class="s1">it</span>

    <span class="s2">def </span><span class="s1">test_arithmetic_operation_table_interval_and_literal_interval(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">connection</span><span class="s3">, </span><span class="s1">arithmetic_table_fixture</span>
    <span class="s1">):</span>
        <span class="s1">interval_table = arithmetic_table_fixture</span>
        <span class="s1">data = datetime.timedelta(days=</span><span class="s6">2</span><span class="s3">, </span><span class="s1">seconds=</span><span class="s6">5</span><span class="s1">)</span>
        <span class="s1">connection.execute(</span>
            <span class="s1">interval_table.insert()</span><span class="s3">, </span><span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">1</span><span class="s3">, </span><span class="s5">&quot;interval_data&quot;</span><span class="s1">: data}</span>
        <span class="s1">)</span>
        <span class="s0"># Subtraction Operation</span>
        <span class="s1">value = connection.execute(</span>
            <span class="s1">select(interval_table.c.interval_data - literal(self.data))</span>
        <span class="s1">).scalar()</span>
        <span class="s1">eq_(value</span><span class="s3">, </span><span class="s1">data - self.data)</span>

        <span class="s0"># Addition Operation</span>
        <span class="s1">value = connection.execute(</span>
            <span class="s1">select(interval_table.c.interval_data + literal(self.data))</span>
        <span class="s1">).scalar()</span>
        <span class="s1">eq_(value</span><span class="s3">, </span><span class="s1">data + self.data)</span>

    <span class="s2">def </span><span class="s1">test_arithmetic_operation_table_date_and_literal_interval(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">connection</span><span class="s3">, </span><span class="s1">arithmetic_table_fixture</span>
    <span class="s1">):</span>
        <span class="s1">interval_table = arithmetic_table_fixture</span>
        <span class="s1">now = datetime.datetime.now().replace(microsecond=</span><span class="s6">0</span><span class="s1">)</span>
        <span class="s1">connection.execute(</span>
            <span class="s1">interval_table.insert()</span><span class="s3">, </span><span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">1</span><span class="s3">, </span><span class="s5">&quot;date_data&quot;</span><span class="s1">: now}</span>
        <span class="s1">)</span>
        <span class="s0"># Subtraction Operation</span>
        <span class="s1">value = connection.execute(</span>
            <span class="s1">select(interval_table.c.date_data - literal(self.data))</span>
        <span class="s1">).scalar()</span>
        <span class="s1">eq_(value</span><span class="s3">, </span><span class="s1">(now - self.data))</span>

        <span class="s0"># Addition Operation</span>
        <span class="s1">value = connection.execute(</span>
            <span class="s1">select(interval_table.c.date_data + literal(self.data))</span>
        <span class="s1">).scalar()</span>
        <span class="s1">eq_(value</span><span class="s3">, </span><span class="s1">(now + self.data))</span>


<span class="s2">class </span><span class="s1">PrecisionIntervalTest(IntervalTest):</span>
    <span class="s1">__requires__ = (</span><span class="s5">&quot;datetime_interval&quot;</span><span class="s3">,</span><span class="s1">)</span>
    <span class="s1">__backend__ = </span><span class="s2">True</span>

    <span class="s1">datatype = Interval(day_precision=</span><span class="s6">9</span><span class="s3">, </span><span class="s1">second_precision=</span><span class="s6">9</span><span class="s1">)</span>
    <span class="s1">data = datetime.timedelta(days=</span><span class="s6">103</span><span class="s3">, </span><span class="s1">seconds=</span><span class="s6">4</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">_DateFixture(_LiteralRoundTripFixture</span><span class="s3">, </span><span class="s1">fixtures.TestBase):</span>
    <span class="s1">compare = </span><span class="s2">None</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">define_tables(cls</span><span class="s3">, </span><span class="s1">metadata):</span>
        <span class="s2">class </span><span class="s1">Decorated(TypeDecorator):</span>
            <span class="s1">impl = cls.datatype</span>
            <span class="s1">cache_ok = </span><span class="s2">True</span>

        <span class="s1">Table(</span>
            <span class="s5">&quot;date_table&quot;</span><span class="s3">,</span>
            <span class="s1">metadata</span><span class="s3">,</span>
            <span class="s1">Column(</span>
                <span class="s5">&quot;id&quot;</span><span class="s3">, </span><span class="s1">Integer</span><span class="s3">, </span><span class="s1">primary_key=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">test_needs_autoincrement=</span><span class="s2">True</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">Column(</span><span class="s5">&quot;date_data&quot;</span><span class="s3">, </span><span class="s1">cls.datatype)</span><span class="s3">,</span>
            <span class="s1">Column(</span><span class="s5">&quot;decorated_date_data&quot;</span><span class="s3">, </span><span class="s1">Decorated)</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_round_trip(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">date_table = self.tables.date_table</span>

        <span class="s1">connection.execute(</span>
            <span class="s1">date_table.insert()</span><span class="s3">, </span><span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">1</span><span class="s3">, </span><span class="s5">&quot;date_data&quot;</span><span class="s1">: self.data}</span>
        <span class="s1">)</span>

        <span class="s1">row = connection.execute(select(date_table.c.date_data)).first()</span>

        <span class="s1">compare = self.compare </span><span class="s2">or </span><span class="s1">self.data</span>
        <span class="s1">eq_(row</span><span class="s3">, </span><span class="s1">(compare</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s2">assert </span><span class="s1">isinstance(row[</span><span class="s6">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">type(compare))</span>

    <span class="s2">def </span><span class="s1">test_round_trip_decorated(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">date_table = self.tables.date_table</span>

        <span class="s1">connection.execute(</span>
            <span class="s1">date_table.insert()</span><span class="s3">, </span><span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">1</span><span class="s3">, </span><span class="s5">&quot;decorated_date_data&quot;</span><span class="s1">: self.data}</span>
        <span class="s1">)</span>

        <span class="s1">row = connection.execute(</span>
            <span class="s1">select(date_table.c.decorated_date_data)</span>
        <span class="s1">).first()</span>

        <span class="s1">compare = self.compare </span><span class="s2">or </span><span class="s1">self.data</span>
        <span class="s1">eq_(row</span><span class="s3">, </span><span class="s1">(compare</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s2">assert </span><span class="s1">isinstance(row[</span><span class="s6">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">type(compare))</span>

    <span class="s2">def </span><span class="s1">test_null(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">date_table = self.tables.date_table</span>

        <span class="s1">connection.execute(date_table.insert()</span><span class="s3">, </span><span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">1</span><span class="s3">, </span><span class="s5">&quot;date_data&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s1">})</span>

        <span class="s1">row = connection.execute(select(date_table.c.date_data)).first()</span>
        <span class="s1">eq_(row</span><span class="s3">, </span><span class="s1">(</span><span class="s2">None</span><span class="s3">,</span><span class="s1">))</span>

    <span class="s1">@testing.requires.datetime_literals</span>
    <span class="s2">def </span><span class="s1">test_literal(self</span><span class="s3">, </span><span class="s1">literal_round_trip):</span>
        <span class="s1">compare = self.compare </span><span class="s2">or </span><span class="s1">self.data</span>

        <span class="s1">literal_round_trip(</span>
            <span class="s1">self.datatype</span><span class="s3">, </span><span class="s1">[self.data]</span><span class="s3">, </span><span class="s1">[compare]</span><span class="s3">, </span><span class="s1">compare=compare</span>
        <span class="s1">)</span>

    <span class="s1">@testing.requires.standalone_null_binds_whereclause</span>
    <span class="s2">def </span><span class="s1">test_null_bound_comparison(self):</span>
        <span class="s0"># this test is based on an Oracle issue observed in #4886.</span>
        <span class="s0"># passing NULL for an expression that needs to be interpreted as</span>
        <span class="s0"># a certain type, does the DBAPI have the info it needs to do this.</span>
        <span class="s1">date_table = self.tables.date_table</span>
        <span class="s2">with </span><span class="s1">config.db.begin() </span><span class="s2">as </span><span class="s1">conn:</span>
            <span class="s1">result = conn.execute(</span>
                <span class="s1">date_table.insert()</span><span class="s3">, </span><span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">1</span><span class="s3">, </span><span class="s5">&quot;date_data&quot;</span><span class="s1">: self.data}</span>
            <span class="s1">)</span>
            <span class="s1">id_ = result.inserted_primary_key[</span><span class="s6">0</span><span class="s1">]</span>
            <span class="s1">stmt = select(date_table.c.id).where(</span>
                <span class="s1">case(</span>
                    <span class="s1">(</span>
                        <span class="s1">bindparam(</span><span class="s5">&quot;foo&quot;</span><span class="s3">, </span><span class="s1">type_=self.datatype) != </span><span class="s2">None</span><span class="s3">,</span>
                        <span class="s1">bindparam(</span><span class="s5">&quot;foo&quot;</span><span class="s3">, </span><span class="s1">type_=self.datatype)</span><span class="s3">,</span>
                    <span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">else_=date_table.c.date_data</span><span class="s3">,</span>
                <span class="s1">)</span>
                <span class="s1">== date_table.c.date_data</span>
            <span class="s1">)</span>

            <span class="s1">row = conn.execute(stmt</span><span class="s3">, </span><span class="s1">{</span><span class="s5">&quot;foo&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s1">}).first()</span>
            <span class="s1">eq_(row[</span><span class="s6">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">id_)</span>


<span class="s2">class </span><span class="s1">DateTimeTest(_DateFixture</span><span class="s3">, </span><span class="s1">fixtures.TablesTest):</span>
    <span class="s1">__requires__ = (</span><span class="s5">&quot;datetime&quot;</span><span class="s3">,</span><span class="s1">)</span>
    <span class="s1">__backend__ = </span><span class="s2">True</span>
    <span class="s1">datatype = DateTime</span>
    <span class="s1">data = datetime.datetime(</span><span class="s6">2012</span><span class="s3">, </span><span class="s6">10</span><span class="s3">, </span><span class="s6">15</span><span class="s3">, </span><span class="s6">12</span><span class="s3">, </span><span class="s6">57</span><span class="s3">, </span><span class="s6">18</span><span class="s1">)</span>

    <span class="s1">@testing.requires.datetime_implicit_bound</span>
    <span class="s2">def </span><span class="s1">test_select_direct(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">result = connection.scalar(select(literal(self.data)))</span>
        <span class="s1">eq_(result</span><span class="s3">, </span><span class="s1">self.data)</span>


<span class="s2">class </span><span class="s1">DateTimeTZTest(_DateFixture</span><span class="s3">, </span><span class="s1">fixtures.TablesTest):</span>
    <span class="s1">__requires__ = (</span><span class="s5">&quot;datetime_timezone&quot;</span><span class="s3">,</span><span class="s1">)</span>
    <span class="s1">__backend__ = </span><span class="s2">True</span>
    <span class="s1">datatype = DateTime(timezone=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">data = datetime.datetime(</span>
        <span class="s6">2012</span><span class="s3">, </span><span class="s6">10</span><span class="s3">, </span><span class="s6">15</span><span class="s3">, </span><span class="s6">12</span><span class="s3">, </span><span class="s6">57</span><span class="s3">, </span><span class="s6">18</span><span class="s3">, </span><span class="s1">tzinfo=datetime.timezone.utc</span>
    <span class="s1">)</span>

    <span class="s1">@testing.requires.datetime_implicit_bound</span>
    <span class="s2">def </span><span class="s1">test_select_direct(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">result = connection.scalar(select(literal(self.data)))</span>
        <span class="s1">eq_(result</span><span class="s3">, </span><span class="s1">self.data)</span>


<span class="s2">class </span><span class="s1">DateTimeMicrosecondsTest(_DateFixture</span><span class="s3">, </span><span class="s1">fixtures.TablesTest):</span>
    <span class="s1">__requires__ = (</span><span class="s5">&quot;datetime_microseconds&quot;</span><span class="s3">,</span><span class="s1">)</span>
    <span class="s1">__backend__ = </span><span class="s2">True</span>
    <span class="s1">datatype = DateTime</span>
    <span class="s1">data = datetime.datetime(</span><span class="s6">2012</span><span class="s3">, </span><span class="s6">10</span><span class="s3">, </span><span class="s6">15</span><span class="s3">, </span><span class="s6">12</span><span class="s3">, </span><span class="s6">57</span><span class="s3">, </span><span class="s6">18</span><span class="s3">, </span><span class="s6">39642</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TimestampMicrosecondsTest(_DateFixture</span><span class="s3">, </span><span class="s1">fixtures.TablesTest):</span>
    <span class="s1">__requires__ = (</span><span class="s5">&quot;timestamp_microseconds&quot;</span><span class="s3">,</span><span class="s1">)</span>
    <span class="s1">__backend__ = </span><span class="s2">True</span>
    <span class="s1">datatype = TIMESTAMP</span>
    <span class="s1">data = datetime.datetime(</span><span class="s6">2012</span><span class="s3">, </span><span class="s6">10</span><span class="s3">, </span><span class="s6">15</span><span class="s3">, </span><span class="s6">12</span><span class="s3">, </span><span class="s6">57</span><span class="s3">, </span><span class="s6">18</span><span class="s3">, </span><span class="s6">396</span><span class="s1">)</span>

    <span class="s1">@testing.requires.timestamp_microseconds_implicit_bound</span>
    <span class="s2">def </span><span class="s1">test_select_direct(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">result = connection.scalar(select(literal(self.data)))</span>
        <span class="s1">eq_(result</span><span class="s3">, </span><span class="s1">self.data)</span>


<span class="s2">class </span><span class="s1">TimeTest(_DateFixture</span><span class="s3">, </span><span class="s1">fixtures.TablesTest):</span>
    <span class="s1">__requires__ = (</span><span class="s5">&quot;time&quot;</span><span class="s3">,</span><span class="s1">)</span>
    <span class="s1">__backend__ = </span><span class="s2">True</span>
    <span class="s1">datatype = Time</span>
    <span class="s1">data = datetime.time(</span><span class="s6">12</span><span class="s3">, </span><span class="s6">57</span><span class="s3">, </span><span class="s6">18</span><span class="s1">)</span>

    <span class="s1">@testing.requires.time_implicit_bound</span>
    <span class="s2">def </span><span class="s1">test_select_direct(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">result = connection.scalar(select(literal(self.data)))</span>
        <span class="s1">eq_(result</span><span class="s3">, </span><span class="s1">self.data)</span>


<span class="s2">class </span><span class="s1">TimeTZTest(_DateFixture</span><span class="s3">, </span><span class="s1">fixtures.TablesTest):</span>
    <span class="s1">__requires__ = (</span><span class="s5">&quot;time_timezone&quot;</span><span class="s3">,</span><span class="s1">)</span>
    <span class="s1">__backend__ = </span><span class="s2">True</span>
    <span class="s1">datatype = Time(timezone=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">data = datetime.time(</span><span class="s6">12</span><span class="s3">, </span><span class="s6">57</span><span class="s3">, </span><span class="s6">18</span><span class="s3">, </span><span class="s1">tzinfo=datetime.timezone.utc)</span>

    <span class="s1">@testing.requires.time_implicit_bound</span>
    <span class="s2">def </span><span class="s1">test_select_direct(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">result = connection.scalar(select(literal(self.data)))</span>
        <span class="s1">eq_(result</span><span class="s3">, </span><span class="s1">self.data)</span>


<span class="s2">class </span><span class="s1">TimeMicrosecondsTest(_DateFixture</span><span class="s3">, </span><span class="s1">fixtures.TablesTest):</span>
    <span class="s1">__requires__ = (</span><span class="s5">&quot;time_microseconds&quot;</span><span class="s3">,</span><span class="s1">)</span>
    <span class="s1">__backend__ = </span><span class="s2">True</span>
    <span class="s1">datatype = Time</span>
    <span class="s1">data = datetime.time(</span><span class="s6">12</span><span class="s3">, </span><span class="s6">57</span><span class="s3">, </span><span class="s6">18</span><span class="s3">, </span><span class="s6">396</span><span class="s1">)</span>

    <span class="s1">@testing.requires.time_implicit_bound</span>
    <span class="s2">def </span><span class="s1">test_select_direct(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">result = connection.scalar(select(literal(self.data)))</span>
        <span class="s1">eq_(result</span><span class="s3">, </span><span class="s1">self.data)</span>


<span class="s2">class </span><span class="s1">DateTest(_DateFixture</span><span class="s3">, </span><span class="s1">fixtures.TablesTest):</span>
    <span class="s1">__requires__ = (</span><span class="s5">&quot;date&quot;</span><span class="s3">,</span><span class="s1">)</span>
    <span class="s1">__backend__ = </span><span class="s2">True</span>
    <span class="s1">datatype = Date</span>
    <span class="s1">data = datetime.date(</span><span class="s6">2012</span><span class="s3">, </span><span class="s6">10</span><span class="s3">, </span><span class="s6">15</span><span class="s1">)</span>

    <span class="s1">@testing.requires.date_implicit_bound</span>
    <span class="s2">def </span><span class="s1">test_select_direct(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">result = connection.scalar(select(literal(self.data)))</span>
        <span class="s1">eq_(result</span><span class="s3">, </span><span class="s1">self.data)</span>


<span class="s2">class </span><span class="s1">DateTimeCoercedToDateTimeTest(_DateFixture</span><span class="s3">, </span><span class="s1">fixtures.TablesTest):</span>
    <span class="s4">&quot;&quot;&quot;this particular suite is testing that datetime parameters get 
    coerced to dates, which tends to be something DBAPIs do. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__requires__ = </span><span class="s5">&quot;date&quot;</span><span class="s3">, </span><span class="s5">&quot;date_coerces_from_datetime&quot;</span>
    <span class="s1">__backend__ = </span><span class="s2">True</span>
    <span class="s1">datatype = Date</span>
    <span class="s1">data = datetime.datetime(</span><span class="s6">2012</span><span class="s3">, </span><span class="s6">10</span><span class="s3">, </span><span class="s6">15</span><span class="s3">, </span><span class="s6">12</span><span class="s3">, </span><span class="s6">57</span><span class="s3">, </span><span class="s6">18</span><span class="s1">)</span>
    <span class="s1">compare = datetime.date(</span><span class="s6">2012</span><span class="s3">, </span><span class="s6">10</span><span class="s3">, </span><span class="s6">15</span><span class="s1">)</span>

    <span class="s1">@testing.requires.datetime_implicit_bound</span>
    <span class="s2">def </span><span class="s1">test_select_direct(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">result = connection.scalar(select(literal(self.data)))</span>
        <span class="s1">eq_(result</span><span class="s3">, </span><span class="s1">self.data)</span>


<span class="s2">class </span><span class="s1">DateTimeHistoricTest(_DateFixture</span><span class="s3">, </span><span class="s1">fixtures.TablesTest):</span>
    <span class="s1">__requires__ = (</span><span class="s5">&quot;datetime_historic&quot;</span><span class="s3">,</span><span class="s1">)</span>
    <span class="s1">__backend__ = </span><span class="s2">True</span>
    <span class="s1">datatype = DateTime</span>
    <span class="s1">data = datetime.datetime(</span><span class="s6">1850</span><span class="s3">, </span><span class="s6">11</span><span class="s3">, </span><span class="s6">10</span><span class="s3">, </span><span class="s6">11</span><span class="s3">, </span><span class="s6">52</span><span class="s3">, </span><span class="s6">35</span><span class="s1">)</span>

    <span class="s1">@testing.requires.date_implicit_bound</span>
    <span class="s2">def </span><span class="s1">test_select_direct(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">result = connection.scalar(select(literal(self.data)))</span>
        <span class="s1">eq_(result</span><span class="s3">, </span><span class="s1">self.data)</span>


<span class="s2">class </span><span class="s1">DateHistoricTest(_DateFixture</span><span class="s3">, </span><span class="s1">fixtures.TablesTest):</span>
    <span class="s1">__requires__ = (</span><span class="s5">&quot;date_historic&quot;</span><span class="s3">,</span><span class="s1">)</span>
    <span class="s1">__backend__ = </span><span class="s2">True</span>
    <span class="s1">datatype = Date</span>
    <span class="s1">data = datetime.date(</span><span class="s6">1727</span><span class="s3">, </span><span class="s6">4</span><span class="s3">, </span><span class="s6">1</span><span class="s1">)</span>

    <span class="s1">@testing.requires.date_implicit_bound</span>
    <span class="s2">def </span><span class="s1">test_select_direct(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">result = connection.scalar(select(literal(self.data)))</span>
        <span class="s1">eq_(result</span><span class="s3">, </span><span class="s1">self.data)</span>


<span class="s2">class </span><span class="s1">IntegerTest(_LiteralRoundTripFixture</span><span class="s3">, </span><span class="s1">fixtures.TestBase):</span>
    <span class="s1">__backend__ = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">test_literal(self</span><span class="s3">, </span><span class="s1">literal_round_trip):</span>
        <span class="s1">literal_round_trip(Integer</span><span class="s3">, </span><span class="s1">[</span><span class="s6">5</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s6">5</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">_huge_ints():</span>
        <span class="s2">return </span><span class="s1">testing.combinations(</span>
            <span class="s6">2147483649</span><span class="s3">,  </span><span class="s0"># 32 bits</span>
            <span class="s6">2147483648</span><span class="s3">,  </span><span class="s0"># 32 bits</span>
            <span class="s6">2147483647</span><span class="s3">,  </span><span class="s0"># 31 bits</span>
            <span class="s6">2147483646</span><span class="s3">,  </span><span class="s0"># 31 bits</span>
            <span class="s1">-</span><span class="s6">2147483649</span><span class="s3">,  </span><span class="s0"># 32 bits</span>
            <span class="s1">-</span><span class="s6">2147483648</span><span class="s3">,  </span><span class="s0"># 32 interestingly, asyncpg accepts this one as int32</span>
            <span class="s1">-</span><span class="s6">2147483647</span><span class="s3">,  </span><span class="s0"># 31</span>
            <span class="s1">-</span><span class="s6">2147483646</span><span class="s3">,  </span><span class="s0"># 31</span>
            <span class="s6">0</span><span class="s3">,</span>
            <span class="s6">1376537018368127</span><span class="s3">,</span>
            <span class="s1">-</span><span class="s6">1376537018368127</span><span class="s3">,</span>
            <span class="s1">argnames=</span><span class="s5">&quot;intvalue&quot;</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s1">@_huge_ints()</span>
    <span class="s2">def </span><span class="s1">test_huge_int_auto_accommodation(self</span><span class="s3">, </span><span class="s1">connection</span><span class="s3">, </span><span class="s1">intvalue):</span>
        <span class="s4">&quot;&quot;&quot;test #7909&quot;&quot;&quot;</span>

        <span class="s1">eq_(</span>
            <span class="s1">connection.scalar(</span>
                <span class="s1">select(intvalue).where(literal(intvalue) == intvalue)</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">intvalue</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s1">@_huge_ints()</span>
    <span class="s2">def </span><span class="s1">test_huge_int(self</span><span class="s3">, </span><span class="s1">integer_round_trip</span><span class="s3">, </span><span class="s1">intvalue):</span>
        <span class="s1">integer_round_trip(BigInteger</span><span class="s3">, </span><span class="s1">intvalue)</span>

    <span class="s1">@testing.fixture</span>
    <span class="s2">def </span><span class="s1">integer_round_trip(self</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s2">def </span><span class="s1">run(datatype</span><span class="s3">, </span><span class="s1">data):</span>
            <span class="s1">int_table = Table(</span>
                <span class="s5">&quot;integer_table&quot;</span><span class="s3">,</span>
                <span class="s1">metadata</span><span class="s3">,</span>
                <span class="s1">Column(</span>
                    <span class="s5">&quot;id&quot;</span><span class="s3">,</span>
                    <span class="s1">Integer</span><span class="s3">,</span>
                    <span class="s1">primary_key=</span><span class="s2">True</span><span class="s3">,</span>
                    <span class="s1">test_needs_autoincrement=</span><span class="s2">True</span><span class="s3">,</span>
                <span class="s1">)</span><span class="s3">,</span>
                <span class="s1">Column(</span><span class="s5">&quot;integer_data&quot;</span><span class="s3">, </span><span class="s1">datatype)</span><span class="s3">,</span>
            <span class="s1">)</span>

            <span class="s1">metadata.create_all(config.db)</span>

            <span class="s1">connection.execute(</span>
                <span class="s1">int_table.insert()</span><span class="s3">, </span><span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">1</span><span class="s3">, </span><span class="s5">&quot;integer_data&quot;</span><span class="s1">: data}</span>
            <span class="s1">)</span>

            <span class="s1">row = connection.execute(select(int_table.c.integer_data)).first()</span>

            <span class="s1">eq_(row</span><span class="s3">, </span><span class="s1">(data</span><span class="s3">,</span><span class="s1">))</span>

            <span class="s2">assert </span><span class="s1">isinstance(row[</span><span class="s6">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">int)</span>

        <span class="s2">return </span><span class="s1">run</span>


<span class="s2">class </span><span class="s1">CastTypeDecoratorTest(_LiteralRoundTripFixture</span><span class="s3">, </span><span class="s1">fixtures.TestBase):</span>
    <span class="s1">__backend__ = </span><span class="s2">True</span>

    <span class="s1">@testing.fixture</span>
    <span class="s2">def </span><span class="s1">string_as_int(self):</span>
        <span class="s2">class </span><span class="s1">StringAsInt(TypeDecorator):</span>
            <span class="s1">impl = String(</span><span class="s6">50</span><span class="s1">)</span>
            <span class="s1">cache_ok = </span><span class="s2">True</span>

            <span class="s2">def </span><span class="s1">column_expression(self</span><span class="s3">, </span><span class="s1">col):</span>
                <span class="s2">return </span><span class="s1">cast(col</span><span class="s3">, </span><span class="s1">Integer)</span>

            <span class="s2">def </span><span class="s1">bind_expression(self</span><span class="s3">, </span><span class="s1">col):</span>
                <span class="s2">return </span><span class="s1">cast(type_coerce(col</span><span class="s3">, </span><span class="s1">Integer)</span><span class="s3">, </span><span class="s1">String(</span><span class="s6">50</span><span class="s1">))</span>

        <span class="s2">return </span><span class="s1">StringAsInt()</span>

    <span class="s2">def </span><span class="s1">test_special_type(self</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">connection</span><span class="s3">, </span><span class="s1">string_as_int):</span>
        <span class="s1">type_ = string_as_int</span>

        <span class="s1">t = Table(</span><span class="s5">&quot;t&quot;</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">Column(</span><span class="s5">&quot;x&quot;</span><span class="s3">, </span><span class="s1">type_))</span>
        <span class="s1">t.create(connection)</span>

        <span class="s1">connection.execute(t.insert()</span><span class="s3">, </span><span class="s1">[{</span><span class="s5">&quot;x&quot;</span><span class="s1">: x} </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">[</span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">3</span><span class="s1">]])</span>

        <span class="s1">result = {row[</span><span class="s6">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">connection.execute(t.select())}</span>
        <span class="s1">eq_(result</span><span class="s3">, </span><span class="s1">{</span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">3</span><span class="s1">})</span>

        <span class="s1">result = {</span>
            <span class="s1">row[</span><span class="s6">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">connection.execute(t.select().where(t.c.x == </span><span class="s6">2</span><span class="s1">))</span>
        <span class="s1">}</span>
        <span class="s1">eq_(result</span><span class="s3">, </span><span class="s1">{</span><span class="s6">2</span><span class="s1">})</span>


<span class="s2">class </span><span class="s1">TrueDivTest(fixtures.TestBase):</span>
    <span class="s1">__backend__ = </span><span class="s2">True</span>

    <span class="s1">@testing.combinations(</span>
        <span class="s1">(</span><span class="s5">&quot;15&quot;</span><span class="s3">, </span><span class="s5">&quot;10&quot;</span><span class="s3">, </span><span class="s6">1.5</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s5">&quot;-15&quot;</span><span class="s3">, </span><span class="s5">&quot;10&quot;</span><span class="s3">, </span><span class="s1">-</span><span class="s6">1.5</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">argnames=</span><span class="s5">&quot;left, right, expected&quot;</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_truediv_integer(self</span><span class="s3">, </span><span class="s1">connection</span><span class="s3">, </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">, </span><span class="s1">expected):</span>
        <span class="s4">&quot;&quot;&quot;test #4926&quot;&quot;&quot;</span>

        <span class="s1">eq_(</span>
            <span class="s1">connection.scalar(</span>
                <span class="s1">select(</span>
                    <span class="s1">literal_column(left</span><span class="s3">, </span><span class="s1">type_=Integer())</span>
                    <span class="s1">/ literal_column(right</span><span class="s3">, </span><span class="s1">type_=Integer())</span>
                <span class="s1">)</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">expected</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s1">@testing.combinations(</span>
        <span class="s1">(</span><span class="s5">&quot;15&quot;</span><span class="s3">, </span><span class="s5">&quot;10&quot;</span><span class="s3">, </span><span class="s6">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">&quot;-15&quot;</span><span class="s3">, </span><span class="s5">&quot;5&quot;</span><span class="s3">, </span><span class="s1">-</span><span class="s6">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">argnames=</span><span class="s5">&quot;left, right, expected&quot;</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_floordiv_integer(self</span><span class="s3">, </span><span class="s1">connection</span><span class="s3">, </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">, </span><span class="s1">expected):</span>
        <span class="s4">&quot;&quot;&quot;test #4926&quot;&quot;&quot;</span>

        <span class="s1">eq_(</span>
            <span class="s1">connection.scalar(</span>
                <span class="s1">select(</span>
                    <span class="s1">literal_column(left</span><span class="s3">, </span><span class="s1">type_=Integer())</span>
                    <span class="s1">// literal_column(right</span><span class="s3">, </span><span class="s1">type_=Integer())</span>
                <span class="s1">)</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">expected</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s1">@testing.combinations(</span>
        <span class="s1">(</span><span class="s5">&quot;5.52&quot;</span><span class="s3">, </span><span class="s5">&quot;2.4&quot;</span><span class="s3">, </span><span class="s5">&quot;2.3&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">argnames=</span><span class="s5">&quot;left, right, expected&quot;</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_truediv_numeric(self</span><span class="s3">, </span><span class="s1">connection</span><span class="s3">, </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">, </span><span class="s1">expected):</span>
        <span class="s4">&quot;&quot;&quot;test #4926&quot;&quot;&quot;</span>

        <span class="s1">eq_(</span>
            <span class="s1">connection.scalar(</span>
                <span class="s1">select(</span>
                    <span class="s1">literal_column(left</span><span class="s3">, </span><span class="s1">type_=Numeric(</span><span class="s6">10</span><span class="s3">, </span><span class="s6">2</span><span class="s1">))</span>
                    <span class="s1">/ literal_column(right</span><span class="s3">, </span><span class="s1">type_=Numeric(</span><span class="s6">10</span><span class="s3">, </span><span class="s6">2</span><span class="s1">))</span>
                <span class="s1">)</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">decimal.Decimal(expected)</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s1">@testing.combinations(</span>
        <span class="s1">(</span><span class="s5">&quot;5.52&quot;</span><span class="s3">, </span><span class="s5">&quot;2.4&quot;</span><span class="s3">, </span><span class="s6">2.3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">argnames=</span><span class="s5">&quot;left, right, expected&quot;</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_truediv_float(self</span><span class="s3">, </span><span class="s1">connection</span><span class="s3">, </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">, </span><span class="s1">expected):</span>
        <span class="s4">&quot;&quot;&quot;test #4926&quot;&quot;&quot;</span>

        <span class="s1">eq_(</span>
            <span class="s1">connection.scalar(</span>
                <span class="s1">select(</span>
                    <span class="s1">literal_column(left</span><span class="s3">, </span><span class="s1">type_=Float())</span>
                    <span class="s1">/ literal_column(right</span><span class="s3">, </span><span class="s1">type_=Float())</span>
                <span class="s1">)</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">expected</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s1">@testing.combinations(</span>
        <span class="s1">(</span><span class="s5">&quot;5.52&quot;</span><span class="s3">, </span><span class="s5">&quot;2.4&quot;</span><span class="s3">, </span><span class="s5">&quot;2.0&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">argnames=</span><span class="s5">&quot;left, right, expected&quot;</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_floordiv_numeric(self</span><span class="s3">, </span><span class="s1">connection</span><span class="s3">, </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">, </span><span class="s1">expected):</span>
        <span class="s4">&quot;&quot;&quot;test #4926&quot;&quot;&quot;</span>

        <span class="s1">eq_(</span>
            <span class="s1">connection.scalar(</span>
                <span class="s1">select(</span>
                    <span class="s1">literal_column(left</span><span class="s3">, </span><span class="s1">type_=Numeric())</span>
                    <span class="s1">// literal_column(right</span><span class="s3">, </span><span class="s1">type_=Numeric())</span>
                <span class="s1">)</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">decimal.Decimal(expected)</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_truediv_integer_bound(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s4">&quot;&quot;&quot;test #4926&quot;&quot;&quot;</span>

        <span class="s1">eq_(</span>
            <span class="s1">connection.scalar(select(literal(</span><span class="s6">15</span><span class="s1">) / literal(</span><span class="s6">10</span><span class="s1">)))</span><span class="s3">,</span>
            <span class="s6">1.5</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_floordiv_integer_bound(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s4">&quot;&quot;&quot;test #4926&quot;&quot;&quot;</span>

        <span class="s1">eq_(</span>
            <span class="s1">connection.scalar(select(literal(</span><span class="s6">15</span><span class="s1">) // literal(</span><span class="s6">10</span><span class="s1">)))</span><span class="s3">,</span>
            <span class="s6">1</span><span class="s3">,</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">NumericTest(_LiteralRoundTripFixture</span><span class="s3">, </span><span class="s1">fixtures.TestBase):</span>
    <span class="s1">__backend__ = </span><span class="s2">True</span>

    <span class="s1">@testing.fixture</span>
    <span class="s2">def </span><span class="s1">do_numeric_test(self</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s2">def </span><span class="s1">run(type_</span><span class="s3">, </span><span class="s1">input_</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">filter_=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">check_scale=</span><span class="s2">False</span><span class="s1">):</span>
            <span class="s1">t = Table(</span><span class="s5">&quot;t&quot;</span><span class="s3">, </span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">Column(</span><span class="s5">&quot;x&quot;</span><span class="s3">, </span><span class="s1">type_))</span>
            <span class="s1">t.create(connection)</span>
            <span class="s1">connection.execute(t.insert()</span><span class="s3">, </span><span class="s1">[{</span><span class="s5">&quot;x&quot;</span><span class="s1">: x} </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">input_])</span>

            <span class="s1">result = {row[</span><span class="s6">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">connection.execute(t.select())}</span>
            <span class="s1">output = set(output)</span>
            <span class="s2">if </span><span class="s1">filter_:</span>
                <span class="s1">result = {filter_(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">result}</span>
                <span class="s1">output = {filter_(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">output}</span>
            <span class="s1">eq_(result</span><span class="s3">, </span><span class="s1">output)</span>
            <span class="s2">if </span><span class="s1">check_scale:</span>
                <span class="s1">eq_([str(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">result]</span><span class="s3">, </span><span class="s1">[str(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">output])</span>

            <span class="s1">connection.execute(t.delete())</span>

            <span class="s0"># test that this is actually a number!</span>
            <span class="s0"># note we have tiny scale here as we have tests with very</span>
            <span class="s0"># small scale Numeric types.  PostgreSQL will raise an error</span>
            <span class="s0"># if you use values outside the available scale.</span>
            <span class="s2">if </span><span class="s1">type_.asdecimal:</span>
                <span class="s1">test_value = decimal.Decimal(</span><span class="s5">&quot;2.9&quot;</span><span class="s1">)</span>
                <span class="s1">add_value = decimal.Decimal(</span><span class="s5">&quot;37.12&quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">test_value = </span><span class="s6">2.9</span>
                <span class="s1">add_value = </span><span class="s6">37.12</span>

            <span class="s1">connection.execute(t.insert()</span><span class="s3">, </span><span class="s1">{</span><span class="s5">&quot;x&quot;</span><span class="s1">: test_value})</span>
            <span class="s1">assert_we_are_a_number = connection.scalar(</span>
                <span class="s1">select(type_coerce(t.c.x + add_value</span><span class="s3">, </span><span class="s1">type_))</span>
            <span class="s1">)</span>
            <span class="s1">eq_(</span>
                <span class="s1">round(assert_we_are_a_number</span><span class="s3">, </span><span class="s6">3</span><span class="s1">)</span><span class="s3">,</span>
                <span class="s1">round(test_value + add_value</span><span class="s3">, </span><span class="s6">3</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">run</span>

    <span class="s2">def </span><span class="s1">test_render_literal_numeric(self</span><span class="s3">, </span><span class="s1">literal_round_trip):</span>
        <span class="s1">literal_round_trip(</span>
            <span class="s1">Numeric(precision=</span><span class="s6">8</span><span class="s3">, </span><span class="s1">scale=</span><span class="s6">4</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s6">15.7563</span><span class="s3">, </span><span class="s1">decimal.Decimal(</span><span class="s5">&quot;15.7563&quot;</span><span class="s1">)]</span><span class="s3">,</span>
            <span class="s1">[decimal.Decimal(</span><span class="s5">&quot;15.7563&quot;</span><span class="s1">)]</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_render_literal_numeric_asfloat(self</span><span class="s3">, </span><span class="s1">literal_round_trip):</span>
        <span class="s1">literal_round_trip(</span>
            <span class="s1">Numeric(precision=</span><span class="s6">8</span><span class="s3">, </span><span class="s1">scale=</span><span class="s6">4</span><span class="s3">, </span><span class="s1">asdecimal=</span><span class="s2">False</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s6">15.7563</span><span class="s3">, </span><span class="s1">decimal.Decimal(</span><span class="s5">&quot;15.7563&quot;</span><span class="s1">)]</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s6">15.7563</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_render_literal_float(self</span><span class="s3">, </span><span class="s1">literal_round_trip):</span>
        <span class="s1">literal_round_trip(</span>
            <span class="s1">Float()</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s6">15.7563</span><span class="s3">, </span><span class="s1">decimal.Decimal(</span><span class="s5">&quot;15.7563&quot;</span><span class="s1">)]</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s6">15.7563</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">filter_=</span><span class="s2">lambda </span><span class="s1">n: n </span><span class="s2">is not None and </span><span class="s1">round(n</span><span class="s3">, </span><span class="s6">5</span><span class="s1">) </span><span class="s2">or None</span><span class="s3">,</span>
            <span class="s1">support_whereclause=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s1">@testing.requires.precision_generic_float_type</span>
    <span class="s2">def </span><span class="s1">test_float_custom_scale(self</span><span class="s3">, </span><span class="s1">do_numeric_test):</span>
        <span class="s1">do_numeric_test(</span>
            <span class="s1">Float(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">decimal_return_scale=</span><span class="s6">7</span><span class="s3">, </span><span class="s1">asdecimal=</span><span class="s2">True</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s6">15.7563827</span><span class="s3">, </span><span class="s1">decimal.Decimal(</span><span class="s5">&quot;15.7563827&quot;</span><span class="s1">)]</span><span class="s3">,</span>
            <span class="s1">[decimal.Decimal(</span><span class="s5">&quot;15.7563827&quot;</span><span class="s1">)]</span><span class="s3">,</span>
            <span class="s1">check_scale=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_numeric_as_decimal(self</span><span class="s3">, </span><span class="s1">do_numeric_test):</span>
        <span class="s1">do_numeric_test(</span>
            <span class="s1">Numeric(precision=</span><span class="s6">8</span><span class="s3">, </span><span class="s1">scale=</span><span class="s6">4</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s6">15.7563</span><span class="s3">, </span><span class="s1">decimal.Decimal(</span><span class="s5">&quot;15.7563&quot;</span><span class="s1">)]</span><span class="s3">,</span>
            <span class="s1">[decimal.Decimal(</span><span class="s5">&quot;15.7563&quot;</span><span class="s1">)]</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_numeric_as_float(self</span><span class="s3">, </span><span class="s1">do_numeric_test):</span>
        <span class="s1">do_numeric_test(</span>
            <span class="s1">Numeric(precision=</span><span class="s6">8</span><span class="s3">, </span><span class="s1">scale=</span><span class="s6">4</span><span class="s3">, </span><span class="s1">asdecimal=</span><span class="s2">False</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s6">15.7563</span><span class="s3">, </span><span class="s1">decimal.Decimal(</span><span class="s5">&quot;15.7563&quot;</span><span class="s1">)]</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s6">15.7563</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s1">@testing.requires.infinity_floats</span>
    <span class="s2">def </span><span class="s1">test_infinity_floats(self</span><span class="s3">, </span><span class="s1">do_numeric_test):</span>
        <span class="s4">&quot;&quot;&quot;test for #977, #7283&quot;&quot;&quot;</span>

        <span class="s1">do_numeric_test(</span>
            <span class="s1">Float(</span><span class="s2">None</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">[float(</span><span class="s5">&quot;inf&quot;</span><span class="s1">)]</span><span class="s3">,</span>
            <span class="s1">[float(</span><span class="s5">&quot;inf&quot;</span><span class="s1">)]</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s1">@testing.requires.fetch_null_from_numeric</span>
    <span class="s2">def </span><span class="s1">test_numeric_null_as_decimal(self</span><span class="s3">, </span><span class="s1">do_numeric_test):</span>
        <span class="s1">do_numeric_test(Numeric(precision=</span><span class="s6">8</span><span class="s3">, </span><span class="s1">scale=</span><span class="s6">4</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s2">None</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s2">None</span><span class="s1">])</span>

    <span class="s1">@testing.requires.fetch_null_from_numeric</span>
    <span class="s2">def </span><span class="s1">test_numeric_null_as_float(self</span><span class="s3">, </span><span class="s1">do_numeric_test):</span>
        <span class="s1">do_numeric_test(</span>
            <span class="s1">Numeric(precision=</span><span class="s6">8</span><span class="s3">, </span><span class="s1">scale=</span><span class="s6">4</span><span class="s3">, </span><span class="s1">asdecimal=</span><span class="s2">False</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[</span><span class="s2">None</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s2">None</span><span class="s1">]</span>
        <span class="s1">)</span>

    <span class="s1">@testing.requires.floats_to_four_decimals</span>
    <span class="s2">def </span><span class="s1">test_float_as_decimal(self</span><span class="s3">, </span><span class="s1">do_numeric_test):</span>
        <span class="s1">do_numeric_test(</span>
            <span class="s1">Float(asdecimal=</span><span class="s2">True</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s6">15.756</span><span class="s3">, </span><span class="s1">decimal.Decimal(</span><span class="s5">&quot;15.756&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s2">None</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">[decimal.Decimal(</span><span class="s5">&quot;15.756&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s2">None</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">filter_=</span><span class="s2">lambda </span><span class="s1">n: n </span><span class="s2">is not None and </span><span class="s1">round(n</span><span class="s3">, </span><span class="s6">4</span><span class="s1">) </span><span class="s2">or None</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_float_as_float(self</span><span class="s3">, </span><span class="s1">do_numeric_test):</span>
        <span class="s1">do_numeric_test(</span>
            <span class="s1">Float()</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s6">15.756</span><span class="s3">, </span><span class="s1">decimal.Decimal(</span><span class="s5">&quot;15.756&quot;</span><span class="s1">)]</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s6">15.756</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">filter_=</span><span class="s2">lambda </span><span class="s1">n: n </span><span class="s2">is not None and </span><span class="s1">round(n</span><span class="s3">, </span><span class="s6">5</span><span class="s1">) </span><span class="s2">or None</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s1">@testing.requires.literal_float_coercion</span>
    <span class="s2">def </span><span class="s1">test_float_coerce_round_trip(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">expr = </span><span class="s6">15.7563</span>

        <span class="s1">val = connection.scalar(select(literal(expr)))</span>
        <span class="s1">eq_(val</span><span class="s3">, </span><span class="s1">expr)</span>

    <span class="s0"># this does not work in MySQL, see #4036, however we choose not</span>
    <span class="s0"># to render CAST unconditionally since this is kind of an edge case.</span>

    <span class="s1">@testing.requires.implicit_decimal_binds</span>
    <span class="s2">def </span><span class="s1">test_decimal_coerce_round_trip(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">expr = decimal.Decimal(</span><span class="s5">&quot;15.7563&quot;</span><span class="s1">)</span>

        <span class="s1">val = connection.scalar(select(literal(expr)))</span>
        <span class="s1">eq_(val</span><span class="s3">, </span><span class="s1">expr)</span>

    <span class="s2">def </span><span class="s1">test_decimal_coerce_round_trip_w_cast(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">expr = decimal.Decimal(</span><span class="s5">&quot;15.7563&quot;</span><span class="s1">)</span>

        <span class="s1">val = connection.scalar(select(cast(expr</span><span class="s3">, </span><span class="s1">Numeric(</span><span class="s6">10</span><span class="s3">, </span><span class="s6">4</span><span class="s1">))))</span>
        <span class="s1">eq_(val</span><span class="s3">, </span><span class="s1">expr)</span>

    <span class="s1">@testing.requires.precision_numerics_general</span>
    <span class="s2">def </span><span class="s1">test_precision_decimal(self</span><span class="s3">, </span><span class="s1">do_numeric_test):</span>
        <span class="s1">numbers = {</span>
            <span class="s1">decimal.Decimal(</span><span class="s5">&quot;54.234246451650&quot;</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">decimal.Decimal(</span><span class="s5">&quot;0.004354&quot;</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">decimal.Decimal(</span><span class="s5">&quot;900.0&quot;</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">}</span>

        <span class="s1">do_numeric_test(Numeric(precision=</span><span class="s6">18</span><span class="s3">, </span><span class="s1">scale=</span><span class="s6">12</span><span class="s1">)</span><span class="s3">, </span><span class="s1">numbers</span><span class="s3">, </span><span class="s1">numbers)</span>

    <span class="s1">@testing.requires.precision_numerics_enotation_large</span>
    <span class="s2">def </span><span class="s1">test_enotation_decimal(self</span><span class="s3">, </span><span class="s1">do_numeric_test):</span>
        <span class="s4">&quot;&quot;&quot;test exceedingly small decimals. 
 
        Decimal reports values with E notation when the exponent 
        is greater than 6. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">numbers = {</span>
            <span class="s1">decimal.Decimal(</span><span class="s5">&quot;1E-2&quot;</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">decimal.Decimal(</span><span class="s5">&quot;1E-3&quot;</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">decimal.Decimal(</span><span class="s5">&quot;1E-4&quot;</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">decimal.Decimal(</span><span class="s5">&quot;1E-5&quot;</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">decimal.Decimal(</span><span class="s5">&quot;1E-6&quot;</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">decimal.Decimal(</span><span class="s5">&quot;1E-7&quot;</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">decimal.Decimal(</span><span class="s5">&quot;1E-8&quot;</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">decimal.Decimal(</span><span class="s5">&quot;0.01000005940696&quot;</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">decimal.Decimal(</span><span class="s5">&quot;0.00000005940696&quot;</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">decimal.Decimal(</span><span class="s5">&quot;0.00000000000696&quot;</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">decimal.Decimal(</span><span class="s5">&quot;0.70000000000696&quot;</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">decimal.Decimal(</span><span class="s5">&quot;696E-12&quot;</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">}</span>
        <span class="s1">do_numeric_test(Numeric(precision=</span><span class="s6">18</span><span class="s3">, </span><span class="s1">scale=</span><span class="s6">14</span><span class="s1">)</span><span class="s3">, </span><span class="s1">numbers</span><span class="s3">, </span><span class="s1">numbers)</span>

    <span class="s1">@testing.requires.precision_numerics_enotation_large</span>
    <span class="s2">def </span><span class="s1">test_enotation_decimal_large(self</span><span class="s3">, </span><span class="s1">do_numeric_test):</span>
        <span class="s4">&quot;&quot;&quot;test exceedingly large decimals.&quot;&quot;&quot;</span>

        <span class="s1">numbers = {</span>
            <span class="s1">decimal.Decimal(</span><span class="s5">&quot;4E+8&quot;</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">decimal.Decimal(</span><span class="s5">&quot;5748E+15&quot;</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">decimal.Decimal(</span><span class="s5">&quot;1.521E+15&quot;</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">decimal.Decimal(</span><span class="s5">&quot;00000000000000.1E+12&quot;</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">}</span>
        <span class="s1">do_numeric_test(Numeric(precision=</span><span class="s6">25</span><span class="s3">, </span><span class="s1">scale=</span><span class="s6">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">numbers</span><span class="s3">, </span><span class="s1">numbers)</span>

    <span class="s1">@testing.requires.precision_numerics_many_significant_digits</span>
    <span class="s2">def </span><span class="s1">test_many_significant_digits(self</span><span class="s3">, </span><span class="s1">do_numeric_test):</span>
        <span class="s1">numbers = {</span>
            <span class="s1">decimal.Decimal(</span><span class="s5">&quot;31943874831932418390.01&quot;</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">decimal.Decimal(</span><span class="s5">&quot;319438950232418390.273596&quot;</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">decimal.Decimal(</span><span class="s5">&quot;87673.594069654243&quot;</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">}</span>
        <span class="s1">do_numeric_test(Numeric(precision=</span><span class="s6">38</span><span class="s3">, </span><span class="s1">scale=</span><span class="s6">12</span><span class="s1">)</span><span class="s3">, </span><span class="s1">numbers</span><span class="s3">, </span><span class="s1">numbers)</span>

    <span class="s1">@testing.requires.precision_numerics_retains_significant_digits</span>
    <span class="s2">def </span><span class="s1">test_numeric_no_decimal(self</span><span class="s3">, </span><span class="s1">do_numeric_test):</span>
        <span class="s1">numbers = {decimal.Decimal(</span><span class="s5">&quot;1.000&quot;</span><span class="s1">)}</span>
        <span class="s1">do_numeric_test(</span>
            <span class="s1">Numeric(precision=</span><span class="s6">5</span><span class="s3">, </span><span class="s1">scale=</span><span class="s6">3</span><span class="s1">)</span><span class="s3">, </span><span class="s1">numbers</span><span class="s3">, </span><span class="s1">numbers</span><span class="s3">, </span><span class="s1">check_scale=</span><span class="s2">True</span>
        <span class="s1">)</span>

    <span class="s1">@testing.combinations(sqltypes.Float</span><span class="s3">, </span><span class="s1">sqltypes.Double</span><span class="s3">, </span><span class="s1">argnames=</span><span class="s5">&quot;cls_&quot;</span><span class="s1">)</span>
    <span class="s1">@testing.requires.float_is_numeric</span>
    <span class="s2">def </span><span class="s1">test_float_is_not_numeric(self</span><span class="s3">, </span><span class="s1">connection</span><span class="s3">, </span><span class="s1">cls_):</span>
        <span class="s1">target_type = cls_().dialect_impl(connection.dialect)</span>
        <span class="s1">numeric_type = sqltypes.Numeric().dialect_impl(connection.dialect)</span>

        <span class="s1">ne_(target_type.__visit_name__</span><span class="s3">, </span><span class="s1">numeric_type.__visit_name__)</span>
        <span class="s1">ne_(target_type.__class__</span><span class="s3">, </span><span class="s1">numeric_type.__class__)</span>


<span class="s2">class </span><span class="s1">BooleanTest(_LiteralRoundTripFixture</span><span class="s3">, </span><span class="s1">fixtures.TablesTest):</span>
    <span class="s1">__backend__ = </span><span class="s2">True</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">define_tables(cls</span><span class="s3">, </span><span class="s1">metadata):</span>
        <span class="s1">Table(</span>
            <span class="s5">&quot;boolean_table&quot;</span><span class="s3">,</span>
            <span class="s1">metadata</span><span class="s3">,</span>
            <span class="s1">Column(</span><span class="s5">&quot;id&quot;</span><span class="s3">, </span><span class="s1">Integer</span><span class="s3">, </span><span class="s1">primary_key=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">autoincrement=</span><span class="s2">False</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">Column(</span><span class="s5">&quot;value&quot;</span><span class="s3">, </span><span class="s1">Boolean)</span><span class="s3">,</span>
            <span class="s1">Column(</span><span class="s5">&quot;unconstrained_value&quot;</span><span class="s3">, </span><span class="s1">Boolean(create_constraint=</span><span class="s2">False</span><span class="s1">))</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_render_literal_bool(self</span><span class="s3">, </span><span class="s1">literal_round_trip):</span>
        <span class="s1">literal_round_trip(Boolean()</span><span class="s3">, </span><span class="s1">[</span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_round_trip(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">boolean_table = self.tables.boolean_table</span>

        <span class="s1">connection.execute(</span>
            <span class="s1">boolean_table.insert()</span><span class="s3">,</span>
            <span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">1</span><span class="s3">, </span><span class="s5">&quot;value&quot;</span><span class="s1">: </span><span class="s2">True</span><span class="s3">, </span><span class="s5">&quot;unconstrained_value&quot;</span><span class="s1">: </span><span class="s2">False</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s1">row = connection.execute(</span>
            <span class="s1">select(boolean_table.c.value</span><span class="s3">, </span><span class="s1">boolean_table.c.unconstrained_value)</span>
        <span class="s1">).first()</span>

        <span class="s1">eq_(row</span><span class="s3">, </span><span class="s1">(</span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s1">))</span>
        <span class="s2">assert </span><span class="s1">isinstance(row[</span><span class="s6">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">bool)</span>

    <span class="s1">@testing.requires.nullable_booleans</span>
    <span class="s2">def </span><span class="s1">test_null(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">boolean_table = self.tables.boolean_table</span>

        <span class="s1">connection.execute(</span>
            <span class="s1">boolean_table.insert()</span><span class="s3">,</span>
            <span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">1</span><span class="s3">, </span><span class="s5">&quot;value&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s3">, </span><span class="s5">&quot;unconstrained_value&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s1">}</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s1">row = connection.execute(</span>
            <span class="s1">select(boolean_table.c.value</span><span class="s3">, </span><span class="s1">boolean_table.c.unconstrained_value)</span>
        <span class="s1">).first()</span>

        <span class="s1">eq_(row</span><span class="s3">, </span><span class="s1">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_whereclause(self):</span>
        <span class="s0"># testing &quot;WHERE &lt;column&gt;&quot; renders a compatible expression</span>
        <span class="s1">boolean_table = self.tables.boolean_table</span>

        <span class="s2">with </span><span class="s1">config.db.begin() </span><span class="s2">as </span><span class="s1">conn:</span>
            <span class="s1">conn.execute(</span>
                <span class="s1">boolean_table.insert()</span><span class="s3">,</span>
                <span class="s1">[</span>
                    <span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">1</span><span class="s3">, </span><span class="s5">&quot;value&quot;</span><span class="s1">: </span><span class="s2">True</span><span class="s3">, </span><span class="s5">&quot;unconstrained_value&quot;</span><span class="s1">: </span><span class="s2">True</span><span class="s1">}</span><span class="s3">,</span>
                    <span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">2</span><span class="s3">, </span><span class="s5">&quot;value&quot;</span><span class="s1">: </span><span class="s2">False</span><span class="s3">, </span><span class="s5">&quot;unconstrained_value&quot;</span><span class="s1">: </span><span class="s2">False</span><span class="s1">}</span><span class="s3">,</span>
                <span class="s1">]</span><span class="s3">,</span>
            <span class="s1">)</span>

            <span class="s1">eq_(</span>
                <span class="s1">conn.scalar(</span>
                    <span class="s1">select(boolean_table.c.id).where(boolean_table.c.value)</span>
                <span class="s1">)</span><span class="s3">,</span>
                <span class="s6">1</span><span class="s3">,</span>
            <span class="s1">)</span>
            <span class="s1">eq_(</span>
                <span class="s1">conn.scalar(</span>
                    <span class="s1">select(boolean_table.c.id).where(</span>
                        <span class="s1">boolean_table.c.unconstrained_value</span>
                    <span class="s1">)</span>
                <span class="s1">)</span><span class="s3">,</span>
                <span class="s6">1</span><span class="s3">,</span>
            <span class="s1">)</span>
            <span class="s1">eq_(</span>
                <span class="s1">conn.scalar(</span>
                    <span class="s1">select(boolean_table.c.id).where(~boolean_table.c.value)</span>
                <span class="s1">)</span><span class="s3">,</span>
                <span class="s6">2</span><span class="s3">,</span>
            <span class="s1">)</span>
            <span class="s1">eq_(</span>
                <span class="s1">conn.scalar(</span>
                    <span class="s1">select(boolean_table.c.id).where(</span>
                        <span class="s1">~boolean_table.c.unconstrained_value</span>
                    <span class="s1">)</span>
                <span class="s1">)</span><span class="s3">,</span>
                <span class="s6">2</span><span class="s3">,</span>
            <span class="s1">)</span>


<span class="s2">class </span><span class="s1">JSONTest(_LiteralRoundTripFixture</span><span class="s3">, </span><span class="s1">fixtures.TablesTest):</span>
    <span class="s1">__requires__ = (</span><span class="s5">&quot;json_type&quot;</span><span class="s3">,</span><span class="s1">)</span>
    <span class="s1">__backend__ = </span><span class="s2">True</span>

    <span class="s1">datatype = JSON</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">define_tables(cls</span><span class="s3">, </span><span class="s1">metadata):</span>
        <span class="s1">Table(</span>
            <span class="s5">&quot;data_table&quot;</span><span class="s3">,</span>
            <span class="s1">metadata</span><span class="s3">,</span>
            <span class="s1">Column(</span><span class="s5">&quot;id&quot;</span><span class="s3">, </span><span class="s1">Integer</span><span class="s3">, </span><span class="s1">primary_key=</span><span class="s2">True</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">Column(</span><span class="s5">&quot;name&quot;</span><span class="s3">, </span><span class="s1">String(</span><span class="s6">30</span><span class="s1">)</span><span class="s3">, </span><span class="s1">nullable=</span><span class="s2">False</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">Column(</span><span class="s5">&quot;data&quot;</span><span class="s3">, </span><span class="s1">cls.datatype</span><span class="s3">, </span><span class="s1">nullable=</span><span class="s2">False</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">Column(</span><span class="s5">&quot;nulldata&quot;</span><span class="s3">, </span><span class="s1">cls.datatype(none_as_null=</span><span class="s2">True</span><span class="s1">))</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_round_trip_data1(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">self._test_round_trip({</span><span class="s5">&quot;key1&quot;</span><span class="s1">: </span><span class="s5">&quot;value1&quot;</span><span class="s3">, </span><span class="s5">&quot;key2&quot;</span><span class="s1">: </span><span class="s5">&quot;value2&quot;</span><span class="s1">}</span><span class="s3">, </span><span class="s1">connection)</span>

    <span class="s1">@testing.combinations(</span>
        <span class="s1">(</span><span class="s5">&quot;unicode&quot;</span><span class="s3">, </span><span class="s2">True</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">&quot;ascii&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s1">)</span><span class="s3">, </span><span class="s1">argnames=</span><span class="s5">&quot;unicode_&quot;</span><span class="s3">, </span><span class="s1">id_=</span><span class="s5">&quot;ia&quot;</span>
    <span class="s1">)</span>
    <span class="s1">@testing.combinations(</span><span class="s6">100</span><span class="s3">, </span><span class="s6">1999</span><span class="s3">, </span><span class="s6">3000</span><span class="s3">, </span><span class="s6">4000</span><span class="s3">, </span><span class="s6">5000</span><span class="s3">, </span><span class="s6">9000</span><span class="s3">, </span><span class="s1">argnames=</span><span class="s5">&quot;length&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_round_trip_pretty_large_data(self</span><span class="s3">, </span><span class="s1">connection</span><span class="s3">, </span><span class="s1">unicode_</span><span class="s3">, </span><span class="s1">length):</span>
        <span class="s2">if </span><span class="s1">unicode_:</span>
            <span class="s1">data = </span><span class="s5">&quot;réve🐍illé&quot; </span><span class="s1">* ((length // </span><span class="s6">9</span><span class="s1">) + </span><span class="s6">1</span><span class="s1">)</span>
            <span class="s1">data = data[</span><span class="s6">0 </span><span class="s1">: (length // </span><span class="s6">2</span><span class="s1">)]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">data = </span><span class="s5">&quot;abcdefg&quot; </span><span class="s1">* ((length // </span><span class="s6">7</span><span class="s1">) + </span><span class="s6">1</span><span class="s1">)</span>
            <span class="s1">data = data[</span><span class="s6">0</span><span class="s1">:length]</span>

        <span class="s1">self._test_round_trip({</span><span class="s5">&quot;key1&quot;</span><span class="s1">: data</span><span class="s3">, </span><span class="s5">&quot;key2&quot;</span><span class="s1">: data}</span><span class="s3">, </span><span class="s1">connection)</span>

    <span class="s2">def </span><span class="s1">_test_round_trip(self</span><span class="s3">, </span><span class="s1">data_element</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">data_table = self.tables.data_table</span>

        <span class="s1">connection.execute(</span>
            <span class="s1">data_table.insert()</span><span class="s3">,</span>
            <span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">1</span><span class="s3">, </span><span class="s5">&quot;name&quot;</span><span class="s1">: </span><span class="s5">&quot;row1&quot;</span><span class="s3">, </span><span class="s5">&quot;data&quot;</span><span class="s1">: data_element}</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s1">row = connection.execute(select(data_table.c.data)).first()</span>

        <span class="s1">eq_(row</span><span class="s3">, </span><span class="s1">(data_element</span><span class="s3">,</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">_index_fixtures(include_comparison):</span>
        <span class="s2">if </span><span class="s1">include_comparison:</span>
            <span class="s0"># basically SQL Server and MariaDB can kind of do json</span>
            <span class="s0"># comparison, MySQL, PG and SQLite can't.  not worth it.</span>
            <span class="s1">json_elements = []</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">json_elements = [</span>
                <span class="s1">(</span><span class="s5">&quot;json&quot;</span><span class="s3">, </span><span class="s1">{</span><span class="s5">&quot;foo&quot;</span><span class="s1">: </span><span class="s5">&quot;bar&quot;</span><span class="s1">})</span><span class="s3">,</span>
                <span class="s1">(</span><span class="s5">&quot;json&quot;</span><span class="s3">, </span><span class="s1">[</span><span class="s5">&quot;one&quot;</span><span class="s3">, </span><span class="s5">&quot;two&quot;</span><span class="s3">, </span><span class="s5">&quot;three&quot;</span><span class="s1">])</span><span class="s3">,</span>
                <span class="s1">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">{</span><span class="s5">&quot;foo&quot;</span><span class="s1">: </span><span class="s5">&quot;bar&quot;</span><span class="s1">})</span><span class="s3">,</span>
                <span class="s1">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">[</span><span class="s5">&quot;one&quot;</span><span class="s3">, </span><span class="s5">&quot;two&quot;</span><span class="s3">, </span><span class="s5">&quot;three&quot;</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">]</span>

        <span class="s1">elements = [</span>
            <span class="s1">(</span><span class="s5">&quot;boolean&quot;</span><span class="s3">, </span><span class="s2">True</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s5">&quot;boolean&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s5">&quot;boolean&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s5">&quot;string&quot;</span><span class="s3">, </span><span class="s5">&quot;some string&quot;</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s5">&quot;string&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s5">&quot;string&quot;</span><span class="s3">, </span><span class="s5">&quot;réve illé&quot;</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span>
                <span class="s5">&quot;string&quot;</span><span class="s3">,</span>
                <span class="s5">&quot;réve🐍 illé&quot;</span><span class="s3">,</span>
                <span class="s1">testing.requires.json_index_supplementary_unicode_element</span><span class="s3">,</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s5">&quot;integer&quot;</span><span class="s3">, </span><span class="s6">15</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s5">&quot;integer&quot;</span><span class="s3">, </span><span class="s6">1</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s5">&quot;integer&quot;</span><span class="s3">, </span><span class="s6">0</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s5">&quot;integer&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s5">&quot;float&quot;</span><span class="s3">, </span><span class="s6">28.5</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s5">&quot;float&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s5">&quot;float&quot;</span><span class="s3">, </span><span class="s6">1234567.89</span><span class="s3">, </span><span class="s1">testing.requires.literal_float_coercion)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s5">&quot;numeric&quot;</span><span class="s3">, </span><span class="s6">1234567.89</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s0"># this one &quot;works&quot; because the float value you see here is</span>
            <span class="s0"># lost immediately to floating point stuff</span>
            <span class="s1">(</span>
                <span class="s5">&quot;numeric&quot;</span><span class="s3">,</span>
                <span class="s6">99998969694839.983485848</span><span class="s3">,</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s5">&quot;numeric&quot;</span><span class="s3">, </span><span class="s6">99939.983485848</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s5">&quot;_decimal&quot;</span><span class="s3">, </span><span class="s1">decimal.Decimal(</span><span class="s5">&quot;1234567.89&quot;</span><span class="s1">))</span><span class="s3">,</span>
            <span class="s1">(</span>
                <span class="s5">&quot;_decimal&quot;</span><span class="s3">,</span>
                <span class="s1">decimal.Decimal(</span><span class="s5">&quot;99998969694839.983485848&quot;</span><span class="s1">)</span><span class="s3">,</span>
                <span class="s0"># fails on SQLite and MySQL (non-mariadb)</span>
                <span class="s1">requirements.cast_precision_numerics_many_significant_digits</span><span class="s3">,</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(</span>
                <span class="s5">&quot;_decimal&quot;</span><span class="s3">,</span>
                <span class="s1">decimal.Decimal(</span><span class="s5">&quot;99939.983485848&quot;</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">)</span><span class="s3">,</span>
        <span class="s1">] + json_elements</span>

        <span class="s2">def </span><span class="s1">decorate(fn):</span>
            <span class="s1">fn = testing.combinations(id_=</span><span class="s5">&quot;sa&quot;</span><span class="s3">, </span><span class="s1">*elements)(fn)</span>

            <span class="s2">return </span><span class="s1">fn</span>

        <span class="s2">return </span><span class="s1">decorate</span>

    <span class="s2">def </span><span class="s1">_json_value_insert(self</span><span class="s3">, </span><span class="s1">connection</span><span class="s3">, </span><span class="s1">datatype</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">data_element):</span>
        <span class="s1">data_table = self.tables.data_table</span>
        <span class="s2">if </span><span class="s1">datatype == </span><span class="s5">&quot;_decimal&quot;</span><span class="s1">:</span>
            <span class="s0"># Python's builtin json serializer basically doesn't support</span>
            <span class="s0"># Decimal objects without implicit float conversion period.</span>
            <span class="s0"># users can otherwise use simplejson which supports</span>
            <span class="s0"># precision decimals</span>

            <span class="s0"># https://bugs.python.org/issue16535</span>

            <span class="s0"># inserting as strings to avoid a new fixture around the</span>
            <span class="s0"># dialect which would have idiosyncrasies for different</span>
            <span class="s0"># backends.</span>

            <span class="s2">class </span><span class="s1">DecimalEncoder(json.JSONEncoder):</span>
                <span class="s2">def </span><span class="s1">default(self</span><span class="s3">, </span><span class="s1">o):</span>
                    <span class="s2">if </span><span class="s1">isinstance(o</span><span class="s3">, </span><span class="s1">decimal.Decimal):</span>
                        <span class="s2">return </span><span class="s1">str(o)</span>
                    <span class="s2">return </span><span class="s1">super().default(o)</span>

            <span class="s1">json_data = json.dumps(data_element</span><span class="s3">, </span><span class="s1">cls=DecimalEncoder)</span>

            <span class="s0"># take the quotes out.  yup, there is *literally* no other</span>
            <span class="s0"># way to get Python's json.dumps() to put all the digits in</span>
            <span class="s0"># the string</span>
            <span class="s1">json_data = re.sub(</span><span class="s5">r'&quot;(%s)&quot;' </span><span class="s1">% str(value)</span><span class="s3">, </span><span class="s1">str(value)</span><span class="s3">, </span><span class="s1">json_data)</span>

            <span class="s1">datatype = </span><span class="s5">&quot;numeric&quot;</span>

            <span class="s1">connection.execute(</span>
                <span class="s1">data_table.insert().values(</span>
                    <span class="s1">name=</span><span class="s5">&quot;row1&quot;</span><span class="s3">,</span>
                    <span class="s0"># to pass the string directly to every backend, including</span>
                    <span class="s0"># PostgreSQL which needs the value to be CAST as JSON</span>
                    <span class="s0"># both in the SQL as well as at the prepared statement</span>
                    <span class="s0"># level for asyncpg, while at the same time MySQL</span>
                    <span class="s0"># doesn't even support CAST for JSON, here we are</span>
                    <span class="s0"># sending the string embedded in the SQL without using</span>
                    <span class="s0"># a parameter.</span>
                    <span class="s1">data=bindparam(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">json_data</span><span class="s3">, </span><span class="s1">literal_execute=</span><span class="s2">True</span><span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">nulldata=bindparam(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">json_data</span><span class="s3">, </span><span class="s1">literal_execute=</span><span class="s2">True</span><span class="s1">)</span><span class="s3">,</span>
                <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">connection.execute(</span>
                <span class="s1">data_table.insert()</span><span class="s3">,</span>
                <span class="s1">{</span>
                    <span class="s5">&quot;name&quot;</span><span class="s1">: </span><span class="s5">&quot;row1&quot;</span><span class="s3">,</span>
                    <span class="s5">&quot;data&quot;</span><span class="s1">: data_element</span><span class="s3">,</span>
                    <span class="s5">&quot;nulldata&quot;</span><span class="s1">: data_element</span><span class="s3">,</span>
                <span class="s1">}</span><span class="s3">,</span>
            <span class="s1">)</span>

        <span class="s1">p_s = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">datatype:</span>
            <span class="s2">if </span><span class="s1">datatype == </span><span class="s5">&quot;numeric&quot;</span><span class="s1">:</span>
                <span class="s1">a</span><span class="s3">, </span><span class="s1">b = str(value).split(</span><span class="s5">&quot;.&quot;</span><span class="s1">)</span>
                <span class="s1">s = len(b)</span>
                <span class="s1">p = len(a) + s</span>

                <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s3">, </span><span class="s1">decimal.Decimal):</span>
                    <span class="s1">compare_value = value</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">compare_value = decimal.Decimal(str(value))</span>

                <span class="s1">p_s = (p</span><span class="s3">, </span><span class="s1">s)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">compare_value = value</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">compare_value = value</span>

        <span class="s2">return </span><span class="s1">datatype</span><span class="s3">, </span><span class="s1">compare_value</span><span class="s3">, </span><span class="s1">p_s</span>

    <span class="s1">@_index_fixtures(</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_index_typed_access(self</span><span class="s3">, </span><span class="s1">datatype</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s1">data_table = self.tables.data_table</span>
        <span class="s1">data_element = {</span><span class="s5">&quot;key1&quot;</span><span class="s1">: value}</span>

        <span class="s2">with </span><span class="s1">config.db.begin() </span><span class="s2">as </span><span class="s1">conn:</span>
            <span class="s1">datatype</span><span class="s3">, </span><span class="s1">compare_value</span><span class="s3">, </span><span class="s1">p_s = self._json_value_insert(</span>
                <span class="s1">conn</span><span class="s3">, </span><span class="s1">datatype</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">data_element</span>
            <span class="s1">)</span>

            <span class="s1">expr = data_table.c.data[</span><span class="s5">&quot;key1&quot;</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">datatype:</span>
                <span class="s2">if </span><span class="s1">datatype == </span><span class="s5">&quot;numeric&quot; </span><span class="s2">and </span><span class="s1">p_s:</span>
                    <span class="s1">expr = expr.as_numeric(*p_s)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">expr = getattr(expr</span><span class="s3">, </span><span class="s5">&quot;as_%s&quot; </span><span class="s1">% datatype)()</span>

            <span class="s1">roundtrip = conn.scalar(select(expr))</span>
            <span class="s1">eq_(roundtrip</span><span class="s3">, </span><span class="s1">compare_value)</span>
            <span class="s1">is_(type(roundtrip)</span><span class="s3">, </span><span class="s1">type(compare_value))</span>

    <span class="s1">@_index_fixtures(</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_index_typed_comparison(self</span><span class="s3">, </span><span class="s1">datatype</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s1">data_table = self.tables.data_table</span>
        <span class="s1">data_element = {</span><span class="s5">&quot;key1&quot;</span><span class="s1">: value}</span>

        <span class="s2">with </span><span class="s1">config.db.begin() </span><span class="s2">as </span><span class="s1">conn:</span>
            <span class="s1">datatype</span><span class="s3">, </span><span class="s1">compare_value</span><span class="s3">, </span><span class="s1">p_s = self._json_value_insert(</span>
                <span class="s1">conn</span><span class="s3">, </span><span class="s1">datatype</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">data_element</span>
            <span class="s1">)</span>

            <span class="s1">expr = data_table.c.data[</span><span class="s5">&quot;key1&quot;</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">datatype:</span>
                <span class="s2">if </span><span class="s1">datatype == </span><span class="s5">&quot;numeric&quot; </span><span class="s2">and </span><span class="s1">p_s:</span>
                    <span class="s1">expr = expr.as_numeric(*p_s)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">expr = getattr(expr</span><span class="s3">, </span><span class="s5">&quot;as_%s&quot; </span><span class="s1">% datatype)()</span>

            <span class="s1">row = conn.execute(</span>
                <span class="s1">select(expr).where(expr == compare_value)</span>
            <span class="s1">).first()</span>

            <span class="s0"># make sure we get a row even if value is None</span>
            <span class="s1">eq_(row</span><span class="s3">, </span><span class="s1">(compare_value</span><span class="s3">,</span><span class="s1">))</span>

    <span class="s1">@_index_fixtures(</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_path_typed_comparison(self</span><span class="s3">, </span><span class="s1">datatype</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s1">data_table = self.tables.data_table</span>
        <span class="s1">data_element = {</span><span class="s5">&quot;key1&quot;</span><span class="s1">: {</span><span class="s5">&quot;subkey1&quot;</span><span class="s1">: value}}</span>
        <span class="s2">with </span><span class="s1">config.db.begin() </span><span class="s2">as </span><span class="s1">conn:</span>
            <span class="s1">datatype</span><span class="s3">, </span><span class="s1">compare_value</span><span class="s3">, </span><span class="s1">p_s = self._json_value_insert(</span>
                <span class="s1">conn</span><span class="s3">, </span><span class="s1">datatype</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">data_element</span>
            <span class="s1">)</span>

            <span class="s1">expr = data_table.c.data[(</span><span class="s5">&quot;key1&quot;</span><span class="s3">, </span><span class="s5">&quot;subkey1&quot;</span><span class="s1">)]</span>

            <span class="s2">if </span><span class="s1">datatype:</span>
                <span class="s2">if </span><span class="s1">datatype == </span><span class="s5">&quot;numeric&quot; </span><span class="s2">and </span><span class="s1">p_s:</span>
                    <span class="s1">expr = expr.as_numeric(*p_s)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">expr = getattr(expr</span><span class="s3">, </span><span class="s5">&quot;as_%s&quot; </span><span class="s1">% datatype)()</span>

            <span class="s1">row = conn.execute(</span>
                <span class="s1">select(expr).where(expr == compare_value)</span>
            <span class="s1">).first()</span>

            <span class="s0"># make sure we get a row even if value is None</span>
            <span class="s1">eq_(row</span><span class="s3">, </span><span class="s1">(compare_value</span><span class="s3">,</span><span class="s1">))</span>

    <span class="s1">@testing.combinations(</span>
        <span class="s1">(</span><span class="s2">True</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s2">False</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s2">None</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s6">15</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s6">0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(-</span><span class="s6">1</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(-</span><span class="s6">1.0</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s6">15.052</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s5">&quot;a string&quot;</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s5">&quot;réve illé&quot;</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s5">&quot;réve🐍 illé&quot;</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_single_element_round_trip(self</span><span class="s3">, </span><span class="s1">element):</span>
        <span class="s1">data_table = self.tables.data_table</span>
        <span class="s1">data_element = element</span>
        <span class="s2">with </span><span class="s1">config.db.begin() </span><span class="s2">as </span><span class="s1">conn:</span>
            <span class="s1">conn.execute(</span>
                <span class="s1">data_table.insert()</span><span class="s3">,</span>
                <span class="s1">{</span>
                    <span class="s5">&quot;name&quot;</span><span class="s1">: </span><span class="s5">&quot;row1&quot;</span><span class="s3">,</span>
                    <span class="s5">&quot;data&quot;</span><span class="s1">: data_element</span><span class="s3">,</span>
                    <span class="s5">&quot;nulldata&quot;</span><span class="s1">: data_element</span><span class="s3">,</span>
                <span class="s1">}</span><span class="s3">,</span>
            <span class="s1">)</span>

            <span class="s1">row = conn.execute(</span>
                <span class="s1">select(data_table.c.data</span><span class="s3">, </span><span class="s1">data_table.c.nulldata)</span>
            <span class="s1">).first()</span>

            <span class="s1">eq_(row</span><span class="s3">, </span><span class="s1">(data_element</span><span class="s3">, </span><span class="s1">data_element))</span>

    <span class="s2">def </span><span class="s1">test_round_trip_custom_json(self):</span>
        <span class="s1">data_table = self.tables.data_table</span>
        <span class="s1">data_element = {</span><span class="s5">&quot;key1&quot;</span><span class="s1">: </span><span class="s5">&quot;data1&quot;</span><span class="s1">}</span>

        <span class="s1">js = mock.Mock(side_effect=json.dumps)</span>
        <span class="s1">jd = mock.Mock(side_effect=json.loads)</span>
        <span class="s1">engine = engines.testing_engine(</span>
            <span class="s1">options=dict(json_serializer=js</span><span class="s3">, </span><span class="s1">json_deserializer=jd)</span>
        <span class="s1">)</span>

        <span class="s0"># support sqlite :memory: database...</span>
        <span class="s1">data_table.create(engine</span><span class="s3">, </span><span class="s1">checkfirst=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">engine.begin() </span><span class="s2">as </span><span class="s1">conn:</span>
            <span class="s1">conn.execute(</span>
                <span class="s1">data_table.insert()</span><span class="s3">, </span><span class="s1">{</span><span class="s5">&quot;name&quot;</span><span class="s1">: </span><span class="s5">&quot;row1&quot;</span><span class="s3">, </span><span class="s5">&quot;data&quot;</span><span class="s1">: data_element}</span>
            <span class="s1">)</span>
            <span class="s1">row = conn.execute(select(data_table.c.data)).first()</span>

            <span class="s1">eq_(row</span><span class="s3">, </span><span class="s1">(data_element</span><span class="s3">,</span><span class="s1">))</span>
            <span class="s1">eq_(js.mock_calls</span><span class="s3">, </span><span class="s1">[mock.call(data_element)])</span>
            <span class="s2">if </span><span class="s1">testing.requires.json_deserializer_binary.enabled:</span>
                <span class="s1">eq_(</span>
                    <span class="s1">jd.mock_calls</span><span class="s3">,</span>
                    <span class="s1">[mock.call(json.dumps(data_element).encode())]</span><span class="s3">,</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">eq_(jd.mock_calls</span><span class="s3">, </span><span class="s1">[mock.call(json.dumps(data_element))])</span>

    <span class="s1">@testing.combinations(</span>
        <span class="s1">(</span><span class="s5">&quot;parameters&quot;</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s5">&quot;multiparameters&quot;</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s5">&quot;values&quot;</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s5">&quot;omit&quot;</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">argnames=</span><span class="s5">&quot;insert_type&quot;</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_round_trip_none_as_sql_null(self</span><span class="s3">, </span><span class="s1">connection</span><span class="s3">, </span><span class="s1">insert_type):</span>
        <span class="s1">col = self.tables.data_table.c[</span><span class="s5">&quot;nulldata&quot;</span><span class="s1">]</span>

        <span class="s1">conn = connection</span>

        <span class="s2">if </span><span class="s1">insert_type == </span><span class="s5">&quot;parameters&quot;</span><span class="s1">:</span>
            <span class="s1">stmt</span><span class="s3">, </span><span class="s1">params = self.tables.data_table.insert()</span><span class="s3">, </span><span class="s1">{</span>
                <span class="s5">&quot;name&quot;</span><span class="s1">: </span><span class="s5">&quot;r1&quot;</span><span class="s3">,</span>
                <span class="s5">&quot;nulldata&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s3">,</span>
                <span class="s5">&quot;data&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s3">,</span>
            <span class="s1">}</span>
        <span class="s2">elif </span><span class="s1">insert_type == </span><span class="s5">&quot;multiparameters&quot;</span><span class="s1">:</span>
            <span class="s1">stmt</span><span class="s3">, </span><span class="s1">params = self.tables.data_table.insert()</span><span class="s3">, </span><span class="s1">[</span>
                <span class="s1">{</span><span class="s5">&quot;name&quot;</span><span class="s1">: </span><span class="s5">&quot;r1&quot;</span><span class="s3">, </span><span class="s5">&quot;nulldata&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s3">, </span><span class="s5">&quot;data&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s1">}</span>
            <span class="s1">]</span>
        <span class="s2">elif </span><span class="s1">insert_type == </span><span class="s5">&quot;values&quot;</span><span class="s1">:</span>
            <span class="s1">stmt</span><span class="s3">, </span><span class="s1">params = (</span>
                <span class="s1">self.tables.data_table.insert().values(</span>
                    <span class="s1">name=</span><span class="s5">&quot;r1&quot;</span><span class="s3">,</span>
                    <span class="s1">nulldata=</span><span class="s2">None</span><span class="s3">,</span>
                    <span class="s1">data=</span><span class="s2">None</span><span class="s3">,</span>
                <span class="s1">)</span><span class="s3">,</span>
                <span class="s1">{}</span><span class="s3">,</span>
            <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">insert_type == </span><span class="s5">&quot;omit&quot;</span><span class="s1">:</span>
            <span class="s1">stmt</span><span class="s3">, </span><span class="s1">params = (</span>
                <span class="s1">self.tables.data_table.insert()</span><span class="s3">,</span>
                <span class="s1">{</span><span class="s5">&quot;name&quot;</span><span class="s1">: </span><span class="s5">&quot;r1&quot;</span><span class="s3">, </span><span class="s5">&quot;data&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert False</span>

        <span class="s1">conn.execute(stmt</span><span class="s3">, </span><span class="s1">params)</span>

        <span class="s1">eq_(</span>
            <span class="s1">conn.scalar(</span>
                <span class="s1">select(self.tables.data_table.c.name).where(col.is_(null()))</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s5">&quot;r1&quot;</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s1">eq_(conn.scalar(select(col))</span><span class="s3">, </span><span class="s2">None</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_round_trip_json_null_as_json_null(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">col = self.tables.data_table.c[</span><span class="s5">&quot;data&quot;</span><span class="s1">]</span>

        <span class="s1">conn = connection</span>
        <span class="s1">conn.execute(</span>
            <span class="s1">self.tables.data_table.insert()</span><span class="s3">,</span>
            <span class="s1">{</span><span class="s5">&quot;name&quot;</span><span class="s1">: </span><span class="s5">&quot;r1&quot;</span><span class="s3">, </span><span class="s5">&quot;data&quot;</span><span class="s1">: JSON.NULL}</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s1">eq_(</span>
            <span class="s1">conn.scalar(</span>
                <span class="s1">select(self.tables.data_table.c.name).where(</span>
                    <span class="s1">cast(col</span><span class="s3">, </span><span class="s1">String) == </span><span class="s5">&quot;null&quot;</span>
                <span class="s1">)</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s5">&quot;r1&quot;</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s1">eq_(conn.scalar(select(col))</span><span class="s3">, </span><span class="s2">None</span><span class="s1">)</span>

    <span class="s1">@testing.combinations(</span>
        <span class="s1">(</span><span class="s5">&quot;parameters&quot;</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s5">&quot;multiparameters&quot;</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(</span><span class="s5">&quot;values&quot;</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">argnames=</span><span class="s5">&quot;insert_type&quot;</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_round_trip_none_as_json_null(self</span><span class="s3">, </span><span class="s1">connection</span><span class="s3">, </span><span class="s1">insert_type):</span>
        <span class="s1">col = self.tables.data_table.c[</span><span class="s5">&quot;data&quot;</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">insert_type == </span><span class="s5">&quot;parameters&quot;</span><span class="s1">:</span>
            <span class="s1">stmt</span><span class="s3">, </span><span class="s1">params = self.tables.data_table.insert()</span><span class="s3">, </span><span class="s1">{</span>
                <span class="s5">&quot;name&quot;</span><span class="s1">: </span><span class="s5">&quot;r1&quot;</span><span class="s3">,</span>
                <span class="s5">&quot;data&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s3">,</span>
            <span class="s1">}</span>
        <span class="s2">elif </span><span class="s1">insert_type == </span><span class="s5">&quot;multiparameters&quot;</span><span class="s1">:</span>
            <span class="s1">stmt</span><span class="s3">, </span><span class="s1">params = self.tables.data_table.insert()</span><span class="s3">, </span><span class="s1">[</span>
                <span class="s1">{</span><span class="s5">&quot;name&quot;</span><span class="s1">: </span><span class="s5">&quot;r1&quot;</span><span class="s3">, </span><span class="s5">&quot;data&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s1">}</span>
            <span class="s1">]</span>
        <span class="s2">elif </span><span class="s1">insert_type == </span><span class="s5">&quot;values&quot;</span><span class="s1">:</span>
            <span class="s1">stmt</span><span class="s3">, </span><span class="s1">params = (</span>
                <span class="s1">self.tables.data_table.insert().values(name=</span><span class="s5">&quot;r1&quot;</span><span class="s3">, </span><span class="s1">data=</span><span class="s2">None</span><span class="s1">)</span><span class="s3">,</span>
                <span class="s1">{}</span><span class="s3">,</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert False</span>

        <span class="s1">conn = connection</span>
        <span class="s1">conn.execute(stmt</span><span class="s3">, </span><span class="s1">params)</span>

        <span class="s1">eq_(</span>
            <span class="s1">conn.scalar(</span>
                <span class="s1">select(self.tables.data_table.c.name).where(</span>
                    <span class="s1">cast(col</span><span class="s3">, </span><span class="s1">String) == </span><span class="s5">&quot;null&quot;</span>
                <span class="s1">)</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s5">&quot;r1&quot;</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s1">eq_(conn.scalar(select(col))</span><span class="s3">, </span><span class="s2">None</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_unicode_round_trip(self):</span>
        <span class="s0"># note we include Unicode supplementary characters as well</span>
        <span class="s2">with </span><span class="s1">config.db.begin() </span><span class="s2">as </span><span class="s1">conn:</span>
            <span class="s1">conn.execute(</span>
                <span class="s1">self.tables.data_table.insert()</span><span class="s3">,</span>
                <span class="s1">{</span>
                    <span class="s5">&quot;name&quot;</span><span class="s1">: </span><span class="s5">&quot;r1&quot;</span><span class="s3">,</span>
                    <span class="s5">&quot;data&quot;</span><span class="s1">: {</span>
                        <span class="s5">&quot;réve🐍 illé&quot;</span><span class="s1">: </span><span class="s5">&quot;réve🐍 illé&quot;</span><span class="s3">,</span>
                        <span class="s5">&quot;data&quot;</span><span class="s1">: {</span><span class="s5">&quot;k1&quot;</span><span class="s1">: </span><span class="s5">&quot;drôl🐍e&quot;</span><span class="s1">}</span><span class="s3">,</span>
                    <span class="s1">}</span><span class="s3">,</span>
                <span class="s1">}</span><span class="s3">,</span>
            <span class="s1">)</span>

            <span class="s1">eq_(</span>
                <span class="s1">conn.scalar(select(self.tables.data_table.c.data))</span><span class="s3">,</span>
                <span class="s1">{</span>
                    <span class="s5">&quot;réve🐍 illé&quot;</span><span class="s1">: </span><span class="s5">&quot;réve🐍 illé&quot;</span><span class="s3">,</span>
                    <span class="s5">&quot;data&quot;</span><span class="s1">: {</span><span class="s5">&quot;k1&quot;</span><span class="s1">: </span><span class="s5">&quot;drôl🐍e&quot;</span><span class="s1">}</span><span class="s3">,</span>
                <span class="s1">}</span><span class="s3">,</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_eval_none_flag_orm(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">Base = declarative_base()</span>

        <span class="s2">class </span><span class="s1">Data(Base):</span>
            <span class="s1">__table__ = self.tables.data_table</span>

        <span class="s2">with </span><span class="s1">Session(connection) </span><span class="s2">as </span><span class="s1">s:</span>
            <span class="s1">d1 = Data(name=</span><span class="s5">&quot;d1&quot;</span><span class="s3">, </span><span class="s1">data=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">nulldata=</span><span class="s2">None</span><span class="s1">)</span>
            <span class="s1">s.add(d1)</span>
            <span class="s1">s.commit()</span>

            <span class="s1">s.bulk_insert_mappings(</span>
                <span class="s1">Data</span><span class="s3">, </span><span class="s1">[{</span><span class="s5">&quot;name&quot;</span><span class="s1">: </span><span class="s5">&quot;d2&quot;</span><span class="s3">, </span><span class="s5">&quot;data&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s3">, </span><span class="s5">&quot;nulldata&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s1">}]</span>
            <span class="s1">)</span>
            <span class="s1">eq_(</span>
                <span class="s1">s.query(</span>
                    <span class="s1">cast(self.tables.data_table.c.data</span><span class="s3">, </span><span class="s1">String())</span><span class="s3">,</span>
                    <span class="s1">cast(self.tables.data_table.c.nulldata</span><span class="s3">, </span><span class="s1">String)</span><span class="s3">,</span>
                <span class="s1">)</span>
                <span class="s1">.filter(self.tables.data_table.c.name == </span><span class="s5">&quot;d1&quot;</span><span class="s1">)</span>
                <span class="s1">.first()</span><span class="s3">,</span>
                <span class="s1">(</span><span class="s5">&quot;null&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">)</span>
            <span class="s1">eq_(</span>
                <span class="s1">s.query(</span>
                    <span class="s1">cast(self.tables.data_table.c.data</span><span class="s3">, </span><span class="s1">String())</span><span class="s3">,</span>
                    <span class="s1">cast(self.tables.data_table.c.nulldata</span><span class="s3">, </span><span class="s1">String)</span><span class="s3">,</span>
                <span class="s1">)</span>
                <span class="s1">.filter(self.tables.data_table.c.name == </span><span class="s5">&quot;d2&quot;</span><span class="s1">)</span>
                <span class="s1">.first()</span><span class="s3">,</span>
                <span class="s1">(</span><span class="s5">&quot;null&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">)</span>


<span class="s2">class </span><span class="s1">JSONLegacyStringCastIndexTest(</span>
    <span class="s1">_LiteralRoundTripFixture</span><span class="s3">, </span><span class="s1">fixtures.TablesTest</span>
<span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;test JSON index access with &quot;cast to string&quot;, which we have documented 
    for a long time as how to compare JSON values, but is ultimately not 
    reliable in all cases.   The &quot;as_XYZ()&quot; comparators should be used 
    instead. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__requires__ = (</span><span class="s5">&quot;json_type&quot;</span><span class="s3">, </span><span class="s5">&quot;legacy_unconditional_json_extract&quot;</span><span class="s1">)</span>
    <span class="s1">__backend__ = </span><span class="s2">True</span>

    <span class="s1">datatype = JSON</span>

    <span class="s1">data1 = {</span><span class="s5">&quot;key1&quot;</span><span class="s1">: </span><span class="s5">&quot;value1&quot;</span><span class="s3">, </span><span class="s5">&quot;key2&quot;</span><span class="s1">: </span><span class="s5">&quot;value2&quot;</span><span class="s1">}</span>

    <span class="s1">data2 = {</span>
        <span class="s5">&quot;Key 'One'&quot;</span><span class="s1">: </span><span class="s5">&quot;value1&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;key two&quot;</span><span class="s1">: </span><span class="s5">&quot;value2&quot;</span><span class="s3">,</span>
        <span class="s5">&quot;key three&quot;</span><span class="s1">: </span><span class="s5">&quot;value ' three '&quot;</span><span class="s3">,</span>
    <span class="s1">}</span>

    <span class="s1">data3 = {</span>
        <span class="s5">&quot;key1&quot;</span><span class="s1">: [</span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">3</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s5">&quot;key2&quot;</span><span class="s1">: [</span><span class="s5">&quot;one&quot;</span><span class="s3">, </span><span class="s5">&quot;two&quot;</span><span class="s3">, </span><span class="s5">&quot;three&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s5">&quot;key3&quot;</span><span class="s1">: [{</span><span class="s5">&quot;four&quot;</span><span class="s1">: </span><span class="s5">&quot;five&quot;</span><span class="s1">}</span><span class="s3">, </span><span class="s1">{</span><span class="s5">&quot;six&quot;</span><span class="s1">: </span><span class="s5">&quot;seven&quot;</span><span class="s1">}]</span><span class="s3">,</span>
    <span class="s1">}</span>

    <span class="s1">data4 = [</span><span class="s5">&quot;one&quot;</span><span class="s3">, </span><span class="s5">&quot;two&quot;</span><span class="s3">, </span><span class="s5">&quot;three&quot;</span><span class="s1">]</span>

    <span class="s1">data5 = {</span>
        <span class="s5">&quot;nested&quot;</span><span class="s1">: {</span>
            <span class="s5">&quot;elem1&quot;</span><span class="s1">: [{</span><span class="s5">&quot;a&quot;</span><span class="s1">: </span><span class="s5">&quot;b&quot;</span><span class="s3">, </span><span class="s5">&quot;c&quot;</span><span class="s1">: </span><span class="s5">&quot;d&quot;</span><span class="s1">}</span><span class="s3">, </span><span class="s1">{</span><span class="s5">&quot;e&quot;</span><span class="s1">: </span><span class="s5">&quot;f&quot;</span><span class="s3">, </span><span class="s5">&quot;g&quot;</span><span class="s1">: </span><span class="s5">&quot;h&quot;</span><span class="s1">}]</span><span class="s3">,</span>
            <span class="s5">&quot;elem2&quot;</span><span class="s1">: {</span><span class="s5">&quot;elem3&quot;</span><span class="s1">: {</span><span class="s5">&quot;elem4&quot;</span><span class="s1">: </span><span class="s5">&quot;elem5&quot;</span><span class="s1">}}</span><span class="s3">,</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">data6 = {</span><span class="s5">&quot;a&quot;</span><span class="s1">: </span><span class="s6">5</span><span class="s3">, </span><span class="s5">&quot;b&quot;</span><span class="s1">: </span><span class="s5">&quot;some value&quot;</span><span class="s3">, </span><span class="s5">&quot;c&quot;</span><span class="s1">: {</span><span class="s5">&quot;foo&quot;</span><span class="s1">: </span><span class="s5">&quot;bar&quot;</span><span class="s1">}}</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">define_tables(cls</span><span class="s3">, </span><span class="s1">metadata):</span>
        <span class="s1">Table(</span>
            <span class="s5">&quot;data_table&quot;</span><span class="s3">,</span>
            <span class="s1">metadata</span><span class="s3">,</span>
            <span class="s1">Column(</span><span class="s5">&quot;id&quot;</span><span class="s3">, </span><span class="s1">Integer</span><span class="s3">, </span><span class="s1">primary_key=</span><span class="s2">True</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">Column(</span><span class="s5">&quot;name&quot;</span><span class="s3">, </span><span class="s1">String(</span><span class="s6">30</span><span class="s1">)</span><span class="s3">, </span><span class="s1">nullable=</span><span class="s2">False</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">Column(</span><span class="s5">&quot;data&quot;</span><span class="s3">, </span><span class="s1">cls.datatype)</span><span class="s3">,</span>
            <span class="s1">Column(</span><span class="s5">&quot;nulldata&quot;</span><span class="s3">, </span><span class="s1">cls.datatype(none_as_null=</span><span class="s2">True</span><span class="s1">))</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_criteria_fixture(self):</span>
        <span class="s2">with </span><span class="s1">config.db.begin() </span><span class="s2">as </span><span class="s1">conn:</span>
            <span class="s1">conn.execute(</span>
                <span class="s1">self.tables.data_table.insert()</span><span class="s3">,</span>
                <span class="s1">[</span>
                    <span class="s1">{</span><span class="s5">&quot;name&quot;</span><span class="s1">: </span><span class="s5">&quot;r1&quot;</span><span class="s3">, </span><span class="s5">&quot;data&quot;</span><span class="s1">: self.data1}</span><span class="s3">,</span>
                    <span class="s1">{</span><span class="s5">&quot;name&quot;</span><span class="s1">: </span><span class="s5">&quot;r2&quot;</span><span class="s3">, </span><span class="s5">&quot;data&quot;</span><span class="s1">: self.data2}</span><span class="s3">,</span>
                    <span class="s1">{</span><span class="s5">&quot;name&quot;</span><span class="s1">: </span><span class="s5">&quot;r3&quot;</span><span class="s3">, </span><span class="s5">&quot;data&quot;</span><span class="s1">: self.data3}</span><span class="s3">,</span>
                    <span class="s1">{</span><span class="s5">&quot;name&quot;</span><span class="s1">: </span><span class="s5">&quot;r4&quot;</span><span class="s3">, </span><span class="s5">&quot;data&quot;</span><span class="s1">: self.data4}</span><span class="s3">,</span>
                    <span class="s1">{</span><span class="s5">&quot;name&quot;</span><span class="s1">: </span><span class="s5">&quot;r5&quot;</span><span class="s3">, </span><span class="s5">&quot;data&quot;</span><span class="s1">: self.data5}</span><span class="s3">,</span>
                    <span class="s1">{</span><span class="s5">&quot;name&quot;</span><span class="s1">: </span><span class="s5">&quot;r6&quot;</span><span class="s3">, </span><span class="s5">&quot;data&quot;</span><span class="s1">: self.data6}</span><span class="s3">,</span>
                <span class="s1">]</span><span class="s3">,</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_test_index_criteria(self</span><span class="s3">, </span><span class="s1">crit</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">, </span><span class="s1">test_literal=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">self._criteria_fixture()</span>
        <span class="s2">with </span><span class="s1">config.db.connect() </span><span class="s2">as </span><span class="s1">conn:</span>
            <span class="s1">stmt = select(self.tables.data_table.c.name).where(crit)</span>

            <span class="s1">eq_(conn.scalar(stmt)</span><span class="s3">, </span><span class="s1">expected)</span>

            <span class="s2">if </span><span class="s1">test_literal:</span>
                <span class="s1">literal_sql = str(</span>
                    <span class="s1">stmt.compile(</span>
                        <span class="s1">config.db</span><span class="s3">, </span><span class="s1">compile_kwargs={</span><span class="s5">&quot;literal_binds&quot;</span><span class="s1">: </span><span class="s2">True</span><span class="s1">}</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>

                <span class="s1">eq_(conn.exec_driver_sql(literal_sql).scalar()</span><span class="s3">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_string_cast_crit_spaces_in_key(self):</span>
        <span class="s1">name = self.tables.data_table.c.name</span>
        <span class="s1">col = self.tables.data_table.c[</span><span class="s5">&quot;data&quot;</span><span class="s1">]</span>

        <span class="s0"># limit the rows here to avoid PG error</span>
        <span class="s0"># &quot;cannot extract field from a non-object&quot;, which is</span>
        <span class="s0"># fixed in 9.4 but may exist in 9.3</span>
        <span class="s1">self._test_index_criteria(</span>
            <span class="s1">and_(</span>
                <span class="s1">name.in_([</span><span class="s5">&quot;r1&quot;</span><span class="s3">, </span><span class="s5">&quot;r2&quot;</span><span class="s3">, </span><span class="s5">&quot;r3&quot;</span><span class="s1">])</span><span class="s3">,</span>
                <span class="s1">cast(col[</span><span class="s5">&quot;key two&quot;</span><span class="s1">]</span><span class="s3">, </span><span class="s1">String) == </span><span class="s5">'&quot;value2&quot;'</span><span class="s3">,</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s5">&quot;r2&quot;</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s1">@config.requirements.json_array_indexes</span>
    <span class="s2">def </span><span class="s1">test_string_cast_crit_simple_int(self):</span>
        <span class="s1">name = self.tables.data_table.c.name</span>
        <span class="s1">col = self.tables.data_table.c[</span><span class="s5">&quot;data&quot;</span><span class="s1">]</span>

        <span class="s0"># limit the rows here to avoid PG error</span>
        <span class="s0"># &quot;cannot extract array element from a non-array&quot;, which is</span>
        <span class="s0"># fixed in 9.4 but may exist in 9.3</span>
        <span class="s1">self._test_index_criteria(</span>
            <span class="s1">and_(</span>
                <span class="s1">name == </span><span class="s5">&quot;r4&quot;</span><span class="s3">,</span>
                <span class="s1">cast(col[</span><span class="s6">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">String) == </span><span class="s5">'&quot;two&quot;'</span><span class="s3">,</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s5">&quot;r4&quot;</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_string_cast_crit_mixed_path(self):</span>
        <span class="s1">col = self.tables.data_table.c[</span><span class="s5">&quot;data&quot;</span><span class="s1">]</span>
        <span class="s1">self._test_index_criteria(</span>
            <span class="s1">cast(col[(</span><span class="s5">&quot;key3&quot;</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s5">&quot;six&quot;</span><span class="s1">)]</span><span class="s3">, </span><span class="s1">String) == </span><span class="s5">'&quot;seven&quot;'</span><span class="s3">,</span>
            <span class="s5">&quot;r3&quot;</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_string_cast_crit_string_path(self):</span>
        <span class="s1">col = self.tables.data_table.c[</span><span class="s5">&quot;data&quot;</span><span class="s1">]</span>
        <span class="s1">self._test_index_criteria(</span>
            <span class="s1">cast(col[(</span><span class="s5">&quot;nested&quot;</span><span class="s3">, </span><span class="s5">&quot;elem2&quot;</span><span class="s3">, </span><span class="s5">&quot;elem3&quot;</span><span class="s3">, </span><span class="s5">&quot;elem4&quot;</span><span class="s1">)]</span><span class="s3">, </span><span class="s1">String)</span>
            <span class="s1">== </span><span class="s5">'&quot;elem5&quot;'</span><span class="s3">,</span>
            <span class="s5">&quot;r5&quot;</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_string_cast_crit_against_string_basic(self):</span>
        <span class="s1">name = self.tables.data_table.c.name</span>
        <span class="s1">col = self.tables.data_table.c[</span><span class="s5">&quot;data&quot;</span><span class="s1">]</span>

        <span class="s1">self._test_index_criteria(</span>
            <span class="s1">and_(</span>
                <span class="s1">name == </span><span class="s5">&quot;r6&quot;</span><span class="s3">,</span>
                <span class="s1">cast(col[</span><span class="s5">&quot;b&quot;</span><span class="s1">]</span><span class="s3">, </span><span class="s1">String) == </span><span class="s5">'&quot;some value&quot;'</span><span class="s3">,</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s5">&quot;r6&quot;</span><span class="s3">,</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">EnumTest(_LiteralRoundTripFixture</span><span class="s3">, </span><span class="s1">fixtures.TablesTest):</span>
    <span class="s1">__backend__ = </span><span class="s2">True</span>

    <span class="s1">enum_values = </span><span class="s5">&quot;a&quot;</span><span class="s3">, </span><span class="s5">&quot;b&quot;</span><span class="s3">, </span><span class="s5">&quot;a%&quot;</span><span class="s3">, </span><span class="s5">&quot;b%percent&quot;</span><span class="s3">, </span><span class="s5">&quot;réveillé&quot;</span>

    <span class="s1">datatype = Enum(*enum_values</span><span class="s3">, </span><span class="s1">name=</span><span class="s5">&quot;myenum&quot;</span><span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">define_tables(cls</span><span class="s3">, </span><span class="s1">metadata):</span>
        <span class="s1">Table(</span>
            <span class="s5">&quot;enum_table&quot;</span><span class="s3">,</span>
            <span class="s1">metadata</span><span class="s3">,</span>
            <span class="s1">Column(</span><span class="s5">&quot;id&quot;</span><span class="s3">, </span><span class="s1">Integer</span><span class="s3">, </span><span class="s1">primary_key=</span><span class="s2">True</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">Column(</span><span class="s5">&quot;enum_data&quot;</span><span class="s3">, </span><span class="s1">cls.datatype)</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s1">@testing.combinations(*enum_values</span><span class="s3">, </span><span class="s1">argnames=</span><span class="s5">&quot;data&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_round_trip(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">connection.execute(</span>
            <span class="s1">self.tables.enum_table.insert()</span><span class="s3">, </span><span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">1</span><span class="s3">, </span><span class="s5">&quot;enum_data&quot;</span><span class="s1">: data}</span>
        <span class="s1">)</span>

        <span class="s1">eq_(</span>
            <span class="s1">connection.scalar(</span>
                <span class="s1">select(self.tables.enum_table.c.enum_data).where(</span>
                    <span class="s1">self.tables.enum_table.c.id == </span><span class="s6">1</span>
                <span class="s1">)</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">data</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_round_trip_executemany(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">connection.execute(</span>
            <span class="s1">self.tables.enum_table.insert()</span><span class="s3">,</span>
            <span class="s1">[</span>
                <span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">1</span><span class="s3">, </span><span class="s5">&quot;enum_data&quot;</span><span class="s1">: </span><span class="s5">&quot;b%percent&quot;</span><span class="s1">}</span><span class="s3">,</span>
                <span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">2</span><span class="s3">, </span><span class="s5">&quot;enum_data&quot;</span><span class="s1">: </span><span class="s5">&quot;réveillé&quot;</span><span class="s1">}</span><span class="s3">,</span>
                <span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">3</span><span class="s3">, </span><span class="s5">&quot;enum_data&quot;</span><span class="s1">: </span><span class="s5">&quot;b&quot;</span><span class="s1">}</span><span class="s3">,</span>
                <span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">4</span><span class="s3">, </span><span class="s5">&quot;enum_data&quot;</span><span class="s1">: </span><span class="s5">&quot;a%&quot;</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">]</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s1">eq_(</span>
            <span class="s1">connection.scalars(</span>
                <span class="s1">select(self.tables.enum_table.c.enum_data).order_by(</span>
                    <span class="s1">self.tables.enum_table.c.id</span>
                <span class="s1">)</span>
            <span class="s1">).all()</span><span class="s3">,</span>
            <span class="s1">[</span><span class="s5">&quot;b%percent&quot;</span><span class="s3">, </span><span class="s5">&quot;réveillé&quot;</span><span class="s3">, </span><span class="s5">&quot;b&quot;</span><span class="s3">, </span><span class="s5">&quot;a%&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s1">@testing.requires.insert_executemany_returning</span>
    <span class="s2">def </span><span class="s1">test_round_trip_executemany_returning(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">result = connection.execute(</span>
            <span class="s1">self.tables.enum_table.insert().returning(</span>
                <span class="s1">self.tables.enum_table.c.enum_data</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">[</span>
                <span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">1</span><span class="s3">, </span><span class="s5">&quot;enum_data&quot;</span><span class="s1">: </span><span class="s5">&quot;b%percent&quot;</span><span class="s1">}</span><span class="s3">,</span>
                <span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">2</span><span class="s3">, </span><span class="s5">&quot;enum_data&quot;</span><span class="s1">: </span><span class="s5">&quot;réveillé&quot;</span><span class="s1">}</span><span class="s3">,</span>
                <span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">3</span><span class="s3">, </span><span class="s5">&quot;enum_data&quot;</span><span class="s1">: </span><span class="s5">&quot;b&quot;</span><span class="s1">}</span><span class="s3">,</span>
                <span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">4</span><span class="s3">, </span><span class="s5">&quot;enum_data&quot;</span><span class="s1">: </span><span class="s5">&quot;a%&quot;</span><span class="s1">}</span><span class="s3">,</span>
            <span class="s1">]</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s1">eq_(result.scalars().all()</span><span class="s3">, </span><span class="s1">[</span><span class="s5">&quot;b%percent&quot;</span><span class="s3">, </span><span class="s5">&quot;réveillé&quot;</span><span class="s3">, </span><span class="s5">&quot;b&quot;</span><span class="s3">, </span><span class="s5">&quot;a%&quot;</span><span class="s1">])</span>


<span class="s2">class </span><span class="s1">UuidTest(_LiteralRoundTripFixture</span><span class="s3">, </span><span class="s1">fixtures.TablesTest):</span>
    <span class="s1">__backend__ = </span><span class="s2">True</span>

    <span class="s1">datatype = Uuid</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">define_tables(cls</span><span class="s3">, </span><span class="s1">metadata):</span>
        <span class="s1">Table(</span>
            <span class="s5">&quot;uuid_table&quot;</span><span class="s3">,</span>
            <span class="s1">metadata</span><span class="s3">,</span>
            <span class="s1">Column(</span>
                <span class="s5">&quot;id&quot;</span><span class="s3">, </span><span class="s1">Integer</span><span class="s3">, </span><span class="s1">primary_key=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">test_needs_autoincrement=</span><span class="s2">True</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">Column(</span><span class="s5">&quot;uuid_data&quot;</span><span class="s3">, </span><span class="s1">cls.datatype)</span><span class="s3">,</span>
            <span class="s1">Column(</span><span class="s5">&quot;uuid_text_data&quot;</span><span class="s3">, </span><span class="s1">cls.datatype(as_uuid=</span><span class="s2">False</span><span class="s1">))</span><span class="s3">,</span>
            <span class="s1">Column(</span><span class="s5">&quot;uuid_data_nonnative&quot;</span><span class="s3">, </span><span class="s1">Uuid(native_uuid=</span><span class="s2">False</span><span class="s1">))</span><span class="s3">,</span>
            <span class="s1">Column(</span>
                <span class="s5">&quot;uuid_text_data_nonnative&quot;</span><span class="s3">,</span>
                <span class="s1">Uuid(as_uuid=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">native_uuid=</span><span class="s2">False</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">)</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_uuid_round_trip(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">data = uuid.uuid4()</span>
        <span class="s1">uuid_table = self.tables.uuid_table</span>

        <span class="s1">connection.execute(</span>
            <span class="s1">uuid_table.insert()</span><span class="s3">,</span>
            <span class="s1">{</span><span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">1</span><span class="s3">, </span><span class="s5">&quot;uuid_data&quot;</span><span class="s1">: data</span><span class="s3">, </span><span class="s5">&quot;uuid_data_nonnative&quot;</span><span class="s1">: data}</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s1">row = connection.execute(</span>
            <span class="s1">select(</span>
                <span class="s1">uuid_table.c.uuid_data</span><span class="s3">, </span><span class="s1">uuid_table.c.uuid_data_nonnative</span>
            <span class="s1">).where(</span>
                <span class="s1">uuid_table.c.uuid_data == data</span><span class="s3">,</span>
                <span class="s1">uuid_table.c.uuid_data_nonnative == data</span><span class="s3">,</span>
            <span class="s1">)</span>
        <span class="s1">).first()</span>
        <span class="s1">eq_(row</span><span class="s3">, </span><span class="s1">(data</span><span class="s3">, </span><span class="s1">data))</span>

    <span class="s2">def </span><span class="s1">test_uuid_text_round_trip(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">data = str(uuid.uuid4())</span>
        <span class="s1">uuid_table = self.tables.uuid_table</span>

        <span class="s1">connection.execute(</span>
            <span class="s1">uuid_table.insert()</span><span class="s3">,</span>
            <span class="s1">{</span>
                <span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">1</span><span class="s3">,</span>
                <span class="s5">&quot;uuid_text_data&quot;</span><span class="s1">: data</span><span class="s3">,</span>
                <span class="s5">&quot;uuid_text_data_nonnative&quot;</span><span class="s1">: data</span><span class="s3">,</span>
            <span class="s1">}</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s1">row = connection.execute(</span>
            <span class="s1">select(</span>
                <span class="s1">uuid_table.c.uuid_text_data</span><span class="s3">,</span>
                <span class="s1">uuid_table.c.uuid_text_data_nonnative</span><span class="s3">,</span>
            <span class="s1">).where(</span>
                <span class="s1">uuid_table.c.uuid_text_data == data</span><span class="s3">,</span>
                <span class="s1">uuid_table.c.uuid_text_data_nonnative == data</span><span class="s3">,</span>
            <span class="s1">)</span>
        <span class="s1">).first()</span>
        <span class="s1">eq_((row[</span><span class="s6">0</span><span class="s1">].lower()</span><span class="s3">, </span><span class="s1">row[</span><span class="s6">1</span><span class="s1">].lower())</span><span class="s3">, </span><span class="s1">(data</span><span class="s3">, </span><span class="s1">data))</span>

    <span class="s2">def </span><span class="s1">test_literal_uuid(self</span><span class="s3">, </span><span class="s1">literal_round_trip):</span>
        <span class="s1">data = uuid.uuid4()</span>
        <span class="s1">literal_round_trip(self.datatype</span><span class="s3">, </span><span class="s1">[data]</span><span class="s3">, </span><span class="s1">[data])</span>

    <span class="s2">def </span><span class="s1">test_literal_text(self</span><span class="s3">, </span><span class="s1">literal_round_trip):</span>
        <span class="s1">data = str(uuid.uuid4())</span>
        <span class="s1">literal_round_trip(</span>
            <span class="s1">self.datatype(as_uuid=</span><span class="s2">False</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">[data]</span><span class="s3">,</span>
            <span class="s1">[data]</span><span class="s3">,</span>
            <span class="s1">filter_=</span><span class="s2">lambda </span><span class="s1">x: x.lower()</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_literal_nonnative_uuid(self</span><span class="s3">, </span><span class="s1">literal_round_trip):</span>
        <span class="s1">data = uuid.uuid4()</span>
        <span class="s1">literal_round_trip(Uuid(native_uuid=</span><span class="s2">False</span><span class="s1">)</span><span class="s3">, </span><span class="s1">[data]</span><span class="s3">, </span><span class="s1">[data])</span>

    <span class="s2">def </span><span class="s1">test_literal_nonnative_text(self</span><span class="s3">, </span><span class="s1">literal_round_trip):</span>
        <span class="s1">data = str(uuid.uuid4())</span>
        <span class="s1">literal_round_trip(</span>
            <span class="s1">Uuid(as_uuid=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">native_uuid=</span><span class="s2">False</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">[data]</span><span class="s3">,</span>
            <span class="s1">[data]</span><span class="s3">,</span>
            <span class="s1">filter_=</span><span class="s2">lambda </span><span class="s1">x: x.lower()</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s1">@testing.requires.insert_returning</span>
    <span class="s2">def </span><span class="s1">test_uuid_returning(self</span><span class="s3">, </span><span class="s1">connection):</span>
        <span class="s1">data = uuid.uuid4()</span>
        <span class="s1">str_data = str(data)</span>
        <span class="s1">uuid_table = self.tables.uuid_table</span>

        <span class="s1">result = connection.execute(</span>
            <span class="s1">uuid_table.insert().returning(</span>
                <span class="s1">uuid_table.c.uuid_data</span><span class="s3">,</span>
                <span class="s1">uuid_table.c.uuid_text_data</span><span class="s3">,</span>
                <span class="s1">uuid_table.c.uuid_data_nonnative</span><span class="s3">,</span>
                <span class="s1">uuid_table.c.uuid_text_data_nonnative</span><span class="s3">,</span>
            <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">{</span>
                <span class="s5">&quot;id&quot;</span><span class="s1">: </span><span class="s6">1</span><span class="s3">,</span>
                <span class="s5">&quot;uuid_data&quot;</span><span class="s1">: data</span><span class="s3">,</span>
                <span class="s5">&quot;uuid_text_data&quot;</span><span class="s1">: str_data</span><span class="s3">,</span>
                <span class="s5">&quot;uuid_data_nonnative&quot;</span><span class="s1">: data</span><span class="s3">,</span>
                <span class="s5">&quot;uuid_text_data_nonnative&quot;</span><span class="s1">: str_data</span><span class="s3">,</span>
            <span class="s1">}</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s1">row = result.first()</span>

        <span class="s1">eq_(row</span><span class="s3">, </span><span class="s1">(data</span><span class="s3">, </span><span class="s1">str_data</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">str_data))</span>


<span class="s2">class </span><span class="s1">NativeUUIDTest(UuidTest):</span>
    <span class="s1">__requires__ = (</span><span class="s5">&quot;uuid_data_type&quot;</span><span class="s3">,</span><span class="s1">)</span>

    <span class="s1">datatype = UUID</span>


<span class="s1">__all__ = (</span>
    <span class="s5">&quot;ArrayTest&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;BinaryTest&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;UnicodeVarcharTest&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;UnicodeTextTest&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;JSONTest&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;JSONLegacyStringCastIndexTest&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;DateTest&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;DateTimeTest&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;DateTimeTZTest&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;TextTest&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;NumericTest&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;IntegerTest&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;IntervalTest&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;PrecisionIntervalTest&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;CastTypeDecoratorTest&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;DateTimeHistoricTest&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;DateTimeCoercedToDateTimeTest&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;TimeMicrosecondsTest&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;TimestampMicrosecondsTest&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;TimeTest&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;TimeTZTest&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;TrueDivTest&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;DateTimeMicrosecondsTest&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;DateHistoricTest&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;StringTest&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;BooleanTest&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;EnumTest&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;UuidTest&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;NativeUUIDTest&quot;</span><span class="s3">,</span>
<span class="s1">)</span>
</pre>
</body>
</html>